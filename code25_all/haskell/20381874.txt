data Edge a = Boog a a deriving Show
data Graph a = Graaf [a] [Edge a] deriving Show

vindBuren :: Eq a => a -> Graph a -> [a]
vindBuren _ (Graaf list []) = []
vindBuren knoop (Graaf list ((Boog x y):rest))
       | knoop == x = y : (vindBuren knoop (Graaf list rest))
       | knoop == y = x : (vindBuren knoop (Graaf list rest))
       | otherwise = vindBuren knoop (Graaf list rest)

graadKnoop :: Eq a => Graph a -> a -> Int
graadKnoop graaf el = length (vindBuren el graaf) 


buurgraadKnoop :: Eq a => Graph a -> a -> [Int]
buurgraadKnoop graaf el = 
       let
           buren = vindBuren el graaf
       in
          reverse $ sort $ map (graadKnoop graaf) buren

buurgraad :: Eq a => Graph a -> [([Int],[a])]
buurgraad graaf = hulp graaf []


hulp :: Eq a => Graph a -> [([Int],[a])] -> [([Int],[a])]
hulp (Graaf [] bgL) soFar = soFar
hulp g@(Graaf (fstN:restN) l) soFar
       | elem bgraden (map fst soFar) = hulp (Graaf restN l) (mergeG fstN bgraden soFar)
       | otherwise = hulp (Graaf restN l) [(bgraden,[fstN])]:soFar
       where
           bgraden = buurgraadKnoop g fstN

mergeG :: a -> [Int] -> [([Int],[a])] -> [([Int],[a])]
mergeG n ngraden ((gradenL,nodenL):rest)
           | ngraden == gradenL = ((gradenL, sort(nodenL:n)):rest
           | otherwise = mergeG n ngraden rest

