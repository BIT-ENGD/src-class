ad
import Numeric.AD

ex :: Num a => [a] -> a
ex [x, y] = x + 2*y

> grad ex [1.0, 1.0]
[1.0, 2.0]

grad
grad
  :: (Num a, Traversable f) =>
     (forall (s :: * -> *). Mode s => f (AD s a) -> AD s a)
     -> f a -> f a

ex
[Double] -> Double
Couldn't match expected type `AD s a0' with actual type `Double'
Expected type: f0 (AD s a0) -> AD s a0
  Actual type: [Double] -> Double

Double
*
Num
Traversable f
grad
[AD s a] -> AD s a
Mode
Reverse
grad
AD
Mode
Num a => [a] -> a
[Double] -> Double
[Double] -> Double
grad
[Double] -> Double
ex
