-- recursive:

sqrtL1 :: [Integer] -> [Float]
sqrtL1 [] = []
sqrtL1 (n:ns)  = (sqrt x) : sqrtL1(ns)
    where x = fromIntegral n :: Float

-- Listenkomprehension:

sqrtL2 :: [Integer] -> [Float]
sqrtL2 (n:ns) = [sqrt x | x <- ns]
    where x = fromIntegral n :: Float  --(it doesn't work tho)

-- Higher-order:

sqrtL3 :: [Integer] -> [Float]
sqrtL3 ns = map sqrt ns

