Prelude.gcd
selfGCD :: Integral f => f -> f -> f  
selfGCD a b = if b == 0 then
        return a
    else 
        return (selfGCD a (mod a b))

two.hs:32:25:  
Couldn't match type `f' with `m0 f'  
  `f' is a rigid type variable bound by  
      the type signature for selfGCD :: Integral f => f -> f -> f  
      at two.hs:31:1  
In the return type of a call of `return'  
In the expression: return a  
In the expression:  
  if b == 0 then return a else return (selfGCD a (mod a b))  

two.hs:34:25:  
Couldn't match type `f' with `m1 f'  
  `f' is a rigid type variable bound by  
      the type signature for selfGCD :: Integral f => f -> f -> f  
      at two.hs:31:1  
In the return type of a call of `return'  
In the expression: return (selfGCD a (mod a b))  
In the expression:  
  if b == 0 then return a else return (selfGCD a (mod a b))  

