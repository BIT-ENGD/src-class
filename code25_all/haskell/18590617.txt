String -> Maybe a
a
Integer
maybeReadInteger
maybeReadInteger
maybeReadNum
splitIntoSignAndDigits str = case str of 
    '-':rest -> (-1, rest)
    '+':rest -> ( 1, rest)
    _        -> ( 1, str )

maybeReadUnsignedInteger []         = Nothing
maybeReadUnsignedInteger str@(x:xs) = go 0 str
    where go n str = case str of
              []                            -> Just n
              (x:xs) | '0' <= x && x <= '9' -> go (10 * n + digit) xs
                     | otherwise            -> Nothing
                  where digit = toInteger (ord x - ord '0')

maybeReadInteger str = fmap (sign*) (maybeReadUnsignedInteger str')
    where (sign, str') = splitIntoSignAndDigits str

maybeReadNum :: (Integral a, Bounded a) => String -> Maybe a
maybeReadNum = fmap fromInteger . 
               mfilter (\n -> n >= toInteger (minBound :: a) && 
                              n <= toInteger (maxBound :: a)) .
               maybeReadInteger

maybeReadInt :: String -> Maybe Int
maybeReadInt = fmap fromInteger . 
               mfilter (\n -> n >= toInteger (minBound :: Int) && 
                              n <= toInteger (maxBound :: Int)) .
               maybeReadInteger

