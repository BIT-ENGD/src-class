finde_f x =
    if (x-2) mod 3 /= 0
    then 1
    else x - (x-2)/3

*Main> finde_f 6

<interactive>:170:1:
    No instance for (Fractional ((a10 -> a10 -> a10) -> a20 -> a0))
      arising from a use of `finde_f'
    Possible fix:
      add an instance declaration for
      (Fractional ((a10 -> a10 -> a10) -> a20 -> a0))
    In the expression: finde_f 6
    In an equation for `it': it = finde_f 6

<interactive>:170:9:
    No instance for (Num ((a10 -> a10 -> a10) -> a20 -> a0))
      arising from the literal `6'
    Possible fix:
      add an instance declaration for
      (Num ((a10 -> a10 -> a10) -> a20 -> a0))
    In the first argument of `finde_f', namely `6'
    In the expression: finde_f 6
    In an equation for `it': it = finde_f 6

mod
/
mod
*Main> finde_f 3

<interactive>:12:1:
    No instance for (Integral a0) arising from a use of `finde_f'
    The type variable `a0' is ambiguous
    Possible fix: add a type signature that fixes these type variable(s)
    Note: there are several potential instances:
      instance Integral Int -- Defined in `GHC.Real'
      instance Integral Integer -- Defined in `GHC.Real'
      instance Integral GHC.Types.Word -- Defined in `GHC.Real'
    In the expression: finde_f 3
    In an equation for `it': it = finde_f 3

<interactive>:12:9:
    No instance for (Num a0) arising from the literal `3'
    The type variable `a0' is ambiguous
    Possible fix: add a type signature that fixes these type variable(s)
    Note: there are several potential instances:
      instance Num Double -- Defined in `GHC.Float'
      instance Num Float -- Defined in `GHC.Float'
      instance Integral a => Num (GHC.Real.Ratio a)
        -- Defined in `GHC.Real'
      ...plus three others
    In the first argument of `finde_f', namely `3'
    In the expression: finde_f 3
    In an equation for `it': it = finde_f 3

-- Continuous Fraction -------------------------------------------------------------------
-- A --
cont_frac n d k =
    if k == 1
    then (n k) / (d k)
    else (n k) / ((d k) + (cont_frac n d (k-1)))

-- B --
cont_frac_iter n d k count =
    if count == k
    then (n count) / (d count)
    else (n count) / ((d count) + (cont_frac_iter n d k (count+1)))


-- e-2 Continuous Fraction ---------------------------------------------------------------
finde_cf k =
    2 + (cont_frac_iter (\x -> 1) finde_f (k) (1))

-- Auxiliary Function --
finde_f x =
        if mod (x-2) 3 /= 0
        then 1
        else fromIntegral x - (fromIntegral x-2)/3

