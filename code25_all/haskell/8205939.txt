calctvd :: [Perk] -> [Perk] -> Perk -> Double
calctvd ps fs p = (fromIntegral(tvn) / fromIntegral(points)) :: Double
    where
        tvn = calctvn ps fs p
        points = length $ [i | i <- perkAndPreqs ps p, i `notElem` fs]

(fromIntegral(tvn) / fromIntegral(points))
updatetvd :: [Perk] -> [Perk] -> [Perk]
updatetvd [] _ = []
updatetvd ps fs
    --If p is in the list of elements already taken, then do not update it
    | p `elem` fs = [p] ++ updatetvd (tail ps) fs
    --Otherwise, update the tvd value
    | otherwise = [PerkImpl (tvd, school, skill, name, def, preqstr, pref)] ++ updatetvd (tail ps) fs
    where
        p = head ps
        PerkImpl (_, school, skill, name, def, preqstr, pref) = p
        tvd = calctvd ps fs p

(fromIntegral(tvn) / fromIntegral(points))
3 / fromIntegral(points)
testcalctvd :: Double
testcalctvd = fromIntegral(3) / fromIntegral(4) :: Double

testupdatetvd :: Double
testupdatetvd = testcalctvd

3 / fromIntegral(points)
> calctvd initial [] i17
0.6    {This is 3/5, because i17 has 5 points}
> updatetvd initial []
[...3.0...]    {This is just the numerator 3}

--Take a perk and return a list of that perk and all of its pre-requisites
perkAndPreqs :: [Perk] -> Perk -> [Perk]
perkAndPreqs _ NULL = []
perkAndPreqs ps p = [p] ++ perkAndPreqs ps preq
    where
        PerkImpl (_, _, _, _, _, preqstring, _) = p
        preq = perkIdentifier preqstring ps

