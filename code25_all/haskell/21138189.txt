import qualified Data.Vector.Unboxed as Vector
import Data.Vector.Unboxed (Vector)
import qualified Data.Vector.Unboxed.Mutable as MVector

process :: [Int] -> Vector Int -> Vector Int
process [] v = v
process (x:xs) v = process xs $ Vector.modify modify v
  where
  modify mv = do
    old <- MVector.read mv x
    MVector.write mv x (old + 1)

main :: IO ()
main = do
  print $ process [1, 1, 3, 1] $ Vector.replicate 10 0

core
newByteArray#
copyByteArray#
readIntArray#
writeIntArray#
unsafeFreezeByteArray#
modify p = new . New.modify p . clone

RULE
"clone/new [Vector]" forall p.
  clone (new p) = p

modify
modify p2 . modify p1
=> new . New.modify p2 . clone . new . New.modify p1 . clone
=> new . New.modify p2 . New.modify p1 . clone

process
process [1, 2] v
=> process [2] $ Vector.modify modify v
=> process [] $ Vector.modify modify $ Vector.modify modify v
=> Vector.modify modify $ Vector.modify modify v
=> the same as above

