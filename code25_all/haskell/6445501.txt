fmap :: Functor f => (a -> b) -> (f a -> f b)

mapM :: (Traversable f, Monad m) => (a -> m b) -> (f a -> m (f b))

mapKleisli :: (Traversable f, Monad m) => Kleisli m a b -> Kleisli m (f a) (f b)
mapKleisli = Kleisli . mapM . runKleisli

mapCategory :: (X f, Category c) => c a b -> c (f a) (f b)

{-# LANGUAGE TypeOperators #-}

import Prelude hiding (id, (.), mapM)
import Control.Arrow
import Control.Category

class Traversable f where
  traverse :: ArrowApply (~>) => f a -> (a ~> b) ~> f b

mapArrow :: (ArrowApply (~>), Traversable f) => a ~> b -> f a ~> f b
mapArrow a = arr (\x -> (traverse x, a)) >>> app

instance Traversable Maybe where
  traverse Nothing = arr (const Nothing)
  traverse (Just x) = arr (\a -> (a, x)) >>> app >>> arr Just

instance Traversable [] where
  traverse [] = arr (const [])
  traverse (x : xs) = undefined -- this is hard!

[]
