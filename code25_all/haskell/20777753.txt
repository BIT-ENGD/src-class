newtype Canonical Int = Canonical Int

canonicalize :: Int  -> Canonical  Int
canonicalize =  Canonical . (`mod` 10)  -- or whatever

cmap :: (b->Int) -> (Canonical b) -> (Canonical Int)
cmap f (Canonical x) = canonicalize $ f x

cmap2 :: (b->c->Int) -> (Canonical b) -> (Canonical c) -> (Canonical Int)
cmap2 f (Canonical x) (Canonical y) = canonicalize $ f x y

cmap
cmap2
newtype Canonical a = Canonical { value :: a, canonicalizer :: a -> a }

Int
Integral a
instance (Functor Int) (Canonical Int) 

newtype (Integral a) => Canonical a = Canonical a -- -XDatatypeContexts
instance (Integral a) => Functor Canonical where
  fmap f (Canonical x) = canonicalize  $ f x

DatatypeContexts
 `Could not deduce (Integral a1) arising from a use of 'C'   
 from the context (Integral a)
 bound by the instance declaration
 [...] fmap :: (a1 -> b) -> (C a1 -> C b)

Integral a
fmap
(Integral -> Integral)
fmap
instance (Integer a) => Functor Canonical where

