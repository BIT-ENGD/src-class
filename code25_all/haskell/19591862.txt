mrepeat :: Integer -> String -> String
mrepeat numRepeat strRepeat
 | numRepeat == 0 = ""
 | otherwise = strRepeat ++ mrepeat (numRepeat - 1) strRepeat

romanLetter :: [String]
romanValue :: [Int]
romanLetter = ["I", "V", "X", "L", "C", "D", "M"]
romanValue = [1, 5, 10, 50, 100, 500, 1000]
convertIter :: Int -> Integer -> String
convertIter count number
 | count == -1 = ""
 | mod count 2 == 0 && q == 4 = (romanLetter !! count) ++ (romanLetter !! (count + 1)) ++ (convertIter (count - 1) r)
 | mod count 2 == 1 && (mod (number + (romanValue !! (count - 1))) romanValue !! count) == 2 = (romanLetter !! (count - 1)) ++ (romanLetter !! (count + 1)) ++ (convertIter (count - 1) r)
 | otherwise = (mrepeat q (romanLetter !! (count - 1))) ++ (convertIter !! (count - 1) r)
 where (q, r) = divMod number romanValue !! count

intToRoman :: Integer -> String
intToRoman number = convertIter 6 number

test.hs:14:25:
    No instance for (Integral [a0])
      arising from a use of `mod'
    Possible fix: add an instance declaration for (Integral [a0])
    In the first argument of `(!!)', namely
      `mod (number + (romanValue !! (count - 1))) romanValue'
    In the first argument of `(==)', namely
      `(mod (number + (romanValue !! (count - 1))) romanValue !! count)'
    In the second argument of `(&&)', namely
      `(mod (number + (romanValue !! (count - 1))) romanValue !! count)
     ==
       2'

test.hs:14:30:
    Couldn't match expected type `[a0]' with actual type `Integer'
    In the first argument of `(+)', namely `number'
    In the first argument of `mod', namely
      `(number + (romanValue !! (count - 1)))'
    In the first argument of `(!!)', namely
      `mod (number + (romanValue !! (count - 1))) romanValue'

test.hs:14:37:
    No instance for (Num [a0])
      arising from a use of `+'
    Possible fix: add an instance declaration for (Num [a0])
    In the first argument of `mod', namely
      `(number + (romanValue !! (count - 1)))'
    In the first argument of `(!!)', namely
      `mod (number + (romanValue !! (count - 1))) romanValue'
    In the first argument of `(==)', namely
      `(mod (number + (romanValue !! (count - 1))) romanValue !! count)'

test.hs:16:17:
    Couldn't match expected type `[(t0, t1)]'
                with actual type `(a0, a0)'
    In the return type of a call of `divMod'
    In the first argument of `(!!)', namely `divMod number romanValue'
    In the expression: divMod number romanValue !! count
Failed, modules loaded: none.

