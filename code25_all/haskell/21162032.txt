data Car = Car { position :: Int }

move :: Car -> Int -> Car
move c n =  Car { position = n + (position c) }

move
type Parking = IORef Car -- holds a car

newParking :: Car -> IO Parking
newParking = newIORef 

getCar :: Parking -> IO Car
setCar :: Parking -> Car -> IO ()
move :: Car -> Int -> Car
Parking -> Int -> ()
move
import Data.IORef
import Control.Concurrent

-- -----------------------------------------------------

timeGoesBy place = do
        moveTheCar place
        threadDelay 1000000
        timeGoesBy place

moveTheCar place = do
     car <- getCar place
     print $ getPos car
     modifyCar place (move 7)    

-- -----------------------------------------------------
main = do
     place <- newParking (newCar 1000)
     timeGoesBy place
     print "end"

-- -----------------------------------------------------

type Parking = IORef Car -- mutable var for holding a car (the car may be replaced)

newParking :: Car -> IO Parking
newParking = newIORef 

getCar :: Parking -> IO Car
getCar = readIORef 

setCar :: Parking -> Car -> IO ()
setCar = writeIORef

modifyCar :: Parking -> (Car -> Car) -> IO ()
modifyCar = modifyIORef

-- -----------------------------------------------------

data Car = Car { position :: Int } -- Car data type ("pure")

-- create a car
newCar :: Int -> Car
newCar v = Car { position = v}

-- get the position of a car
getPos :: Car -> Int
getPos c = (position c)

-- move : transform a given car into a new "moved car"
move :: Int -> Car -> Car -- first the int so that we can curry (i.e. move 7)
move n car = Car { position = n + (position car) }

