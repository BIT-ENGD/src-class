Num
{-# LANGUAGE GeneralizedNewtypeDeriving #-}

newtype Bivar t = Bivar (t,t) deriving (Show, Eq)

instance (Num t) => Num (Bivar t) where 
  (+) (Bivar (x1,y1)) (Bivar (x2,y2)) = Bivar (x1+x2, y1+y2)
  (-) (Bivar (x1,y1)) (Bivar (x2,y2)) = Bivar (x1-x2, y1-y2)
  (*) (Bivar (x1,y1)) (Bivar (x2,y2)) = Bivar (x1*x2, y1*y2)
  abs (Bivar (x1,y1)) = Bivar (abs x1, abs y1)
  fromInteger i = Bivar (fromInteger i, fromInteger i)
  signum (Bivar (x1,y1)) = Bivar (signum x1, signum y1)

newtype BivarNode = BivarNode (Bivar Int) deriving (Show, Eq, Num)
newtype BivarVal = BivarVal (Bivar Double) deriving (Show, Eq, Num)
newtype HBivarVal = HBivarVal (Bivar Double) deriving (Show, Eq, Num)

-- This is annoying:
a1 = BivarVal (Bivar (1.0, 2.0))
a2 = HBivarVal (Bivar (1.0, 2.0))
b = BivarNode (Bivar (1,2))

-- is there a way so that I can write it this way?
aa1 = BivarVal (1.0, 2.0)
aa2 = HBivarVal (1.0, 2.0)
bb = BivarNode (1,2)

myFunction :: HBivarVal -> Double
myFunction (HBivarVal (Bivar (x,y))) = x 

