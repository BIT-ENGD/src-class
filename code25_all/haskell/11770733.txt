data ListItem l a =
    Nil |
    Cons { headL :: a, tailL :: l a }

Cons a (l a)
{-# LANGUAGE FlexibleContexts, TypeFamilies #-}
type
type ItemM l :: * -> *
Data.List.Class
-- | A class for list types. Every list has an underlying monad.
class (MonadPlus l, Monad (ItemM l)) => List l where
    type ItemM l :: * -> *
    runList :: l a -> ItemM l (ListItem l a)
    joinL :: ItemM l (l a) -> l a
    cons :: a -> l a -> l a
    cons = mplus . return

Identity
import Data.Functor.Identity (Identity(..))
type
type
typedef
instance List [] where
    type ItemM [] = Identity
    runList [] = Identity Nil
    runList (x:xs) = Identity $ Cons x xs
    joinL = runIdentity
    cons = (:)

instance Functor m => Functor (ListItem m) where
    fmap _ Nil = Nil
    fmap func (Cons x xs) = Cons (func x) (fmap func xs)

