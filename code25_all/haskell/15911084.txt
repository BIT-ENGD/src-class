f :: MonadIO m => a -> m b

f
f :: String -> IO String
f s = putStrLn ("hello " ++ s) >> return s

memoize
do
  mf <- memoize f
  s <- mf "world"
  t <- mf "world"
  return (s,t)

"hello world"
("world", "world")
mf
memoize :: (MonadIO m, Ord a) => (a -> m b) -> m (a -> m b)
memoize f = do
  cache <- liftIO $ newTVarIO Map.empty
  return $ \a -> do
              v <- liftIO $ atomically $ lookupInsert cache a
              b <- maybe (f a) return =<< liftIO (atomically $ takeTMVar v)
              liftIO $ atomically $ putTMVar v $ Just b
              return b
    where
      lookupInsert :: Ord a => TVar (Map a (TMVar (Maybe b))) -> a -> STM (TMVar (Maybe b))
      lookupInsert cache a = do
                         mv <- Map.lookup a <$> readTVar cache
                         case mv of
                           Just v -> return v
                           Nothing -> do
                                   v <- newTMVar Nothing
                                   modifyTVar cache (Map.insert a v)
                                   return v

cache
TVar (Map a (TMVar (Maybe b)))
TMVar
Nothing
lookupInsert
cache
TMVar
Nothing
v :: TMVar (Maybe b)
a
f a
Maybe
take
put
f a
