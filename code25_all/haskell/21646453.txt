valid1 :: (Bool -> Bool) -> Bool
valid1 bf = (bf True) && (bf False)

valid2 :: (Bool -> Bool -> Bool) -> Bool
valid2 bf = (bf True True)
            && (bf True False)
            && (bf False True)
            && (bf False False)

valid3 :: (Bool -> Bool -> Bool -> Bool) -> Bool
valid3 bf = and [ bf p q r | p <- [True,False],
                             q <- [True,False],
                             r <- [True,False]]

validR n bf :: Int -> (Bool -> a) -> Bool
validR n bf | n == 1    = valid1 bf 
            | otherwise = (validR (n-1) (bf True)) && (validR (n-1) (bf False))

n
bf
bf
bf True
bf False
