[[Int]]
[Int]
zeroList :: Int -> [Int] -> [Int]
zeroList r myList = (take (r*r-(length myList)) (0 : zeroList r myList))

processList  ::  Int  ->  [Int]  ->  [[Int]]
processList  r myList = (if (length myList < r*r)
                        then (myList:(zeroList r myList))
                        else if (length (myList > r*r))
                        then (reverse (drop r (reverse myList)))
                        else 
                                myList)

make2DList  ::  Int  ->  [Int]  ->  [[Int]]                     


make2DList r myList = (if myList == [] 
                        then make2DList
                    else ( ( take r (processList r myList) ):( make2DList r ( drop r (processList r myList) ) )))

D:\haskell\task1.hs:6:63:
    Couldn't match expected type `[Int]' with actual type `Int'
    Expected type: [[Int]]
      Actual type: [Int]
    In the return type of a call of `zeroList'
    In the second argument of `(:)', namely `(zeroList r myList)'

D:\haskell\task1.hs:14:54:
    Couldn't match expected type `[[Int]]'
                with actual type `Int -> [Int] -> [[Int]]'
    In the expression: make2DList
    In the expression:
      (if myList == [] then
           make2DList
       else
           ((take r myList) : (make2DList r (drop r myList))))
    In an equation for `make2DList':
        make2DList r myList
          = (if myList == [] then
                 make2DList
             else
                 ((take r myList) : (make2DList r (drop r myList))))
Failed, modules loaded: none.
Prelude>

zeroList r myList
