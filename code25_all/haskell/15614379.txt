p0
p0
{-# LANGUAGE TypeFamilies, FlexibleContexts, MultiParamTypeClasses #-}
import Data.List (minimumBy)
import Data.Ord (comparing)
import qualified Math.Geometry.Grid as G (Grid(..))
import qualified Math.Geometry.GridMap as GM (GridMap(..))
import Prelude hiding (lookup)

class Pattern p where
  type Metric p
  difference ∷ p → p → Metric p
  makeSimilar ∷ p → Metric p → p → p

data SOM gm k p = SOM
  {
    sGridMap :: gm p,
    sLearningFunction :: Int -> Int -> Metric p,
    sCounter :: Int
  }

foo 
  :: (Pattern p, Ord v, v ~ Metric p, GM.GridMap gm p, GM.GridMap gm v, 
      k ~ G.Index (GM.BaseGrid gm p), k ~ G.Index (GM.BaseGrid gm v)) => 
    SOM gm k p -> p -> [(k, v)]
foo s p = GM.toList . GM.map (p `difference`) . sGridMap $ s

bar :: (Pattern p, Ord v, v ~ Metric p) => [(k, v)] -> k
bar ds = fst . minimumBy (comparing snd) $ ds

wombat
  :: (Pattern p, Ord v, v ~ Metric p, GM.GridMap gm p, GM.GridMap gm v,
      k ~ G.Index (GM.BaseGrid gm p), k ~ G.Index (GM.BaseGrid gm v)) => 
    SOM gm k p -> p -> (k, [(k, v)])
wombat s p = (bar diffs, diffs)
  where diffs = foo s p

λ> :l ../amy.hs
[1 of 1] Compiling Main             ( ../amy.hs, interpreted )

../amy.hs:33:19:
    Could not deduce (v ~ Metric p0)
    from the context (Pattern p,
                      Ord v,
                      v ~ Metric p,
                      GM.GridMap gm p,
                      GM.GridMap gm v,
                      k ~ G.Index (GM.BaseGrid gm p),
                      k ~ G.Index (GM.BaseGrid gm v))
      bound by the type signature for
                 wombat :: (Pattern p, Ord v, v ~ Metric p, GM.GridMap gm p,
                            GM.GridMap gm v, k ~ G.Index (GM.BaseGrid gm p),
                            k ~ G.Index (GM.BaseGrid gm v)) =>
                           SOM gm k p -> p -> (k, [(k, v)])
      at ../amy.hs:(30,10)-(32,40)
      `v' is a rigid type variable bound by
          the type signature for
            wombat :: (Pattern p, Ord v, v ~ Metric p, GM.GridMap gm p,
                       GM.GridMap gm v, k ~ G.Index (GM.BaseGrid gm p),
                       k ~ G.Index (GM.BaseGrid gm v)) =>
                      SOM gm k p -> p -> (k, [(k, v)])
          at ../amy.hs:30:10
    In the expression: bar diffs
    In the expression: (bar diffs, diffs)
    In an equation for `wombat':
        wombat s p
          = (bar diffs, diffs)
          where
              diffs = foo s p
Failed, modules loaded: none.

