matchListWith eq [] []
matchListWith :: (Eq a) => (a -> a -> Bool) -> [a] -> [a] -> Bool
matchListWith f (x:xs) (y:ys) = (f x y) && (matchListWith f xs ys)
matchListWith _ []     []     = True
matchListWith _ _      _      = False

eq :: (Eq a) => a -> a -> Bool
eq a b = (a == b)

main = do
   print (matchListWith eq [1, 3] [1, 3])
   print (matchListWith eq [1, 3] [1])
   print (matchListWith eq [1] [1, 3])
   print (matchListWith eq [3, 1] [1, 3])
   print (matchListWith eq [1] [])
   print (matchListWith eq [] [])

failure.hs:16:11:
    No instance for (Eq a0) arising from a use of `matchListWith'
    The type variable `a0' is ambiguous
    Possible fix: add a type signature that fixes these type variable(s)
    Note: there are several potential instances:
      instance Eq a => Eq (GHC.Real.Ratio a) -- Defined in `GHC.Real'
      instance Eq () -- Defined in `GHC.Classes'
      instance (Eq a, Eq b) => Eq (a, b) -- Defined in `GHC.Classes'
      ...plus 22 others
    In the first argument of `print', namely `(matchListWith eq [] [])'
    In a stmt of a 'do' block: print (matchListWith eq [] [])
    In the expression:
      do { print (matchListWith eq [1, 3] [1, 3]);
           print (matchListWith eq [1, 3] [1]);
           print (matchListWith eq [1] [1, 3]);
           print (matchListWith eq [3, 1] [1, 3]);
           .... }

matchListWith eq [] []
*Main> matchListWith eq [] []
True
*Main> 

