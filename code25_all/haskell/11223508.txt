import Text.ParserCombinators.Parsec((<|>), unexpected, lookAhead, noneOf, char)
import Control.Monad(when)

data BracketElement = BEChar Char | BEChars String | BEColl String | BEEquiv String | BEClass String

p_set_elem_char = do 
  c <- noneOf "]"
  when (c == '-') $ do
    atEnd <- (lookAhead (char ']') >> return True) <|> (return False)
    when (not atEnd) (unexpected "A dash is in the wrong place in a bracket")
  return (BEChar c)

import Text.ParserCombinators.Parsec((<|>), (<?>), unexpected, lookAhead, noneOf, char)
import Control.Monad(when)
import Data.Functor.Identity
import qualified Text.Parsec.Prim as PR

-- | BracketElement is internal to this module
data BracketElement = BEChar Char | BEChars String | BEColl String | BEEquiv String | BEClass String
                    deriving Show

p_set_elem_char :: PR.ParsecT [Char] u Identity BracketElement  
p_set_elem_char = do 
  c <- noneOf "]"
  when (c == '-') $ do
    atEnd <- (lookAhead (char ']') >> return True) <|> (return False)
    when (not atEnd) (unexpected "A dash is in the wrong place in a bracket")
  return (BEChar c)

type BracketElement = BEChar of char 
                    | BEChars of string 
                    | BEColl of string 
                    | BEEquiv of string 
                    | BEClass of string

let p_set_elem_char : Parser<BracketElement, _> = 
    fun stream ->
        let stateTag = stream.StateTag
        let reply = (noneOf "]") stream
        let chr = reply.Result
        let mutable reply2 = Reply(BEChar chr)
        if reply.Status = Error && stateTag = stream.StateTag then
            reply2.Status <- Error
            reply2.Error <-  reply.Error
        else if chr = '-' && stream.Peek() <> ']' then
            reply2.Status <- Error
            reply2.Error <- messageError ("A dash is in the wrong place in a bracket")
        reply2

