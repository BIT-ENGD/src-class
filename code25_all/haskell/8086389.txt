f :: (Num a) => a -> a -> State [a] a
f x y = modify ((2*x):) >> return (x+y)   -- state and value are modified based on the passed values

State
g :: (Num a) => [a] -> (a, [a]) -> [(a,[a])]
g [] _ = []
g (x:xs) aa@(a,b) = (new : next)
    where new = runState (f x a) b   -- here the old value a is required!
          next = g xs aa

g :: [a] -> [State [a] a] 

g x (y, s)
x
y
s
x_i
x
(y,s)
f x_i y
 g [1,2,3] (4,[2,3,4]) == [(5,[10,2,3,4]),(6,[12,2,3,4]),(7,[14,2,3,4])]

