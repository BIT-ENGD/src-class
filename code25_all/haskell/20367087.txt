11,22,33,44,55
66,77,88,99,10

    {-# Language OverloadedStrings #-}


-- adapted from https://github.com/robinbb/attoparsec-csv


module Text.ParseCSV
   ( 
   parseCSV
   ) where

import Prelude hiding (concat, takeWhile)
import Control.Applicative ((<$>), (<|>), (<*>), (<*), (*>), many)
import Control.Monad (void, liftM)
import Data.Attoparsec.Text
import qualified Data.Text as T (Text, concat, cons, append, pack, lines)
import qualified Data.Text.IO as IO (readFile, putStr)

import qualified Data.ByteString.Char8 as BSCH (readInteger)


lineEnd :: Parser ()
lineEnd =
   void (char '\n') <|> void (string "\r\n") <|> void (char '\r')
   <?> "end of line"

parserInt :: Parser Integer
parserInt = (signed decimal)

record :: Parser [Integer]
record =
   parserInt `sepBy1` char ','
   <?> "record"

file :: Parser [[Integer]]
file =
   (:) <$> record
       <*> manyTill (lineEnd *> record)
                    (endOfInput <|> lineEnd *> endOfInput)
   <?> "file"


parseCSV :: T.Text -> Either String [[Integer]]
parseCSV = 
   parseOnly file


getValues :: Either String [[Integer]] -> [Integer] 
getValues (Right [x]) = x
getValues _ = []


getLines :: FilePath -> IO [T.Text]
getLines = liftM T.lines . IO.readFile

parseAndFilter :: T.Text -> [Integer]
parseAndFilter = ((\x -> filter (>30) x) . getValues . parseCSV)

main = do
    list <- getLines "myfile.txt"
    putStr $ show $ map parseAndFilter list

[Integer]
Data.Vector
--The simplest way to parse a file of Int or Integer types is with a strict or lazy --ByteString, and the readInt or readInteger functions:

{-# LANGUAGE BangPatterns #-}

import qualified Data.ByteString.Lazy.Char8 as L
import qualified Data.Vector                as U
import System.Environment

main = do
    [f] <- getArgs
    s   <- L.readFile f
    print . U.sum . parse $ s

-- Fill a new vector from a file containing a list of numbers.
parse = U.unfoldr step
  where
     step !s = case L.readInt s of
        Nothing       -> Nothing
        Just (!k, !t) -> Just (k, L.tail t)

[Integer]
>30
