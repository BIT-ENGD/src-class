a
a -> v
type OptiF a v = (a -> v) -> a

data Container a = forall v. (Ord v) => Cons (OptiF a v) (a -> Int)

OptiF a v
v
Ord
OptiF a v
val
result
optimize :: (forall v. (Ord v) => a -> v) -> Container a -> Int
optimize val (Cons opti result) = result (opti val)

optimize
callOptimize :: Int
callOptimize = optimize val cont
   where val = (*3)
         opti val' = if val' 1 > val' 0 then 100 else -100
         cont = Cons opti (*2)

Could not deduce (v ~ Int)
from the context (Ord v)
  bound by a type expected by the context: Ord v => Int -> v
  at bla.hs:12:16-32
  `v' is a rigid type variable bound by
      a type expected by the context: Ord v => Int -> v at bla.hs:12:16
Expected type: Int
  Actual type: Int
Expected type: Int -> v
  Actual type: Int -> Int
In the first argument of `optimize', namely `val'
In the expression: optimize val cont

optimize val cont
forall v
optimize
optimize
a -> v
v
optimize
a -> v
Ord v
OptiF a v
v
a -> v
Ord v
optimize
OptiF a v
