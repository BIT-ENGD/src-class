between
sepBy1
Text.ParserCombinators.ReadP
tupleAsIntPair :: ReadP (Int, Int)
ReadP_to_S
"(3,4)"
(3,4)
ReadS
import Text.ParserCombinators.ReadP

isNumericOrSep :: Char -> Bool
isNumericOrSep = flip elem $ "0123456789-, "

tuplify2 :: [Int] -> (Int, Int)
tuplify2 [x,y] = (x,y)

tupleAsIntPair :: ReadP (Int, Int)
tupleAsIntPair = fmap tuplify2 parsedList 
    where   parsedList = fmap (map read) $ sepBy1 noparens sep
            noparens = between open close $ many1 (satisfy isNumericOrSep)
            open = char '('
            close = char ')'
            sep = char ','

(readP_to_S tupleAsIntPair) "(3,4)"
noparens
(readP_to_S noparens) "(3,4)"
[("3,4","")]
(readP_to_S $ sepBy1 (many1 $ satisfy isNumericOrSep) sep) "3,4"
[(["3"],",4"),(["3,"],"4"),(["3","4"],""),(["3,4"],"")]
sepBy1
between
sepBy1
sepBy1
tuplify2
