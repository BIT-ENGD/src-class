foldl
foldl'
sum
foldr
filter
sum_f
sum_f
f x
sum_f :: (Num a) => (a -> Bool) -> [a] -> [a]
sum_f f = 
  let
    sum_f_worker s (x:xs) = 
      let
        rec_call z = sum_f_worker z xs
        next_sum = s + x
      in
        next_sum `seq` if (f x) then next_sum : (rec_call 0) else rec_call next_sum
    sum_f_worker _ [] = []
  in
    sum_f_worker 0

[1, 2, 3+4, 5+6+7+8, 9+10+11+12+13+14+15+16, ...]

[1, 2, 7, 26, 100, ...]

import Data.Bits

main = 
  let
    power_of_two x = (x .&. (x - 1)) == 0 -- .&. is bitwise and
  in
    print $ take 25 $ sum_f power_of_two [(1::Integer)..]

foldl'
foldr
foldl
foldr
