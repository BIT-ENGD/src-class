{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE FlexibleInstances     #-}

data MyError = MyError String deriving (Eq, Show)

data MyList    = MyList [Double] deriving (Eq, Show)
data NamedList = NamedList String MyList deriving (Eq, Show)

class MyNum a b ret where
    myAdd       :: a -> b -> Either MyError ret
    myLessThan  :: a -> b -> Either MyError Bool

instance MyNum MyList Double MyList where
    myAdd (MyList xs) x = Right $ MyList $ map (+x) xs
    myLessThan (MyList xs) x = Right $ all (< x) xs

instance MyNum NamedList Double NamedList where
    myAdd (NamedList n l) x = fmap (NamedList n) $ myAdd l x
    myLessThan (NamedList n l) x = myLessThan l x

No instance for (MyNum MyList Double ret0)
  arising from a use of `myLessThan'
The type variable `ret0' is ambiguous
Possible fix: add a type signature that fixes these type variable(s)
Note: there is a potential instance available:
  instance MyNum MyList Double MyList
    -- Defined at testing_instances.hs:13:10
Possible fix:
  add an instance declaration for (MyNum MyList Double ret0)
In the expression: myLessThan l x
In an equation for `myLessThan':
    myLessThan (NamedList n l) x = myLessThan l x
In the instance declaration for `MyNum NamedList Double NamedList'

MyNum
MyList
myAdd
MyNum
myLessThan
MyNum Double MyList MyList
MyNum MyList MyList MyList
NamedList
myLessThan
