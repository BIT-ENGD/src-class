Couldn't match expected type `a -> Bool'
           against inferred type `[Bool]'
    In the first argument of `any', namely
        `(map (\ t -> contains t b) c)'
    In the second argument of `(||)', namely
        `any (map (\ t -> contains t b) c)'
    In the expression: a == b || any (map (\ t -> contains t b) c)

data Tree a = Leaf a | Branch a [(Tree a)] deriving (Show)

contains :: Tree a -> a -> Bool 
contains (Leaf a) b = a == b
contains (Branch a c) b = a == b or (map (\ t -> contains t b) c)

Occurs check: cannot construct the infinite type:
      a = ([Bool] -> Bool) -> [Bool] -> a
    When generalising the type(s) for `contains'

data Tree a = Leaf a | Branch a [(Tree a)] deriving (Show)

contains :: Eq a => Tree a -> a -> Bool 
contains (Leaf a) b = a == b
contains (Branch a c) b = a == b || (map (\t -> contains t b) c)

Couldn't match expected type `Bool' against inferred type `[Bool]'
    In the second argument of `(||)', namely
        `(map (\ t -> contains t b) c)'
    In the expression: a == b || (map (\ t -> contains t b) c)
    In the definition of `contains':
        contains (Branch a c) b = a == b || (map (\ t -> contains t b) c)

