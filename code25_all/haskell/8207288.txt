{-# LANGUAGE FlexibleContexts, MultiParamTypeClasses,
    FlexibleInstances, UndecidableInstances, ScopedTypeVariables,
    NoMonomorphismRestriction, DeriveTraversable, DeriveFoldable,
    DeriveFunctor, GADTs, KindSignatures, TypeOperators, 
    TemplateHaskell,  BangPatterns
 #-}
{-# OPTIONS_GHC -fno-warn-unused-binds -fno-warn-name-shadowing 
    -fwarn-monomorphism-restriction -fwarn-hi-shadowing
  #-}

module LiftedSpine where
import Test.HUnit

-- Lifted Type View 
newtype Id x = InID x 
newtype Char' x = InChar' Char
newtype Int' x = InInt' Int 
data List' a x = Nil' | Cons' (a x) (List' a x)
data Pair' a b x = InPair' (a x ) (b x)
data Tree' a x = Empty' | Node' (Tree' a x ) (a x) (Tree' a x)

data Type' :: ( * -> * ) -> * where 
  Id :: Type' Id 
  Char' :: Type' Char' 
  Int' :: Type' Int' 
  List' :: Type' a -> Type' (List' a)
  Pair' :: Type' a -> Type' b -> Type' (Pair' a b)
  Tree' :: Type' a -> Type' (Tree' a)

infixl 1 :->
data Typed' (f :: * -> *)  a = (f a) :-> (Type' f)


size :: forall (f :: * -> *)  (a :: *) . Typed' f a -> Int 
size (Nil' :-> (List' a' )) = 0 
size (Cons' x xs :-> List' a' ) =  
  size (xs :-> List' a') + size (x :-> a' )

