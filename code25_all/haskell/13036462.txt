import GHC.Generics

{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DefaultSignaturesGeneric #-}

data Bin = O | I deriving Show

data UserTree a = Node a (UserTree a) (UserTree a) | Leaf deriving Generic

class GSerialize f where
    gput :: f a -> [Bin]

instance GSerialize U1 where
    gput U1 = []

instance (GSerialize a, GSerialize b) => GSerialize (a :*: b) where
    gput (x :*: y) = gput x ++ gput y

instance (GSerialize a, GSerialize b) => GSerialize (a :+: b) where
    gput (L1 x) = O : gput x
    gput (R1 x) = I : gput x

instance (GSerialize a) => GSerialize (M1 i c a) where
    gput (M1 x) = gput x

instance (Serialize a) => GSerialize (K1 i a) where
    gput (K1 x) = put x

class Serialize a where
    put :: a -> [Bin]
    default put :: (Generic a, GSerialize (Rep a)) => a -> [Bin]
    put = gput . from

instance Serialize Int
instance Serialize Char
instance Serialize Bool
instance (Serialize a) => Serialize (UserTree a)

toserialize :: (Serialize (UserTree a) ) => UserTree a -> [Bin]
toserialize tree = put tree

toserialize Leaf

 Ambiguous type variable `a0' in the constraint:
   (Serialize a0) arising from a use of `toserialize'
 Probable fix: add a type signature that fixes these type variable(s)
 In the expression: serialize Leaf
 In an equation for `it': it = toserialize Leaf

