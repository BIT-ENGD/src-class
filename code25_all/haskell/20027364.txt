changeIn2dList :: (Eq a) => (Int, Int) -> a -> [[a]] -> [[a]] 
changeIn2dList _ _ [] = error "Can't change empty list" 
changeIn2dList (x, y) w (z:zs) 
  | x == 0 = changeInList y w z 
  | otherwise = z:(changeIn2dList (x-1, y) w zs)

Could not deduce (a ~ [a])
 from the context (Eq a)
   bound by the type signature for
              changeIn2dList :: Eq a => (Int, Int) -> a -> [[a]] -> [[a]]
   at starter/Helpers.hs:25:19-61
   `a' is a rigid type variable bound by
       the type signature for
          changeIn2dList :: Eq a => (Int, Int) -> a -> [[a]] -> [[a]]
       at starter/Helpers.hs:25:19
 In the second argument of `changeInList', namely `w'
 In the expression: changeInList y w z
 In an equation for `changeIn2dList':
     changeIn2dList (x, y) w (z : zs)
       | x == 0 = changeInList y w z
       | otherwise = z : (changeIn2dList (x - 1, y) w zs)

--changeIn2dList :: (Eq a) => (Int, Int) -> a -> [[a]] -> [[a]] 
changeIn2dList _ _ [] = error "Can't change empty list" 
changeIn2dList (x, y) w (z:zs) 
| x == 0 = changeInList y w z 
| otherwise = z:(changeIn2dList (x-1, y) w zs)

Occurs check: cannot construct the infinite type: a1 = [a1]
In the first argument of `(:)', namely `z'
In the expression: z : (changeIn2dList (x - 1, y) w zs)
In an equation for `changeIn2dList':
    changeIn2dList (x, y) w (z : zs)
      | x == 0 = changeInList y w z
      | otherwise = z : (changeIn2dList (x - 1, y) w zs)

| otherwise = z : (changeIn2dList (x - 1, y) w zs)

z:([[a]])
z
(changeIn2dList (x - 1, y) w zs)
changeInList
changeInList :: (Eq a) => Int -> a -> [a] -> [a]
changeInList _ _ [] = error "Can't change empty list"
changeInList x w (z:zs)
  | x == 0 = w:zs
  | otherwise = z:(changeInList (x - 1) w zs)

