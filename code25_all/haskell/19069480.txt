module SetOrd (Set(..),emptySet,isEmpty,inSet,subSet,insertSet,
           deleteSet,powerSet,takeSet,(!!!),list2set,unionSet) 

where

import Data.List (sort) 

{-- Sets implemented as ordered lists without duplicates --} 

newtype Set a = Set [a] deriving (Eq,Ord)

instance (Show a) => Show (Set a) where
showsPrec _ (Set s) str = showSet s str

showSet []     str = showString "{}" str
showSet (x:xs) str = showChar '{' ( shows x ( showl xs str))
 where showl []     str = showChar '}' str
       showl (x:xs) str = showChar ',' (shows x (showl xs str))

getSetInt :: IO Set
getSetInt = do 
            d <- getRandomInt 10
            n <- getRandomInt 5
            m <- getRandomInt 5
            getSetI d n m

getSetI :: Int -> Int -> Int -> IO Set
getSetI _ _ 0 = return (Set [])
getSetI d n m = do 
        f <- getRandomSet d n
        fs <- getSetI d n (m-1)
        return (Set (f:fs))

getRandomSet :: Int -> Int -> IO Set
getRandomSet _ 0 = return (Set [])
getRandomSet d n = do
                f <- getRandomInt d
                fs <- getRandomSet d (n-1)
                return (Set (f:fs))

Expecting one more argument to "Set"
    In the type signature for "getSetInt": getSetInt :: IO Set
