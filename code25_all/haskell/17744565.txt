composM
data Expr =
    | Var String
    | Abs String Expr

composExprM :: (Monad m) => (Expr -> m Expr) -> Expr -> m Expr
composExprM f e =
    case e of
        Abs n e -> f e >>= (\e' -> return $ Abs n e')
        _       -> return e

type Expr =
    | Var of string
    | Abs of string * Expr

let rec composExprM f e = match e with
    | Abs (n, e) -> f e >>= (fun e' -> return' <| Abs (n, e'))
    | Var _      -> return' e

> Could not resolve the ambiguity inherent in the use of the operator 'instance' at or near this program point. Consider using type annotations to resolve the ambiguity.

> Type constraint mismatch when applying the default type 'obj' for a type inference variable. No overloads match for method 'instance'. The available overloads are shown below (or in the Error List window). Consider adding further type constraints

> Possible overload: 'static member Return.instance : _Monad:Return * Maybe<'a> -> ('a -> Maybe<'a>)'. Type constraint mismatch. The type 
      obj    
  is not compatible with type
    Maybe<'a>    
  The type 'obj' is not compatible with the type 'Maybe<'a>'.

> etc.....

