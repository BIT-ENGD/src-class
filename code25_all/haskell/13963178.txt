-- this isn't real code!

type Suit = [String]
type CardValue = [String]

data (Card s v) = (Card s v) {suit :: (s :: Suit), value :: (v :: CardValue)}

usualSuit :: Suit
usualSuit = ["Club","Diamond","Heart","Spade"]

flowerSuit :: Suit
flowerSuit = ["Rose","Daisy","Poppy"]

import Data.List

type Suit = String
type Value = Integer
type ListOfSuits = [Suit]
type ListOfValues = [Value]

data Deck = Deck {listofsuits :: ListOfSuits, listofvalues :: ListOfValues } deriving (Show)

sillyDeck :: Integer -> Deck
-- This is some function.  For example, we might have
sillyDeck n = Deck ["Heart","Spade"] [1..n]
-- Note that this defines infinitely many different decks

-- How should I define a card in sillyDeck n?  One option is
data Card = Card {suit :: Suit, value :: Value } deriving (Show)
-- but this doesn't reference the deck I'm using.  I could try
data Card2 = Card2 {suit2 :: Suit, value2 :: Value, deck2 :: Deck } deriving (Show)
-- but then
cardInWrongDeck :: Card2
cardInWrongDeck = Card2 "Cheese" 999 (sillyDeck 3)
-- is valid, when I'd hope for something like a type error.
-- Of course, I could write a function to check that each card is in the
-- deck it claims to be, and apply it regularly, but that's a horrible solution.

-- Is there a better way to do this?

