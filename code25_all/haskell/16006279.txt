newtype Parser a = Parser { runParser :: String -> Maybe (a, String) }

satisfy :: ( Char -> Bool ) -> Parser Char
satisfy g = Parser $ \stream -> case stream of
    (x:xs) | g x -> Just ( x, xs )
    otherwise    -> Nothing

instance Functor Parser where
    fmap g ( Parser p ) = Parser $ \xs0 -> p xs0 >>= \(x,xs) -> return ( g x, xs )


instance Applicative Parser where
    pure a                      = Parser $ \xs0 -> Just ( a, xs0 )
    (Parser p1) <*> (Parser p2) = Parser $ \xs0 -> do
        (x1, xs1) <- p1 xs0
        (x2, xs2) <- p2 xs1
        return ( x1 x2, xs2 )

instance Alternative Parser where
    empty                        = Parser $ const Nothing
    (Parser p1) <|> (Parser p2)  = Parser $ \ss -> let ss1 = p1 ss in case ss1 of
        Nothing  -> p2 ss
        _        -> ss1

satisfy
-- | A parser that parses the first two chars in the stream if they are upper case
uParser = satisfy isUpper
parser1 = ( (:) <$> uParser ) <*> ( (\x -> [x]) <$> uParser )
runParser parser1 "HEllo" = Just ("HE","llo")
runParser parser1 "Hello" = Nothing

runParser idealParser "hello"             = Nothing
runParser idealParser "HEllo"             = Just ("HE","llo")
runParser idealParser "HELLOIAMnotincaps" = Just ("HELLOIAM", "notincaps")

