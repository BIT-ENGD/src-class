newtype Set a = Set [a]

sing :: a -> Set a
sing x = Set [x]

memSet :: (Eq a) => a -> Set a -> Bool
memSet _ (Set []) = False
memSet x (Set xs)
    | elem x xs = True
    | otherwise = False

{-
makeSet :: (Eq a) => [a] -> Set a
makeSet [] = empty
makeset (x:xs) = union (sing x) (makeSet xs)
-- etc
-- we need the obvious stuff:

union        :: Set a -> Set a -> Set a
unionMult    :: [ Set a ] -> Set a
intersection :: Set a -> Set a -> Set a
subSet       :: Set a -> Set a -> Bool
mapSet       :: (a -> b) -> Set a -> Set b
mapset f (Set xs) = makeSet (map f xs)
-}

-- now making it a monad:
instance Monad Set where
   return = sing
   (Set x) >>= f =  unionMult (map f x)

return a >>= f ≡ f a

 m >>= return ≡ m

 (m >>= f) >>= g ≡ m >>= (\x -> f x >>= g)

return x >>= f
(Set [x]) >>= f
unionMult (map f [x])
unionMult [ (f x) ] = f x

(Set [xs]) >>= return
unionMult (map return [xs])
unionMult [ys]
Set [xs]

