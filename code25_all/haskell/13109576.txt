data MyType0 a = Tong1 a | Tong2 a  deriving Show
data MyType1 a = Cons1 a | Cons2 a | Cons3 | Cons4 deriving Show
data MyType2 a = MyType2 a deriving Show

fun ((Cons2 s):t:ts) (symseq, MyType2 msg) = (symseq, MyType2 (msg ++ ["You provided wrong symbol: " ++ (show t) ++ " Please provide symbol: " ++ (show Cons3) ]))
--fun ((Cons2 s):t:ts) (symseq, MyType2 msg) = (symseq, MyType2 (msg ++ ["You provided wrong symbol: " ++ (show t) ++ " Please provide symbol: " ]))
fun _ syms                                  = syms

showerr.hs:6:148:
    Ambiguous type variable `a0' in the constraint:
      (Show a0) arising from a use of `show'
    Probable fix: add a type signature that fixes these type variable(s)
    In the second argument of `(++)', namely `(show Cons3)'
    In the second argument of `(++)', namely
      `" Please provide symbol: " ++ (show Cons3)'
    In the second argument of `(++)', namely
      `(show t) ++ " Please provide symbol: " ++ (show Cons3)'
Failed, modules loaded: none.

main = do run <- getLine
          val <- getLine
          case run of
              "len" -> print . show . len $ (read val)
              "rev" -> print . show . rev $ (read val)
              _ -> putStr "wrong option"

rev :: [a] -> [a]
rev = foldl (flip (:)) []

len :: [a] -> Int
len = foldl (\ac _ -> ac + 1) 0

ideone_x0cMx.hs:4:46:
    Ambiguous type variable `a0' in the constraint:
      (Read a0) arising from a use of `read'
    Probable fix: add a type signature that fixes these type variable(s)
    In the second argument of `($)', namely `(read val)'
    In the expression: print . show . len $ (read val)
    In a case alternative: "len" -> print . show . len $ (read val)

ideone_x0cMx.hs:5:46:
    Ambiguous type variable `a1' in the constraints:
      (Read a1) arising from a use of `read' at ideone_x0cMx.hs:5:46-49
      (Show a1) arising from a use of `show' at ideone_x0cMx.hs:5:32-35
    Probable fix: add a type signature that fixes these type variable(s)
    In the second argument of `($)', namely `(read val)'
    In the expression: print . show . rev $ (read val)
    In a case alternative: "rev" -> print . show . rev $ (read val)
Failed, modules loaded: none.

