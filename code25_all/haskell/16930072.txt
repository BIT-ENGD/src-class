module ModuleMaker where

import LLVM.Core
import LLVM.FFI.Core
import Data.Int

main :: IO ()
main = do
  m <- newNamedModule "test"

  fns <- defineModule m buildMod

  writeBitcodeToFile "ModuleMaker.bc" m

  return ()

buildMod :: CodeGenModule (Function (IO Int32))
buildMod = do 
  main <- createNamedFunction ExternalLinkage "main" $ do
    addResult <- iadd (2::Int32) (3::Int32)
    ret addResult

  return main

ModuleMaker.hs:20:18:
    No instance for (ABinOp Int32 Int32 (v0 c0))
      arising from a use of `iadd'
    Possible fix:
      add an instance declaration for (ABinOp Int32 Int32 (v0 c0))
    In a stmt of a 'do' block:
      addResult <- iadd (2 :: Int32) (3 :: Int32)
    In the second argument of `($)', namely
      `do { addResult <- iadd (2 :: Int32) (3 :: Int32);
            ret addResult }'
    In a stmt of a 'do' block:
      main <- createNamedFunction ExternalLinkage "main"
              $ do { addResult <- iadd (2 :: Int32) (3 :: Int32);
                     ret addResult }

ModuleMaker.hs:21:5:
    No instance for (Ret (v0 c0) Int32) arising from a use of `ret'
    The type variables `v0', `c0' are ambiguous
    Possible fix: add a type signature that fixes these type variable(s)
    Note: there is a potential instance available:
      instance [overlap ok] Ret (LLVM.Core.Value a) a
        -- Defined in `llvm-3.2.0.2:LLVM.Core.Instructions'
    Possible fix: add an instance declaration for (Ret (v0 c0) Int32)
    In a stmt of a 'do' block: ret addResult
    In the second argument of `($)', namely
      `do { addResult <- iadd (2 :: Int32) (3 :: Int32);
            ret addResult }'
    In a stmt of a 'do' block:
      main <- createNamedFunction ExternalLinkage "main"
              $ do { addResult <- iadd (2 :: Int32) (3 :: Int32);
                     ret addResult }

(ABinOp Int32 Int32
iadd
Int32
(v0 c0)
add
v0
c0
