renderFrame :: Frame -> Fay ()
renderFrame frame = do
     stack <- getStack
     if length stack > 0
           then (do
                   let e = head stack
                   traceEventCoord e)
           else (do return ())
     reqFrame renderFrame
     emptyStack
     where traceEventCoord :: Event -> Fay ()
           traceEventCoord e = do
               eX <- pageX e
               eY <- pageY e
               let str = show eX ++ " x " ++ show eY
               trace <- elById "trace"
               if isNull trace
                   then return ()
                   else elSetHtml (fromNullable trace) str


pageX :: Event -> Fay Int
pageX = ffi "%1['pageX']"

pageY :: Event -> Fay Int
pageY = ffi "%1['pageY']"

getParentGroups :: Fragment -> Fay [Fragment]
getParentGroups f = do
    p <- getParent f
    nn <- nodeName (fromNullable p)
    return [fromNullable p]

getParent :: Fragment -> Fay (Nullable Fragment)
getParent = ffi "%1.parent()"
nodeName :: Fragment -> Fay String
nodeName = ffi "%1.node.nodeName"

fay: your FFI declaration needs a type signature pageX = ffi "%1['pageX']"
fay: your FFI declaration needs a type signature: getParent = ffi "%1.parent()"
-- ...
where traceEventCoord :: Event -> Fay ()
      traceEventCoord e = do
          eX <- pageX e
          eY <- pageY e
          let str = show eX ++ " x " ++ show eY
          trace <- elById "trace"
          if isNull trace
              then return ()
              else elSetHtml (fromNullable trace) str
       pageX :: Event -> Fay Int
       pageX = ffi "%1['pageX']"
       pageY :: Event -> Fay Int
       pageY = ffi "%1['pageY']"

getParentGroups f = do
    p <- getParent f
    nn <- nodeName (fromNullable p)
    return [fromNullable p]
    where
        getParent :: Fragment -> Fay (Nullable Fragment)    
        getParent = ffi "%1.parent()"
        nodeName :: Fragment -> Fay String
        nodeName = ffi "%1.node.nodeName"

traceEventCoords
