fixProxy :: (Monad m, Proxy p) => (b -> m b) -> b -> () -> p a' a () b m r
fixProxy f a () = runIdentityP $ do
  v  <- respond a
  a' <- lift (f a)
  fixProxy f a' v

>>> :t \g -> runRVarT . runWriterT . runProxy $ fixProxy g 0 >-> toListD
(Num a, RandomSource m s, MonadRandom (WriterT [a] (RVarT n)),
  Data.Random.Lift.Lift n m) =>
 (a -> WriterT [a] (RVarT n) a) -> s -> m (a, [a])

RVarT
Lift
RVar
Lift
n :~> m
fixProxy :: (Monad m, Monad n, Lift m n, Proxy p) 
            => (b -> m b) -> b -> () -> p a' a () b n r

Lift
runRVarT . runWriterT . runProxy 
$ hoistK lift (fixProxy (const $ sample StdUniform) 0) >-> toListD

