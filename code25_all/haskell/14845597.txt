func
call
import Data.Maybe 

data Operator = Add | Sub | Mul | Div | And | Or | Not | Eq | Less | Great
  deriving (Eq, Show)
data Expression = Lit Value
         | Prim Operator [Expression]
         | Variable String
         | If Expression Expression Expression
         | Let [(String, Expression)] Expression
     | Func [String] Expression
     | Call Expression [Expression]
  deriving (Show, Eq)

data Value = Num Int
           | Bool Bool
       | Closure [String] Expression Environment
  deriving (Eq, Show)

type Environment = [(String, Value)]
--20
prim :: Operator -> [Value] -> Value
prim Add [Num a, Num b] = Num (a+b)
prim Mul [Num a, Num b] = Num (a*b)
prim Sub [Num a, Num b] = Num (a-b)
prim Div [Num a, Num b] = Num (a `div` b)
prim And [Bool a, Bool b] = Bool (a && b)
prim Or [Bool a, Bool b] = Bool (a || b)
prim Not [Bool a] = Bool (not a)
prim Eq [a, b] = Bool (a == b)
prim Less [Num a, Num b] = Bool (a < b)
prim Great [Num a, Num b] = Bool (a > b)
--32
evaluate :: Environment -> Expression -> Value
evaluate e (Lit v)  = v
evaluate e (Prim op as) = prim op (map (evaluate e) as)
evaluate e (Variable x) = fromJust (lookup x e)
evaluate e (If a b c)   = evaluate e (if fromBool (evaluate e a) then b else c)
evaluate e (Let bs b)   = evaluate ([(x, evaluate e d) | (x,d) <- bs ] ++ e) b

eval e (Func str ex) = (Closure str ex e) --40
evaluate e (Call ex exl) = let (Closure a b c) = (evaluate e ex) 
            in (Closure a b (c ++ (helper a (map (evaluate e) exl)))) 

helper :: [String] -> [Expression] -> [(String, Expression)]
helper (a:ar) (b:br) = (a, b) : helper ar br 

fromBool (Bool b) = b
--48
main = do
  let m = "m"
      k = Variable "k"  -- parse error on input `='
      y = Variable "y"
      lit m = Lit (Num m)
      a0 = Func [“k”] (Prim Mul [k, lit 2))
      in return $ Let [(“y”, a0)] (Prim Add [Call y [lit 3], Call y [lit 10]]) 
-- This is basically Let y = func(k) k*2 in y(3) + y(10) which returns 26.

