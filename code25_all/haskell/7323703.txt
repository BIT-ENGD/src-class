--------------------------------------------------
has_empty_string :: [String] -> Bool
has_empty_string col =
  any null col

----------------------------------------
get_hashrow :: [[String]] -> [String]
get_hashrow sheet =
  -- looking at column 5
  map (\row -> row !! 5) sheet

------------------------------
process_lines :: (String -> b) -> Handle -> IO ()
process_lines func inh = do
    ineof <- hIsEOF inh
    if ineof
      then return ()
      else do inpStr <- hGetLine inh
              result <- func inpStr
              putStrLn $ show result
              process_lines func inh


------------------------------
process_lines_in_file :: (String -> b) -> FilePath -> IO ()
process_lines_in_file func filename =
  do inh <- openFile filename ReadMode
         process_lines func inh

----------------------------------------
test_csv_row :: String -> Bool
test_csv_row row =
  has_empty_string ( get_hashrow ( readCSV row))

----------------------------------------
main :: IO ()
main = do
  [filename] <- getArgs
  process_lines_in_file test_csv_row filename
  return ()

 Couldn't match expected type `b' against inferred type `IO a'
      `b' is a rigid type variable bound by
          the type signature for `process_lines' at content-hash-p.hs:29:28
    In a stmt of a 'do' expression: result <- func inpStr
    In the expression:
        do { inpStr <- hGetLine inh;
             result <- func inpStr;
               putStrLn $ show result;
             process_lines func inh }
    In the expression:
        if ineof then
            return ()
        else
            do { inpStr <- hGetLine inh;
                 result <- func inpStr;
                   putStrLn $ show result;
                 .... }

