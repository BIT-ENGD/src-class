File 1:
  Bill 9176
  Tom 9183
  Steve 4353

import Text.Parsec
import Text.Parsec.String

parseNameNumber :: Parser (String, Integer)
parseNameNumber = do
spaces
name <- many1 letter
space
number <- fmap read $ many1 digit
return (name, number)

parseFile :: String -> IO ()
parseFile = do
result <- parseFromFile (parseNameNumber `sepBy` newline)
case result of
Left err  -> print err
Right res -> print res  

Couldn't match type `IO ()' with `String -> IO ()'
Expected type: IO (Either a0 a1)
               -> (Either a0 a1 -> IO ()) -> String -> IO ()
  Actual type: IO (Either a0 a1)
               -> (Either a0 a1 -> IO ()) -> IO ()
In a stmt of a 'do' block:
  result <- parseFromFile (parseNameNumber `sepBy` newline)
In the expression:
  do { result <- parseFromFile (parseNameNumber `sepBy` newline);
       case result of {
         Left err -> print err
         Right res -> print res } }
In an equation for `parseFile':
    parseFile
      = do { result <- parseFromFile (parseNameNumber `sepBy` newline);
             case result of {
               Left err -> print err
               Right res -> print res } }

file.hs:14:13:
Couldn't match expected type `IO (Either a0 a1)'
            with actual type `String
                              -> IO (Either ParseError [(String, Integer)])'
In the return type of a call of `parseFromFile'
Probable cause: `parseFromFile' is applied to too few arguments
In a stmt of a 'do' block:
  result <- parseFromFile (parseNameNumber `sepBy` newline)
In the expression:
  do { result <- parseFromFile (parseNameNumber `sepBy` newline);
       case result of {
         Left err -> print err
         Right res -> print res } }

