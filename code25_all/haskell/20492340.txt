File 1:
    Tom 965432145  
    Bill 932121234

File 2:
      Steve 923432323  
      Tom 933232323

choosing :: [String] −> Int −> Int −> Int
choosing ("Name_of_person":_) num1 _ = num1 
choosing _ num1 num2
        | num2 ‘div‘ 100000000 == 2 = num2
        | otherwise = num1

import System.IO
import Data.Char

choosing :: [String] −> Int −> Int −> Int
choosing name num1 _ = num1
choosing _ num1 num2
  | num2 `div` 100000000 == 2 = num2
  | otherwise = num1

main :: IO ()
main = do 
   in1 <- openFile "in1.txt" ReadMode
   in2 <- openFile "in2.txt" ReadMode
   out <- openFile "out.txt" WriteMode
   processData in1 in2 out
   hClose in1
   hClose in2
   hClose out



processData :: Handle -> Handle -> Handle -> IO ()
processData in1 in2 out =
    do ineof <- hIsEOF in1
       ineof2 <- h2IsEOF in2
        if ineof && ineof2
            then return ()
            else do inpStr <- hGetLine in1
                    inp2Str <- h2GetLine in2
                    num1Int <- num1GetNumber in1
                    num2Int <- num2GetNumber in2
                    if inpStr = inp2Str 
                        then PutStrLn out (impStr choosing inpStr num1Int num2Int )
                        else PutStrLn out (inpStr num1Int)
                             PutStrLn out (inp2Str num2Int)
                             processData in1 in2 out

import System.IO
import Data.Char


choosing name num1 _ = num1
choosing _ num1 num2
  | num2 `div` 100000000 == 2 = num2
  | otherwise = num1

main :: IO ()
main = do 
   in1 <- openFile "in1.rtf" ReadMode
   in2 <- openFile "in2.rtf" ReadMode
   out <- openFile "out.rtf" WriteMode
   mainloop in1 out
   mainloop in2 out
   hClose in1
   hClose in2
   hClose out


mainloop :: Handle -> Handle -> IO ()
mainloop _ out =
  do ineof <- hIsEOF in
     if ineof
       then return ()
       else do inpStr <- hGetLine in
               hPutStrLn out (inpStr)
               mainloop in out

import System.IO
import Data.Char

- Main function to run the program

main = do
  entries1 <- fmap parseEntries $ readFile "in1.txt"
  entries2 <- fmap parseEntries $ readFile "in2.txt"
  writeFile "out.txt" $ serializeEntries $ mergeEntries entries1 entries2

- Function to deal with duplicates

choosing name num1 _ = num1
choosing _ num1 num2
  | num2 `div` 100000000 == 2 = num2
  | otherwise = num1

- Function to read a line from a file into a tuple
Now i need help making this function 'cover' the whole file, and not just one line of it.

parseLine :: String -> (String, Int)
parseLine xs = (\(n:i:_) -> (n, read i)) (words xs)


- A function that receives entries, merges them into a single string so that it can be writen to a file.

import Data.Char

tupleToString :: (Int, Char) -> [Char]
tupleToString x = (intToDigit.fst) x:(snd x):[]

tuplesToStrings [] = []
tuplesToStrings (x:xs) = tupleToString x : tuplesToStrings xs

tuplesToString xs = (concat . tuplesToStrings) xs

