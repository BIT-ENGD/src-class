-- Exercise 9
pack :: Eq a => [a] -> [[a]]
pack [] = []
pack list = let (left,right) = span (== head list) list in
            left : pack right

-- Exercise 10        
encode :: (Eq a, Integral c) => [a] -> [(c, a)]
encode [] = []
encode list = map (\x -> (length x, head x)) (pack list)
-- this doesn't work      ^^^^^^^^

Could not deduce (c ~ Int)
from the context (Eq a, Integral c)
  bound by the type signature for
             encode :: (Eq a, Integral c) => [a] -> [(c, a)]
  at C:\fakepath\ex.hs:6:11-47
  `c' is a rigid type variable bound by
      the type signature for
        encode :: (Eq a, Integral c) => [a] -> [(c, a)]
      at C:\fakepath\ex.hs:6:11
In the return type of a call of `length'
In the expression: length x
In the expression: (length x, head x) 

fromIntegral
encode list = map (\x -> (fromIntegral $ length x, head x)) (pack list)

:t length
[a] -> Int
Integral c
