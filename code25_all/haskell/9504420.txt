Prelude> :t (+1)
(+1) :: Num a => a -> a
Prelude> :t \x->x+1
\x->x+1 :: Num a => a -> a

data B = B { 
    pos :: Int, 
    cells :: [Int] 
} deriving (Show)

createB :: Int -> B
createB n = B 0 (take n $ repeat 0)

size :: B -> Int
size b = length $ cells b

get_curr :: B -> Int
get_curr b = (cells b) !! (pos b)

apply :: (Int -> Int) -> B -> B
apply f b = let n = pos b
                h = take n $ cells b       -- head
                t = drop (n + 1) $ cells b -- tail
                in B n $ h ++ [f (get_curr b)] ++ t

-- ...
eval :: [Char] -> StateT B IO ()
eval [] = return ()
eval (x:xs) = do
                b <- get

                put $ case x of
                        '+'         -> apply (+1) b
                        '-'         -> apply (-1) b
                        '>'         -> fwd b
                        '<'         -> back b
                        otherwise   -> b
                -- ...

> :load BrainFuck.hs 
[1 of 1] Compiling BrainFuck        ( BrainFuck.hs, interpreted )

BrainFuck.hs:49:40:
    No instance for (Num (Int -> Int))
      arising from the literal `1'
    Possible fix: add an instance declaration for (Num (Int -> Int))
    In the expression: 1
    In the first argument of `apply', namely `(- 1)'
    In the expression: apply (- 1) b
Failed, modules loaded: none.

