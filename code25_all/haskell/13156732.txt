State'
type State' m a = StateT Int m a

-- genData, return some string (using Int value and State')
genData :: Int -> State' String
genData n = ...

-- genDatas, return multiple strings
genDatas :: Int -> State' [String]
genDatas n = mapM genData [1..n]

-- printLog, write log message (enumerating lines)
printLog :: String -> State' IO ()
printLog msg = do
  n <- get
  let n' = n + 1
  put n'
  liftIO $ putStrLn $ "Message #" ++ (show n') ++ ": " ++ msg

-- If I need a "in context function" returning a Int value...
--
-- addExtra, return current Int in state plus x
addExtra :: Int -> State' Identity Int
addExtra x = get >>= return.(+x)

addExtra
doComplex :: State' IO ()
doComplex = do
  printLog "Starting process..."

  -- It's ugly!
  s <- get
  Identity (w, s') <- return $ runStateT (addExtra 5) s
  put s' -- save state

  printLog $ "computed value: " ++ (show w)

State'
IO a
