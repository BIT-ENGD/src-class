type KEY = (IPv4, Integer)
type TPSQ = TVar (PSQ.PSQ KEY POSIXTime)
type TMap a = TVar (Map.Map KEY [a])

data Qcfg a = Qcfg { qthresh :: Int, tdelay :: Rational, cwpsq :: TPSQ, cwmap :: TMap a
, cwchan :: TChan String }

getTMap = do
   c <- ask
   return (cwmap c)

No instance for (MonadReader (Qcfg a2) m2)
      arising from a use of `ask'
    Possible fix:
      add an instance declaration for (MonadReader (Qcfg a2) m2)
    In a stmt of a 'do' expression: c <- ask
    In the expression:
      do { c <- ask;
           return (cwmap c) }
    In an equation for `getTMap':
        getTMap
          = do { c <- ask;
                 return (cwmap c) }

getTMap :: Reader (Qcfg a) (TMap a)
getTMap = do
   c <- ask
   return (cwmap c)

getTPsq :: Reader (Qcfg a) TPSQ
getTPsq = do
   c <- ask
   return (cwpsq c)
...
let q = getTPsq 
 qT <- atomically $ readTVar q

   Couldn't match expected type `TVar a0'
                with actual type `ReaderT
                                    (Qcfg a1) Data.Functor.Identity.Identity TPSQ'
    Expected type: TVar a0
      Actual type: Reader (Qcfg a1) TPSQ
    In the first argument of `readTVar', namely `q'
    In the second argument of `($)', namely `readTVar q'

