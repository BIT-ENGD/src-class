import Data.Vector.Unboxed as U
import Data.Vector.Unboxed.Mutable as M
import Control.Monad
import Control.Monad.ST
import Control.Monad.Primitive

f :: U.Vector Int -> U.Vector Int
f x = runST $ do
        y <- U.thaw x
        add1 y 0
        U.freeze y

add1 :: (PrimMonad m) => MVector (PrimState m) Int -> Int -> m()
add1 v i | i == M.length v = return ()
add1 v i = do
     c <- M.unsafeRead v i
     M.unsafeWrite v i (c + 1)
     add1 v (i+1)

add1 :: (PrimMonad m) => MVector (PrimState m) Int -> m()
add1 v = do add1_ 0
    where len = M.length v
          add1_ i | i == len = do return ()
          add1_ i = do
                x <- M.unsafeRead v i
                M.unsafeWrite v i (x + 1)
                add1_ (i+1)

f x = let len = U.length x
          y = U.thaw x
          add1 i | i == len = return ()
          add1 i = do
             y' <- y
             c <- M.unsafeRead y' i
             M.unsafeWrite y' i (c+1)
             add1 (i+1)
      in runST $ do
            add1 0
            y' <- y
            U.freeze y'

couldn't match type 'm0' with 'ST s'
couldn't match type 's' with 'PrimState m0'

