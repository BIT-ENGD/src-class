recursiveParser :: (a -> A.Parser a) -> a -> A.Parser a
recursiveParser parser a = (parser a >>= recursiveParser parser) <|> return a

data Expression = ConsExpr Expression Expression | EmptyExpr

parseRHS :: Expression -> Parser Expression
parseRHS e = ConsExpr e <$> parseFoo

parseExpression :: Parser Expression
parseExpression = parseLHS >>= recursiveParser parseRHS
  where parseLHS = parseRHS EmptyExpr

recursiveParser
sepBy
fix
data Segment = Choice1 Expression
             | Choice2 Expression
data Expression = ConsExpr Segment Expression 
                | Token String
                | EmptyExpr

a -> b
c:d
:
->
a -> b
(ConsExpr (Choice1 (Token "a")) (Token "b"))

c:d
(ConsExpr (Choice2 (Token "d")) (Token "c"))

foldl
foldr
"a:b:c -> e:f -> :g:h ->"
"-> a"
"b:"
fix
fixParser :: (a -> A.Parser a) -> a -> A.Parser a
fixParser parser a = (parser a >>= fixParser parser) <|> pure a

