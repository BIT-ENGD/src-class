module Main where

import qualified Data.Map as M
import Data.Map (Map)
import Data.Maybe

main = do
    catch (main' M.empty 1) (const $ return ()) 

main' _ 11 = return ()
main' m c = do
    x <- readLn
    let (k,m2) = sol m x
    print k
    main' m2 (c+1)


sol :: Map Integer Integer -> Integer -> (Integer, Map Integer Integer)
sol m x     |M.member x m = (fromJust $ M.lookup x m,m)
            |x > x2+x3+x4 = (x,M.insert x x m)
            |otherwise = (fullSoll, M.insert x fullSoll m4)
    where
        x2 = div x 2
        x3 = div x 3
        x4 = div x 4
        (sx2, m2) = sol m x2
        (sx3, m3) = sol m2 x3
        (sx4, m4) = sol m3 x4
        fullSoll = sx2+sx3+sx4

