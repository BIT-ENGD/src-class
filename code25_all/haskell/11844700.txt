-- other stuff omitted
import Data.Functor.Identity (Identity(..))

data ListItem l a =
    Nil |
    Cons { headL :: a, tailL :: l a }

Data.List.Class
-- | A class for list types. Every list has an underlying monad.
class (MonadPlus l, Monad (ItemM l)) => List l where
    type ItemM l :: * -> *
    runList :: l a -> ItemM l (ListItem l a)
    joinL :: ItemM l (l a) -> l a
    cons :: a -> l a -> l a
    cons = mplus . return

instance List [] where
    type ItemM [] = Identity
    runList [] = Identity Nil
    runList (x:xs) = Identity $ Cons x xs
    joinL = runIdentity
    cons = (:)

fromList :: List l => [a] -> l a
fromList = foldr cons mzero

joinL $ runList [1, 2, 3]
Couldn't match type `ItemM (ListItem [])' with `Identity'
Expected type: ItemM (ListItem []) (ListItem [] Integer)
  Actual type: ItemM [] (ListItem [] Integer)

runList :: l a -> ItemM l (ListItem l a)
joinL :: ItemM l (l a) -> l a
fromList [1,2,3]
Ambiguous type variable `l0' in the constraint:
  (List l0) arising from a use of `fromList'
Probable fix: add a type signature that fixes these type variable(s)
In the expression: fromList [1, 2, 3]
In an equation for `it': it = fromList [1, 2, 3]

