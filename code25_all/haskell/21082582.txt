Foldable
Traversable
Functor
Applicative
Monad
Monad
fmap
liftM :: Monad m => (a->b) -> m a -> m b
liftM f q = return . f =<< q

foldMap
foldLiftT :: (Traversable t, Monoid m) => (a -> m) -> t a -> m
foldLiftT f = fst . traverse (f >>> \x -> (x,x))
           -- or: . sequenceA . fmap (f >>> \x -> (x, x))

Monoid m => (,) m
class (Functor m) => Monad m where
  return :: a -> m a
  join :: m (m a) -> m a

Functor
liftM
Traversable
class (Functor t, Foldable t) => Traversable t where
  skim :: ???

Traverse
sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)

instance (Traversable t) => Foldable t where
  foldMap = ... skim ...

data T
instance Traversable T where
  skim = ...

Foldable
Traversable
Monad
Functor
>>=
join
fmap
join
