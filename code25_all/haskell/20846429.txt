Parsec
uu-parsinglib
uu-parsinglib
pa = char 'a'
pb = char 'b'
pTest = many $ try(pa <* pb)

uu-parsinglib
pa = pSym 'a'
pb = pSym 'b'
pTest = pList_ng (pa <* pb)

Parsec
many
(pa <* pb)
"ab"
uu-parsinglib
pList_ng
(pa <* pb)
pList(try(pa <* pb))
uu-parsinglib
pExample = pTest <* (pa <* pb)

"ababab"
Parsec
pTest
"ab"
uu-parsinglib
pList_ng
pList
Parsec
pExample2 = pTest <* pa

"ababa"
Parsec
uu-parsinglib
pList
uu-parsinglib
pList_ng
"ababab"
Parsec
pTest
pa
uu-parsinglib
"ab"
pattern = many("ab") + "a"
input   = many(pattern)

uu-parsinglib
import Data.Char
import qualified Text.ParserCombinators.UU      as UU
import Text.ParserCombinators.UU                hiding(parse)
import Text.ParserCombinators.UU.BasicInstances hiding (Parser)

import System.TimeIt (timeIt)

pa = pSym 'a'
pb = pSym 'b'
pTest = pList $ pList_ng ((\x y -> [x,y]) <$> pa <*> pb) <* pa

main :: IO ()
main = do
    timeIt maininner
    return ()

maininner = do
    let (x,e) = UU.parse ((,) <$> pTest <*> pEnd) (createStr (LineColPos 0 0 0) (concat $ replicate 1000 (concat (replicate 1000 "ab") ++ "a")))
    print $ length x

Parsec
import           Control.Applicative
import           Text.Parsec          hiding (many, optional, parse, (<|>))
import qualified Text.Parsec          as Parsec

import System.TimeIt (timeIt)

pa = char 'a'
pb = char 'b'
pTest = many $ many (try ((\x y -> [x,y]) <$> pa <*> pb)) <* pa

main :: IO ()
main = do
    timeIt maininner2
    return ()

maininner2 = do
    let Right x = Parsec.runParser pTest (0::Int) "test" $ (concat $ replicate 1000 (concat (replicate 1000 "ab") ++ "a"))
    print $ length x

uu-parsinglib
uu-parsinglib - 3.19s
Parsec        - 1.04s

ghc -O3
