module Main
where
import IO
import Maybe
import Control.Monad.Reader
--il mio environment consiste in una lista di tuple/coppie chiave-valore
data Environment = Env {variables::[(String,String)]}deriving (Show)

fromEnvToPair :: Environment-> [(String,String)]
fromEnvToPair (Env e)= e

estrai' x d
|length x==0=[]
|otherwise=estrai x d
estrai (x:xs) d
| (x:xs)=="" =[]
| x== d=[]
| otherwise = x:(estrai  xs d)
--estrae da una stringa tutti i caratteri saino a d
conta'  x d n 
| length x==0 = 0
|otherwise = conta x d n 
conta (x:xs) d n
| x== d=n
| otherwise = (conta  xs d (n+1))
primo (a,b,c)=a
secondo (a,b,c)=b
terzo (a,b,c)=c

estraifrom x d n
|n>=(length x) =[]
| x!!n==d = []
|otherwise = x!!n:(estraifrom x d (n+1))

readerContent :: Reader Environment Environment
readerContent =do
content <- ask
return ( content)

-- resolve a template into a string
resolve :: [Char]-> Reader Environment (String)
resolve key= do
varValue <- asks (lookupVar key)
return $ maybe "" id varValue

maketuple x =(k,v,l) where
k= (estrai' x ':')--usare estrai'

v=estraifrom x ';' (conta' x ':' 1)
l= (length k)+(length v)+2 --Ã¨ l'offset dovuto al; e al :
makecontext x
| length x==0 = []
| (elem ':' x)&&(elem ';' x)==False = []
|otherwise= (k,v):makecontext (drop l x) where
    t= maketuple x
    k= primo t
    v= secondo t
    l= terzo t



doRead filename = do
    bracket(openFile filename ReadMode) hClose(\h -> do 
        contents <- hGetContents h 
        return contents
        let cont=makecontext contents
        putStrLn (take 100 contents)
        return (contents))
--          putStrLn (snd (cont!!1)))
--          putStrLn (take 100 contents))


-- estrae i caratteri di una stringa dall'inizio fino al carattere di controllo
-- aggiungere parametri to the environment

-- estrae i caratteri di una stringa dall'inizio fino al carattere di controllo
-- aggiungere parametri to the environment



-- lookup a variable from the environment
lookupVar :: [Char] -> Environment -> Maybe String
lookupVar name env = lookup name (variables env)
lookup'  x t=[v| (k,v)<-t,k==x]





fromJust' :: Maybe a -> a
fromJust' (Just x) = x
fromJust' Nothing  = error "fromJust: Nothing"

main = do

file<- doRead "context.txt"-- leggo il contesto
let env= Env( makecontext file) -- lo converto in Environment
let c1= fromEnvToPair(runReader readerContent env)
putStrLn(fromJust'(lookupVar "user" env))
--putStrLn ((lookup' "user" (fromEnvToPair env))!!0)-- read the environment
--putStrLn ("user"++ (fst (c1!!1)))
putStrLn ("finito")
--putStrLn("contesto" ++ (snd(context!!1)))

