parse error on input `)'

import Data.Maybe 

data Operator = Add | Sub | Mul | Div | And | Or | Not | Eq | Less | Great
  deriving (Eq, Show)
data Expression = Literal Val
         | Primitive Operator [Expression]
         | Var String
         | If Expression Expression Expression
         | Let [(String, Expression)] Expression
     | Fun [String] Expression
     | Call Expression [Expression]
  deriving (Show, Eq)

data Val = Num Int
           | Boolean Boolean
       | Closure [String] Expression Env
  deriving (Eq, Show)

type Env = [(String, Val)]
--20
prim :: Operator -> [Val] -> Val
prim Add [Num a, Num b] = Num (a+b)
prim Mul [Num a, Num b] = Num (a*b)
prim Sub [Num a, Num b] = Num (a-b)
prim Div [Num a, Num b] = Num (a `div` b)
prim And [Boolean a, Boolean b] = Boolean (a && b)
prim Or [Boolean a, Boolean b] = Boolean (a || b)
prim Not [Boolean a] = Boolean (not a)
prim Eq [a, b] = Boolean (a == b)
prim Less [Num a, Num b] = Boolean (a < b)
prim Great [Num a, Num b] = Boolean (a > b)
--32
evaluate :: Env -> Expression -> Val
evaluate e (Literal v)  = v
evaluate e (Prim op as) = prim op (map (evaluate e) as)
evaluate e (Var x) = fromJust (lookup x e)
evaluate e (If a b c)   = evaluate e (if fromBoolean (evaluate e a) then b else c)
evaluate e (Let bs b)   = evaluate ([(x, evaluate e d) | (x,d) <- bs ] ++ e) b

evaluate e (Fun str ex) = (Closure str ex e) --40
evaluate e (Call ex exl) = let (Closure a b c) = (evaluate e ex) 
            in (Closure a b (c ++ (helper a (map (evaluate e) exl)))) 

helper :: [String] -> [Val] -> [(String, Val)]
helper (a:ar) (b:br) = (a, b) : helper ar br 

fromBoolean (Boolean b) = b
--48
main = do
    let x = Var "x"
        fun1 = Primitive Mul [(Var "x"), (Literal (Num 2))]
        fun2 = Primitive Mul [(Var "x"), (Literal (Num 5))]
        in print (evaluate [] (Call (if (Boolean true) (fun1) (fun2)) (Literal (Num 3)))) -- parse error on input `)'

