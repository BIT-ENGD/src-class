 append :: [a] -> [a] -> [a]
 append xs ys = foldr (:) ys xs

 traverse :: a -> [a] -> [[a]]
 traverse x [] = [[x]]
 traverse x (y:ys) = append [(x:y:ys)] (map (y:) (traverse x ys))

 comb :: [a] -> [[a]]
 comb [] = [[]]
 comb (x:[]) = [[x]]
 comb (x:y:[]) = [[x,y],[y,x]] 
 comb (x:xs) = map (traverse x) (comb xs)

pr27.hs:13:20:
Couldn't match type `a' with `[a]'
`a' is a rigid type variable bound by
the type signature for comb :: [a] -> [[a]] at pr27.hs:10:1
Expected type: [a] -> [a]
Actual type: [a] -> [[a]]
In the return type of a call of `traverse'
In the first argument of `map', namely `(traverse x)'
Failed, modules loaded: none

traverse
Main> map (traverse 3) [[1,2],[2,1]]
     [[[3,1,2],[1,3,2],[1,2,3]],[[3,2,1],[2,3,1],[2,1,3]]]

