data V2 a = V2 a a deriving (Show, Eq)

instance Num a => Num (V2 a) where
    (-) (V2 x0 y0) (V2 x1 y1) = V2 (x0 - x1) (y0 - y1)
    (+) (V2 x0 y0) (V2 x1 y1) = V2 (x0 + x1) (y0 + y1)
    (*) (V2 x0 y0) (V2 x1 y1) = V2 (x0 * x1) (y0 * y1)
    abs = undefined
    signum = undefined
    fromInteger = undefined

instance Fractional a => Fractional (V2 a) where
    (/) (V2 x0 y0) (V2 x1 y1) = V2 (x0 / x1) (y0 / y1)
    recip = undefined
    fromRational = undefined

-- Multiply by scalar
(*$) :: Num a => V2 a -> a -> V2 a
(*$) (V2 x y) s = V2 (x * s) (y * s)

-- Length of the vector
len :: (Num a, Integral a, Floating b) => V2 a -> b
len (V2 x y) = sqrt $ fromIntegral $ x * x + y * y

normal :: (Num a, Integral a) => V2 a -> V2 a
normal v = v *$ (1 / len v)

{-

Math\V2.hs:31:20:
    Could not deduce (Fractional a) arising from a use of `/'
    from the context (Num a, Integral a)
      bound by the type signature for
                 normal :: (Num a, Integral a) => V2 a -> V2 a
      at Math\V2.hs:31:1-27
    Possible fix:
      add (Fractional a) to the context of
        the type signature for
          normal :: (Num a, Integral a) => V2 a -> V2 a
    In the second argument of `(*$)', namely `(1 / len v)'
    In the expression: v *$ (1 / len v)
    In an equation for `normal': normal v = v *$ (1 / len v)

Math\V2.hs:31:22:
    Could not deduce (Floating a) arising from a use of `len'
    from the context (Num a, Integral a)
      bound by the type signature for
                 normal :: (Num a, Integral a) => V2 a -> V2 a
      at Math\V2.hs:31:1-27
    Possible fix:
      add (Floating a) to the context of
        the type signature for
          normal :: (Num a, Integral a) => V2 a -> V2 a
    In the second argument of `(/)', namely `len v'
    In the second argument of `(*$)', namely `(1 / len v)'
    In the expression: v *$ (1 / len v)

-}

