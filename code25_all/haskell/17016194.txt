simple       :: Integer -> Integer -> Integer -> Integer
simple x y z = x * (y + z)

applyAll          :: [(f -> a)] -> a -> a
applyAll [f] v  = foldr (.) v [f]

a = (applyAll [simple 2 2, (+3)] 5)
print a

Couldn't match type `f' with `a0 -> f'
  `f' is a rigid type variable bound by
      the type signature for applyAll :: [f -> a] -> a -> a

Expected type: (f -> a) -> a -> a
  Actual type: (f -> a) -> (a0 -> f) -> a0 -> a
In the first argument of `foldr', namely `(.)'
In the expression: foldr (.) v [f]

