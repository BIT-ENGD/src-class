data Pair = Pair
instance SType Pair where
    zmqSocketType = const pair

data SocketOpts = SocketOpts
 { end :: SocketEnd
 , sType :: SType st => st
 }

socket ctx $ sType so
Ambiguous type variable `a0' in the constraint:
(SType a0) arising from a use of `sType'

socket :: SType a => Context -> a -> IO (Socket a)
let so = SocketOpts (Bind "some") Pull

<interactive>:1:35:
Could not deduce (st ~ Pull)
from the context (SType st)
  bound by a type expected by the context: SType st => st
  at <interactive>:1:10-38
  `st' is a rigid type variable bound by
       a type expected by the context: SType st => st
       at <interactive>:1:10
In the second argument of `SocketOpts', namely `Pull'
In the expression: SocketOpts (Bind "some") Pull
In an equation for `so': so = SocketOpts (Bind "some") Pull

data SocketOpts st = SocketOpts
     { end :: SocketEnd
     , sType :: st
     }

zmqSource :: (ResourceIO m, SType st) => Context -> SocketOpts st -> Source m a
zmqSource ctx so = sourceIO
          mkSocket
          recvSock
          (\x -> undefined)
          where
              recvSock = undefined
              mkSocket = socket ctx $ sType so

SockOpts (Connect "tcp://127.0.0.1:9999") Sub  -- This would be bad

SockOpts :: (SType st, <not SubsType st>) => SocketEnd -> st -> SocketOpts st

