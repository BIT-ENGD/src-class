data Value e = OK e | Error String deriving (Eq)

-- assuming we know how to type e can be shown, i.e. Show e, then
-- we know how to show a Value e type
instance (Show e) => Show (Value e) where
    show (OK x) = (show x)
    show (Error s) = "ERROR: " ++ s

type Token = String
type Result = Value Int
type Intermediate = [ (Value Int) ]

-- an algebra is a things that knows about plus and times
class Algebra a where
    plus :: a -> a -> a
    times :: a -> a -> a
    subtraction :: a -> a -> a
    division :: a -> a-> a

-- assuming that we know how to + and * things of type e, (i.e.
-- we have Num e, then we have algebra's over Value e 
instance (Num e) => Algebra (Value e) where
    plus (OK x) (OK y) = (OK (x+y))
    times (OK x) (OK y) = (OK (x*y))
    subtraction (OK x) (OK y) = (OK (x-y))
    division (OK x) (OK 0) = (Error "div by 0")
    division (OK x) (OK y) = (OK (x `div` y))   <-- this is line 44 that it complains about

test.hs:44:34:  
    Could not deduce (Integral e)  
      from the context (Algebra (Value e), Num e)  
      arising from a use of `div' at test.hs:44:34-42  
    Possible fix:  
      add (Integral e) to the context of the instance declaration  
    In the first argument of `OK', namely `(x `div` y)'  
    In the expression: (OK (x `div` y))  
    In the definition of `division':  
        division (OK x) (OK y) = (OK (x `div` y))  

