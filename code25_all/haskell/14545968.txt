t <- getClockTime
talk :: WS.Protocol p => MVar State -> Client -> WS.WebSockets p ()
talk state client@(user, sink) = flip WS.catchWsError catchDisconnect $ 
  forever $ do
    t <- getClockTime
    msg <- WS.receiveData
    case () of
      () | T.unpack(msg) == "#list" -> liftIO $ readMVar state >>= listClients client
        | T.unpack(msg) == "#time" -> liftIO (sendTime client)
        | "#name" `T.isPrefixOf` msg -> liftIO (command msg client)
        | otherwise -> liftIO $ readMVar state >>= broadcast
          (user `mappend` msg)
  where
    catchDisconnect e = case fromException e of
        Just WS.ConnectionClosed -> liftIO $ modifyMVar_ state $ \s -> do
            let new_state = removeClient client s
            return new_state
        _ -> return ()

t <- getClockTime
Couldn't match type `WS.WebSockets p0' with `IO'
Expected type: IO Text
  Actual type: WS.WebSockets p0 Text
In a stmt of a 'do' block: msg <- WS.receiveData
In the second argument of `($)', namely
  `do { t <- getClockTime;
        msg <- WS.receiveData;
        case () of {
          ()
            | T.unpack (msg) == "#list"
            -> liftIO $ readMVar state >>= listClients client
            | T.unpack (msg) == "#time" -> liftIO (sendTime client)
            | "#name" `T.isPrefixOf` msg -> liftIO (command msg client)
            | otherwise
            -> liftIO $ readMVar state >>= broadcast (user `mappend` msg) } }'
In the second argument of `($)', namely
  `forever
   $ do { t <- getClockTime;
          msg <- WS.receiveData;
          case () of {
            ()
              | T.unpack (msg) == "#list"
              -> liftIO $ readMVar state >>= listClients client
              | T.unpack (msg) == "#time" -> liftIO (sendTime client)
              | "#name" `T.isPrefixOf` msg -> liftIO (command msg client)
              | otherwise
              -> liftIO $ readMVar state >>= broadcast (user `mappend` msg) } }'

