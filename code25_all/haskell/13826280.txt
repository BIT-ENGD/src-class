>play pStone pRandom 1
1 games were played. Player 1 won 1 and player 2 won 1, making the match a draw.

>play pStone pCopy 100
100 games were played. Player 1 won 1 and player 2 won 1, making the match a draw.

>play pCopy pAntiCopy 100
100 games were played. Player 1 won 31 and player 2 won 37, making player 2 the overall winner.

import System.Random

data Move= Paper|Scissors|Stone deriving Show
type Plan=([IO Move]->[IO Move]->IO Move)

play :: Plan -> Plan -> Integer -> IO ()
play plan1 plan2 numRounds=do p1intwins<-p1wins;p2intwins<-p2wins;putStr(show numRounds ++ " games were played. Player 1 won " ++ show p1intwins ++ " and player 2 won " ++ show p2intwins ++ ", making " ++ (if p1intwins > p2intwins then "player 1 the overall winner." else (if p1intwins < p2intwins then "player 2 the overall winner." else "the match a draw."))) where (_, _, _, _, _, _, p1wins, p2wins)=(playRound (plan1, plan2, numRounds,[],[], 0, return 0, return 0))

playRound :: (Plan, Plan, Integer, [IO Move], [IO Move], Integer, IO Integer, IO Integer) -> (Plan, Plan, Integer, [IO Move], [IO Move], Integer, IO Integer, IO Integer)
playRound (plan1, plan2, numRounds, p1moves, p2moves, elapsedRounds, p1wins, p2wins)=if elapsedRounds==numRounds then (plan1, plan2, numRounds, p1moves, p2moves, elapsedRounds, p1wins, p2wins) else (playRound (plan1, plan2, numRounds, p1moves++[p1move], p2moves++[p2move], elapsedRounds+1, do p1win<-beatsCaller p1move p2move;p1intwins<-p1wins;return (p1intwins+if p1win then 1 else 0), do p2win<-beatsCaller p2move p1move;p2intwins<-p2wins;return(p2intwins+(if p2win then 1 else 0)) )) where p1move=plan1 p1moves p2moves; p2move=plan2 p2moves p1moves

beatsCaller :: IO Move -> IO Move -> IO Bool
beatsCaller iom1 iom2=do m1<-iom1;m2<-iom2;return(beats m1 m2)

beats :: Move -> Move -> Bool
beats Scissors Paper=True
beats Stone Scissors=True
beats Paper Stone=True
beats _ _=False

--                                           ###############Plans###################
pStone :: Plan
pStone _ _ = return Stone

pScissors :: Plan
pScissors _ _ = return Scissors

pPaper :: Plan
pPaper _ _ = return Paper

pUScissors :: Plan
pUScissors [] _ = randomMove
pUScissors _ _ = return Scissors

pCopy :: Plan
pCopy _ []= randomMove
pCopy _ theirMoves= last theirMoves

pRandom :: Plan
pRandom _ _=randomMove

pAntiCopy :: Plan
pAntiCopy [] _ = randomMove
pAntiCopy ourMoves _ = do ourMove<-last ourMoves;return(beaterOf ourMove)

--                                           ##############Plan Logic###############

beaterOf ::  Move -> Move
beaterOf Scissors = Stone
beaterOf Paper = Scissors
beaterOf Stone = Paper

randomMove :: IO Move
randomMove=do x<-genRandom;return (doRMove x)

doRMove:: Int -> Move
doRMove rand
    |rand==1 =Paper
    |rand==2 =Scissors
    |rand==3 =Stone

genRandom :: IO Int
genRandom =getStdRandom (randomR (1,3))

