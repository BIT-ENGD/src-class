data Tree a = T a [Tree a] deriving (Eq,Ord,Show)

count :: Tree a -> Int
count (T _ xs) = 1 + sum(map count xs)

filterKnoten :: (a -> Bool) -> Tree a -> [a]
filterKnoten p (T x []) = (if p(x) then [x] else []) 
filterKnoten p (T x xs) 
                    | p(x) == True = x:(map multP xs)
                    | p(x) == False = map multP xs
                    where multP = filterKnoten p

ex1 = T True [T False [T True[]] , T True []]

filterKnoten (==True) ex1

Couldn't match type `a' with `[a]'
  `a' is a rigid type variable bound by
      the type signature for filterKnoten :: (a -> Bool) -> Tree a -> [a]
      at WS11.hs:138:17
Expected type: Tree a -> a
  Actual type: Tree a -> [a]
In the first argument of `map', namely `multP'
In the expression: map multP xs
In an equation for `filterKnoten':
    filterKnoten p (T x xs)
      | p (x) == True = x : (map multP xs)
      | p (x) == False = map multP xs
      where
          multP = filterKnoten p
Failed, modules loaded: none.

