{-# LANGUAGE ScopedTypeVariables #-}

module Main where
import qualified Reactive.Banana as R
import qualified Reactive.Banana.Frameworks as RF

main = start setupNetwork

start :: forall t. RF.Frameworks t =>  R.Moment t () -> IO ()
start network = do
    net <- RF.compile $ network
    RF.actuate net

keyAddHandler = RF.newAddHandler

setupNetwork :: forall t. RF.Frameworks t => R.Moment t ()
setupNetwork = do
    (addKey, firekey) <- RF.liftIO keyAddHandler
    return ()

Test.hs:11:25:
Could not deduce (t ~ t1)
from the context (RF.Frameworks t)
  bound by the type signature for
             start :: RF.Frameworks t => R.Moment t () -> IO ()
  at Test.hs:(10,1)-(12,18)
or from (RF.Frameworks t1)
  bound by a type expected by the context:
             RF.Frameworks t1 => R.Moment t1 ()
  at Test.hs:11:12-31
  `t' is a rigid type variable bound by
      the type signature for
        start :: RF.Frameworks t => R.Moment t () -> IO ()
      at Test.hs:10:1
  `t1' is a rigid type variable bound by
       a type expected by the context: RF.Frameworks t1 => R.Moment t1 ()
       at Test.hs:11:12
Expected type: R.Moment t1 ()
  Actual type: R.Moment t ()
In the second argument of `($)', namely `network'
In a stmt of a 'do' block: net <- RF.compile $ network

