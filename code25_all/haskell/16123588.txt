pure (const ()) <*> m
pure ()
pure (\a b -> (a, b)) <*> m <*> n
pure (\a b -> (b, a)) <*> n <*> m
pure (\a b -> (a, b)) <*> m <*> m
pure (\a -> (a, a)) <*> m
F
F
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE RankNTypes #-}
import Control.Monad.State

newtype X i = X Integer deriving (Eq)

newtype F i a = F (State Integer a) deriving (Monad)

new :: F i (X i)
new = F $ modify (+1) >> gets X

evalF :: (forall i . F i a) -> a
evalF (F m) = evalState m 0

X
F
new
evalF
liftM (const ()) m
return ()
liftM2 (\a b -> (a, b)) m n
liftM2 (\a b -> (b, a)) n m
liftM2 (,) new new
liftM (\a -> (a,a)) new
test = evalF (liftM (uncurry (==)) $ liftM2 (,) new new)
    /= evalF (liftM (uncurry (==)) $ liftM (\a -> (a,a)) new)

pure (,) <*> m <*> n

pure (const id) <*> pure () <*> (pure (,) <*> m <*> n)

pure (const id) <*> (pure (const ()) <*> n) <*> (pure (,) <*> m <*> n)

pure (.) <*> pure (const id) <*> pure (const ()) <*> n <*> (pure (,) <*> m <*> n)

pure const <*> n <*> (pure (,) <*> m <*> n)

pure (\_ a b -> (a, b)) <*> n <*> m <*> n

pure (\b a _ -> (a, b)) <*> n <*> m <*> n

pure (\b a -> (a, b)) <*> n <*> m

pure (flip (,)) <*> n <*> m

pure (\_ _ b -> b) <*> n <*> m <*> n

pure (\_ b -> b) <*> n <*> n

pure (\b -> b) <*> n

pure (\b _ -> b) <*> n <*> n

pure (\b _ _ -> b) <*> n <*> m <*> n

pure f1 <*> m  ===   pure g1 <*> m
pure f2 <*> m  ===   pure g2 <*> m

pure (\x -> (f1 x, f2 x)) m  ===  pure (\x -> (g1 x, g2 x)) m

pure (\_ a b -> (a, b)) <*> n <*> m <*> n

pure (\b a _ -> (a, b)) <*> n <*> m <*> n

G
G'
G
newtype G a = G (State Bool a) deriving (Monad)

putTrue :: G ()
putTrue = G $ put True

getBool :: G Bool
getBool = G get

evalG :: G a -> a
evalG (G m) = evalState m False

G
putTrue
getBool
evalG
Monad
G'
G
execG
execG :: G' a -> Bool
execG (G m) = execState m False

getBool
