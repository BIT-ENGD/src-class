bruteSolveWithStartAndEnd :: Node -> Node -> [Node] -> [(Float, [Node])] -> [(Float, [Node])]
bruteSolveWithStartAndEnd st en mp r
           | length mp - 1 == length (snd ( head r)) = sortBy (comparing fst) $ map (\x -> (fst x + (distanceBetweenTwoNodes en $ last $ snd x), snd x ++ [en])) r
           | otherwise = bruteSolveWithStartAndEnd st en mp $ nextStepsForMany r $ filter (/= en) mp

bruteSolve :: [Node] -> [(Float, [Node])] -> [(Float, [Node])]
bruteSolve mp [] = bruteSolve mp $ map (\l -> (0, [l])) mp
bruteSolve mp r
           | length mp == length(snd (head r)) = sortBy (comparing fst) $ r
           | otherwise = bruteSolve mp $ nextStepsForMany r mp

nextSteps :: (Float, [Node]) -> [Node] -> [(Float, [Node])]
nextSteps r n = map (\l -> ((fst r) + (distanceBetweenTwoNodes l $ last $ snd r), snd r ++ [l])) [ nn | nn <- n, nn `notElem` (snd r)]

nextStepsForMany :: [(Float, [Node])] -> [Node] -> [(Float, [Node])]
nextStepsForMany ar n = concat $ map (\l -> nextSteps l n) ar

*> bruteSolve [(Node 0 1), (Node 2 3), (Node 4 5)] []
[(5.656854,[Node {x = 0, y = 1},Node {x = 2, y = 3},Node {x = 4, y = 5}]),(5.656854,[Node {x = 4, y = 5},Node {x = 2, y = 3},Node {x = 0, y = 1}]),(8.485281,[Node {x = 0, y = 1},Node {x = 4, y = 5},Node {x = 2, y = 3}]),(8.485281,[Node {x = 2, y = 3},Node {x = 0, y = 1},Node {x = 4, y = 5}]),(8.485281,[Node {x = 2, y = 3},Node {x = 4, y = 5},Node {x = 0, y = 1}]),(8.485281,[Node {x = 4, y = 5},Node {x = 0, y = 1},Node {x = 2, y = 3}])] 


*> bruteSolveWithStartAndEnd (Node 0 0) (Node 5 5) [Node 0 0, Node 1 1, Node 2 2, Node 3 3, Node 4 4, Node 5 5]

<interactive>:1:1:
    No instance for (Show ([(Float, [Node])] -> [(Float, [Node])]))
      arising from a use of `print'
    Possible fix:
      add an instance declaration for
      (Show ([(Float, [Node])] -> [(Float, [Node])]))
    In a stmt of an interactive GHCi command: print it

