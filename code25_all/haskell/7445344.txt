module Main where

import qualified Data.List as List

main :: IO ()
main = do
    print $ conspire fabFive fabFive

-- here i actually have 80 constructors
data Eris = Hera | Athene | Aphrodite | Paris | Helene
            deriving (Ord, Eq, Show, Read, Enum, Bounded)

fabFive = [minBound..maxBound] :: [Eris]

conspire :: [Eris] -> [Eris] -> [Eris]
conspire [Hera]   [Hera]   = [Hera, Athene]
...
conspire [Hera]   [Helene] = [Athene, Aphrodite, Paris]
...
conspire [Helene] [Helene] = [Hera]

conspire [a] (b:bs) =
    List.union (conspire [a] [b]) (conspire [a] bs)
conspire (a:as) ls =
    List.union (conspire [a] ls) (conspire as ls)

module Main where

import qualified Data.Map as Map
import qualified Data.Set as Set

main :: IO ()
main = do 
    print $ conspire (Set.fromList fabFive) (Set.fromList fabFive)

fabFive = [ Hera, Athene, Aphrodite, Paris, Helene ]

conspire :: Set.Set String -> Set.Set String -> Set.Set String
conspire set1 set2 = Set.fold Set.union Set.empty $ Set.map
    (\x -> Set.fold Set.union Set.empty $ Set.map
        (\y -> conspiracy Map.! (Set.singleton x, Set.singleton y))
        set2
    )
    set1

conspiracy = Map.fromList
    [ ( (Set.singleton "Hera" , Set.singleton "Hera" )
      , Set.fromList [ "Hera", "Athene" ]
      )
    ...
    , ( (Set.singleton "Hera" , Set.singleton "Helene" )
      , Set.fromList [ "Athene", "Aphrodite", "Paris" ]
      )
    ...
    , ( (Set.singleton "Helene" , Set.singleton "Helene" )
      , Set.fromList [ "Hera" ]
      )
    ]

