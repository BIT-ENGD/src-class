import Control.Applicative

-- | RWS monad.
newtype RWS r w s a = RWS {runRWS :: r -> s -> (a, s, w)}

-- | A class for unary type constructors that support a Cartesian
-- product operation.
class ProductObject f where
    (***) :: f a -> f b -> f (a, b)
infixr ***

-- | Example instance of 'ProductObject'.
instance ProductObject [] where
    (***) = liftA2 (,)


-- | A class for binary type constructors (read as morphisms
-- between their type parameters) that support a product morphism
-- operation.
class ProductMorphism arrow where
    (****) :: arrow a b -> arrow c d -> arrow (a, c) (b, d)
infixr ****

-- | Example instance of 'ProductMorphism'.  
instance ProductMorphism (->) where
    f **** g = \(a, c) -> (f a, g c)


-- | A class for ternary type constructors (read as two-place
-- multiarrows @a, b -> c@) with products.
class ProductMultimorphism2 arr2 where
    (*****) :: arr2 a b c -> arr2 d e f -> arr2 (a, d) (b, e) (c, f)
infixr *****


-- | A class for ternary type constructors (read as two-place
-- multiarrows @a, b -> c@) with products.
class ProductMultimorphism3 arr3 where
    (******) :: arr3 a b c d -> arr3 e f g h -> arr3 (a, e) (b, f) (c, g) (d, h)
infixr ******

-- | Let's pretend that the 'RWS' monad was not a type synonym
-- for 'RWST'.  Then an example of 'ProductMorphism3' would be:
instance ProductMultimorphism3 RWS where
    f ****** g = RWS $ \(fr, gr) (fs, gs) ->
        let (fa, fs', fw) = runRWS f fr fs
            (ga, gs', gw) = runRWS g gr gs
        in ((fa, ga), (fs', gs'), (fw, gw))

****
*****
PolyKinds
PolyKinds
