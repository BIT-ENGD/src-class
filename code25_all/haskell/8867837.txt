(2 * var) + (3 * var) == 4

\x y -> 2 * x + 3 * y == 4 -- (result)

yices-painless
var
\x -> x
var
\x -> x
\y -> y
\x -> \y -> x * y
var
f :: α -> E -- rest of computation

var
result
x
f x
var' = \f -> (\x -> f x)

xf
yf
var
f :: α -> E
xf
yf
x
y
mult xf yf = \f -> xf (\x -> yf (\y -> f (x Prelude.* y)))

const' c = \f -> f c
var' = \f -> (\x -> f x) -- add a new argument, "x", to the function
add xf yf = \f -> xf (\x -> yf (\y -> f (x Prelude.+ y)))
mult xf yf = \f -> xf (\x -> yf (\y -> f (x Prelude.* y)))

v_α = var' -- "x"
v_β = var' -- "y"
v_γ = var' -- "z"
m = mult v_α v_β -- "x * y"
a = add m v_γ -- "x * y + z"
eval_six = (m id) 2 3
eval_seven = (a id) 2 3 1

two = const' 2 -- "2"
m2 = mult two v_γ -- "2 * z"
a2 = add m m2 -- "x * y + 2 * z"
eval_two = (m2 id) 1
eval_eight = (a2 id) 2 3 1

quad_ary = (var' `mult` var') `mult` (var' `mult` var')
eval_thirty = (quad_ary id) 1 2 3 5

