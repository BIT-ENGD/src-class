import Data.Maybe 

data Operator = Add | Sub | Mul | Div | And | Or | Not | Eq | Less | Great
  deriving (Eq, Show)
data Expression = Literal Val
            | Prim Operator [Expression]
            | Variable String
            | If Expression Expression Expression
            | Let [(String, Expression)] Expression
        | Func [String] Expression
        | Call Expression [Expression]
  deriving (Show, Eq)

data Val = Num Int
           | Bool Bool
       | Closure [String] Expression Environment
  deriving (Eq, Show)

type Environment = [(String, Val)]
--20
primitive :: Operator -> [Val] -> Val
primitive Add [Num a, Num b] = Num (a+b)
primitive Mul [Num a, Num b] = Num (a*b)
primitive Sub [Num a, Num b] = Num (a-b)
primitive Div [Num a, Num b] = Num (a `div` b)
primitive And [Bool a, Bool b] = Bool (a && b)
primitive Or [Bool a, Bool b] = Bool (a || b)
primitive Not [Bool a] = Bool (not a)
primitive Eq [a, b] = Bool (a == b)
primitive Less [Num a, Num b] = Bool (a < b)
primitive Great [Num a, Num b] = Bool (a > b)
--32
evaluate :: Environment -> Expression -> Val
evaluate e (Literal v)  = v
evaluate e (Prim op as) = primitive op (map (evaluate e) as)
evaluate e (Variable x) = fromJust (lookup x e)
evaluate e (If a b c)   = evaluate e (if fromBool (evaluate e a) then b else c)
evaluate e (Let bp b)   = evaluate ([(x, evaluate e d) | (x,d) <- bp ] ++ e) b

evaluate e (Func str ex) = str ex e
evaluate e (Call ex exl) = [[a, b, c ++ (map (evaluate e) exl)] | (a, b, c)<-(evaluate e ex)] --41
--42
fromBool (Bool b) = b

main = do
   let x = Variable "x"
       func1 = x*2 -- this is where I am getting a "parse error (possibly incorrect indentation)"
       func2 = x*5
    in print(evaluate [("r",Num 7)] (Call (If (Bool True) func1 func2) [Num 5]))

