Map
Fold
ConstraintKinds
-- A list where length is implicit in the type.
-- This allows us to have classes like
-- Combineable a b c  u v w | ... where
--    combine :: (a -> b -> c) -> u -> v -> w
-- which is a version of ZipWith that only works on
-- lists of the same length.
data a :. b = !a :. !b

-- A simple class that works on our length-implicit lists
class Fold v a | v -> a where
  fold  :: (a -> a -> a) -> v -> a
instance Fold (a:.()) a where
  fold  f   (a:._) = a
instance Fold (a':.u) a => Fold (a:.a':.u) a where
  fold  f   (a:.v) = f a (fold f v)

-- A type constraint to simplify the constraints on our functions,
-- which in the real world also contain a bunch of things like
-- Map a a v v, Combineable a (Maybe a) (Maybe a) v w w, etc.
type NList v i = ( Fold (v i) i )

-- A function that uses our type constraint
foo :: (Num a, NList v a) -> v a -> a
foo = fold (+) 1

> foo ((1::Int) :. ())

Couldn't match type `Int' with `()'
When using functional dependencies to combine
  Fold (a :. ()) a,
    arising from the dependency `v -> a'
    in the instance declaration in `Data.Vec.Base'
  Fold (Int :. ()) (),
    arising from a use of `foo' at <interactive>:72:1-4
In the expression: foo ((1 :: Int) :. ())
In an equation for `it': it = foo ((1 :: Int) :. ())

