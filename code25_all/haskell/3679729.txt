possibKs n r = [ (k, (hanoiRCountK n k r)) | k <- [1 .. n-1] ]

possibKs n r 
    | n < parCutoff  = results
    | otherwise      = parListChunk parChunkSize results
    where results = [ (k, (hanoiRCountK n k r)) | k <- [1 .. n-1] ]

parListChunk :: Int -> Strategy a -> Strategy [a]

Int
Strategy<a>
Strategy<[a]>
Int
a
Int
Strategy<Int>
Strategy
Strategy
type Strategy a = a -> Done

Strategy<Int>
sPar :: a -> Strategy b
sSeq :: a -> Strategy b
r0 :: Strategy a
rwhnf :: Strategy a

Strategy<b>
a
a
return . maximum $ map optimize xs `using` parList

using
using :: a -> Strategy a -> a

a
[Int]
Strategy<[Int]>
otherwise
| otherwise      = results `using` parListChunk parChunkSize

Couldn't match expected type `[(Int, Integer)]'
       against inferred type `a -> Eval a'
Probable cause: `parListChunk' is applied to too few arguments
In the second argument of `using', namely
    `parListChunk parChunkSize'
In the expression: results `using` parListChunk parChunkSize

Strategy a
Strategy [a]
rseq
| otherwise      = results `using` (parListChunk parChunkSize rseq)

Control.Parallel.Strategies
Loading package deepseq-1.1.0.0 ... linking ... done.
Loading package parallel-2.2.0.1 ... linking ... done.

