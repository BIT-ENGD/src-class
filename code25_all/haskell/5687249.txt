import Data.List(nub) 
import qualified Text.PrettyPrint.HughesPJ as PP
import Text.PrettyPrint.HughesPJ(Doc,text,int,(<>),(<+>),($+$),render)

data Prop a = 
     LetterP a
   | AndP (Prop a) (Prop a)
 deriving Eq

class PPLetter a where
  ppLetter :: a -> Doc

instance PPLetter Int where
  ppLetter a = text ("p"++show a)

instance PPLetter Char where
  ppLetter = PP.char

instance PPLetter a => PPLetter [a] where
  ppLetter = PP.hcat . (map ppLetter)

class PP a where
  pp :: a -> Doc

instance PP Bool where
  pp True = text "True"
  pp False = text "False"

parens n (term@(LetterP _)) = pp term

instance PPLetter a => PP(Prop a) where   
  pp (LetterP a) = ppLetter a
  pp (AndP x y) = PP.sep [ parens 4 x, text "/\\", parens 4 y]

instance PPLetter a => Show (Prop a) where
  show x = render (pp x)

main = do
    let p = LetterP 1
    print p

LetterP
ho8.hs:19:12: parse error on input `='
Failed, modules loaded: none.

LetterP
parens n (term@(LetterP _)) = pp term
parens
term@
term
{}
ho8.hs:43:9:
    Ambiguous type variable `a0' in the constraints:
      (PPLetter a0) arising from a use of `print' at ho8.hs:43:9-13
      (Num a0) arising from the literal `1' at ho8.hs:42:25
    Probable fix: add a type signature that fixes these type variable(s)
    In the expression: print p
    In the expression:
      do { let p = LetterP 1;
           print p }
    In an equation for `main':
        main
          = do { let p = ...;
                 print p }
Failed, modules loaded: none.

