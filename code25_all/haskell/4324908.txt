probablyPrime n 0 = False
probablyPrime n t =
      do a <- randomRIO(3, n-1 :: Integer)      
         let comp = defComp(a,n)     
         let ret  = (not comp) && (probablyPrime n t-1)
         return ret


defComp a n = xcon1 && xcon2
where (s,m) = findsm n
      x = a^m `mod` n
      xcon1 = x /= 1 || x /= n-1
      xcon2 = comploop x n s


comploop x n 0 = False
comploop x n s = x1 || (comploop x n (s-1))
    where x1 = (x^2 `mod` n) == 1


findsm n = (s,m)
where m = findm n
      s = n/m


findm n = m
  where f = (logBase 2 n) - (truncate (logBase 2 n))
        m' = 2^f
        m = m_ify m'


m_ify m | m mod 1 == 0 = m
     | otherwise = m_ify (m*2)

Couldn't match expected type `Bool' against inferred type `IO b'
In a stmt of a 'do' expression:
    a <- randomRIO (3, n - 1 :: Integer)
In the expression:
    do { a <- randomRIO (3, n - 1 :: Integer);
         let comp = defComp ...;
         let ret = (not comp) && (probablyPrime n t - 1);
         return ret }
In the definition of `probablyPrime':
    probablyPrime n t
                    = do { a <- randomRIO (3, n - 1 :: Integer);
                           let comp = ...;
                           let ret = ...;
                           .... }

