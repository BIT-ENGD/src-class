data Formula
    = Atom String
    | Neg  Formula
    | Conj Formula Formula
    | Disj Formula Formula

precedence :: Formula -> Int
precedence Atom{} = 4
precedence Neg {} = 3
precedence Conj{} = 2
precedence Disj{} = 1

displayPrec :: Int -> Formula -> String
displayPrec dCntxt f = bracket unbracketed where
dHere       = precedence f
recurse     = displayPrec dHere
unbracketed = case f of
    Atom s   -> s
    Neg  p   -> "~ " ++ recurse p
    Conj p q -> recurse p ++ " & " ++ recurse q
    Disj p q -> recurse p ++ " | " ++ recurse q
bracket
    | dCntxt > dHere = \s -> "(" ++ s ++ ")"
    | otherwise      = id

display :: Formula -> String
display = displayPrec 0

fun precedence(operator) = 
    case operator of
        Atom a => 4 
      | Neg p => 3
      | Conj(p,q) => 2
      | Disj(p,q) => 1

fun displayPrec dCntxt f = 
   let 
      val dHere = precedence f
      val recurse = displayPrec dHere

      val unbracketed = case f of 
                 Atom a => a
               | Neg p => "~ " ^ recurse p
               | Conj(p,q)=>(recurse p) ^ " & " ^ (recurse q)
               | Disj(p,q)=>(recurse p) ^ " | " ^ (recurse q)

      (* missing bracket function *)               

   in
      (* bracket *) unbracketed 
   end

