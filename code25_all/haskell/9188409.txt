Random
Arbitrary
enumRandomR :: (RandomGen g, Enum e) => (e, e) -> g -> (e, g)
enumRandomR  (lo,hi) gen = 
    let (int, gen') = randomR (fromEnum lo, fromEnum hi) gen in (toEnum int, gen')

enumRandom  :: (RandomGen g, Enum e) => g -> (e, g)
enumRandom gen = 
    let (int, gen') = random gen in (toEnum int, gen')

System.Random.Random
Test.QuickCheck.Arbitrary
{-# LANGUAGE FlexibleInstances, UndecidableInstances, OverlappingInstances #-}

instance (Enum a, Bounded a) => Random a where
   random = enumRandom
   randomR = enumRandomR

instance (Enum a, Bounded a) => Arbitrary a where
  arbitrary = choose (minBound, maxBound)

Bounded
Enum
data Dir = N | E | S | W
   deriving (Show, Enum, Bounded)

> import Test.QuickCheck
> sample (arbitrary:: Gen Dir)
N
E
N
S
N
E
W
N
N
W
W

{-# LANGUAGE FlexibleInstances, UndecidableInstances, OverlappingInstances #-}"

- Constraint is no smaller than the instance head
  in the constraint: Enum a
(Use -XUndecidableInstances to permit this)

- Overlapping instances for Random Int
  arising from a use of `randomR'
Matching instances:
  instance Random Int -- Defined in System.Random
  instance (Enum a, Bounded a) => Random a

- Illegal instance declaration for `Random a'
  (All instance types must be of the form (T a1 ... an)
   where a1 ... an are *distinct type variables*,
   and each type variable appears at most once in the instance head.
   Use -XFlexibleInstances if you want to disable this.)

