data Suit = Club | Diamond | Heart | Spade
      deriving (Eq, Ord, Bounded, Enum, Show)


data Rank =
    R2 | R3 | R4 | R5 | R6 | R7 | R8 | R9 | R10 |
    Jack | Queen | King | Ace
        deriving (Eq, Ord, Bounded, Enum, Show)


data Card = Card {suit::Suit, rank::Rank}
          deriving (Eq, Bounded)

instance Ord Card where
    compare (Card s1 r1) (Card s2 r2) =
        let suitorder = compare s1 s2
        in  if suitorder == EQ then compare r1 r2 else suitorder

instance Enum Card where
    fromEnum (Card s r) = (fromEnum s)*13 + (fromEnum r)
    toEnum n = (Card s r)
      where s = toEnum (n `div` 13)
            r = toEnum (n `mod` 13)

instance Show Card where
    show (Card s r) = show r ++ show s


type GameState = [[Card]] -- store the remaining possible cards

initialGuess :: ([String],GameState)

nextGuess :: ([String],GameState) -> (Int,Int,Int) -> ([String],GameState)

initialGuess::([String], GameState)
initialGuess = let guess = [(Card Club R2),(Card Club R3),(Card Club R4)]
                            gs = FilterGameState
                            in (guess, gs)
                            .....                 -not complete yet    

FilterGameState :: [[Card]]
FilterGameState = filter ([x,y,z]) decks
   where decks = [[x,y,z] | x <- [minBound..maxBound] :: [Card], 
                            y <- [minBound..maxBound] :: [Card],
                            z <- [minBound..maxBound] :: [Card]]

