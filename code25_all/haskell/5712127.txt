module Main where
import Language.Haskell.Interpreter
import Test.SomeModule

main :: IO ()
main = do r <- runInterpreter testHint
          case r of
            Left err -> printInterpreterError err
            Right () -> putStrLn "Done."
          -- Right here I want to do something like the following
          -- but how do I do testInterpret thing so it uses the
          -- pre-initialized interpreter?
          case (testInterpret "expression one")
            Left err -> printInterpreterError err
            Right () -> putStrLn "Done."
          case (testInterpret "expression two")
            Left err -> printInterpreterError err
            Right () -> putStrLn "Done."

testHint :: Interpreter ()
testHint =
    do
      loadModules ["src/Test/SomeModule.hs"]
      setImportsQ [("Prelude", Nothing), ("Test.SomeModule", Just "SM")]
      say "loaded"
      -- Split here, so what I want is something like this though I know
      -- this doesn't make sense as is:
      -- testExpr = Interpreter () -> String -> Interpreter ()
      -- testExpr hintmonad expr = interpret expr
      let expr1 = "let p1o1 = SM.exported undefined; p1o2 = SM.exported undefined; in p1o1"
      say $ "e.g. typeOf " ++ expr1
      say =<< typeOf expr1


say :: String -> Interpreter ()
say = liftIO . putStrLn

printInterpreterError :: InterpreterError -> IO ()
printInterpreterError e = putStrLn $ "Ups... " ++ (show e)

