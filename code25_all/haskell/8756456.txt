typeCheck
numberList
data Type =
    Function Type Type |
    Number |
    Tuple [Type] |
    Limited [Type]
        deriving (Show, Eq)

-- type x is of type y
typeCheck :: Type -> Type -> Bool
typeCheck x y = case y of

    Function ya yr -> case x of
        Function xa xr -> typeCheck xa ya && typeCheck xr yr
        _ -> False


    Number -> x == Number 

    Tuple ys -> case x of 
        Tuple xs | length xs == length ys -> 
            all (==True) $ zipWith typeCheck xs ys
        _ -> False

Limited ys -> case x of
    Limited xs | length ys >= length xs -> 
        all (==True) $ zipWith typeCheck xs ys
    _ -> any (==True) $ map (typeCheck x) ys

{- 
 - A list of numbers can be represented as follows
 - () empty list
 - (1, ()) [1]
 - (1, (2, (3, ()))) [1,2,3]
-}

numberList = Limited [ Tuple [], Tuple [ Number, numberList ] ]

