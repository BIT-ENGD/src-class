{-# LANGUAGE OverloadedStrings,RankNTypes #-}
module Main where

import qualified Data.Attoparsec.Char8 as A

import qualified Pipes as P
import qualified Pipes.Attoparsec as PA        
import qualified Pipes.ByteString as PB
import qualified Pipes.Parse  as PP

passthrough :: A.Parser PB.ByteString
passthrough = A.takeWhile (\s->True)

f :: Monad m => PP.StateT (P.Producer PB.ByteString m r) m (Either String  String)
f = do
  r <- PA.parse passthrough
  return $ case r of
    Left e -> Left "a"
    Right (_,r1) -> Right "b"

g = PP.evalStateT f PB.stdin

h = P.runEffect g

P.hs:16:8:
    Couldn't match type `pipes-4.0.2:Pipes.Internal.Proxy
                           Data.Void.Void () () PB.ByteString m r0'
                  with `P.Proxy P.X () () PB.ByteString m r'
    Expected type: PP.StateT
                     (PP.Producer PB.ByteString m r)
                     m
                     (Either PA.ParsingError (Int, PB.ByteString))
      Actual type: PP.StateT
                     (pipes-4.0.2:Pipes.Core.Producer PB.ByteString m r0)
                     m
                     (Either PA.ParsingError (Int, PB.ByteString))
    In the return type of a call of `PA.parse'
    In a stmt of a 'do' block: r <- PA.parse passthrough
    In the expression:
      do { r <- PA.parse passthrough;
           return
           $ case r of {
               Left e -> Left "a"
               Right (_, r1) -> Right "b" } } Failed, modules loaded: none.

