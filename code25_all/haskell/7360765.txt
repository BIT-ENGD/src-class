{-# LANGUAGE ExistentialQuantification, RankNTypes, TypeSynonymInstances #-}
module Main where

import Unsafe.Coerce

main = do
  --doTest1 $ Hider "blue"
  doTest2 $ Hider "blue"

doTest1 :: Hider -> IO ()
doTest1 hh@(Hider h) =
  test $ unsafeCoerce h

doTest2 :: Hider -> IO ()
doTest2 hh@(Hider h) =
  test2 hh

test :: HasString a => a -> IO ()
test x = print $ toString x

test2 :: Hider -> IO ()
test2 (Hider x) = print $ toString (unsafeCoerce x)

data Hider = forall a. Hider a

class HasString a where
  toString :: a -> String

instance HasString String where
  toString = id

[1 of 1] Compiling Main             ( Test.hs, Test.o )

Test.hs:12:3:
    Ambiguous type variable `a1' in the constraint:
      (HasString a1) arising from a use of `test'
    Probable fix: add a type signature that fixes these type variable(s)
    In the expression: test
    In the expression: test $ unsafeCoerce h
    In an equation for `doTest1':
        doTest1 hh@(Hider h) = test $ unsafeCoerce h

[1 of 1] Compiling Main             ( Test.hs, Test.o )

Test.hs:12:3:
    Ambiguous type variable `a1' in the constraint:
      (HasString a1) arising from a use of `test'
    Probable fix: add a type signature that fixes these type variable(s)
    In the expression: test
    In the expression: test $ unsafeCoerce h
    In an equation for `doTest1':
        doTest1 hh@(Hider h) = test $ unsafeCoerce h

