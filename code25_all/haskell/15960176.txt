{-# LANGUAGE OverloadedStrings #-}

import Data.Aeson
import Data.Maybe
import Data.ByteString.Lazy
import Control.Applicative
import Debug.Trace
import Control.Monad
import qualified Data.Aeson.Types as T

main = do
  res <- liftA show (liftA decodeOriginal (Data.ByteString.Lazy.readFile "./a.json"))
  Prelude.putStrLn res

interpretResult :: Maybe String -> String
interpretResult Nothing = "Error."
interpretResult x = fromJust x

data TotalLine1 = TotalLine1 {
  timestamp :: Integer,
  value :: Integer
} deriving (Eq, Show)

data Original = Original {
  totals :: [TotalLine1]
} deriving (Eq, Show)

instance FromJSON Original where
  parseJSON (Object v) = traceStack "Original" (Original <$> (parseJSON =<< (v .: "visitors.total")))
  parseJSON _ = mzero

instance FromJSON TotalLine1 where
  parseJSON (Object v) = TotalLine1 <$>
                         v .: "timestamp" <*>
                         v .: "value"
decodeOriginal :: ByteString -> Maybe Original
decodeOriginal b = traceStack "decoding" (do
  a <- decode b :: Maybe Original
  return a)

{
visitors.total: [
{
timestamp: 1365548400,
value: 1
},
{
timestamp: 1365548700,
value: 2
},
{
timestamp: 1365549000,
value: 5
},
]
}

