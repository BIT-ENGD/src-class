data SupervisedDataSet x y = SupervisedDataSet [([x], y)] deriving (Show)       

class DataSet a where                                                           
 augment :: x -> a -> a --Augment each input vector, making x the head.                                                       

instance DataSet (SupervisedDataSet x y) where                                   
  augment v (SupervisedDataSet ds) =Â·                                           
    let xsys = unzip ds in                                                      
      SupervisedDataSet $ zip (map (v:) $ fst xsys) (snd xsys)  

SupervisedDataSet
augment
Perceptron.hs:16:7:
  Couldn't match type `x1' with `x'
    `x1' is a rigid type variable bound by
         the type signature for
           agument :: x1 -> SupervisedDataSet x y -> SupervisedDataSet x y
         at Perceptron.hs:14:3
    `x' is a rigid type variable bound by
        the instance declaration at Perceptron.hs:13:37
  Expected type: SupervisedDataSet x1 y
    Actual type: SupervisedDataSet x y
  In the expression:
    SupervisedDataSet $ zip (map (v :) $ fst xsys) (snd xsys)
  In the expression:
    let xsys = unzip ds
    in SupervisedDataSet $ zip (map (v :) $ fst xsys) (snd xsys)

