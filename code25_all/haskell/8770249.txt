pos 2 [1, 2, 3, 2] -> [2, 4]
pos 1 [1, 2, 3, 2] -> [1]
pos 8 [1, 2, 3, 2] -> []

--findFirstPosition :: Eq a => a -> [a] -> Maybe a
findFirstPosition val xs = case f of 
    Nothing -> Nothing 
    Just (v, i) -> Just(i)
  where f = (find (\ (v, i) -> val == v) (zip xs [1..]))

--pos :: Eq a => a -> [a] -> [Int]
pos _ [] = []
pos val xs = if (finded) 
    then concat[
           [fromJust res],
            map (\a -> a + (fromJust res)) 
            (pos val (drop  (fromJust res) xs))]
    else []  
  where 
    res = findFirstPosition val xs
    finded = (isJust res)

Could not deduce (a ~ Int)
from the context (Eq a)
  bound by the type signature for pos :: Eq a => a -> [a] -> [Int]
  at \test.hs:(63,1)-(72,29)
  `a' is a rigid type variable bound by
      the type signature for pos :: Eq a => a -> [a] -> [Int]
      at \test.hs:63:1
Expected type: Maybe Int
  Actual type: Maybe a
In the first argument of `fromJust', namely `res'
In the first argument of `drop', namely `(fromJust res)'

find
