module Orexio.Radix where

import Data.Data
import Data.Map (Map)
import qualified Data.Map as Map
import Data.Typeable
import Text.JSON.Generic

class Resource a where
  type Representation a :: *
  identifier :: Resource a => Identifier a

class Endpoint a where
  call :: Resource a => a -> Representation a

data Identifier a = Identifier [String] deriving (Show)

data Binding a = Binding (JSValue -> Either String JSValue)

bind :: (Data a, Resource a, Endpoint a, Data (Representation a)) => Binding a
bind = Binding (\x -> binding $ query x)
  where binding query = fmap (\x -> toJSON $ call x) (resultToEither query)
        query jsvalue = fromJSON jsvalue

{-- DEMO --}

data HelloWorld = HelloWorld { 
  name :: String
} deriving (Show, Typeable, Data)

instance Resource HelloWorld where
  type Representation HelloWorld = String
  identifier = Identifier ["helloworld"]

instance Endpoint HelloWorld where
  call r = "Hello " ++ name r

FlexibleContexts
Data (Representation a)
src/Orexio/Radix.hs:21:33:
    Could not deduce (Data a0) arising from a use of `query'
    from the context (Data a,
                      Resource a,
                      Endpoint a,
                      Data (Representation a))
      bound by the type signature for
                 bind :: (Data a, Resource a, Endpoint a,
                          Data (Representation a)) =>
                         Binding a
      at src/Orexio/Radix.hs:20:9-78
    The type variable `a0' is ambiguous
    Possible fix: add a type signature that fixes these type variable(s)
    Note: there are several potential instances:
      instance Data HelloWorld -- Defined at src/Orexio/Radix.hs:29:29
      instance Data () -- Defined in `Data.Data'
      instance (Data a, Data b) => Data (a, b) -- Defined in `Data.Data'
      ...plus 42 others
    In the second argument of `($)', namely `query x'
    In the expression: binding $ query x
    In the first argument of `Binding', namely
      `(\ x -> binding $ query x)'

DeriveDataTypeable
ExistentialQuantification
NoMonomorphismRestriction
TypeFamilies
