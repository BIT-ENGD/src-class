ReaderT
ErrorT
StateT
IO
(MonadIO m, MonadReader MyContext m, MonadState MyState m, MonadError MyError m) => m ()
ReaderT MyContext (StateT MyState (ErrorT MyError IO)))
State
Error
MyContext
    data MyContext = MyContext { _callbacks :: Callbacks {- etc -} }

    -- In this example, 2 callbacks only
    data Callbacks = Callbacks {
        _callback1 :: IORef (m ()),
        _callback2 :: IORef (m ())}

m
Callbacks
m
data (MonadIO m, MonadReader (MyContext m) m) => Callbacks m = Callbacks {
   _callback1 :: IORef (m ()),
   _callback2 :: IORef (m ())}

Callbacks
MyContext
MonadReader (MyContext m) m
data Callbacks = forall m . (MonadIO m, MonadReader MyContext m) => Callbacks {
   _callback1 :: IORef (m ()),
   _callback2 :: IORef (m ())}

Callbacks
register :: (MonadIO m, MonadReader MyContext m) => m () -> m ()
register f = do
  (Callbacks { _callback1 = ref1 }) <- asks _callbacks -- Note the necessary use of pattern matching
  liftIO $ modifyIORef ref1 (const f)

Could not deduce (m ~ m1)
  from the context (MonadIO m, MonadReader MyContext m)
    bound by the type signature for
         register :: (MonadIO m, MonadReader MyContext m) => m () -> m ()
  or from (MonadIO m1, MonadReader MyContext m1)
    bound by a pattern with constructor
         Callbacks :: forall (m :: * -> *).
                   (MonadIO m, MonadReader MyContext m) =>
                   IORef (m ())
                   -> IORef (m ())
                   -> Callbacks,
  Expected type: m1 ()
  Actual type: m ()

m
Callbacks
Data.Default
instance (MonadIO m, MonadReader (MyContext m) m) => Default (Callbacks m) where
  def = Callbacks {
    _callback1 = {- something that makes explicit use of the Reader layer -},
    _callback2 = return ()}

Variable occurs more often in a constraint than in the instance head
  in the constraint: MonadReader (MyContext m) m

Data.Default
