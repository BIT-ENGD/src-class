data Type t where
  Num  :: Type Int
  Bool :: Type Bool

data Ty = TNum | TBool deriving Eq

data Tagged t = Tagged (Type t) t deriving Typeable
data Dynamic  = forall t . Typeable t => Dynamic (Tagged t) deriving Typeable

forget :: Typeable t => Tagged t -> Dynamic
forget = Dynamic

remember :: Typeable b => Dynamic -> Maybe b
remember (Dynamic c) = cast c

(isSucc :: Int -> Int -> Bool)
data SplitFun = SF { dynamic    :: [Dynamic] -> Dynamic 
                   , inputTypes :: [Ty] 
                   , outputType :: Ty
                   }

apply
(\(a:b:_) -> isSucc a b) == apply (makeDynamicFn isSucc)

makeDynamicFn :: FunType -> SplitFun
isSucc
anInt . anInt . retBool $ isSucc :: SplitFun

anInt
retBool
printf
