{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE DeriveGeneric, ScopedTypeVariables #-}

import Data.Generics (Data, Typeable)
import Data.Conduit
import qualified Data.Conduit.List as CL
import Database.CouchDB.Conduit.Generic
import Database.CouchDB.Conduit
import Database.CouchDB.Conduit.View
import Data.ByteString.Char8 (ByteString, empty)
import Control.Monad.IO.Class (liftIO)
import Data.Aeson
import Data.Aeson.Types
import GHC.Generics

data Page = Page { id_ :: ByteString, url :: ByteString }
            deriving (Show, Data, Typeable, Generic)

instance FromJSON Page

getPages :: IO ()
getPages = runCouch (def { couchHost = "192.168.0.103" }) $ do
    couchView_ "reader" "reader" "pages" [] $ CL.mapM_ (liftIO . print)

    *Main> getPages 
    fromList [("key",String "802e343945c7f8da2d8a71fdb80025a7"),("id",String "802e343945c7f8da2d8a71fdb80025a7"),("value",String "http://yandex.ru")]`

getPages :: IO [Page]
getPages = runCouch (def { couchHost = "192.168.0.103" }) $ do
    couchView_ "reader" "reader" "pages" [] $ toType =$ CL.consume`

`Reader/Couch.hs:24:47:
    Couldn't match expected type `Object' with actual type `Value'
    Expected type: Conduit Object m1 b0
      Actual type: Conduit Value m0 a0
    In the first argument of `(=$)', namely `toType'
    In the second argument of `($)', namely `toType =$ CL.consume'
Failed, modules loaded: none.

Sink Object m a
