readFile
module Main where

import Control.Error
import qualified Data.ByteString.Lazy as BSL

replaceLeftT :: Monad m => String -> EitherT String m a -> EitherT String m a
replaceLeftT message e = EitherT $ do
  unwrapped <- runEitherT e
  let x = case unwrapped of
            Left _ -> Left message
            y      -> y
  return x

main :: IO ()
main = runScript $ do
  contents <- replaceLeftT "Could not read file" $
                scriptIO $ BSL.readFile "somefile"
  scriptIO $ putStrLn "Won't get here"

Control.Error
