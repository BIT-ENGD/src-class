/t     /x
| P(x)*| P(y) dydx
/t0    /t0

R -> C^(nxn)
import Numeric.GSL.Integration
import Data.Complex
import Data.List

prec :: Double
prec = 1E-9

integrate :: (Double -> Double) -> Double -> Double -> Double
integrate f a b = fst $ integrateQNG prec f a b 

integrateC :: (Double -> Complex Double) -> Double -> Double -> Complex Double
integrateC cf a b = (integrate (\x -> realPart (cf x)) a b :+ integrate (\x -> imagPart (cf x)) a b)

multipleIntegration :: Int -> (Double -> Complex Double) -> Double -> (Double -> Complex Double)
multipleIntegration n f a =  foldl' (\ acc g' -> (\ x -> integrateC (g'*acc) a x)) (\_ -> 1:+0) (replicate n f)

Double -> Complex Double
import MathObj.Matrix as Mat
import Algebra.Ring as AR
import Control.Applicative
import qualified Prelude as P
import Prelude hiding ((*))
import Number.Complex as NC
import Numeric.GSL.Integration
import Data.List

type Complex a = NC.T a

prec :: Double
prec = 1E-9

testMat :: Mat.T (Double -> Complex Double)
testMat = Mat.fromRows 2 2 [[\x-> 0.5 +: 2*x,\y-> cos y +: sin y],[\x-> 0.1*x +:x,\_-> 1 +: 1]]

integrateC :: (Double -> Complex Double) -> Double -> Double -> Complex Double
integrateC cf a b = (integrate (\x -> real (cf x)) a b +: integrate (\x -> imag (cf x)) a b)

integrate :: (Double -> Double) -> Double -> Double -> Double
integrate f a b = fst $ integrateQNG prec f a b 

integrateCMat' :: Mat.T (Double -> Complex Double) -> Double -> Mat.T (Double -> Complex Double)
integrateCMat' cmf a =  ((\f -> integrateC f a ) <$> cmf)

multipleIntegrationMat :: Int -> Mat.T (Double -> Complex Double) -> Double -> Mat.T (Double -> Complex Double)
multipleIntegrationMat n mf a =  integrateCMat' ( testMat * (integrateCMat' testMat a)) a

multipleIntegrationMat
matmul.hs:27:59:
No instance for (C (Double -> Complex Double))
  arising from a use of `*'
Possible fix:
  add an instance declaration for (C (Double -> Complex Double))
In the first argument of `integrateCMat'', namely
  `(testMat * (integrateCMat' testMat a))'
In the expression:
  integrateCMat' (testMat * (integrateCMat' testMat a)) a
In an equation for `multipleIntegrationMat':
    multipleIntegrationMat n mf a
      = integrateCMat' (testMat * (integrateCMat' testMat a)) a
Failed, modules loaded: none.

Data.Complex
Number.Complex
