Double * 10 ^ Integer
+
newtype Sci f p = Sci (f ,p)  deriving (Eq,Show) 


instance (Floating a,Integral b) => Num (Sci a b) where
   Sci (a,b) * Sci (c,d) = fixSci( Sci(a*c,b*d) )


mulSci :: Sci Double Integer -> Sci Double Integer -> Sci Double Integer
mulSci (Sci(a,b)) (Sci(c,d)) = fixSci (Sci(a*c,b*d))


mkSci :: Double -> Sci Double Integer   
mkSci 0 = Sci(0, 0)
mkSci n = let lg = (floor ((log10 . abs) n)) in Sci((n/(10**(fromIntegral lg))), if lg > 0 then lg else 0)

fixSci :: Sci Double Integer -> Sci Double Integer
fixSci (Sci(a,b)) = let n = mkSci a in (\(Sci(c,d)) -> Sci(c,b+d)) n

fromSci (Sci(a,b)) = a*10**(fromIntegral b)

showSci (Sci(a,b)) = (show a)++"e"++(show b) 

lx :: Double
lx = log 10

log10 :: Double -> Double
log10 y = log y / lx


-- ~ main = putStrLn $ showSci $ fixSci $ Sci(95,0)
main = putStrLn $ showSci $ mkSci 95

sci.hs:5:40:
   Could not deduce (a ~ Double)
   from the context (Floating a, Integral b)
     bound by the instance declaration at sci.hs:4:10-49
     `a' is a rigid type variable bound by
         the instance declaration at sci.hs:4:20
   In the first argument of `(*)', namely `a'
   In the expression: a * c
   In the first argument of `Sci', namely `(a * c, b * d)'

sci.hs:5:44:
   Could not deduce (b ~ Integer)
   from the context (Floating a, Integral b)
     bound by the instance declaration at sci.hs:4:10-49
     `b' is a rigid type variable bound by
         the instance declaration at sci.hs:4:31
   In the first argument of `(*)', namely `b'
   In the expression: b * d
   In the first argument of `Sci', namely `(a * c, b * d)'

