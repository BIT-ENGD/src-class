euclidean :: Integral a => [a] -> [a] -> Double
euclidean a b = sqrt . sum $ zipWith (\u v -> (u - v)^2) x y
                where x = map fromIntegral a
                      y = map fromIntegral b

type Vector1 = Integer
data Vector2 = Vector2 Integer Integer

d :: a -> a -> Double
d (Vector2 x1 y1) (Vector2 x2 y2) = euclidean [x1, y1] [x2, y2]
d a b = euclidean [a] [b]

Couldn't match expected type `a' with actual type `Vector2'
  `a' is a rigid type variable bound by
      the type signature for d :: a -> a -> Double at test.hs:11:6
In the pattern: Vector2 x1 y1
In an equation for `d':
    d (Vector2 x1 y1) (Vector2 x2 y2) = euclidean [x1, y1] [x2, y2]

{-# LANGUAGE FlexibleInstances #-}

class Metric a where
  d :: a -> a -> Double

instance Metric Vector1 where
  d a b = euclidean [a] [b]

instance Metric Vector2 where
  d (Vector2 x1 y1) (Vector2 x2 y2) = euclidean [x1, y1] [x2, y2]

d
d
No instance for (Metric a) arising from a use of `d'
Possible fix:
  add (Metric a) to the context of
    the type signature for someFunction :: [a] -> [a] -> [a]
In the expression: d c x
In the expression: (x, d c x)
In the first argument of `map', namely `(\ x -> (x, d c x))'

someFunction1 :: [Vector1] -> [Vector1] -> [Vector1]
-- Lots of code
where d a b = euclidean [a] [b]

someFunction2 :: [Vector2] -> [Vector2] -> [Vector2]
-- Exactly the same code
where d (Vector2 x1 y1) (Vector2 x2 y2) = euclidean [x1, y1] [x2, y2]

