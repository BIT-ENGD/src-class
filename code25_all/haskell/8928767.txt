follow :: Handle -> IO [String]
follow h = unsafeInterleaveIO $ do
  catch (do line <- hGetLine h
            lines <- follow h
            return $ line : lines)
        (const (do threadDelay (1000 * 100)
                   follow h)) 

h <- openFile "test.log" ReadMode
ls <- follow h 
mapM_ putStrLn ls

follow
h <- openFile "test.log" ReadMode
ls <- follow h 
mapM_ putStrLn (concatWhen (isPrefixOf "foo") ls)

concatWhen :: (String -> Bool) -> [String] -> [String]
concatWhen _ [] = []
concatWhen p as = let (xs, as') = span p as
                      (ys, rest) = break p as'
                   in (concat xs) : ys ++ (concatWhen p rest)

follow
