sumOfSquare :: Int -> Int -> Int
sumOfSquare a b = a * a + b * b

hipotenuse :: Int -> Int -> Int
hipotenuse a b = truncate(sqrt(x))
           where x = fromIntegral(sumOfSquare a b)

squareCheck :: Int -> Bool
squareCheck n = truncate(sqrt(x)) * truncate(sqrt(x)) == n
         where x = fromIntegral n

isItSquare :: Int -> Int -> Bool
isItSquare a b = squareCheck (sumOfSquare a b)

calc :: (Integral a) => a -> [(a, a, a)]
calc a = [(x, y, (hipotenuse x y)) | x <- [1..a], y <-[1..a], (isItSquare x y)]

Prelude> :load "some.hs"
[1 of 1] Compiling Main             ( some.hs, interpreted )

some.hs:16:74:
    Couldn't match expected type `Int' against inferred type `a'
      `a' is a rigid type variable bound by
          the type signature for `calc' at some.hs:15:18
    In the first argument of `isItSquare', namely `x'
    In the expression: (isItSquare x y)
    In a stmt of a list comprehension: (isItSquare x y)
Failed, modules loaded: none.

