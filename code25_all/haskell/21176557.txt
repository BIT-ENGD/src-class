module Main where

data NestedList a=Elem a | List[NestedList a] deriving Show

flatten ::NestedList a->[a]
flatten (Elem x)=[x]
flatten (List(x:xs))=flatten(x)++flatten(List xs)
--flatten NestedList (x:xs)=flatten(x)++flatten(xs)
flatten(List [])=[]

------------------

count::[a]->Int
count a=length (a)

-----------------
append::NestedList a->NestedList a->Either String (NestedList a)
append (_) (Elem a)=Left "Elements are not allowed"
append (Elem a) (_)=Left "Elements are not allowed"
append (List a) (List b)=Right (List (flatten(List a)++flatten(List b)))
-------------------

main=do
        print(flatten (List[Elem 1, Elem 2,List[Elem 1, Elem 2 ]]))
        print(count(flatten (List[Elem 1, Elem 2,List[Elem 1, Elem 2 ]])))
        print(append (List[List[Elem 1, Elem 2 ]]) (List[Elem 1, Elem 2,List[Elem 1, Elem 2 ]]    ))  

   flatten_list.hs:18:52:
   Couldn't match type `a' with `NestedList a'
      `a' is a rigid type variable bound by
      the type signature for
        append :: NestedList a
                  -> NestedList a -> Either String (NestedList a)
      at flatten_list.hs:15:9
       Expected type: [NestedList (NestedList a)]
  Actual type: [NestedList a]
In the first argument of `List', namely `a'
In the first argument of `flatten', namely `(List a)'
In the first argument of `(++)', namely `flatten (List a)'

flatten_list.hs:18:69:
    Couldn't match type `a' with `NestedList a'
  `a' is a rigid type variable bound by
      the type signature for
        append :: NestedList a
                  -> NestedList a -> Either String (NestedList a)
      at flatten_list.hs:15:9
    Expected type: [NestedList (NestedList a)]
  Actual type: [NestedList a]
In the first argument of `List', namely `b'
In the first argument of `flatten', namely `(List b)'
In the second argument of `(++)', namely `flatten (List b)'

