alternatives
agents
alternatives
agents
import Data.List
-----------
-- Setup
-----------
alternatives = [1, 2, 3]
agent_1 x = case x of
    1 -> 1
    2 -> 0.6
    _ -> 0.2
agent_2 x = case x of
    1 -> 0.4
    2 -> 1
    _ -> 0.3

agent_3 x = case x of
    1 -> 0.2
    2 -> 0.3
    _ -> 1

agents = [ agent_1, agent_2, agent_3]

-- collaboration imperative
h x = x^2

-----------
-- Program
-----------

-- Sum of scores by agent
s_i agent = sum [agent(x) | x <- alternatives]
-- Sum of all the scores
s agents = sum [s_i agent | agent <- agents]

-- Importance of an agent
im agent = s_i agent / s agents

-- evaulate agent importances and sort them
agent_ims agents = sort [im agent | agent <- agents]

-- agent scores and importances sorted by scores for a particular alternative 'x'
agent_scores :: Integer -> [(Double, Double)]
agent_scores x = sortBy (\(s1,im1) (s2,im2) -> compare s1 s2)
    [(agent x, im agent) | agent <- agents]

num = length(agents)
--U for an alternative 'x' and index 'i'
u x i = sum $ drop (num - i) $ [im | (score, im) <- agent_scores x]

-- 'w' for an agent given a particular collaboration imperative h
-- and alternative 'x'
w i x h = h(u x i) - h(u x (i-1))

-- sort according to which agent's score is the greatest for a given -- alternative
b alt = reverse $ sort [agent alt | agent <- agents]

-- zip 'b' with an index variable, to pass to the w 
zipped_alt alt = zip [1..] (b alt)

--group pref function - for an alternative 'x'
g x = sum $ [ w i x h * score  | (i, score) <- zipped_alt x]

Test.hs
import GroupPreference
import Data.List

-----------
-- Setup
-----------
alternatives = [1, 2, 3]
agent_1 x = case x of
    1 -> 1
    2 -> 0.6
    _ -> 0.2
agent_2 x = case x of
    1 -> 0.4
    2 -> 1
    _ -> 0.3

agent_3 x = case x of
    1 -> 0.2
    2 -> 0.3
    _ -> 1

agents = [ agent_1, agent_2, agent_3]

-- collaboration imperative
h x = x^2

main :: IO ()
main = putStrLn $ show $ g 2 h agents alternatives

GroupPreference.hs
module GroupPreference 
where

import Data.List

-----------
-- Program
-----------

-- Sum of scores by agent
s_i agent alternatives = sum [agent(x) | x <- alternatives]
-- Sum of all the scores
s agents alternatives = sum [s_i agent alternatives | agent <- agents]

-- Importance of an agent
im agent agents alternatives = s_i agent alternatives / s agents alternatives

-- agent scores and importances sorted by scores for a particular alternative 'x'
agent_scores x agents alternatives = sortBy (\(s1,im1) (s2,im2) -> compare s1 s2)
    [(agent x, im agent agents alternatives) | agent <- agents]

--U for an alternative 'x' and index 'i'
u x i agents alternatives = sum $ drop (length(agents) - i) $ [im | (score, im) <- agent_scores x agents alternatives]

-- 'w' for an agent given a particular collaboration imperative h
-- and alternative 'x'
w i x h agents alternatives = h(u x i agents alternatives) - h(u x (i-1) agents alternatives)

-- sort according to which agent's score is the greatest for a given -- alternative
b alt agents = reverse $ sort [agent alt | agent <- agents]

-- zip 'b' with an index variable, to pass to the w 
zipped_alt alt agents = zip [1..] (b alt agents)

--group pref function - for an alternative 'x'
g x h agents alternatives = sum $ [ w i x h agents alternatives * score  | (i, score) <- zipped_alt x agents]

