module RandState where
import UCState
import System.Random

-- In order to generate pseudo-random numbers, need to pass around generator
--  state in State monad
type RandState a = State StdGen a

-- runRandom runs a RandState monad, given an initial random number generator
runRandom :: RandState a -> StdGen -> a
runRandom (State f) s = res
    where (res, state) = f s

-- rand is a helper function that generates a random instance of any
--  type in the Random class, using the RandState monad.
rand :: Random a => RandState a
rand = do
    gen <- get
    let (x, gen') = random gen
    put gen'
    return x

{- 
 - Simplified implementation of the State monad.  The real implementation
 - is in the Control.Monad.State module: using that is recommended for real 
 - programs.
 -}
module UCState where

data State s a = State { runState :: s -> (a, s) }

instance Monad (State s)
    where
        {-
         - return lifts a function x up into the state monad, turning it into
         -  a state function that just passes through the state it receives
         -}
        return x = State ( \s -> (x, s) )

        {- 
         - The >>= combinator combines two functions p and f, and 
         -  gives back a new function (Note: p is originally wrapped in the 
         -  State monad)
         -
         - p: a function that takes the initial state (from right at the start
         - of the monad chain), and gives back a new state and value, 
         - corresponding to the result of the chain up until this >>=
         - f: a function representing the rest of the chain of >>='s
         -}
        (State p) >>= f = State ( \initState -> 
                                  let (res, newState) = p initState
                                      (State g) = f res
                                  in g newState )

-- Get the state
get :: State s s  
get = State ( \s -> (s, s) )

-- Update the state
put :: s -> State s ()
put s = State ( \_ -> ((), s))

randR :: Random a => (a, a) -> RandState a
randR (lo, hi) = do
    gen <- get
    let (x, gen') = randomR (lo, hi) gen
    put gen'
    return x

testRandR1 :: IO Bool
testRandR1 = do
    gen <- newStdGen
    let genR = runRandom (randR (1,5)) gen :: Int
    return (genR <=5 && genR >=1)

testRandR2 :: IO Bool
testRandR2 = do
    gen <- newStdGen
    let genR = runRandom (randR (10.0, 11.5)) gen :: Double
    return (genR <= 11.5 && genR >= 10.0)

rollTwoDice :: RandState Int
rollTwoDice = do
    gen <- get
    let (a, gen') = randomR (1, 6) gen :: (Int, StdGen)
    put gen'
    let (b, gen'') = randomR (1, 6) gen' :: (Int, StdGen)
    put gen''
    return $ a + b

testRollTwoDice :: IO Bool
testRollTwoDice = do
    gen <- newStdGen
    let genR = runRandom (rollTwoDice) gen
    return (genR <= 12 && genR >= 2)

-- Data types to represent playing cards
data CardValue = King | Queen | Jack | NumberCard Int
    deriving (Show, Eq)
data CardSuit = Hearts | Diamonds | Spades | Clubs
    deriving (Show, Eq)
data PlayingCard = PlayingCard CardSuit CardValue
    deriving (Show, Eq)

{-
 - fullCardDeck will be a deck of cards, 52 in total, with a King, a Queen, 
 - a Jack and NumberCards from 1 to 10 for each suit.
 -}
-- fullCardDeck and its definition were given in the lab
fullCardDeck :: [PlayingCard]
fullCardDeck = [ PlayingCard s v | s <- allsuits, v <- allvals ] where
        allvals = King : Queen : Jack : [ NumberCard i | i <- [1..10] ]
        allsuits = [Hearts, Diamonds, Spades, Clubs]

removeCard :: [a] -> RandState [a]
removeCard deck = do
    gen <- get
    let n = runRandom (randR(1, length (deck))) gen :: Int
    let (xs, ys) = splitAt (n-1) deck
    return $ head ys : xs ++ tail ys

shuffleDeck deck = do
    gen <- get
    let f deck = head $ runRandom (removeCard deck) gen
    return $ take (length(deck)) (iterate f deck)

RandState.hs:88:31:
    Occurs check: cannot construct the infinite type: a0 = [a0]
    Expected type: [a0] -> [a0]
      Actual type: [a0] -> a0
    In the first argument of `iterate', namely `f'
    In the second argument of `take', namely `(iterate f deck)'
    In the second argument of `($)', namely `take 52 (iterate f deck)'

