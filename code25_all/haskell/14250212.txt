data Foo z q = Foo1 (z q)
             | Foo2 (z q)

class Qux q -- where ...
class Baz z -- where ...

class Bar a where             -- a has kind *->*
  type BCtx a q :: Constraint -- using ConstraintKinds to allow constraints on the concrete type
  f :: (BCtx a q) => a q -> a q -> a q
  g :: (BCtx a q, BCtx a q') => a q -> a q'

instance (Baz z) => Bar (Foo z) where
  type BCtx (Foo z) q = (Num (z q), Qux q) -- for example
  f (Foo1 x) (Foo1 y) = Foo1 $ x+y -- these functions need access to the type q to do arithmetic mod q
  f (Foo1 x) (Foo2 y) = Foo2 $ x-y
  -- ...

q
qi
data QList qi qs = QCons qi qs
                 | QNil

data FList c q = FNil 
               | FCons (c (Head q)) (FList c (Tail q))

(Head q)
qi
(Tail q)
qs
q
FList
(Qux q)
(Qux qi)
FList
instance (Bar c) => Bar (FList c) where
   type BCtx (FList c) q = () -- Anything I put here is not enough
   f (FCons x xs) (FCons y ys) = FCons (f x y) (f xs ys)
   -- the left call to `f` calls a concrete instance, the right call to `f` is a recursive call on the rest of the list
   -- ...

Could not deduce (BCtx c (Head q), BCtx c (Tail q))

Could not deduce (BCtx c (Head (Tail q)), BCtx c (Tail (Tail q)))

FList c q
c~Foo z
q~QCons q1 (QCons q2 QNil)
qi
FList
QList
