{-# LANGUAGE FlexibleInstances #-}

class    Funk a       where  truth :: a  -> [Bool]
instance Funk [Bool]  where  truth =  \x ->  x
instance Funk Bool    where  truth =  \x -> [x]

instance Funk b => Funk (Bool -> b) where
    truth f = concat [truth (f True), truth (f False)]

truth
Bool
[Bool]
Main> truth (\x y -> x && y)
[True,False,False,False]

Main> truth (\x y -> x || y)
[True,True,True,False]

Main> main
T T T | T
T T F | T
T F T | T
T F F | F
F T T | T
F T F | F
F F T | T
F F F | T

class TruthTable a where
    truthTable :: Funk f => f -> a

instance TruthTable [String] where
    truthTable f = zipWith (++) (hCells (div (length t) 2)) (map showBool $ truth f)
        where
            showBool True = "| T"
            showBool False = "| F"
            hCells 1 = ["T ", "F "]
            hCells n = ["T " ++ x | x <- hCells (div n 2)] ++ ["F " ++ x | x <- hCells (div n 2)]

instance TruthTable [Char] where
    truthTable f = foldl1 join (truthTable f)
        where join a b = a ++ "\n" ++ b

instance TruthTable (IO a) where
    truthTable f = putStrLn (truthTable f) >> return undefined

main :: IO ()
main = truthTable (\x y z -> x `xor` y ==> z)

xor :: Bool -> Bool -> Bool
xor a b = not $ a == b

(==>) :: Bool -> Bool -> Bool
a ==> b = not $ a && not b

