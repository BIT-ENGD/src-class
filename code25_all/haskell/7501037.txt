import Data.List (isPrefixOf)
import Text.XML.HaXml.XmlContent
import Text.XML.HaXml.Types
import Text.XML.HaXml.Pretty (document)

data MyType = A | B String deriving (Eq, Show)
      {-! derive : XmlContent !-}   -- this line is for DrIFT

{- Generated by DrIFT (Automatic class derivations for Haskell) -}
{-# LINE 1 "ts.hs" #-}
import Data.List (isPrefixOf)
import Text.XML.HaXml.XmlContent
import Text.XML.HaXml.Types
import Text.XML.HaXml.Pretty (document)


data MyType = A | B String deriving (Eq, Show)
      {-! derive : XmlContent !-}   -- this line is for DrIFT
{-* Generated by DrIFT : Look, but Don't Touch. *-}
instance HTypeable MyType where
    toHType v =
    Defined "MyType" [] [Constr "A" [] [],Constr "B" [] [toHType aa]]
      where
    (B aa) = v
instance XmlContent MyType where
    parseContents = do
    { e@(Elem t _ _) <- elementWith (flip isPrefixOf) ["B","A"]
    ; case t of
      _ | "B" `isPrefixOf` t -> interior e $ fmap B parseContents
        | "A" `isPrefixOf` t -> interior e $ return A
    }
    toContents v@A =
    [mkElemC (showConstr 0 (toHType v)) []]
    toContents v@(B aa) =
    [mkElemC (showConstr 1 (toHType v)) (toContents aa)]

--  Imported from other files :-

19:32:
    Couldn't match expected type `[Char]' with actual type `QName'
    In the second argument of `isPrefixOf', namely `t'
    In the expression: "B" `isPrefixOf` t
    In a stmt of a pattern guard for
                 a case alternative:
          "B" `isPrefixOf` t

