function [Tc, dT] = CTD_TempTimelagCorrection(T0,Tau,t)
N1 = Tau/t;
Tc = T0;
    N = 3;

    for j=ceil(N/2):numel(T0)-ceil(N/2)

        A = nan(N,1);
        # Compute weights
        for k=1:N
            A(k) = (1/N) + N1 * ((12*k - (6*(N+1))) / (N*(N^2 - 1)));
        end
        A = A./sum(A);

        # Verify unity
        if sum(A) ~= 1
            disp('Error: Sum of weights is not unity');
        end

        Comp = nan(N,1);
        # Compute components
        for k=1:N
            Comp(k) = A(k)*T0(j - (ceil(N/2)) + k);
        end


        Tc(j) = sum(Comp);
        dT = Tc - T0;    
    end

CTD_TempTimelagCorrection <- function(temp,Tau,t){

## Define which equation to use based on duration of lag and frequency
##  With ESM2 profiler sampling @ 2hz: N1>tau/t = TRUE 

N1 = Tau/t
Tc = temp
N = 3

for(i in ceiling(N/2):length(temp)-ceiling(N/2)){
    A = matrix(nrow=N,ncol=1)
    # Compute weights
    for(k in 1:N){
        A[k] = (1/N) + N1 * ((12*k - (6*(N+1))) / (N*(N^2 - 1)))
    }
    A = A/sum(A)

    # Verify unity
    if(sum(A) != 1){
    print("Error: Sum of weights is not unity")
    }

    Comp = matrix(nrow=N,ncol=1)
    # Compute components
    for(k in 1:N){
        Comp[k] = A[k]*temp[i - (ceiling(N/2)) + k]
    }

    Tc[i] = sum(Comp)
    dT = Tc - temp  
}
return(dT)
}

