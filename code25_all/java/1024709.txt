r = pixel >> 16 & 0xFF

pixel = a | r <<16 | g << 8 | b 

private void medianFilterSquare(int[] source, int[] dest, int rWidth,
        int rHeight, int radius) {
    // Source has been reflected into a border of size radius
    // This makes it radius * 2 pixels wider and taller than the dest
    int r,g,b;
    int destOffset, rOffset, kOffset;

    // The first offset into the source to calculate a median for
    // This corresponds to the first pixel in dest
    int rFirst = radius + (rWidth*radius);

    // We use a square kernel with the radius passed
    int neighbours = (radius+radius+1)*(radius+radius+1);

    int index;

    // Arrays to accumulate the values for median calculation
    int[] rs = new int[neighbours];
    int[] gs = new int[neighbours];
    int[] bs = new int[neighbours];

    // Declaring outside the loop helps speed? I'm sure this is done for me
    // by the compiler
    int pixel;

    // Iterate over the destination pixels
    for(int x = 0; x < height; x++){
        for(int y = 0; y < width; y++){
            // Offset into destination
            destOffset = x + (y * width);
            // Offset into source with border size radius
            rOffset = destOffset + rFirst + (y * (radius *2));

            index = 0;

            // Iterate over kernel
            for(int xk = -radius; xk < radius ; xk ++){
                for(int yk = -radius; yk < radius ; yk ++){
                    kOffset = rOffset + (xk + (rWidth*yk));
                    pixel = source[kOffset];
                    // Color.red is equivalent to (pixel>>16) & 0xFF
                    rs[index] = Color.red(pixel);
                    gs[index] = Color.green(pixel);
                    bs[index] = Color.blue(pixel);
                    index++;
                }   
            }
            r = medianFilter(rs);
            g = medianFilter(gs);
            b = medianFilter(bs);

            dest[destOffset] = Color.rgb(r, g, b);
        }           
    }       
}

