import java.util.*;

class TreeNode383<E extends Comparable> {

  private E data;

  private TreeNode383<E> left;

  private TreeNode383<E> right;

  private TreeNode383<E> parent;

  public TreeNode383( ) { left = right = parent = null; }

  public TreeNode383( E d, TreeNode383 <E> l, TreeNode383 <E> r,
                     TreeNode383 <E> p) {

    data = d;

    left = l;

    right = r;

    parent = p;

  }

  public  E getData( ) { return data; }

  public void setData(E d) { data = d; }

  public TreeNode383<E> getLeft( ) { return left; }

  public void setLeft(TreeNode383<E> l) { left = l; }

  public TreeNode383<E> getRight( ) { return right; }

  public void setRight(TreeNode383<E> r) { right = r; }

  public TreeNode383<E> getParent( ) { return parent; }

  public void setParent(TreeNode383<E> p) { parent = p; }


  public String toString( ) {

    String answer = "";

    if (left != null) answer += left.toString( );

    answer += data + " ";

    if (right != null) answer += right.toString( );

    return answer;
  }
}

**The start of my remove method**


  boolean remove (E obj)
  {

 if(root == obj)

 return false;


 //when deleting a leaf just delete it

 else if(obj.getleft == NULL && obj.getright == NULL)
  parent = obj = NULL;


 //when deleting an interior node with 1 child
 //replace that node with the child

 else if(obj.getleft == NULL && obj.getright != NULL)
 obj.setright = new TreeNode383<E>(newData, null, null, null);

 else if(obj.getleft != NULL && obj.getright == NULL
 obj.setleft = new TreeNode383<E>(newData, null, null, null);


 //when deleting an interior node with 2 children
 //find left most node in right subtree,
 //promote it to replace the deleted node
 //promote its child to replace where it was



  /*
  private BinaryNode findMin( BinaryNode t )
  {
      if( t == null )
            return null;
      else if( t.left == null )
           return t;
      return findMin( t.left );
   }
 */

