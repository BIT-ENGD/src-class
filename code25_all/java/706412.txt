wrappedResp.setHeader("Content-Encoding", "gzip");
public class CompressionFilter implements Filter {

  private ServletContext ctx;
  private FilterConfig cfg;

    /**
     * The init method saves the config object and a quick reference to the
     * servlet context object (for logging purposes).
     */
  public void init(FilterConfig cfg) 
     throws ServletException {
    this.cfg = cfg;
    ctx = cfg.getServletContext();
    //ctx.log(cfg.getFilterName() + " initialized.");
  }

        /**
         * The heart of this filter wraps the response object with a Decorator
         * that wraps the output stream with a compression I/O stream.
         * Compression of the output stream is only performed if and only if
         * the client includes an Accept-Encoding header (specifically, for gzip).
         */
      public void doFilter(ServletRequest req,
                   ServletResponse resp,
                   FilterChain fc)
         throws IOException, ServletException {
        HttpServletRequest request = (HttpServletRequest) req;
        HttpServletResponse response = (HttpServletResponse) resp;

        // Dose the client accept GZIP compression?
        String valid_encodings = request.getHeader("Accept-Encoding");
        if ( (valid_encodings != null) && (valid_encodings.indexOf("gzip") > -1) ) {

          // Then wrap the response object with a compression wrapper
          // We'll look at this class in a minute.
          CompressionResponseWrapper wrappedResp = new CompressionResponseWrapper(response);

          // Declare that the response content is being GZIP encoded.
          wrappedResp.setHeader("Content-Encoding", "gzip");

          // Chain to the next component (thus processing the request)
          fc.doFilter(request, wrappedResp);

          // A GZIP compression stream must be "finished" which also
          // flushes the GZIP stream buffer which sends all of its
          // data to the original response stream.
          GZIPOutputStream gzos = wrappedResp.getGZIPOutputStream();
          gzos.finish();
          // The container handles the rest of the work.

          //ctx.log(cfg.getFilterName() + ": finished the request.");

        } else {
          fc.doFilter(request, response);
          //ctx.log(cfg.getFilterName() + ": no encoding performed.");
        }   
      }

      public void destroy() {
          // nulling out my instance variables
          cfg = null;
          ctx = null;
      }
    }

public ActionForward get(ActionMapping mapping,
    ActionForm     form,
    HttpServletRequest request,
    HttpServletResponse response) {
       JSONObject json = // Do some logic here
       RequestUtils.populateWithJSON(response, json);
       return null;         
}

public static void populateWithJSON(HttpServletResponse response,JSONObject json) {
    if(json!=null) {
        response.setContentType("text/x-json;charset=UTF-8");       
        response.setHeader("Cache-Control", "no-cache");
        try {
             response.getWriter().write(json.toString());
        } catch (IOException e) {
            throw new ApplicationException("IOException in populateWithJSON", e);
        }               
    }
 }

    $.post(url,parameters, function(json) {
    // Do some DOM manipulation with the data contained in the JSON Object
}, "json");

