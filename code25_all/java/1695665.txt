public class scanner implements CompilerConstants {
 private char c;
  private BufferedReader source; 
  public int token;

  private String attr = "";
  //private int val = '0'; 
  private

    public scanner(BufferedReader buffer) {
     source = buffer;

     getChar();
    } //constructor of scanner


    public void getChar()
    {
     c = (char)(source.read());
     //do a read in
    }


    //lookup for finding identifiers
    public boolean lookup(String word)
    {
     boolean check = false;
     for(int i=0; i < RESERVEDWORD.length;i++)
      if(word==(RESERVEDWORD[i]))
      {
       check = true;
      }
     return check;
    }


    //public boolean T(int tcc, String attt) //to return token
    //{
    // tokenCode = tcc;
    // attribute = attt;
    // return T;
   // }


     public Token nextToken() throws IOException
    {

    attr = "";

    //need to save to do lookup see if its identifier or not
    while(c!=EOFCHAR);  //if not end of file then do  
    { 
     while (Character.isWhitespace(c))//remove white space, check whether is letter or digit
     {
   getChar();
     }
     if (Character.isLetter(c))
     {
   while(Character.isLetterOrDigit(c))
   { 
    attr = attr + c;
    getChar();
   }

   return new Token(lookup(attr), attr); //
     }
    else if (Character.isDigit(c)) {
   while(Character.isDigit(c))
   {
    attr = attr + c;
    getChar();
   }
   return new Token(NUMBER, attr);
    } 
    else {
 switch (c) {

  case '<' : getChar();
   if(c=='>')
   {
    getChar();
    return new Token(NE, null);
   } 
   else if (c=='=')
   {
    getChar();
    return new Token(LE, null);
   }
   return new Token(LT, null);


  case '>' : getChar();
   if(c=='<')
   {
    getChar();
    return new Token(NE, null);
   } 
   else if (c=='=')
   {
    getChar();
    return new Token(GE, null);
   }
   return new Token(GT, null);


  case '=' : getChar();
  return new Token(EQ, null);

  case '|' : getChar();
  return new Token(OR, null);

  case '+' : getChar();
  return new Token(PLUS, null);

  case '-' : getChar();
  return new Token(MINUS, null);

  case '*' : getChar();
  return new Token(TIMES, null);

  case '/' : getChar();
  return new Token(DIVIDE, null);

  case '[' : getChar();
  return new Token(LEFTSQ, null);

  case ']' : getChar();
  return new Token(RIGHTSQ, null);

  case '(' : getChar();
  return new Token(LEFTPAREN, null);

  case ')' : getChar();
  return new Token(RIGHTPAREN, null);

  case ',' : getChar();
  return new Token(COMMA, null);

  case EOFCHAR : getChar();
  return new Token(EOF, null);

 }
 } // switch

  //return EOF.Token;
  return Token(tokenCode, attr);  //tokenAttribute

    } // if
   // return Token;
} // getToken


public static void main(String[] args)
{
 BufferedReader source = new BufferedReader(new FileReader(scantest.echo));
}
}

Token class

public class Token implements CompilerConstants {
   private int tokenCode;
   private String attribute;

    public Token(int tc, String att) //constructor  
    {
        tokenCode = tc;
        attribute = att;

    }

    public int getToken()//return tokencode
    {
        return tokenCode;
    }
    //return token attribute    

    public String tokenAttribute()
    {
        return attribute;
    }

    public String toString(){

    String tokenString = tokenCode + "  ";

    switch (tokenCode) {  //// relational expressions for metasymbols
        case AND: return (tokenString + "/n AND");
        case IDENTIFIER: return (tokenString + "/n IDENTIFIER" + attribute); 
        case OR: return (tokenString + "/n OR");
        case NOT: return (tokenString + "/n NOT");  
        case ARRAY: return (tokenString + "/n ARRAY");
        case BEGIN: return (tokenString + "/n BEGIN ");
        case  BOOLEAN: return (tokenString + "/n BOOLEAN ");
        case  DO: return (tokenString + "/n DO ");
        case  ELSE: return (tokenString + "/n ELSE");
        case  END: return (tokenString + "/n END");
        case  FOR: return (tokenString + "/n FOR");
        case  FROM: return (tokenString + "/n FROM");
        case  IF: return (tokenString + "/n IF");
        case  INTEGER: return (tokenString + "/n INTEGER");
        case  PROCEDURE: return (tokenString + "/n PROCEDURE");
        case  PROGRAM: return (tokenString + "/n PROGAM");
        case  READ: return (tokenString + "/n READ");
        case  START: return (tokenString + "/n START");
        case  THEN: return (tokenString + "/n THEN");
        case  TO: return (tokenString + "/n TO");
        case  TRUE: return (tokenString + "/n TRUE");
        case  WHILE: return (tokenString + "/n WHILE");
        case  WRITE: return (tokenString + "/n WRITE");
        case  WRITELN: return (tokenString + "/n WRITELN");
        case  NUMBER: return (tokenString + "/n NUMBER" + attribute);
        case  STRING: return (tokenString + "/n STRING" + attribute);
        case  LT: return (tokenString + "/n LT");
        case  LE: return (tokenString + "/n LE");
        case  GT: return (tokenString + "/n GT");
        case  GE: return (tokenString + "/n GE");
        case  EQ: return (tokenString + "/n EQ");
        case  NE: return (tokenString + "/n NE");
        case  PLUS: return (tokenString + "/n PLUS");
        case  MINUS: return (tokenString + "/n MINUS");
        case  TIMES: return (tokenString + "/n TIMES");
        case  DIVIDE: return (tokenString + "/n DIVIDE");
        case  LEFTSQ: return (tokenString + "/n LEFTSQ");
        case  RIGHTSQ: return (tokenString + "/n RIGHTSQ");
        case  LEFTPAREN: return (tokenString + "/n LEFTPAREN");
        case  COLONEQUAL: return (tokenString + "/n COLONEQUAL");
        case  COMMA: return (tokenString + "/n COMMA");
        case  EOF: return (tokenString + "/n  EOF");


    }
  return tokenString;
   } 
}   

CompilerConstants

public interface CompilerConstants {
   public static final int AND = 1;
   public static final int ARRAY = 2;
   public static final int BEGIN = 3;
   public static final int BOOLEAN = 4;
   public static final int DO = 5;
   public static final int ELSE = 6;
   public static final int END = 7;
   public static final int FALSE = 8;
   public static final int FOR = 9;
   public static final int FROM = 10;
   public static final int IF = 11;
   public static final int INTEGER = 12;
   public static final int NOT = 13;
   public static final int OR = 14;
   public static final int PROCEDURE = 15;
   public static final int PROGRAM = 16;
   public static final int READ = 17;
   public static final int START = 18;
   public static final int THEN = 19;
   public static final int TO = 20;
   public static final int TRUE = 21;
   public static final int WHILE = 22;
   public static final int WRITE = 23;
   public static final int WRITELN = 24;
   public static final int IDENTIFIER = 30;
   public static final int NUMBER = 31;
   public static final int STRING = 32;
   public static final int LT = 33;
   public static final int LE = 34;
   public static final int GT = 35;
   public static final int GE = 36;
   public static final int EQ = 37;
   public static final int NE = 38;
   public static final int PLUS = 39;
   public static final int MINUS = 40;
   public static final int TIMES = 41;
   public static final int DIVIDE = 42;
   public static final int LEFTSQ = 43;
   public static final int RIGHTSQ = 44;
   public static final int LEFTPAREN = 45;
   public static final int RIGHTPAREN = 46;
   public static final int COLONEQUAL = 47;
   public static final int COMMA = 48;
   public static final int EOF = 99;

   public static final char EOFCHAR = (char)(-1);

   public static final String[] RESERVEDWORD = {"","and","array","begin","boolean",
                 "do","else","end","false","for","from","if","integer","not","or",
                 "procedure","program","read","start","then","to","true","while",
                 "write","writeln"};

   public static final boolean DEBUG = true;

} // interface CompilerConstants

