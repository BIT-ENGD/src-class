def background_sync
 @background_task_uid = Model.async_process_model_cache({:name => 'name'})
 @model_sync = ModelSync.new  # Adds a new record in the queue of pending jobs
 @model_sync.process_id = @background_task_uid  # Puts the background process id into the new ModelSync record
 @model_sync.save
end

def process_model_cache(options={})
     [long background task]
     result = Workling::Return::Store.set(options[:uid], 'done')
     result = Workling::Return::Store.get(options[:uid])  #=>  'done'      
end

<%= periodically_call_remote( :url => { :action => :background_complete }, :frequency => 5, :update => 'status_div') %>

def background_complete
 @background_task_uid = ModelSync.find(:last)
 if @background_task_uid
  @background_task_uid.each do |task|
    unless task.process_id == "" || task.process_id.nil?
      @result = Workling::Return::Store.get(task.process_id) #=> nil
      if @result.nil?
        task.destroy
      end
    else
      task.destroy
    end
    unless @result.nil?
      render :text => "<span style='font-size:12px;margin-left:20px;'>"+@result+"</span>"
    else
      @result = "none" if @result.nil?
      render :text => "<span style='font-size:12px;margin-left:20px;'>"+@result+"</span>"
    end
   end
  end
end

Workling::Return::Store.instance = Workling::Return::Store::MemoryReturnStore.new
Workling::Remote.dispatcher = Workling::Remote::Runners::StarlingRunner.new

@result = Workling::Return::Store.get(task.process_id) #=> nil

