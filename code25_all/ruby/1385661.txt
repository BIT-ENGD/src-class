#This works

class Example 
  def initialize(a,b,c)
    @pA = a
    @pB = b
    @pC = c
  end

  def shouldntThisWork()
    myArray = [@pA,@pB,@pC]
  end

  def test()
    arr1 = [@pA, @pB, @pC]
    arr1.each { | elem | print elem, "\n"}
    return 
  end

end



#This works

class Triangle
  #checks first if inputs are of type float and bigger than zero
  def initialize(sideA, sideB, sideC)
    raise "Side A must be a float." if not sideA.kind_of? Float
    raise "Side B must be a float." if not sideB.kind_of? Float
    raise "Side C must be a float." if not sideC.kind_of? Float

    raise "Size error for side A (must be greater than 0)" if sideA <= 0
    raise "Size error for side B (must be greater than 0)" if sideB <= 0
    raise "Size error for side C (must be greater than 0)" if sideC <= 0

    @pA = sideA
    @pB = sideB
    @pC = sideC
  end

  def test()
    arr1 = [@pA, @pB, @pC]
    arr1.each { | elem | print elem, "\n"}
    return 
  end

end



#This works

class Triangle
  #checks first if inputs are of type float and bigger than zero
  def initialize(sideA, sideB, sideC)
    raise "Side A must be a float." if not sideA.kind_of? Float
    raise "Side B must be a float." if not sideB.kind_of? Float
    raise "Side C must be a float." if not sideC.kind_of? Float

    raise "Size error for side A (must be greater than 0)" if sideA <= 0
    raise "Size error for side B (must be greater than 0)" if sideB <= 0
    raise "Size error for side C (must be greater than 0)" if sideC <= 0

    @pA = sideA
    @pB = sideB
    @pC = sideC
  end

  def isEquilateral()
    return (@pA == @pB and @pB == @pC) 
  end

  def isIsosceles()
    numEqual = 0
    if @pA == @pB
      numEqual += 1
    end
    if @pA == @pC
      numEqual += 1
    end
    if @pC == @pB
      numEqual += 1
    end

    return (numEqual == 2)
  end

  def test()
    arr1 = [@pA, @pB, @pC]
    arr1.each { | elem | print elem, "\n"}
    return 
  end

end




# This Works

class Triangle
  #checks first if inputs are of type float and bigger than zero
  def initialize(sideA, sideB, sideC)
    raise "Side A must be a float." if not sideA.kind_of? Float
    raise "Side B must be a float." if not sideB.kind_of? Float
    raise "Side C must be a float." if not sideC.kind_of? Float

    raise "Size error for side A (must be greater than 0)" if sideA <= 0
    raise "Size error for side B (must be greater than 0)" if sideB <= 0
    raise "Size error for side C (must be greater than 0)" if sideC <= 0

    @pA = sideA
    @pB = sideB
    @pC = sideC
  end

  def isEquilateral()
    return (@pA == @pB and @pB == @pC) 
  end

  def isIsosceles()
    numEqual = 0
    if @pA == @pB
      numEqual += 1
    end
    if @pA == @pC
      numEqual += 1
    end
    if @pC == @pB
      numEqual += 1
    end

    return (numEqual == 2)
  end

  def test()
    arr1 = [@pA, @pB, @pC]
    arr1.each { | elem | print elem, "\n"}
    return 
  end

end

#This works
class Triangle
  #checks first if inputs are of type float and bigger than zero
  def initialize(sideA, sideB, sideC)
    raise "Side A must be a float." if not sideA.kind_of? Float
    raise "Side B must be a float." if not sideB.kind_of? Float
    raise "Side C must be a float." if not sideC.kind_of? Float

    raise "Size error for side A (must be greater than 0)" if sideA <= 0
    raise "Size error for side B (must be greater than 0)" if sideB <= 0
    raise "Size error for side C (must be greater than 0)" if sideC <= 0

    @pA = sideA
    @pB = sideB
    @pC = sideC
  end

  def A()
    return @pA
  end

  def B()
    return @pB
  end

  def C()
    return @pC
  end

  def test()
    arr1 = [@pA, @pB, @pC]
    arr1.each { | elem | print elem, "\n"}
    return 
  end

  def isEquilateral()
    return (@pA == @pB and @pB == @pC) 
  end

end

# this doesnt work
class Triangle
  #checks first if inputs are of type float and bigger than zero
  def initialize(sideA, sideB, sideC)
    raise "Side A must be a float." if not sideA.kind_of? Float
    raise "Side B must be a float." if not sideB.kind_of? Float
    raise "Side C must be a float." if not sideC.kind_of? Float

    raise "Size error for side A (must be greater than 0)" if sideA <= 0
    raise "Size error for side B (must be greater than 0)" if sideB <= 0
    raise "Size error for side C (must be greater than 0)" if sideC <= 0

    @pA = sideA
    @pB = sideB
    @pC = sideC
  end

  def A()
    return @pA
  end

  def B()
    return @pB
  end

  def C()
    return @pC
  end

  def test()
    arr1 = [@pA, @pB, @pC]
    arr1.each { | elem | print elem, "\n"}
    return 
  end

  def isEquilateral()
    return (@pA == @pB and @pB == @pC) 
  end

  def isIsosceles()
    numEqual = 0
    if @pA == @pB
      numEqual += 1
    end
    if @pA == @pC
      numEqual += 1
    end
    if @pC == @pB
      numEqual += 1
    end

    return (numEqual == 2)
  end

end




# But then this does work
class Triangle
  #checks first if inputs are of type float and bigger than zero
  def initialize(sideA, sideB, sideC)
    raise "Side A must be a float." if not sideA.kind_of? Float
    raise "Side B must be a float." if not sideB.kind_of? Float
    raise "Side C must be a float." if not sideC.kind_of? Float

    raise "Size error for side A (must be greater than 0)" if sideA <= 0
    raise "Size error for side B (must be greater than 0)" if sideB <= 0
    raise "Size error for side C (must be greater than 0)" if sideC <= 0

    @pA = sideA
    @pB = sideB
    @pC = sideC
  end

  def A()
    return @pA
  end

  def B()
    return @pB
  end

  def C()
    return @pC
  end

  def isEquilateral()
    return (@pA == @pB and @pB == @pC) 
  end

  def isIsosceles()
    numEqual = 0
    if @pA == @pB
      numEqual += 1
    end
    if @pA == @pC
      numEqual += 1
    end
    if @pC == @pB
      numEqual += 1
    end

    return (numEqual == 2)
  end

end



# This doesnt

class Triangle
  #checks first if inputs are of type float and bigger than zero
  def initialize(sideA, sideB, sideC)
    raise "Side A must be a float." if not sideA.kind_of? Float
    raise "Side B must be a float." if not sideB.kind_of? Float
    raise "Side C must be a float." if not sideC.kind_of? Float

    raise "Size error for side A (must be greater than 0)" if sideA <= 0
    raise "Size error for side B (must be greater than 0)" if sideB <= 0
    raise "Size error for side C (must be greater than 0)" if sideC <= 0

    @pA = sideA
    @pB = sideB
    @pC = sideC
  end

  def A()
    return @pA
  end

  def B()
    return @pB
  end

  def C()
    return @pC
  end

  def isEquilateral()
    return (@pA == @pB and @pB == @pC) 
  end

  def isIsosceles()
    numEqual = 0
    if @pA == @pB
      numEqual += 1
    end
    if @pA == @pC
      numEqual += 1
    end
    if @pC == @pB
      numEqual += 1
    end

    return (numEqual == 2)
  end

  def test()
    arr1 = [@pA, @pB, @pC]
    arr1.each { | elem | print elem, "\n"}
    return 
  end

end



# This works again
class Triangle
  #checks first if inputs are of type float and bigger than zero
  def initialize(sideA, sideB, sideC)

    @pA = sideA
    @pB = sideB
    @pC = sideC
  end

  def A()
    return @pA
  end

  def B()
    return @pB
  end

  def C()
    return @pC
  end

  def isEquilateral()
    return (@pA == @pB and @pB == @pC) 
  end

  def isIsosceles()
    numEqual = 0
    if @pA == @pB
      numEqual += 1
    end
    if @pA == @pC
      numEqual += 1
    end
    if @pC == @pB
      numEqual += 1
    end

    return (numEqual == 2)
  end

  def test()
    arr1 = [@pA, @pB, @pC]
    arr1.each { | elem | print elem, "\n"}
    return 
  end

end

#test
class Triangle
  #checks first if inputs are of type float and bigger than zero
  def initialize(sideA, sideB, sideC)

    @pA = sideA
    @pB = sideB
    @pC = sideC
  end

  def A()
    return @pA
  end

  def B()
    return @pB
  end

  def C()
    return @pC
  end

  def isEquilateral()
    return (@pA == @pB and @pB == @pC) 
  end

  def isIsosceles()
    numEqual = 0
    if @pA == @pB
      numEqual += 1
    end
    if @pA == @pC
      numEqual += 1
    end
    if @pC == @pB
      numEqual += 1
    end

    return (numEqual == 2)
  end

  def test()
    arr1 = [@pA, @pB, @pC]
    arr1.each { | elem | print elem, "\n"}
    return 
  end

  def dunno()
    return "Dunno"
  end

  def neee()
    return "Een ", @pA
  end
end

