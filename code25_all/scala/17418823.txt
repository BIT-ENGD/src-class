class A
object Macros {
  def genA(str: String): A[_] = macro _genA
  def _genA(c: Context)(str: c.Expr[String]): c.Expr[A[_]] = {
    import c.universe._
    c.Expr[A[_]](
      reify { new A[Int] }.tree)
}
// somewhere in code
genA("int") // --> new A[Int]

class A
object Macros {
  def genA(str: String): A[_] = macro _genA
  def _genA(c: Context)(str: c.Expr[String]): c.Expr[A[_]] = {
    import c.universe._
    c.Expr[A[_]](
      Match(
        str.tree.duplicate,
        List(
          CaseDef(Literal(Constant("int")), EmptyTree,
            reify { new A[Int] }.tree))))
  }
}
// again, somewhere far, far away in the code
genA("int") // it expands to ("int" match { case "int" => new A[Int] })

found   : rsf.macros.A[Int]
required: rsf.macros.A[_$1] where type _$1
       genA("int")
           ^

val a: A[_] = "int" match { case "int" => new A[Int] }

class A
object Macros {
  def genA(str: String): A[_] = macro _genA
  def _genA(c: Context)(str: c.Expr[String]): c.Expr[A[_]] = {
    import c.universe._
    val mtch = c.Expr[A[_]](
      Match(
        str.tree.duplicate,
        List(
          CaseDef(Literal(Constant("int")), EmptyTree,
            reify { new A[Int] }.tree))))
    reify {
      mtch.splice.asInstanceOf[A[_]]
    }
  }
}

