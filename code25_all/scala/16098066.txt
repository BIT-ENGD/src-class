abstract class Box
class StringBox(val sValue : String) extends Box

object Box{
    def apply(s: String)  = new StringBox(s)
    def apply(b: Boolean) = new BooleanBox(b)
    def apply(d: Double)  = new DoubleBox(d)
}

    val sb = Box("StringBox)

def unapply(b: Box) = b match {
  case sb: StringBox => Some(sb.sValue)
  case bb: BooleanBox => Some(bb.bValue)
  case db: DoubleBox => Some(db.dValue)
  case _ => None

 abstract class Box[T] {def value : T}
 class StringBox(val sValue : String)  extends Box[String] { 
   override def value : String = sValue
 }

def unapply[T](b: Box[T]) = b match {
  case sb: Box[String]  => Some(sb.value)
  case bb: Box[Boolean] => Some(bb.value)
  case db: Box[Double]  => Some(db.value)
  case _ => None

def unapply[T](b: Box[_])(implicit target: Manifest[T]): Option[T] = {

   if(b.value ==  target) Some(b.value.asInstanceOf[T])
   else None 
}

