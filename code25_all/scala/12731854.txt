trait Meta[T] {
  def ~=(e: T): Boolean
}

(m,i) match {
case (x:Meta[T], y: T) if x ~= y => println ("right")
case _ => println ("wrong")}

T
x: Meta[T]
y
y
T
ClassCastException
x ~= y
trait Meta[T] {
  type t = T
  def ~=(e: T): Boolean
}

sealed abstract class A 
case class Ide(s: String) extends A
case class MIde(s: String) extends A with Meta[A] {
  def ~=(e: A) = e match {
    case e: Ide => true
    case e: MIde => false
  }
}
sealed abstract class B 
case class Foo(s: String) extends B

object Test {

  def m = MIde("x")
  def i = Ide("i")
  def f = Foo("f")

  def main[T](args: Array[String]) {
    (m, i) match {
      case (x: Meta[T], y: T) if x ~= y => println("right")
      case _ => println("wrong")
    }
    // -> right
    (m, f) match {
      case (x: Meta[T], y: T) if x ~= y => println("right")
      case _ => println("wrong")
    }
    // -> Exception in thread "main" java.lang.ClassCastException: 
    // Examples.Foo cannot be cast to Examples.A

  }
}

