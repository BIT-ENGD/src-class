  trait A {
    type O
    def f(a: Int, os: Seq[O]): Int
  }

  trait B {
    type O
    def g(a: Int, o: O): Int = { h1(o) + h2(a) }
    def h1(o: O): Int
    def h2(a: Int): Int = {a/2}
  }

  trait C extends A with B {
    def f(a: Int, os: Seq[O]): Int = {
      os.map{ o => g(a, o) }.sum
    }
  } 

  class D extends C {
    type O = Int
    def h1(o: O): Int = {5 * o}
  }

C
O
A.O == B.O
B.g
A.f
type O
  val d = new D
  println(d.f(1, Seq(1,2,3)))

A.O
B.O
  case class Z()
  case class Z1() extends Z
  case class Z2() extends Z1

  trait A {
    type O <: Z
  }

  trait B {
    type O >: Z2
  }


class D extends C {
    type O = Z1

  trait A {
    type O <: Z
  }

  trait B {
    type O <: Z1
  }
  class D extends C {
    type O = Z2

