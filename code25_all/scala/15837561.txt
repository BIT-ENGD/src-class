Map[String, List[String]]
def myFunction():Map[String, List[String]] = {

  val userMap = Map[String, String](("123456", "ASDBYYBAYGS456789"),
                                    ("54321", "HGFDSA5432"))

  //the result map to return when all data is collected and added
  val resultMap:Future[Map[String, List[String]]]

  //when this map is finished (filled) this map is set to resultMap
  val progressMap = Map[String, List[String]]()

  for(user <- userMap){

     //facebook graph API call to get posts.
     val responsePost = WS.url("async get to facebook url").get()

     responsePosts.flatMap { response => 
        val jsonBody = response.json
        val dataList = List[String]()

        for(i <-0 until 5){

           //parse the json-data to strings
           val messages = (jsonBody.\("statuses").\("data")(i).\("message"))
           val likesArray = (jsonBody.\("statuses").\("data")(i).\\("data")).flatMap(_.as[List[JsObject]])
           val likes = likesArray.length

           //Put post with likes in temporary list
           dataList ::= Â ("Post: " + message.toString + " Likes: " + likes.toString)
        }  

           //facebook graph API call to get friends.
           val responseFriends = WS.url("async get to facebook url").get()

           responseFriends.map { response =>
               val jsonBody = response.json
               val friendCount = jsonBody.\("data")(0).\("friend_count").toString

               //add "Friends: xxx" to the dataList and add the new row to resultMap containig a list with post and friends.
               dataList ::= ("Friends: " + friendCount)
               progressMap += user._1 -> dataList

               //check if all users has been updated
               if(progressMap.size == userMap.size){
                  resultMap = progressMap
               }
            }
       }
    }

    //return the resultMap.
    return resultMap
 }
}

"get to facebook url"
