abstract class Foo( val theType : type )
object Foo{
   case object Foo1 extends Foo(String)
   case object Foo2 extends Foo(Long)     
}

theFoo match{
   case String => "Is a string"
   case Long => "Is a long"
}

theFoo.asInstanceOf[Foo1.theType]

Array(Foo1,Foo1,Foo2,Foo3,Foo1)
Array(Foo3, Foo4, Foo5)
trait Command{

  //This is implemented in every command
  val schema : List[Tuple[String,Int,Int,Type]]  //Position,Size,DataType

  def parse() : List[Tuple[String,Int,Int,Type,Any]] = schema.map(//match using the type)
}

class Command1 extends Command {
  override val schema = List[Tuple("theName",0,10,String),Tuple("myType",10,12,MyType),Tuple("theId",13,20,Long)]
  val theActualName = parse().find(_._1 == "theName")._5.asInstanceOf[String] //I would like to avoid this cast

}

