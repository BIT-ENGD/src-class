package language

object chainedImplicits {
  implicit def chainImplicits[A, B, C](a: A)(implicit conv1: A => B, conv2: B => C): C = conv2(conv1(a))
}

package language

package chainedImplicits {

  final class Chained[A, B] private[chainedImplicits] (val f: A => B)

  trait Low { this: `package`.type =>
    implicit def startChaining(implicit conv: A => B): Chained[A, B] = new Chained[A, B](conv)
    implicit def chainImplicits[A, B, C](implicit conv1: Chained[A, B], conv2: B => C): Chained[B, C] = new Chained(conv1.f andThen conv2)
  }

}

package object chainedImplicits extends Low {
  implicit def endChain[A, B](a: A)(implicit conv: Chained[A, B]): B = conv.f(a)
}

