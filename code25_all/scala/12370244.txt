sealed abstract class Base(val myparam:String)

case class Foo(override val myparam:String) extends Base(myparam)
case class Bar(override val myparam:String) extends Base(myparam)

def getIt( a:Base ) = a.copy(myparam="changed")

abstract class Base{ def copy(myparam:String):Base }
case class Foo(myparam:String) extends Base
class Foo needs to be abstract, since method copy in class Base of type (myparam: String)Base is not defined
Base
def getIt(f:Base)={ 
  (f.getClass.getConstructors.head).newInstance("yeah").asInstanceOf[Base]
}

