abstract class Parent { type T }
class Child extends Parent { type T = Int }

def f[T <: Parent](a: Array[T]): Array[T#T] = null
def f[T](a: T): Array[T] = null

val s = f(Array(new Child))                   // OK; calls the first f
val t: Array[Child#T] = f(Array(new Child))   // type mismatch; tries to apply the second f

