trait Impl [S]
trait Event[S, A]
trait Key  [A]

def declare[A](fun: Impl[_] => Event[_, A]): Key[A] = ???

fun
Impl[S] => Event[S, A]
S
trait Impl[S] { def ev1: Event[S, Int]; def ev2: Event[T, Int] }

declare(_.ev1)

declare(_.ev2)  // this currently compiles

trait Sys  [S <: Sys[S]]
trait Event[S <: Sys[S], A, Repr]

trait Decl {
  type Impl[S <: Sys[S]]

  protected def declare[U](fun: Impl[_] => Event[_, U, Impl[_]]): Unit = ???
}

object Test extends Decl {
  type Impl[S <: Sys[S]] = Test[S]

  case class Renamed(name: String)

  declare[Renamed](_.renamed)
}

trait Test[S <: Sys[ S]] {
  def renamed: Event[S, Test.Renamed, Test[S]]
}

error: type mismatch;
 found   : Event[_$1,Test.Renamed,Test[_$1]] where type _$1
 required: Event[_, Test.Renamed, Test.Impl[_]]
Note: _$1 <: Any, but trait Event is invariant in type S.
You may wish to define S as +S instead. (SLS 4.5)
Note: Test[_$1] <: Test[_], but trait Event is invariant in type Repr.
You may wish to define Repr as +Repr instead. (SLS 4.5)
          declare[ Renamed ]( _.renamed )
                                ^

Impl[_] => Event[_, U, _]
