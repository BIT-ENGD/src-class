object Addresses extends Table[Address]("address"){
  //some mapping columns
  .... 

  //a method I want to made generic 
  def findAll(limit: Option[Int], offset: Option[Int]): Seq[Address] = DBTest.db.withSession { implicit db: Session =>
    (limit, offset) match {
      case (Some(l), Some(o)) => Addresses.map { a => a }.drop(o).take(l).list
      case (None, None) => Addresses.map { a => a }.drop(ConfigurationsLoader.DefaultOffset).take(ConfigurationsLoader.DefaultLimit).list
      case (Some(l), None) => Addresses.map { a => a }.take(l).list
      case (None, Some(o)) => Addresses.map { a => a }.drop(o).list
    }
  }

Address
findAll
trait DbGenericOperations[T, U <: Table[T]]{
  val entities: U
  /**
   * Based on REST conventions, for listing it's good to use limit and offset, like: /entities?limit=25&offset=50.
   */
  def findAll(limit: Option[Int], offset: Option[Int]): Seq[T] = DBTest.db.withSession { implicit db: Session =>
    (limit, offset) match {
      case (Some(l), Some(o)) => entities.map { a => a }.drop(o).take(l).list
      case (None, None) => entities.map { a => a }.drop(ConfigurationsLoader.DefaultOffset).take(ConfigurationsLoader.DefaultLimit).list
      case (Some(l), None) => entities.map { a => a }.take(l).list
      case (None, Some(o)) => entities.map { a => a }.drop(o).list
    }
  }
}

entities
object Addresses extends Table[Address]("address") with DbGenericOperations[Address, Addresses]{
Addresses
trait DbGenericOperations[T]{
      /**
       * Based on REST conventions, for listing it's good to use limit and offset, like: /entities?limit=25&offset=50.
       */
      def findAll(limit: Option[Int], offset: Option[Int], entities: Table[T]): Seq[T] = DBTest.db.withSession { implicit db: Session =>
        (limit, offset) match {
          case (Some(l), Some(o)) => entities.map { a => a }.drop(o).take(l).list
          case (None, None) => entities.map { a => a }.drop(ConfigurationsLoader.DefaultOffset).take(ConfigurationsLoader.DefaultLimit).list
          case (Some(l), None) => entities.map { a => a }.take(l).list
          case (None, Some(o)) => entities.map { a => a }.drop(o).list
        }
      }
    }

object Addresses extends Table[Address]("address") with DbGenericOperations[Address]
val results = Addresses.findAll(limit, offset, Addresses)
