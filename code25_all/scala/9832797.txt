T
A
B
C
Seq[T]
A
B
C
Seq[_ <: T]
TC[_]
A
B
C
TC[A]
Seq[_ : TC]
V
A => V
B => V
C => V
Seq[V]
A
B
C
V1
V2
Seq[V1 with V2]
// a sort of product or intersection, basically identical to Tuple2
final class &[A, B](val a: A, val b: B)

// implicit conversions from the product to its member types
implicit def productToA[A, B](ab: A & B): A = ab.a
implicit def productToB[A, B](ab: A & B): B = ab.b

// implicit conversion from A to (V1 & V2)
implicit def viewsToProduct[A, V1, V2](a: A)(implicit v1: A => V1, v2: A => V2) =
  new &(v1(a), v2(a))

Seq[V1 & V2]
trait Foo { def foo: String }
trait Bar { def bar: String }

implicit def stringFoo(a: String) = new Foo { def foo = a + " sf" }
implicit def stringBar(a: String) = new Bar { def bar = a + " sb" }
implicit def intFoo(a: Int) = new Foo { def foo = a.toString + " if" }
implicit def intBar(a: Int) = new Bar { def bar = a.toString + " ib" }

val s1 = Seq[Foo & Bar]("hoho", 1)
val s2 = s1 flatMap (ab => Seq(ab.foo, ab.bar))
// equal to Seq("hoho sf", "hoho sb", "1 if", "1 ib")

String
Int
Foo & Bar
Foo & Bar
Foo
Bar
foobar.foo
foobar.bar
Seq[Foo & Bar & Baz]
HList
Seq[Foo & Foo]
Seq[All[A :: B :: C :: HNil]]
HList
Seq[A & B & C]
abc[A].a
