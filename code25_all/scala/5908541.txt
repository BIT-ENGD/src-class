String
case class A(s:String, f: List[String] => List[String])

val f: List[String] => List[String] = { ... stuff ... }
"foo"{f} // == A("foo", f)

List[String] => List[String]
implicit def c(s:String) = new {
    def apply(f: List[String] => List[String]) = A(s, f)
}

String
StringOps
scala> "foo"{f}                                                
<console>:19: error: type mismatch;
 found   : java.lang.String
 required: ?{val apply: ?}
Note that implicit conversions are not applicable because they are ambiguous:
 both method c in object $iw of type (s: String)java.lang.Object{def apply(f: (List[String]) => List[String]): A}
 and method augmentString in object Predef of type (x: String)scala.collection.immutable.StringOps
 are possible conversion functions from java.lang.String to ?{val apply: ?}
       "foo"{f}
   ^

required: ?{val apply: ?}
List[String] => List[String]
case class param(val v: String) {
    def apply(f: Emit.Selector) = Variable(v, f)
}

val $foo = param("foo")
foo{selector} // works fine

scala> class A()
defined class A

scala> class B()
defined class B

scala> implicit def one(s:String) = new {
     |   def a(a:A) = s + " A"
     | }
one: (s: String)java.lang.Object{def a(a: A): java.lang.String}

scala> implicit def another(s:String) = new {
     |   def a(b:B) = s + " B"
     | }
another: (s: String)java.lang.Object{def a(b: B): java.lang.String}

scala> "hello" a new A
res1: java.lang.String = hello A

scala> "hello" a new B
res2: java.lang.String = hello B

