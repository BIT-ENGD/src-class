State
List.zipWithIndex
def numberSA[A](list : List[A]) : State[Int, List[(A, Int)]] = list match {
  case x :: xs => (init[Int] <* modify((_:Int) + 1)) map { s : Int => (x -> s) :: (numberSA(xs) ! s) }
  case Nil     => state( (i : Int) => i -> nil[(A, Int)] )
}

scala> res4
res5: List[java.lang.String] = List(one, two, three)

scala> numberSA(res4) ! 1
res6: List[(String, Int)] = List((one,1), (two,1), (three,1))

case x :: xs => (init[Int]) map { s : Int => (x -> s) :: (numberSA(xs) ! (s + 1)) }

def numberSA[A](list : List[A]) : State[Int, List[(A, Int)]] = {
  def single(a : A) : State[Int, List[(A, Int)]] = (init[Int] <* modify((_ : Int) + 1)) map { s : Int => List(a -> s) }
  list match {
    case Nil     => state( (_ : Int) -> nil[(A, Int)] )
    case x :: xs => (single(x) <**> numberSA(xs)) { _ ::: _ }
  }
}

List
def index[M[_], A](ma : M[A])
      (implicit pure : Pure[M], empty : Empty[M], semigroup : Semigroup[M[(A, Int)]], foldable : Foldable[M]) 
      : State[Int, M[(A, Int)]] = {
  def single(a : A) : State[Int, M[(A, Int)]] = (init[Int] <* modify((_ : Int) + 1)) map { s : Int => pure.pure(a -> s) }
  foldable.foldLeft(ma, state( (_ : Int) -> empty.empty[(A, Int)] ), { (s : State[Int, M[(A, Int)]],a : A) => (s <**> single(a)) { (x,y) => semigroup.append(x,y)}  } )
}

def index[M[_] : Pure : Empty : Plus : Foldable, A](ma : M[A]) 
     : State[Int, M[(A, Int)]] = {
  import Predef.{implicitly => ??}
  def single(a : A) : State[Int, M[(A, Int)]] = (init[Int] <* modify((_ : Int) + 1)) map { s : Int => ??[Pure[M]].pure(a -> s) }
  ??[Foldable[M]].foldLeft(ma, state( (_ : Int) -> ??[Empty[M]].empty[(A, Int)] ), { (s : State[Int, M[(A, Int)]],a : A) => (s <**> single(a)) { (x,y) => ??[Plus[M]].plus(x,y)}  } )
}

