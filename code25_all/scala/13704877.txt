case class MyException(message: String) extends Exception(message)

val exceptionClass = MyException.getClass.getName
val exceptionName = if (exceptionClass.last == '$') exceptionClass.dropRight(1) else exceptionClass
val symbol = rootMirror.getModuleByName(newTermName(exceptionName))

import CODE._
THROW(symbol, Literal(Constant("My message")))

Throw(symbol.tpe, Literal(Constant("My Message")))
Throw(NEW(symbol, Literal(Constant("My message"))))
Throw(New(symbol.tpe, Literal(Constant("My message"))))

== Enclosing template or block ==

Apply( // val <error>: <error> in class <error>
  new MyException.type."<init>" // val <error>: <error> in class <error>, tree.tpe=<error>
  Nil
)

== Expanded type of tree ==

TypeRef(TypeSymbol(class MyException extends ))

uncaught exception during compilation: scala.reflect.internal.Types$TypeError
error: scala.reflect.internal.Types$TypeError: MyException.type does not have a constructor
...

