map()
newBuilder
CanBuildFrom
filter
partition
drop
take
span
newBuilder
List[Int]
List[Int]
BitSet
RNA
BitSet
RNA
CanBuildFrom
BitSet
String
RNA
Base
map
flatMap
collect
scanLeft
++
scala> import collection.immutable.TreeSet
import collection.immutable.TreeSet

scala> val treeset = TreeSet(1,2,3,4,5) // static type == dynamic type
treeset: scala.collection.immutable.TreeSet[Int] = TreeSet(1, 2, 3, 4, 5)

scala> val set: Set[Int] = TreeSet(1,2,3,4,5) // static type != dynamic type
set: Set[Int] = TreeSet(1, 2, 3, 4, 5)

scala> treeset.filter(_ % 2 == 0)
res0: scala.collection.immutable.TreeSet[Int] = TreeSet(2, 4) // fine, a TreeSet again

scala> set.filter(_ % 2 == 0)    
res1: scala.collection.immutable.Set[Int] = TreeSet(2, 4) // fine

scala> treeset.map(_ + 1)        
res2: scala.collection.immutable.SortedSet[Int] = TreeSet(2, 3, 4, 5, 6) // still fine

scala> set.map(_ + 1)    
res3: scala.collection.immutable.Set[Int] = Set(4, 5, 6, 2, 3) // uh?!

CanBuildFrom
def apply(from: Coll)
BitSet
Int
TreeSet
for (i <- set) {
  val x = i + 1
  println(x)
}

TreeSet
for (i <- set; x = i + 1)
  println(x)

implicit sameTypeEvidence: A =:= B
null
implicit canReuseCalleeBuilderEvidence: B <:< A = null
CanBuildFrom
