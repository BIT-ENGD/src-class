import scala.collection.immutable.List

object MergeSort {
    def sort[T,E]( comparator: (E,E) => Int ) (l: List[T]): List[T] = {
        def merge[T](first: List[T], second: List[T]): List[T] = (first, second) match {
                case (_, List()) => first
                case (List(), _) => second
                case (f::restFirst, s::restSecond) if comparator(f.asInstanceOf[E],s.asInstanceOf[E]) < 0 => f :: merge(restFirst, second)
                case (f::restFirst, s::restSecond) => s :: merge(first, restSecond)
            }

        l match {
            case List() => return l
            case List(x) => return l
            case _ => {
                val (first, second) = l.splitAt( l.length / 2 )
                merge( sort(comparator)(first), sort(comparator)(second) )
            }
        }
    }
}

import scala.collection.immutable.List

object MergeSort {
    def sort[T]( comparator: (T,T) => Int ) (l: List[T]): List[T] = {
        def merge[T](first: List[T], second: List[T]): List[T] = (first, second) match {
                case (_, List()) => first
                case (List(), _) => second
                case (f::restFirst, s::restSecond) if comparator(f,s) < 0 => f :: merge(restFirst, second)
                case (f::restFirst, s::restSecond) => s :: merge(first, restSecond)
            }

        l match {
            case List() => return l
            case List(x) => return l
            case _ => {
                val (first, second) = l.splitAt( l.length / 2 )
                merge( sort(comparator)(first), sort(comparator)(second) )
            }
        }
    }
}

MergeSort.scala:10: type mismatch;
[error]  found   : f.type (with underlying type T)
[error]  required: T
[error]  case (f::restFirst, s::restSecond) if comparator(f,s) < 0 => f :: merge(restFirst, second)

