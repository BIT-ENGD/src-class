class Element {
}
trait Container[T <: Element] {
    type ElemType = T
    val value : T
}

trait Id {
}

class ElementWithId extends Element with Id

trait Algo[T <: Container[_]] {
    def algo(t : T) : Option[T#ElemType]
}

object Algo {
    implicit def impl[C <: Container[_ <: Id]] = new Algo[C] {
        def algo(cont : C) : Option[C#ElemType] = {
            Some(cont.value)
        }
    }

    implicitly[Algo[Container[ElementWithId]]].algo(new Container[ElementWithId] {
                                                  override val value = new ElementWithId
                                              })
}

[error] test.scala:126: type mismatch;
[error]  found   : cont.value.type (with underlying type _$2)
[error]  required: _$2
[error]  Note: implicit method impl is not applicable here because it comes after the application point and it lacks an explicit result type
[error]                 Some(cont.value)
[error]                           ^
[error] test.scala:130: could not find implicit value for parameter e: Algo[Container[ElementWithId]]
[error]         implicitly[Algo[Container[ElementWithId]]].algo(new Container[ElementWithId] {
[error]                   ^
[warn] test.scala:124: inferred existential type $anon forSome { type $anon <: Algo[C]{def algo(cont: C): Option[_$2]}; type _$2 <: Id }, which cannot be expressed by wildcards,  should be enabled
[warn] by making the implicit value language.existentials visible.
[warn] This can be achieved by adding the import clause 'import scala.language.existentials'
[warn] or by setting the compiler option -language:existentials.
[warn] See the Scala docs for value scala.language.existentials for a discussion
[warn] why the feature should be explicitly enabled.
[warn]         implicit def impl[C <: Container[_ <: Id]] = new Algo[C] {
[warn]                                                      ^
[warn] one warning found
[error] two errors found
[error] (Ducktank/compile:compile) Compilation failed
[error] Total time: 1 s, completed 25.04.2013 23:22:17

