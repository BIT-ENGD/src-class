def eat(f : Food)
/// Abstract Interface Types

trait Vertex 
{ 
   type V <: Vertex
   def position : Float 
   def + (v : V) : V
}

/// Derived class of vertex shader will use a specific derived class of
/// vertex that it can shade
trait VertexShader
{
   type V <: Vertex
   def shade( v : V ) : Float
}

/// Concrete Implementation Example

class MyVertex(p : Float, c : Float) extends Vertex
{
   type V = MyVertex   
   val position : Float = p       // inherited 
   val color    : Float = p*2.0f  // custom  

   def + (v : MyVertex) : MyVertex = new MyVertex(position + v.position, color + v.color)
}

class MyVertexShader extends VertexShader
{
   type V = MyVertex
   def shade( v : MyVertex ) : Float = v.position + v.color
}


object Bootstrap
{
   def main ( args : Array[String] )
   {
      /// Vertex and vertex shader, pretend concrete class type is unknown
      /// as these objects will be pulled out of some other abstract object
      /// interface at runtime
      val mVShader : VertexShader = new MyVertexShader
      val mV0 : Vertex = new MyVertex(1.0f, 9.0f)

     /////////////////////////////////////////

      val shadeValue = mVShader.shade(mV0 + mV0)
   }
}

