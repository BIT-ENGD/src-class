class Attribute[C[_], E]

class Id[E]

trait Entity {
  val att1: List[Int]
  val att2: Int
}

object Entity {
  val att1reif = new Attribute[List, Int]
  val att2reif = new Attribute[Id, Int]
}

def Let[T <: Entity, C[_], E](en: T, att: Attribute[C, E], ce: C[E]): T =
  /* Updates the whole attribute */

def Let[T <: Entity, C[_], E](en: Entity, att: Attribute[C, E], e: E, mode: Boolean): T = 
  /* Adds or removes (mode) an item */

val ent = new Entity { val att1 = List(); val att2 = 3 }
Let(ent, Entity.att1reif, List(1, 2, 3)) // att1 = List(1, 2, 3)
Let(ent, Entity.att1reif, 4, true)       // att1 = List(1, 2, 3, 4)
Let(ent, Entity.att1reif, 1, false)      // att1 = List(2, 3, 4)

// Same code as DSL
ent.att1 := List(1, 2, 3)
ent.att1 :+ 4
ent.att1 :- 1

trait AttributeHelper {
  type T <: Entity
  type C[_]
  type E
  val ent: T
  val att: Attribute[C, E]
  def :=(ce: C[E]): T = Let(ent, att, ce)
  def :+(e: E): T = Let(ent, att, e, true)
  def :-(e: E): T = Let(ent, att, e, false)
}

def toAttributeHelperImpl[V: c.AbsTypeTag](c: Context)(expr: c.Expr[V]): c.Expr[AttributeHelper] = 
  /* A looong macro (currently broken), since I can't split V into C[_] and E,
   * which are needed to generate the expression that instantiates an *AttributeHelper*.
   * The macro is responsible of finding the attribute reification.
   */

implicit def toAttributeHelper[V](expr: V): AttributeHelper = macro toAttributeHelperImpl[V]

