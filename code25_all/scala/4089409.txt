abstract class MyObjects
case class Apple(id: Int, name: String, color: String) extends MyObjects
case class Orange(id: Long, name: String, state: String) extends MyObjects

abstract class MyResponse
case class Fruits[T <: MyObjects](aisle: Int, bin: Int, hasWhat: Option[List[T]])

myJson.extract[Fruits[Apple]]

net.liftweb.json.MappingException: do not know how to get type parameter from T
    at net.liftweb.json.Meta$.fail(Meta.scala:128)
    at net.liftweb.json.Meta$Reflection$.term$1(Meta.scala:206)
    at net.liftweb.json.Meta$Reflection$.typeParameters(Meta.scala:220)
    at net.liftweb.json.Meta$.mkContainer$1(Meta.scala:91)
    at net.liftweb.json.Meta$.fieldMapping$1(Meta.scala:101)
    at net.liftweb.json.Meta$.mkContainer$1(Meta.scala:90)
    at net.liftweb.json.Meta$.fieldMapping$1(Meta.scala:107)
    at net.liftweb.json.Meta$.toArg$1(Meta.scala:117)
    at net.liftweb.json.Meta$$anonfun$constructors$1$1$$anonfun$apply$1.apply(Meta.scala:83)
    at net.liftweb.json.Meta$$anonfun$constructors$1$1$$anonfun$apply$1.apply(Meta.scala:82)
    at scala.collection.TraversableLike$$anonfun$map$1.apply(TraversableLike.scala:...

val apples = """{ "aisle" : 1, "bin" : 1,
            "hasWhat" : [{ "id" : 4, "name" : "Granny", "color" : "green"}, 
                         { "id" : 4, "name" : "Fuji", "color" : "red"}] }"""

val oranges = """ { "aisle" : 3, "bin" : 2, 
             "hasWhat" : [{ "id" : 2, "name" : "Navel", "state" : "FL" }, 
                         { "id" : 2, "name" : "Clementine", "state" : "Spain" }]}"""

scala> val aJson = parse(apples)
aJson: net.liftweb.json.JsonAST.JValue = JObject(List(JField(aisle,JInt(1)), JField(bin,JInt(1)), JField(hasWhat,JArray(List(JObject(List(JField(id,JInt(4)), JField(name,JString(Granny)), JField(color,JString(green)))), JObject(List(JField(id,JInt(4)), JField(name,JString(Fuji)), JField(color,JString(red)))))))))

scala> val oJson = parse(oranges)
oJson: net.liftweb.json.JsonAST.JValue = JObject(List(JField(aisle,JInt(3)), JField(bin,JInt(2)), JField(hasWhat,JArray(List(JObject(List(JField(id,JInt(2)), JField(name,JString(Navel)), JField(state,JString(FL)))))))))

scala> val doesntWork = aJson.extract[Fruits]
doesntWork: org.spin.node.gogrid.objects.Fruits = Fruits(1,1,None)

scala> val works = aJson.extract[AFruit]
works: org.spin.node.gogrid.objects.AFruit = AFruit(1,1,Some(List(Apple(4,Granny,green), Apple(4,Fuji,red))))

case class AFruit(aisle: Int, bin: Int, hasWhat: Option[List[Apple]])

