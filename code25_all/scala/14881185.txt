Node
getMessage
importantAlgorithm
// Classes defined by the framework //
abstract class Node {
    def getMessage(n: Node) : Int
}

def importantAlgorithm(lstNodes1: List[_ <: Node], lstNodes2: List[_ <: Node]) = {

    val results = lstNodes1.zip(lstNodes2).map({case (n1, n2) =>
        // I would like to get the proper message *BASED ON
        // THE TYPE OF N1 and N2*
        val message = n1.getMessage(n2)
        // Do some work with the message
        //...
        //...
        })
    //...
}

// Classes defined by framework users //
class ItemNode(val p: Int) extends Node {
    override def getMessage(n: UserNode) = {
        // Compute message based on this ItemNode member variables
        // and n (instance of UserNode) member variables
    }
    override def getMessage(n: ItemNode) = {
        // Compute message based on this ItemNode member variables
        // and n (instance of UserNode) member variables
        // The algorithm is different from the algorithm
        // used in the previous method
    }
}

class UserNode extends Node {
    override def getMessage(n: OtherNode) = {
        // Compute message. Same idea as above
    }
}

class OtherNode extends Node { 
    override def getMessage(n: UserNode) = {
        // Compute message. Same idea as above
    }
}

// The user should be able to use the framework this way
importantAlgorithm(List(new UserNode(), new ItemNode(236), new OtherNode(),
   List(new OtherNode(), new ItemNode(542), new UserNode()))

isInstanceOf[]
