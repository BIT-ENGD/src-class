T
A
trait T { def i: Int }
abstract class A
type AT = A with T
class B extends A
// class C extends A
// class D extends A
// ...

a
B
AT
A
AT
Seq[AT]
val a: AT = new B with T { val i = 8 }

def toAT(a: A, i: Int): AT = {
 // how to ???
}

trait T { def i: Int }
abstract class A {
  def asAT(i: Int): AT
}
class B extends A {
  def asAT(ii: Int): AT = new B with T { val i = ii }
}
type AT = A with T
def toAT(a: A, i: Int): AT = a.asAT(i)

B, C, ..., Z
toAT
redecorated
trait T { def b: Boolean}
type AT = A with T
abstract class A(val i: Int) {
  def changedBy(x: Int): A
  def redecorated(oldAT: AT): AT
}
class B(x: Int) extends A(x) {
  def changedBy(x: Int): A = new B(i * x) 
  def redecorated(oldAT: AT): AT = new B(i) with T { val b = oldAT.b }
}
class C(x: Int) extends A(x) {
  def changedBy(x: Int): A = new C(i * x * x) 
  def redecorated(oldAT: AT): AT = new C(i) with T { val b = oldAT.b }
}
val b = new B(1) with T { val b = true  }
val c = new C(1) with T { val b = false }
val x = 8
val res: Seq[AT] = Seq(b,c) map { at => at.changedBy(x).redecorated(at) }

