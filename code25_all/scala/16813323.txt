trait Id[Type[_]] {
  def id[S]: S => Type[S]
}

trait IdTransformer[Type[_]] {
  type Result[_]  // depends of Type
  def idTransform[P]: P => Result[P]
  def composeWith[Other[_]](other: Id[Other]) = new Id[Result[Other]] { def id[S] = x => idTransform(other.id(x)) }
}

// instance example
class OptionIdTransformer extends IdTransformer[Option] {
  type Result = Option[_]
  def idTransform[S] = x => Some(x)
}

Transformer1.composeWith(Transformer2.composeWith(...(idInstance)))

type Other takes type parameters

IdTransformer.this.Result[<error>] takes no type parameters, expected: one 

