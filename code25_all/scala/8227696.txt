    "generate the correct output when merging an extraction" in {
        val source = new File("src/test/resources/sample-docs/text-and-image-on-page-2.pdf")
        val output = this.extractor.extract(source)
        val pdfGenerator = new ITextPdfGenerator()
        val processor = new ExecutableProcessor()

        val ocrInput = IOUtils.createTempFile("ocr_input", "pdf")
        val ocrOutput = IOUtils.createTempFile("ocr_output", "pdf")

        deleteWhenDone[MatchResult[Any]](output.getFullTextFile, ocrInput, ocrOutput) ( {

            pdfGenerator.generatePdf(source, ocrInput, output.getPagesWithImages)
            processor.process(ocrInput, ocrOutput)

            this.extractor.mergeExtraction(output, ocrOutput)

            IOUtils.readFile(output.getFullTextFile) === """sample text on line 1 page 1 sample text on line 2 page 1 sample text on line 1 page 3 sample text on line 2 page 3 """

        })

    }

def deleteWhenDone[T]( files : File* ) ( fn : => T ) {
    try {
        fn
    } finally {
        IOUtils.deleteFiles( files )
    }
}

IOUtils.readFile(output.getFullTextFile) === "sample text on line 1 page 1 sample text on line 2 page 1 sample text on line 1 page 3 sample text on line 2 page 3 "

deleteWhenDone[Result](output.getFullTextFile, ocrInput, ocrOutput) ( {

  pdfGenerator.generatePdf(source, ocrInput, output.getPagesWithImages)
  processor.process(ocrInput, ocrOutput)

  this.extractor.mergeExtraction(output, ocrOutput)

  IOUtils.readFile(output.getFullTextFile) === "sample text on line 1 page 1 sample text on line 2 page 1 sample text on line 1 page 3 sample text on line 2 page 3 "

})

def deleteWhenDone[T]( files : File* ) ( fn : => T ) : T = {
    try {
        fn
    } finally {
        IOUtils.deleteFiles( files )
    }
}

