object ImplicitTest {
  implicit def RichTraversableOnce[A](t: TraversableOnce[A]): RichTraversableOnce[A] =
    new RichTraversableOnce[A](t)

  class RichTraversableOnce[A](val t: TraversableOnce[A]) {
    def myMinBy[B >: A](f: A => B)(implicit cmp: Ordering[B]): A = {
      if (t.isEmpty)
        throw new UnsupportedOperationException("empty.myMinBy")

      t.reduceLeft((x, y) => if (cmp.lteq(f(x), f(y))) x else y)
    }
  }
}

 @Test
  def testOrdering {
    import ImplicitTest._
    val mx = List(1, 2, 7, 1, 4, 8, 2, 5, 47, 2, 7).myMinBy(_.toDouble)

    // ...but this works:
    // val mx = List(1, 2, 7, 1, 4, 8, 2, 5, 47, 2, 7).minBy(_.toDouble)

    println(mx)
  }

