trait A {
  type Result
}

case class AInt(id: String) extends A {
  type Result = Int
}

case class AString(id: String) extends A {
  type Result = String
}

class AStore {
  val mapInt = new collection.mutable.HashMap[String,Int]()
  val mapString = new collection.mutable.HashMap[String,String]()

  def put[T <: A](t: T, result: T#Result) {
    t match {
      case AInt(id) => mapInt(id) = result
      case AString(id) => mapString(id) = result
    }
  }

  def get[T <: A](t: T): T#Result = t match {
    case AInt(id) => mapInt(id)
    case AString(id) => mapString(id)
  }
}

19: error: type mismatch;
 found   : T#Result
 required: Int
      case AInt(id) => mapInt(id) = result
                                    ^
20: error: type mismatch;
 found   : T#Result
 required: String
      case AString(id) => mapString(id) = result
                                          ^
25: error: type mismatch;
 found   : Int
 required: T#Result
    case AInt(id) => mapInt(id)
                           ^
26: error: type mismatch;
 found   : String
 required: T#Result
    case AString(id) => mapString(id)
                                 ^
four errors found

