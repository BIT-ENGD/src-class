emptying a vessel,
filling a vessel,
pouring water from one vessel to the other, without spilling, until one of the vessels is either full or empty. 

(0, 0)
FillA
FillB
PourAtoB
PourBtoA
EmptyA
EmptyB
import scala.collection.mutable.Queue

def pour(initA:Int, initB:Int, targetCapacity:Int) {
    var pourCombinations = new scala.collection.mutable.HashMap[(Int, Int),Int]
    val capacityA = initA
    val capacityB = initB

    val processingQueue = new Queue[(Int, Int, Int, Int)]

    def FillA(a:Int, b:Int) = {
      (capacityA, b)                    
    }
    def FillB(b:Int, a:Int) = {
      (a, capacityB)
    }   
    def PourAtoB(a:Int, b:Int): (Int, Int) = {
      if((a == 0) || (b == capacityB)) (a, b) 
      else PourAtoB(a - 1, b + 1) 
    }
    def PourBtoA(b:Int, a:Int): (Int, Int) = { 
      if((b == 0) || (a == capacityA)) (a, b) 
      else PourBtoA(b - 1, a + 1)
    }
    def EmptyA(a:Int, b:Int) = {
      (0, b)
    }
    def EmptyB(a:Int, b:Int) = {
      (a, 0)
    }

    processingQueue.enqueue((0, 0, targetCapacity, 0))
    pourCombinations((0, 0)) = 0


    def pourwater(a:Int, b:Int, c:Int, numSteps:Int): Int = {
        println(a + ":" + b + ":" + c + ":" + numSteps)

        if((a == c) || (b == c)) {return numSteps}

        if(processingQueue.isEmpty && (pourCombinations((a,b)) == 1)) {return -1}

        //Put all the vals in a List of tuples
        val pStateList = scala.List(FillA(a, b), FillB(a, b), PourAtoB(a, b), PourBtoA(b, a), EmptyA(a, b), EmptyB(a, b))       

        pStateList.foreach{e =>
          {
            if(!pourCombinations.contains(e)) {
              pourCombinations(e) = 0
              processingQueue.enqueue((e._1, e._2, c, numSteps + 1))
            }
          }
        }   
        pourCombinations((a, b)) = 1
        val processingTuple = processingQueue.dequeue()
        pourwater(processingTuple._1, processingTuple._2, processingTuple._3, processingTuple._4)

     }
     val intialvalue = processingQueue.dequeue()
     pourwater(intialvalue._1, intialvalue._2, intialvalue._3, intialvalue._4)
}

numSteps
