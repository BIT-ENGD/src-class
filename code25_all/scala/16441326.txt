{"to":"UTF-8","cc":"UTF-8","subject":"UTF-8","from":"UTF-8","text":"iso-8859-1","html":"iso-8859-1"}

"text"
"Med Vänliga Hälsningar Jakobs Webshop"
Logger.info(request.body.dataParts.get("text").get)

Med V?nliga H?lsningar Jakobs Webshop

def parseMail = Action(parse.multipartFormData) {
    request => {

    val inputBuffer = request.body.dataParts.get("text").map {
        v => ByteBuffer.wrap(v.head.getBytes())
    }

    val fromCharset = Charset.forName("ISO-8859-1")
    val toCharset = Charset.forName("UTF-8")

    val data = fromCharset.decode(inputBuffer.get)
    Logger.info(""+data)

    val outputBuffer = toCharset.encode(data)
    val text = new String(outputBuffer.array())

    // Save stuff to MongoDB instance

}

Med Vï¿½nliga Hï¿½lsningar Jakobs Webshop

parse.multipartFormData
def handleDataPart: PartHandler[Part] = {
        case headers @ PartInfoMatcher(partName) if !FileInfoMatcher.unapply(headers).isDefined =>
          Traversable.takeUpTo[Array[Byte]](DEFAULT_MAX_TEXT_LENGTH)
            .transform(Iteratee.consume[Array[Byte]]().map(bytes => DataPart(partName, new String(bytes, "utf-8")))(play.core.Execution.internalContext))
            .flatMap { data =>
              Cont({
                case Input.El(_) => Done(MaxDataPartSizeExceeded(partName), Input.Empty)
                case in => Done(data, in)
              })
            }(play.core.Execution.internalContext)
      } 

.transform(Iteratee.consume[Array[Byte]]().map(bytes => DataPart(partName, new String(bytes, "utf-8")))(play.core.Execution.internalContext))

