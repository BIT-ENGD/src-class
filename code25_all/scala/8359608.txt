"functionName arg1=x1 arg2=x2 ..."
xi
functionName(x1,x2,...)
foo
bar
foo
bar
type Word = String
// the original function definitions
def foo(x: Int, w: Word) = println("foo called with " + x + " and " + w)
def bar(y: Int, z: Int)  = println("bar called with " + y + " and " + z)

// the return type for the parser
abstract class Functions
case class Foo(x: Int, w: Word) extends Functions
case class Bar(y: Int, z: Int) extends Functions

object FunctionParse extends RegexParsers {
  val int = """-?\d+""".r ^^ (_.toInt)
  val word = """[a-zA-Z]\w*""".r

  val foo = "foo" ~> ("x=" ~> int) ~ ("w=" ~> word) ^^ { case x~w => Foo(x,w) }
  val bar = "bar" ~> ("y=" ~> int) ~ ("z=" ~> int) ^^ { case y~z => Bar(y,z) }
  val function = foo | bar

  def parseString(s: String) = parse(function, s)
}


def main(args: Array[String]) = {
  FunctionParse.parseString(args.mkString(" ")) match {
    case FunctionParse.Success(result, _) => result match {
      case Foo(x, w) => foo(x, w)
      case Bar(y, z) => bar(y, z)
    }
    case _ => println("sux.")
  }
}

