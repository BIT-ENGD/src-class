val m = new Chunk("some sort of value") // value chunk 
assert(m.getValue == "some sort of value")

val n = new Chunk("key" -> new Chunk("value"), // nested chunks
                  "key2" -> new Chunk("value2"))
assert(n("key").getValue == "value")
assert(n("key2").getValue == "value2")

class Chunk(_map: Map[String, Chunk], _value: Option[String]) extends Map[String, Chunk] {
  def this(items: (String, Chunk)*) = this(items.toMap, None)
  def this(k: String) = this(new HashMap[String, Chunk], Option(k))
  def this(m: Map[String, Chunk]) = this(m, None)

  def +[B1 >: Chunk](kv: (String, B1)) = throw new Exception(":( do not know how to make this work")
  def -(k: String) = new Chunk(_map - k, _value)
  def get(k: String) = _map.get(k)
  def iterator = _map.iterator

  def getValue = _value.get
  def hasValue = _value.isDefined

  override def toString() = {
    if (hasValue) getValue
    else "Chunk(" + (for ((k, v) <- this) yield k + " -> " + v.toString).mkString(", ") + ")"
  }

  def serialize: String = {
    if (hasValue) getValue
    else "{" + (for ((k, v) <- this) yield k + "=" + v.serialize).mkString("|") + "}"
  }
}

object main extends App {
  val m = new Chunk("message_info" -> new Chunk("message_type" -> new Chunk("boom")))
  val n = m + ("c" -> new Chunk("boom2"))
}

def +[B1 >: Chunk](kv: (String, B1)) = Chunk(m + kv) // compiler hates this
def -(k: String) = Chunk(m - k) // compiler is pretty satisfied with this

overloaded method value apply with alternatives: (map: Map[String,Chunk])MapChunk <and> (elems: (String, Chunk)*)MapChunk cannot be applied to (scala.collection.immutable.Map[String,B1])

def +[B1 >: Chunk](kv: (String, B1)) = m + kv

def +(kv: (String, Chunk)):Chunk = Chunk(m + kv)

