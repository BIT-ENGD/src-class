object Timeline {
  ...
  def newBuilder[A]: Builder[(Long, A), Timeline[A]] = 
    new ListBuffer[(Long, A)] mapResult fromSeq

  def fromSeq[A](buf: Seq[(Long, A)]): Timeline[A] = 
    new Timeline(buf toMap)

  def empty[A] = Timeline[A](Map[Long, A]())
}

Long
A
final class Timeline[A] private(t: Map[Long, A]) 
  extends SortedMap[Long, A] 
  with SortedMapLike[Long, A, Timeline[A]] {

  private[this] lazy val iMap = 
    TreeMap(t.toArray: _*)(Ordering.fromLessThan[Long](_ > _))

  override def newBuilder: Builder[(Long, A), Timeline[A]] = Timeline.newBuilder
  override def empty: Timeline[A] = Timeline.empty

  def -(key: Long) = Timeline(iMap - key)
  def get(key: Long) = iMap.get(key)
  def rangeImpl(from: Option[Long], until: Option[Long]) = 
    Timeline(iMap.rangeImpl(from, until))
  def iterator = iMap.iterator
  def ordering = iMap.ordering
}

implicit def canBuildFrom[A]: CanBuildFrom[Timeline[A], A, Timeline[A]] =
  new CanBuildFrom[Timeline[A], A, Timeline[A]] {
    def apply(): Builder[(Long, A), Timeline[A]] = newBuilder[A]
    def apply(from: Timeline[A]): Builder[(Long, A), Timeline[A]] = newBuilder[A]
  }

