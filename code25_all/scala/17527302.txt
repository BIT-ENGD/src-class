object Test {
  trait A {
    def &(other: A) = ???
  }
  case class B(i: Int) extends A
  implicit class C(i: Int) {
    def ? : A= B(i)
  }
  val u = 7?
  val v = 10?
  val w = u & v // Ok, it compiles
  val z = 7? & 10?   //';' expected but 10 found
  val g = 7.? & 10?  //';' expected but 10 found
  val h = (7?) & 10? //Type mismatch. found Int(10). Required Test.A
  val i = 7? & (10?) //Test.A does not take parameters (on the ?)
}

