"Fail1".failNel[Int] and "Fail2".failNel[Int] to Failure("Fail1", "Fail2")
"Fail1".failNel[Int] and 100.successNel[String] to Success(100)

  def aggregateErrorsOrSuccess(v1: ValidationNEL[String, Int], 
                               v2: ValidationNEL[String, Int]) = {
    v2.fold(
      nl => (nl.fail[Int] |@| v1) {(i1, i2) => (/*actually should never happen*/)},
      res => res.successNel[String]
    )
  }

implicit def nel2list[T](nl: NonEmptyList[T]) = nl.head :: nl.tail;

implicit def ValidationNELPlus[X]: Plus[({type λ[α]=ValidationNEL[X, α]})#λ] = new      Plus[({type λ[α]=ValidationNEL[X, α]})#λ] {
def plus[A](a1: ValidationNEL[X, A], a2: => ValidationNEL[X, A]) = a1 match {
    case Success(_) => a1
    case Failure(f1) => a2 match {
      case Success(_) => a2
      case Failure(f2) => (f1 <::: f2).fail[A]
    }
  }
}

val sum = v1 <+> v2

