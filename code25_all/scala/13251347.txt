object InherenceTryout extends App {

  import someimpl._

  val list = List(SomeImpl("A"), SomeImpl("B"))
  val result = new SomeHandler().handleBaseList(list)

  println("%s->%s" format (list, result))

}

package base {

  // Defines that a 'Base' object can create a new 
  // 'Base' object where another 'Base' object is mixed in
  // Does not define how the mixing will take place
  trait Base {
    def mix(other: Base): Base
  }

  // Defines how a default 'Base' object gets mixed into a list of 'Base' objects 
  trait BaseHandler {
    def defaultBase: Base
    def handleBaseList(list: List[Base]): List[Base] = list.map(b => b.mix(defaultBase))
  }

}

package someimpl {

  import base._

  // Some implementation of 'Base'
  // Defines how a new 'SomeImpl' object is created by mixing in another
  // 'SomeImpl' object

  // ERROR: 
  // class SomeImpl needs to be abstract, since method mix in trait Base of type (other: base.Base)base.Base is not defined 
  // (Note that base.Base does not match someimpl.SomeImpl: class SomeImpl in 
  // package someimpl is a subclass of trait Base in package base, but method parameter types must match exactly.)
  case class SomeImpl(id: String) extends Base {
      def mix(other: SomeImpl): SomeImpl = SomeImpl("[%s|%s]" format (id, other.id)) 
  }

  // Defines the default 'SomeImpl' object
  class SomeHandler extends BaseHandler {
    def defaultBase = SomeImpl("D")
  }

}

