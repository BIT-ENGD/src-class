import scala.util.matching.Regex
import scala.util.parsing.combinator.lexical.StdLexical
import scala.util.parsing.combinator.token.StdTokens
import scala.util.parsing.input.CharArrayReader.EofCh

trait SimpleTokens extends StdTokens {
  // Adapted from StdTokens
  case class FloatLit(chars: String) extends Token {
    override def toString = "FloatLit "+chars
  }
  case class IntLit(chars: String) extends Token {
    override def toString = "IntLit "+chars
  }  
  case class BooleanLit(chars: String) extends Token {
    override def toString = "BooleanLit " + chars
  }
  case class StrLit(chars: String) extends Token {

    override def toString = "\"" + chars.slice(1,chars.length-1) + "\""
  }

}

class SimpleLexer extends StdLexical with SimpleTokens {
  import scala.util.parsing.input.CharArrayReader.EofCh

  reserved ++= List( "mod", "div", "array","if","then")

  delimiters ++= List( ";", "(", ")", "+", "-", "*", "/",".")

  def regex(r: Regex): Parser[String] = new Parser[String] {
    def apply(in: Input) = {
      val source = in.source
      val offset = in.offset
      (r findPrefixMatchOf (source.subSequence(offset, source.length))) match {
        case Some(matched) =>
          Success(source.subSequence(offset, offset + matched.end).toString,
            in.drop(matched.end))
        case None =>
          Failure("string matching regex `" + r + "' expected but `" + in.first + "' found", in.drop(0))
      }
    }
  }


  override def token: Parser[Token] = {
    // Adapted from StdLexical
    (
    regex("true|false".r)                   ^^ { BooleanLit(_)}
    |regex("[a-z][a-z]*".r)                 ^^ { processIdent(_) }                  
    |regex("""([0-9]*)(((\.)?[0-9]+(e|E)(\+|-)?[0-9]+)|(\.[0-9]+))""".r)                ^^ { FloatLit(_) }
    |regex("\\d+".r)                        ^^ { IntLit(_) }
    |regex("""'([^'\"]|'')*'""".r)          ^^ {StrLit(_) }
    |EofCh ^^^ EOF
    |delim
    )
  }

  override def whitespace: Parser[Any] = rep(
    whitespaceChar
      | '/' ~ '*' ~ comment
      | '/' ~ '*' ~> failure("unclosed comment"))

  override protected def comment: Parser[Any] = (
    '*' ~ '/' ^^ { case _ => ' ' }
    | chrExcept(EofCh) ~ comment)


}

ErrorToken '

identifier this

identifier is

identifier string

