case class Job(workId: Int, users: List[String])
val jobs = IndexedSeq(Job(1, List("a", "b")), Job(2, List("b", "c")), Job(3, List("a", "c" )), Job(4, List("d", "b")))

Map(c -> Vector(2, 3), a -> Vector(1, 3), d -> Vector(4), b -> Vector(1, 2, 4))

((for (job <- jobs;
   user <- job.users)
   yield { (user, job.work) }) groupBy { tuple => tuple._1 }) map { tuple => (tuple._1 -> (tuple._2 map { _._2 })) }

Map(c -> Vector((c,2), (c,3)), a -> Vector((a,1), (a,3)), d -> Vector((d,4)), b -> Vector((b,1), (b,2), (b,4)))

Map(c -> Vector(2, 3), a -> Vector(1, 3), d -> Vector(4), b -> Vector(1, 2, 4))

val mapping =  scala.collection.mutable.Map[String, IndexedSeq[Int]]()

 for (job <- jobs;
       user <- job.users)
   yield{
     if (mapping.contains(user)) {
       val entry = mapping(user)
       mapping.put(user, entry :+ job.work)
     } else {
       mapping += user -> mutable.IndexedSeq(job.work)
     }
  }

Map(c -> ArrayBuffer(2, 3), a -> ArrayBuffer(1, 3), d -> ArrayBuffer(4), b -> ArrayBuffer(1, 2, 4))

