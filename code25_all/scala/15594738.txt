import scala.reflect.runtime.universe._;

trait CompanionOfReflectiveConstructable[T] {
  def tType : Type;

  lazy val mirror       : Mirror       = runtimeMirror( this.getClass.getClassLoader );
  lazy val ctorDecl     : Symbol       = tType.declaration(nme.CONSTRUCTOR);
  lazy val ctor         : MethodSymbol = ctorDecl.asMethod;
  lazy val tClass       : ClassSymbol  = tType.typeSymbol.asClass;
  lazy val tClassMirror : ClassMirror  = mirror.reflectClass( tClass );
  lazy val ctorF        : MethodMirror = tClassMirror.reflectConstructor( ctor );

  // in real-life, i'd derive arguments from ctor.paramss
  // but to highlight our issue, we'll assume a no arg constructor
  def createInstance : T = ctorF().asInstanceOf[T]; 
}

trait ReflectiveConstructable;

object Test1 extends CompanionOfReflectiveConstructable[Test1] {
  def tType = typeOf[Test1];
}
class Test1 extends ReflectiveConstructable;

class Outer {
  object Test2 extends CompanionOfReflectiveConstructable[Test2] {
    def tType = typeOf[Test2];
  }
  class Test2 extends ReflectiveConstructable;
}

scala> Test1.createInstance
res0: Test1 = Test1@2b52833d

scala> (new Outer).Test2.createInstance
scala.ScalaReflectionException: class Test2 is an inner class, use reflectClass on an InstanceMirror to obtain its ClassMirror
        at scala.reflect.runtime.JavaMirrors$JavaMirror.ErrorInnerClass(JavaMirrors.scala:126)
...

