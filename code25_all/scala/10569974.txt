case class Interval[T](from: T, to: T)(implicit num: Numeric[T]) {
  import num.mkNumericOps // allows us to write from.toDouble and to.toDouble
  def mid: Double = (from.toDouble + to.toDouble) / 2.0
}

(implicit num: Numeric[T])
object Interval {

  def union[T](interval1: Interval[T], interval2: Interval[T])(implicit num: Numeric[T]) = {
    import num.mkOrderingOps // allows interval1.from min
    Interval[T](interval1.from min interval2.from, interval1.to max interval2.to)
  }

  def intersect[T](interval1: Interval[T], interval2: Interval[T])(implicit num: Numeric[T]) = {
    import num.mkOrderingOps
    Interval[T](interval1.from max interval2.from, interval1.to min interval2.to)
  }

}  

(implicit num: Numeric[T])
import num.mkOrderingOps
