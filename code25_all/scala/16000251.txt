  trait CoVariant[+T] {
    def bar: T
  }

  def curried[T](x: String)(y: CoVariant[T]) = y // Not really, but for simplicity
  val applied = curried("foo") _

  val bar = new CoVariant[String] {
    def bar = "bar"
  }
  applied(bar)

- type mismatch;  found   : CoVariant[String]  required: CoVariant[Nothing]

trait StupidWrapper {
   def apply[T](y: CoVariant[T]) : CoVariant[T]
}

def notAsNice(x: String) = new StupidWrapper {
   def apply[T](y: CoVariant[T]) = y
}

val applied = notAsNice("foo")
applied(bar)  

  abstract class ParserToSeq {
    def apply[T](parser: Parser[T]): Seq[T]
  }

  def fromTrainingData(trainingLines: Seq[String]) = new ParserToSeq {
    def apply[T](p: Parser[T]) = trainingLines.map(parseAll(p, _)).map {
      _ match {
        case Success(wt, _) => Some(wt)
        case _ => None
      }
    }.flatten
  }

val thisData = fromTrainingData(trainingLines)
lazy val wordTags = thisData(wordtagParser) // Parser[WordTag]
lazy val uniGrams = thisData(uniGramParser) // Parser[UniGram]
â€¦

def fromTrainingData[T](trainingLines: Seq[String])(p: Parser[T]) = 
  trainingLines.map(parseAll(p, _)).map {
  _ match {
    case Success(wt, _) => Some(wt)
    case _ => None
  }
}.flatten

def fromTrainingData(trainingLines: Seq[String])[T](p: Parser[T])

