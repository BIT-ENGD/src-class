Container[T1,T2]
Container[T1,T2]
case class Container[T1, T2](t1: T1, t2: T2)

  trait ToContainer[A] {
    def wrappingMethod[E](e: E): Container[E, A]
  }

  object ToContainers {
    import language.implicitConversions

    implicit def implicitMethod[A](a: => A) = new ToContainer[A] {
      def wrappingMethod[E](e: E): Container[E, A] = Container(e, a)
    }

    implicit def implicitMethod2[E, A] (c: => Container[E, A])(implicit d:DummyImplicit): ToContainer[A] = new ToContainer[A] {
      def wrappingMethod[EX](e: EX): Container[EX, A] = c.copy(e)
    }
  }

EX
def wrappingMethod[EX]
E
def implicitMethod2[E, A]
        scala>  import     ToContainers._
        import ToContainers._

        scala>  val c1: Container[String, Int] = 1234.wrappingMethod("abc")
        c1: Container[String,Int] = Container(abc,1234)

        scala>  val c2: Container[String, Int] = c1.wrappingMethod("XXX")
        c2: Container[String,Int] = Container(XXX,1234)

        scala>  val c3 = c1.wrappingMethod(0)
        c3: Container[Int,Int] = Container(0,1234)

