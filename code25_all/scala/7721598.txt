 trait A { 
    def foo( s: String ) : String
    def foo : String = foo( "foo" )
 }
 object B extends A {
    def foo( s: String ) : String = s
 } 
 B.foo     // won't compile

 error: ambiguous reference to overloaded function
 both method foo in object B of type(s: String)String
 and method foo in trait A of type => String
 match expected type Unit
 B.foo

 val s: String = B.foo

 B.foo()

 (s: String)String <and>
 => String
 cannot be applied to ()
 B.foo()

 assert( B.foo == "whatever" )

 val expected : String = B.foo
 assert( expected == "whatever" )

