abstract class parentSet[T] protected () {

    def union(other:parentSet[T]):parentSet[T]

}

class childSet[T] private (l: List[T]) extends parentSet[T] {
    def this() = this(List())
    private val elems = l
    val toList = List[T] => new List(l)

    def union(other:parentSet[T]):childSet[T] = {
        for (i <- this.toList) {
            if (other contains i) {}
            else {l :: i}
        }
        return l
    }
}

  def U(other:parentSet[T]):childSet[T] = {
    var w = other.toList
    for (i <- this.toList) {
        if (!(other contains i)) {w = i::w}
    }
    return new childSet(w)

def U(other:parentSet[T]):MapSet[T] =  {
    var a = Map[T,Unit]
    for (i <- this.toList) {
        if (!(other contains i)) {a = a + (i->())}
    }
    return new MapSet(elems + (a->()))
  }

