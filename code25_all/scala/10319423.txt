abstract class A(n: String){
   def name = n
}

abstract class B[T](n: String) extends A(n){
   def printT(t: T) = println(t)
}

object B{
   def unapply[T](b: B[T]) = Some(b.name)
}

case class C extends B[Int]("integer")

val list = List(C)

list match{
   case b @ B(_) => b.printT(2) 
}

case b @ B(_) => b.printT(2)
found   : Int(2)
required: T where type T
case b @ B(_) => b.printT(2)
                              ^

