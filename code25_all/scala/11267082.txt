class Food
abstract class Animal {
  type SuitableFood <: Food
  def eat(food: SuitableFood)
}

class Grass extends Food
class Cow extends Animal {
  type SuitableFood = Grass
  override def eat(food: Grass) {}
}

Cow
class Fish extends Food
val bessy: Animal = new Cow
bessy eat (new Fish) // Error, type mismatch

class Food
abstract class Animal[T <: Food] { 
  def eat(food: T)
}

class Grass extends Food
class Cow extends Animal[Grass] {
  override def eat(food: Grass){}
}

class Fish extends Food
val bessy: Animal[Grass] = new Cow
bessy eat (new Fish) // Also ends in a type mismatch error !

