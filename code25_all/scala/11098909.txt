abstract class A {
  def a() {}
  def aa()
}

class B extends A {
  def aa() {}
  def b()
}

class C extends A {
  def aa() {}
  def c()
}

object Group {

  def apply(as: Buffer[A]) = new Group[A](as)
  def apply[T <: A](as: Buffer[T]) = new Group[T](as)
}

class Group[T <: A](as: Buffer[T]) {

  def a() { as.map(_.a()) }
  def aa() { as.map(_.aa()) }

}

Group
val groupA = Group(Buffer[A]())
groupA.a()  //ok
groupA.aa() //ok
groupA.b()  //error
groupA.c()  //error

A
val groupB = Group[B](Buffer[B]())
groupB.a()  //ok
groupB.aa() //ok
groupB.b()  //ok
groupB.c()  //error

[B]
val groupB = Group(Buffer[B]())

b()
c()
groupC.as.map(_.c())

asInstanceOf
