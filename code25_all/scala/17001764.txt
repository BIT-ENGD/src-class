object CurrencyExtractionRunner {
      def main(args:Array[String]){
        parseArgs(args){
            (currencyType,currencyTypeArgs) => 
                 CurrencyExchanger(curencyType,currencyTypeArgs){
                   (exchanger) => exchanger.startExchange
                 }
            }
        }
      }
   }

parseArgs(args)
(currencyType,currencyTypeArgs)
CurrencyExchanger
exchanger
startExchange
object Args {
    @Parameter(
      names = Array("-h", "--help"), help = true)
    var help = false
    @Parameter(
      names = Array("-c", "--currency-type"),
      description = "Type of currency exchange that needs to be performed",
      required = true)
    var currencyType: String = null
    @Parameter(
      names = Array("-d", "--denominations"),
      description = "Specific denominations to be used during the exchage")
    var exchangeDenomination: String = null
    @Parameter(
      names = Array("-s", "--someotheroptionalarg"),
      description = "Additional argument for a specific currency exchange")
    var someOtherOptionalArg: String = null

  }


trait ParseUtils {
//How do I do this, take the args and return a function.  
def parseArgs(args: Array[String]){
    val jCommander = new JCommander(Args, args.toArray: _*)
    if (Args.help) {
      jCommander.usage()
      System.exit(0)
    }
    //What do I do now? How do I proceed with executing the function with
    //the specific arguments?
    //What do I need to do to wrap the commandline arguments so that it could 
    //be passed to the next function
  }
}

