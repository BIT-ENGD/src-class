def bar[X](as: Seq[A[X]]) = true

// parametised type to use in the question
trait A[T]

// useful types 
trait A[T]
class AI extends A[Int]
class AS extends A[String]

// define two functions that both have the same constraint.
// ie the arg must be a Sequence with all elements of the same parameterised type

def foo(as: Seq[A[X]] forSome { type X }) = true

def bar[X](as: Seq[A[X]]) = true

// these compile because all the elements are the same type (AI)
foo(Seq(new AI, new AI))
bar(Seq(new AI, new AI))

// both these fail compilation as expected because 
// the X param of X[A] is different (AS vs AI)
foo(Seq(new AI, new AS))
bar(Seq(new AI, new AS))

scala> foo(Seq(new AI, new AS))
<console>:12: error: type mismatch;
 found   : Seq[A[_ >: String with Int]]
 required: Seq[A[X]] forSome { type X }

              foo(Seq(new AI, new AS))
                     ^

scala> bar(Seq(new AI, new AS))
<console>:12: error: no type parameters for method bar: (as: Seq[A[X]])Boolean e
xist so that it can be applied to arguments (Seq[A[_ >: String with Int]])
 --- because ---
argument expression's type is not compatible with formal parameter type;
 found   : Seq[A[_ >: String with Int]]
 required: Seq[A[?X]]
              bar(Seq(new AI, new AS))
              ^
<console>:12: error: type mismatch;
 found   : Seq[A[_ >: String with Int]]
 required: Seq[A[X]]
              bar(Seq(new AI, new AS))
                     ^

scala>

