// Model object base class
abstract class Model[M <: Model[M]] {

  val dao: Dao[M]
}

// DAO for each model object, with find, delete, update
abstract class Dao[M <: Model[M]] {

  // meta data describing the model object
  case class Column(val name:String, val get: M => _)

  val columns : Map[String,Column]
}

// example simple model object with it's DAO 
case class ItemModel (val name:String) extends Model[ItemModel] {
  val dao = ItemDao
}

object ItemDao extends Dao[ItemModel] {

  val columns = Map("name" -> Column("name", { v:ItemModel => v.name}))
}

object Works {

  // normal access pattern
  def good1(value: ItemModel) = value.name

  // even through the DAO
  def good2(value: ItemModel) = value.dao.columns("name").get(value)
}

// Trouble trying to manipulate base model objects
object Trouble {

  // type mismatch;  found   : value.type (with underlying type test.Model[_])  required: _$2 where type _$2 Test.scala   
  def bad1(value: Model[_]) = value.dao.columns("name").get(value)  

  // type mismatch;  found   : value.type (with underlying type test.Model[_ <: test.Model[_]])  required: _$3 where type _$3 <: test.Model[_]
  def bad2(value: Model[_ <: Model[_]]) = value.dao.columns("name").get(value)

  // type mismatch;  found   : value.type (with underlying type X forSome { type X <: models.Model[X] })  required: X where type X <: models.Model[X]
  def bad3(value: X forSome {type X <: Model[X]}) = value.dao.columns("name").get(value)
}

