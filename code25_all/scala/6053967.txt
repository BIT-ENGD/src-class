// not restricted to be 4-by-2, can be abritary
// Double will be later replaced by type T : Numeric
var elements = new Array[Double](4*2) 
// can contain other Numemrics as Int
var values = ((11.0,12.0),(21.0,22.0),(31.0,32.0), (4.0,1.0)) 

var i = 0;
var itRow = values.productIterator.asInstanceOf[Iterator[Product]]
while(itRow.hasNext){
    var itCol = itRow.next.productIterator.asInstanceOf[Iterator[Double]]
        while(itCol.hasNext){
            elements(i) = itCol.next.asInstanceOf[Double]
            i = i + 1
        }
}

def flatProduct(t: Product): Iterator[Any] = t.productIterator.flatMap {
    case p: Product => flatProduct(p)
    case x => Iterator(x)
}  

// edit: I think this is better, 
// but still the problematic if there are Int-types in values
flatProduct(values).asInstanceOf[Iterator[Dobule]].copyToArray(elements)

