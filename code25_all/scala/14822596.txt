map
map
map
map
map
prop map { x => 
  x map { actualX =>
   //do something
  }
}

prop map { actualX =>
  //do something
}

// leaving out the observable part
trait ObservableValue[T] {
  def value: T
}

trait LowerPriorityImplicits {
  // default implementation that adds a regular map method
  implicit class RichObservableValue1[A](o: ObservableValue[A]) {
    def map[B](f: A => B): ObservableValue[B] = new ObservableValue[B] {
      def value = f(o.value)
    }
  }
}

object ObservableValue extends LowerPriorityImplicits {

  // describe a type that has a map method
  type HasMapMethod[A, Container[X]] = {
    def map[B](f: A => B): Container[B]
  }

  // complex implementation that uses the builtin map if present
  implicit class RichObservableValue2[A, Container[Z] <: HasMapMethod[Z, Container]](
      o: ObservableValue[Container[A]]) {

    def map[B](f: A => B): ObservableValue[Container[B]] = 
      new ObservableValue[Container[B]] {
        def value = o.value.map(f)
      }
  }
}

class TestCase extends ObservableValue[Option[Int]] {
  def value = None
}

val x = new TestCase

x map { value =>
  // this fails because the compiler finds the lower priority implicit
  (value: Int).toString
}

// the method itself works fine
ObservableValue.RichObservableValue2(x) map { value =>
  (value: Int).toString
}

Container[B]
Any
RichObservableValue2
FilterMonadic
map
Option
FilterMonadic
RichObservableValue3
RichObservableValue
implicit class RichObservableValue3[A, C[Z] <: FilterMonadic[Z, C[Z]]](o: ObservableValue[C[A]]) {

  def map[B, That](f: A => B)(implicit bf: CanBuildFrom[C[A], B, That]): ObservableValue[That] = new ObservableValue[That] {
    def value = o.value.map(f)

    val change = o.change map (_ map f)
  }
}

List[Int]
