val myElement = Form(
    mapping(
      "title" -> nonEmptyText,
      "schedule" ->
        tuple("startSchedule" -> jodaDate("dd/MM/yyyy HH:mm"),
          "endSchedule" -> jodaDate("dd/MM/yyyy HH:mm"))
          .verifying(MyValidator().checkForEndScheduleConsistency("error.schedule")),
    )(MyElement.apply)(MyElement.unapply)
  )

MyElement
case class MyElement(title: String, schedule: (Datetime, Datetime))

MyValidator
def checkForEndScheduleConsistency(errorMsg: String) =
    Constraint[(DateTime, DateTime)]("constraint.schedule", errorMsg) {
      schedule =>
        MyDomainValidator().checkForEndScheduleConsistency(schedule._1, schedule._2, Messages(errorMsg)) match {
          case Success(s) => Valid
          case Failure(f) => Invalid(ValidationError("custom error string from `f`"))
        }
    }

schedule.endSchedule
MyValidator
startSchedule
endSchedule
checkForEndScheduleConsistency
verifying
endSchedule
startSchedule
endSchedule
schedule
Form
withError
def create = Action {
    implicit request =>
      myForm.bindFromRequest.fold(
        myFormWithErrors => {
          myFormWithErrors.error("schedule") match { //check for the presence of potential schedule error
          case Some(e) => {
            BadRequest(views.html.create_element("Create an element", myFormWithErrors.withError("schedule.endSchedule", Messages("error.schedule"))))
          }
          case _ => BadRequest(views.html.create_element("Create an element", myFormWithErrors))
        }
        },
        myForm => {
          treatSubmittedMyForm(myForm)
        }
      )
  }

verifying
endSchedule
