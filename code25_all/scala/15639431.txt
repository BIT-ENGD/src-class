import scala.util.control.Breaks._

object Main {

def pascal(col: Int, row: Int): Int = {
    if(col > row) throw new Exception("Coloumn out of bound");
    else if (col == 0 || col == row) 1;
    else pascal(col - 1, row - 1) + pascal(col, row - 1);
}
def balance(chars: List[Char]): Boolean = {
  val string: String = chars.toString()
  if (string.length() == 0) true;
  else if(stringContains(")", string) == false && stringContains("(", string) == false) true;
  else if(stringContains(")", string) ^ stringContains("(", string)) false;
  else if(getFirstPosition("(", string) > getFirstPosition(")", string)) false;
  else if(getLastPosition("(", string) > getLastPosition(")", string)) false;
  else if(getCount("(", string) != getCount(")", string)) false;
  var positionOfFirstOpeningBracket = getFirstPosition("(", string);
  var openingBracketOccurences = 1; //we already know that at the first position there is an opening bracket so we are incrementing it right away with 1 and skipping the firstPosition variable in the loop
  var closingBracketOccurrences = 0;
  var positionOfClosingBracket = 0;
  breakable {
    for(i <- positionOfFirstOpeningBracket + 1 until string.length()) {

        if (string.charAt(i) == ("(".toCharArray())(0)) {
            openingBracketOccurences += 1;
        }
        else if(string.charAt(i) == (")".toCharArray())(0) ) {
            closingBracketOccurrences += 1;
        }
        if(openingBracketOccurences - closingBracketOccurrences == 0) { //this is an important part of the algorithm. if the string is balanced and at the current iteration opening=closing that means we know the bounds of our current brackets.
            positionOfClosingBracket = i; // this is the position of the closing bracket
            break;
        }  

    }
  }
  val insideBrackets: String = string.substring(positionOfFirstOpeningBracket + 1, positionOfClosingBracket)
  balance(insideBrackets.toList) && balance( string.substring(positionOfClosingBracket + 1, string.length()).toList)

  def getFirstPosition(character: String, pool: String): Int = 
    {
        for(i <- 0 until pool.length()) {
            if (pool.charAt(i) == (character.toCharArray())(0)) {
                i;
            }
        }
        -1;
    }

def getLastPosition(character: String, pool: String): Int =
{
    for(i <- pool.length() - 1 to 0 by -1) {
        if (pool.charAt(i) == (character.toCharArray())(0)) {
            i;
        }
    }
    -1;
}

//checks if a string contains a specific character
def stringContains(needle: String, pool: String): Boolean =  {
    for(i <- 0 until pool.length()) {
        if(pool.charAt(i) == (needle.toCharArray())(0)) true;
    }
    false;
}

//gets the count of occurrences of a character in a string
def getCount(character: String, pool: String) = {
    var count = 0;
    for ( i <- 0 until pool.length()) {
        if(pool.charAt(i) == (character.toCharArray())(0)) count += 1;
    }
    count;
}
}
}

