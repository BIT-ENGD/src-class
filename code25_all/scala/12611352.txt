trait Trait {
  type X
  type Y[_ <: X]
} 

type T[X0,Y0[_ <: X0]] = Trait { type X = X0; type Y[S <: X0] = Y0[S] }

class TraitImpl extends Trait {
  override type X = Int
  override type Y[I <: Int] = List[I]
}

case class Wrap[X,Y[_ <: X]](t: T[X,Y])

val wrap = new Wrap[Int,List](new TraitImpl) // why explicitly write types?

wrap
wrap match {
  case w: Wrap[_,_]      => // error
  case w: Wrap[_,_[_]]   => // error
  case Wrap(t)           => // error
  case w: Wrap[Int,List] => // fine
}

case
case
case Wrap(t) =>
