case class Data(x: Int, y: Int)

trait Accumulator {
  type R   
  def add(acc: R, d: Data): R
  def zero: R
}

trait XAccumulator extends Accumulator {
  type R = Int
  def add(acc: Int, d: Data) = acc + d.x
  def zero = 0
}

trait TraceYAccumulator extends Accumulator {
  abstract override type R = (Seq[Int], super.R)
  // fails:
  // `abstract override' modifier not allowed for type members

  def add(acc: R, d: Data) = {
    val r = super.add(acc._2, d)
    (acc._1 :+ d.y, r)
  }

  def zero = (Seq.empty[Int], super.zero)
}

trait Accumulator[R] {
  def add(acc: R, d: Data): R
  def zero: R
}

trait XAccumulator extends Accumulator[Int] {
  def add(acc: Int, d: Data) = acc + d.x
  def zero = 0
}

trait TraceYAccumulator[T] extends Accumulator[(Seq[Int], T)] {
  this: Accumulator[T] =>

  def add(acc: (Seq[Int], T), d: Data): (Seq[Int], T) = {
    val r = this.add(acc._2, d)
    // fails: overloaded method value add with alternatives:
    // (acc: (Seq[Int], T),d: Data)(Seq[Int], T) <and>
    // (acc: _14695,d: Data)_14695 cannot be applied to (T, Data)
    (acc._1 :+ d.y, r)
  }
  def zero: (Seq[Int], T) = (Seq.empty[Int], this.zero)
}

