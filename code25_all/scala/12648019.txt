def ifSome[B, _](pairs:(Option[B], B => _)*) {
  for((paramOption, setFunc) <- pairs)
    for(someParam <- paramOption) setFunc(someParam)
}

class Foo{ 
  var b=""
  def setB(b:String){this.b = b}
  def setB(b:Int){this.b = b.toString}
}

val f = new Foo

ifSome(Option("hi") -> f.setB _)

<console>:11: error: ambiguous reference to overloaded definition,
both method setB in class Foo of type (b: Int)Unit
and  method setB in class Foo of type (b: String)Unit
match expected type ?
                 ifSome(Option("hi") -> f.setB _)

ifSome(Option("hi") -> (f.setB _:String=>Unit))

