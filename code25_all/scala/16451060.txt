def using[A <: { def close(): Unit }, B](resource: A)(f: A => B) = macro usingImpl[A, B]

def usingImpl[A <: { def close(): Unit }, B](c: Context)(resource: c.Expr[A])(f: c.Expr[A => B]): c.Expr[B] = {

  import c.universe._


  f.tree match {
    case Function(params, body) =>
      //val ValDef(modifiers, name, tpt, _) = params.head
      c.Expr[B](
        Block(
          List(
            //ValDef(modifiers, name, tpt, resource.tree)
            ValDef(params.head.symbol, resource.tree)
          ),
          body
        )
      )

    case _: Select =>
      reify {
        val res = resource.splice
        try {
          f.splice(res)
        } finally {
          res.close()
        }
      }
  }
}

Select
Function
ValDef
Symbol
Tree
x$1
Expr[Int]({
  <synthetic> val x$1: Test.Foo = new Test.this.Foo();
  x$1.bar.+(23)
})

params.head
object Test extends App {
  import Macros._

  class Foo {
    def close() {}

    def bar = 3
  }

  println(using(new Foo)(_.bar + 3))
}

[error] symbol value x$1 does not exist in Test$delayedInit$body.apply
