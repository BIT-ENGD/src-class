abstract class Table(val name: String) {
  val columns: List[Column]

  def getAliasColumns: String = {
    val reallyThere = columns.forall(c => c != null)
    println("Columns really there: " + reallyThere)
    if (reallyThere == false) {
      println(" columns " + columns)
    }

    columns.map(c => s"${c.table.name}.${c.name} as ${c.table.name}_${c.name}")
      .mkString(", ")
  }
}

class Column(val table: Table, val name: String, val foreignKey: Option[Column])

object Column {
  def apply(table: Table, name: String): Column = {
    new Column(table, name, foreignKey = None)
  }

  def apply(table: Table, name: String, fk: Column): Column = {
    new Column(table, name, Some(fk))
  }
}

object Domain {
  object Tenant extends Table("Tenant") {
    object Columns {
      // Primary key
      val Id = Column(Tenant, "id")
      // Just a name
      val Name = Column(Tenant, "name")
    }

    val columns = List(Columns.Id, Columns.Name)
  }

  object Node extends Table("Node") {
    object Columns {
      // Primary key
      val Id = Column(Node, "id")

      // Foreign key to another table
      val TenantId = Column(Node, "tenantId", Tenant.Columns.Id)

      // Foreign key to itself
      val NodeId = Column(Node, "nodeId", Id)

      // Just a name
      val Name = Column(Node, "name")
    }

    val columns = List(Columns.Id, Columns.TenantId, 
      Columns.NodeId, Columns.Name)
  }

  val tables = List(Tenant, Node)
}

object RecursiveObjects extends App {
  Domain.tables.foreach(t => println(t.getAliasColumns))
  println(Domain.Node.getAliasColumns)
}

object RecursiveObjects extends App {
  println(Domain.Node.getAliasColumns)
  Domain.tables.foreach(t => println(t.getAliasColumns))
}

object Node extends {
  val columns = List(Domain.Node.Columns.Id, Domain.Node.Columns.TenantId,
                     Domain.Node.Columns.NodeId, Domain.Node.Columns.Name)
} with Table("Node") {
  object Columns {
    // Primary key
    val Id = Column(Node, "id")
    [...]
  }

}

