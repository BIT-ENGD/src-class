abstract class CanvNode (var swElI: Either[CSplit, VistaT])
{         
  private[this] var _swEl: Either[CSplit, VistaT] = swElI
  def member = _swEl
  def member_= (value: Either[CSplit, VistaT] ){ _swEl = value; attach}
  def attach: Unit
  attach

  def findVista(origV: VistaIn): Option[Tuple2[CanvNode,VistaT]] = member match
  {
    case Right(v) if (v == origV) => Option(this, v) 
    case _ => None
  }
}

def nodes(): List[CanvNode] = topNode :: splits.map(i => List(i.n1, i.n2)).flatten

//Is there a better way of implementing this? 
val temp: Option[Tuple2[CanvNode, VistaT]] = 
  nodes.map(i => i.findVista(origV)).collectFirst{case Some (r) => r}

implicit class TraversableOnceRichClass[A](n: TraversableOnce[A])
{
  def findSome[T](f: (A) => Option[T]) = n.map(f(_)).collectFirst{case Some (r) => r}
}    

val temp: Option[Tuple2[CanvNode, VistaT]] = 
  nodes.findSome(i => i.findVista(origV))

class TraversableOnceRichClass[A](n: TraversableOnce[A])
{
  def findSome[T](f: (A) => Option[T]) = n.map(f(_)).collectFirst{case Some (r) => r}
}

implicit final def TraversableOnceRichClass[A](n: List[A]):
  TraversableOnceRichClass[A] = new TraversableOnceRichClass(n)

