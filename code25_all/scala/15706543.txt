trait Bar

object Model {
  object Foo {
    def unapply[A <: Bar](foo: Foo[A]): Option[Foo[A]] = Some(foo)
  }
  trait Foo[A <: Bar] extends Model[A]
}
trait Model[A <: Bar]

object View {
  def apply[A <: Bar](model: Model[A]): View[A] = model match {
    case Model.Foo(peer) => new Foo(peer)
  }  
  class Foo[A <: Bar](val peer: Model.Foo[A]) extends View[A]
}
trait View[A <: Bar]

Bar
trait Bar[B <: Bar[B]]

object Model {
  object Foo {
    def unapply[A <: Bar[A]](foo: Foo[A]): Option[Foo[A]] = Some(foo)
  }
  trait Foo[A <: Bar[A]] extends Model[A]
}
trait Model[A <: Bar[A]]

object View {
  def apply[A <: Bar[A]](model: Model[A]): View[A] = model match {
    case Model.Foo(peer) => new Foo(peer)
  }  
  class Foo[A <: Bar[A]](val peer: Model.Foo[A]) extends View[A]
}
trait View[A <: Bar[A]]

<console>:12: error: inferred type arguments [A] do not conform to method unapply's 
  type parameter bounds [A <: Bar[A]]
           case Model.Foo(peer) => new Foo(peer)
                      ^
<console>:12: error: type mismatch;
 found   : Model.Foo[A(in method unapply)]
 required: Model.Foo[A(in method apply)]
           case Model.Foo(peer) => new Foo(peer)
                                           ^

unapply
Option[+A]
