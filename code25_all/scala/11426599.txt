trait CanAdd{
  def add(that: CanAdd): CanAdd
}

class A(val value: Int) extends CanAdd{      
  def add(that: CanAdd): CanAdd = {          
    if(!that.isInstanceOf[A]) sys.error("")  
    val thatA: A = that.asInstanceOf[A]      
    new A(value + thatA.value)               
  }                                          
}                                            
class B(val value: Boolean) extends CanAdd{  
  def add(that: CanAdd): CanAdd = {          
    if(!that.isInstanceOf[B]) sys.error("")  
    val thatB: B = that.asInstanceOf[B]      
    new B(value ^ thatB.value)               
  }                                          
}                                            

class User(val stuff: Array[CanAdd]) {                                            
  def add(that: User): User = {                                                   
    assume(stuff.length==that.stuff.length)                                       
    val out = new Array[CanAdd](stuff.length)                                     
    for( i <- 0 until stuff.length) out(i) = stuff(i).add(that.stuff(i))          
    new User(out)                                                                 
  }                                                                               
}              
val u1=new User(Array(new A(0)))                                           
val u2=new User(Array(new B(false)))                                       
val u3 = u1.add(u1)                                                        
val u4 = u1.add(u2) //should fail, ideally, should not even compile        

