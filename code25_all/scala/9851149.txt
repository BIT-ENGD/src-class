def parseDef:Def = {
  currentToken match {
  case ValToken => {
    eat(ValToken);

    val nme:String = currentToken match {
      case IdToken(x) => {advance; x}
      case _ => error("Expected a name after VAL.")
    }

    eat(EqualToken);      
    VAL(nme,parseExp)
    }

  case FunToken => {

    eat(FunToken);

    val fnme:String = currentToken match {
      case IdToken(x) => {advance; x}
      case _ => error("Expected a name after VAL.")
    }

    val xnme:String = currentToken match {
      case IdToken(x) => {advance; x}
      case _ => error("Expected a name after VAL.")
    }

    def parseAnd:Def = currentToken match {
      case AndToken => {eat(AndToken); FUN(fnme,xnme,parseExp,parseAnd)}
      case _ => NOFUN
    }


    FUN(fnme,xnme,parseExp,parseAnd)
    }
    case _ => error("Expected VAL or FUN.");
  }
}

