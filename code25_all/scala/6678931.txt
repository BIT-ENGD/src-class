ProjectAnalysisActors

sealed trait AnalysisEvent {
   def run(project: Project): Future[Any]
   def nextStep: AnalysisEvent = null
}

case class StartAnalysis() extends AnalysisEvent {
   override def run ...
   override def nextStep: AnalysisEvent = new FirstStep
}

case class FirstStep() extends AnalysisEvent {
   override def run ...
   override def nextStep: AnalysisEvent = new SecondStep
}

case class SecondStep() extends AnalysisEvent {
   ...
}

class ProjectAnalysisActor(project: Project) extends Actor {

    def receive = {
        case event: AnalysisEvent =>
            val future = event.run(project)
            future.onComplete { f =>
                self ! event.nextStep
            }
    }

}



def run(project: Project): Future[Any] = {
    Future {
        progressActor ! typicalFireAndForget(project.name)
        val calcResult = (calcActor1 !! doCalcMessage(project)).getOrElse(...)

        val p: Project = ... // created updated project using calcResult

        val result = (storage !! updateProjectInformation(p)).getOrElse(...)
        result
    }
}

