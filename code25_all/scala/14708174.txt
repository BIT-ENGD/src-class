abstract class A {
  def a: Int
  def b: Int
  // real A has additional members
}

case class Foo(a: Int, b: Int) extends A
case class Bar(a: Int, b: Int) extends A
// and many more

val b1 = Bar(1, 2)
val b2 = Bar(1) has 2
assert(b1 == b2) // must hold

has
A
case class PartialA(f: Int => A) {
  def has(b: Int) = f(b)
}

Bar(1)
Bar.apply(1)
apply
Bar
Bar
object Bar extends PartialAConstructor
abstract class PartialAConstructor{
  def apply(a: Int, b: Int): A // abstract, created when the compiler creates
                               // object Bar
  def apply(a: Int) = PartialA((b: Int) => apply(a, b))
}

Foo
Bar
copy
case class Bar(a: Int)(val b: Int)

equals
assert(Foo(1)(0) == Foo(1)(10))

def Bar(a: Int) = PartialA((b: Int) => Bar(a, b))

A
Foo
Bar
