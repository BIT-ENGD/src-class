trait Delta[A] {
  def apply(c: A)
}

abstract class ValueHolder {

  type Value
  type Event <: Delta[ValueHolder]

  def update(next: Value): Event = new UpdateEvent(next)
  // type mismatch;  found   : UpdateEvent[ValueHolder]
  // required: ValueHolder.this.Event
}

class UpdateEvent[C <: ValueHolder](next: C#Value) extends Delta[C] {

  def apply(c: C) = c.update(next)
  // type mismatch;  found   :
  // UpdateEvent.this.next.type (with underlying type C#Value)
  // required: c.Value
}

Delta[C]
C <: ValueHolder
Event <: Delta[ValueHolder]
c
C
c.Value
C#Value
class UpdateEvent[C <: ValueHolder, V <: C#Value](next: V) extends Delta[C] {

(ListBuffer[Int]:_).map(_.toString)

ListBuffer[String]
type Event
Event
UpdateEvent
class UpdateEvent[V, C <: ValueHolder { type Value = V }](
  next: V) extends Delta[C] { ... }

