system ::= equation { equation }

equation ::= variable "=" (arithExpr | param) "\n"

variable ::= algebraicVar | stateVar

algrebraicVar ::= identifier

stateVar ::= algebraicVar'

arithExpr ::= term { "+" term | "-" term }

term ::= factor { "*" factor | "/" factor }

factor ::= algebraicVar
          | powerExpr
          | floatingPointNumber
          | functionCall
          | "(" arithExpr ")"

powerExpr ::= arithExpr {"^" arithExpr}

functionCall
Cos[Omega]
package tests

import scala.util.parsing.combinator.lexical.StdLexical
import scala.util.parsing.combinator.syntactical.StandardTokenParsers
import scala.util.parsing.combinator._
import scala.util.parsing.combinator.JavaTokenParsers
import token._

object Parser1 extends StandardTokenParsers {

  lexical.delimiters ++= List("(", ")", "=", "+", "-", "*", "/", "\n")
  lexical.reserved ++= List(
    "Log", "Ln", "Exp",
    "Sin", "Cos", "Tan",
    "Cot", "Sec", "Csc",
    "Sqrt", "Param", "'")

  def system: Parser[Any] = repsep(equation, "\n")
  def equation: Parser[Any] = variable ~ "=" ~ ("Param" | arithExpr )
  def variable: Parser[Any] = stateVar | algebraicVar
  def algebraicVar: Parser[Any] = ident
  def stateVar: Parser[Any] = algebraicVar ~ "\'"
  def arithExpr: Parser[Any] = term ~ rep("+" ~ term | "-" ~ term)
  def term: Parser[Any] = factor ~ rep("*" ~ factor | "/" ~ factor)
  def factor: Parser[Any] = algebraicVar | floatingPointNumber | "(" ~ arithExpr ~ ")"
  def powerExpr: Parser[Any] = arithExpr ~ rep("^" ~ arithExpr)


  def main(args: Array[String]) {
    val code = "x1 = 2.5 * x2"
    equation(new lexical.Scanner(code)) match {
      case Success(msg, _) => println(msg)
      case Failure(msg, _) => println(msg)
      case Error(msg, _) => println(msg)
    }
  }
}

def factor: Parser[Any] = algebraicVar | floatingPointNumber | "(" ~ arithExpr ~ ")"

floatingPointNumber
lexical.reserved ++= List(
    "Log", "Ln", "Exp",
    "Sin", "Cos", "Tan",
    "Cot", "Sec", "Csc",
    "Sqrt", "Param", "'")

