become
// This is where I store information received by the actor
// In my real application it has more fields, though.
case class Information(list:List[AnyRef]) {
    def received(x:AnyRef) = {
        Information(list :+ x)
    }
}

class MyActor extends Actor {

    // Initial receive block that simply waits for a "start" signal
    def receive = {
        case Start => {
            become(waiting(Information(List())))
        }
    } 

    // The main waiting state. In my real application, I have multiple of
    // these which all have a parameter of type "Information"
    def waiting(info:Information):Receive = {

        // If a certain amount of messages was received, I decide what action
        // to take next.
        if(someCondition) {
            decideNextState(x)
        }

        return {
            case Bar(x) => {
                //
                // !!! Problem occurs here !!!
                //
                // This is where the problem occurs, apparently. After a decision has been
                // made, (i.e. decideNextState was invoked), the info list should've been
                // cleared. But when I check the size of the info list here, after a decision
                // has been made, it appears to still contain all the messages received
                // earlier.
                //
                become(waiting(info received x))
            }
        }
    }

    def decideNextState(info:Information) {
        // Some logic, then the received information list is cleared and 
        // we enter a new state.
        become(waiting((Information(List())))
    }
}

Receive
become
