  case class Work(list: List[Point])
  case class Reply(list: List[Point])

  class QueenWorker(val master: ActorRef) extends Actor {
        override def preStart() = {
      println("new worker")
    }
    def receive = {
      case Work(list) =>
        val len = list.length
        if (len < size) {
          val actors = for (
            i <- 0 until size if (!list.exists(_.y == i))
          ) yield (context.actorOf(Props(new QueenWorker(master))), i)
          actors.foreach { case (actor, pos) => actor ! Work(list :+ (new Point(len, pos))) }

   } else {
          if (check(list)) { //check() checks whether the solution is valid
            master ! Reply(list)
            println("solution found!")
          }
          //else sender ! Reply(List[List[Point]]())
        }
         //context.stop(self) //when do I have to use it?
         //println("worker stopped - len "+len)
    }
  }

  class QueenMaster extends Actor {
    override def preStart() = {
      println("preStart")
      context.actorOf(Props(new QueenWorker(self))) ! Work(List[Point]())
    }

      def receive = {//print solution to console
      case Reply(list) =>
        for (x <- 0 until size) {
          for (y <- 0 until size) {
            if (list.exists(p => p.x == x && p.y == y)) print("x ") else print("o ")
          }
          println()
        }
        println()
    }
  }

 def runParallel {
    val system = ActorSystem("QueenSystem")
    val queenMaster = system.actorOf(Props[QueenMaster])
  }

