class Tree(val id: Int) {
  override def hashCode = id
  override def equals(that: Any) = that.isInstanceOf[Tree] &&
    that.asInstanceOf[Tree].id == id

  case object EmptyValue
}

val t1 = new Tree(33)
val t2 = new Tree(33)

t1 == t2 // ok 
t1.EmptyValue == t2.EmptyValue // wrong -- reports 'false'

EmptyValue
def insert(point: Point, leaf: Leaf): Unit = {
  val qidx = hyperCube.indexOf(point)
  child(qidx) match {
    case EmptyValue => ...
    ...
  }
}

MatchError
Tree$EmptyValue$@4636
Tree$EmptyValue$@3601
case object
class Tree {
  sealed trait LeftChild
  case object  EmptyValue   extends LeftChild
  sealed trait LeftNonEmpty extends LeftChild
  final case class LeftChildBranch() extends LeftNonEmpty

  def testMatch1(l: LeftChild) = l match {
    case EmptyValue        => "empty"
    case LeftChildBranch() => "non-empty"
  }

  def testMatch2(l: LeftChild) = l match {
    case EmptyValue      => "empty"
    case n: LeftNonEmpty => "non-empty"
  }
}

val t1 = new Tree
val t2 = new Tree

t1.testMatch1(t2.LeftChildBranch().asInstanceOf[t1.LeftChild])       // works!!!
t1.testMatch2(t2.LeftChildBranch().asInstanceOf[t1.LeftChild])       // works!!!
t1.testMatch1(t2.EmptyValue.asInstanceOf       [t1.EmptyValue.type]) // fails

