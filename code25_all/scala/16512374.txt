sealed abstract class Method(name: String)

case object GET extends Method("GET")
case object POST extends Method("POST")

abstract class TRUE
abstract class FALSE

case class Builder[HasMethod, HasUri](
  method: Option[Method],
  uri: Option[String]) {

  def withMethod(method: Method): Builder[TRUE, HasUri] = copy(method = Some(method))
  def withUri(uri: String): Builder[HasMethod, TRUE] = copy(uri = Some(uri))
}

implicit val init: Builder[FALSE, FALSE] = Builder[FALSE, FALSE](None, None)

//Fluent examples
val b1: Builder[TRUE, FALSE] = init.withMethod(GET)
val b2: Builder[TRUE, TRUE] = init.withMethod(GET).withUri("bar")

Method
Builder
init
implicit def toMethod[HasUri](m: Method)
  (implicit builder: Builder[_, HasUri]): Builder[TRUE, HasUri] = builder.withMethod(m)

// ** ERROR **: could not find implicit value for parameter builder: 
//              Builder[_, HasUri]  
val b3: Builder[TRUE, TRUE] = GET withUri "foo"

// However the implicit parameter is discovered fine when function is called directly
val b4: Builder[TRUE, FALSE] = toMethod(GET)
val b5: Builder[TRUE, TRUE] = toMethod(GET) withUri "foo"

toMethod
build
Builder
url("http://api.service.org/person") apply { implicit b =>
  GET assert(Ok and ValidJson)
  GET / "john.doe" assert(NotFound)
  POST body johnDoeData assert(Ok)
  GET / "john.doe" assert(Ok and bodyIs(johnDoeData))
}

url
implicit b =>
assert
/
GET url("http://api.service.org/secure/person") apply { implicit b =>
  auth basic("harry", "password") assert(Ok and ValidJson)
  auth basic("sally", "password") assert(PermissionDenied)
}

