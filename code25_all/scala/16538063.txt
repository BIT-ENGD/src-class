utf-8
ISO-8859-1
{"to":"UTF-8","html":"ISO-8859-1","subject":"UTF-8","from":"UTF-8","text":"ISO-8859-1"}

    val charsets = extract(request.body.dataParts, "charsets", _.as[Charsets]).getOrElse(Charsets(Some(""), Some(""), Some(""), Some(""), Some("")))

    def extract[T](env: Map[String, Seq[String]], key: String, conv: JsValue => T): Option[T] = {
        env.get(key).flatMap(_.headOption).map(Json.parse).map(conv)
    }

    case class Charsets(to: Option[String], html: Option[String], subject: Option[String], from: Option[String], text: Option[String])

    object Charsets {
        implicit val charsetReads = Json.format[Charsets]
    }

handleDataPart
utf-8
def handleDataPart: PartHandler[Part] = {
    case headers @ Multipart.PartInfoMatcher(partName) if !Multipart.FileInfoMatcher.unapply(headers).isDefined =>
      Traversable.takeUpTo[Array[Byte]](DEFAULT_MAX_TEXT_LENGTH)
        .transform(Iteratee.consume[Array[Byte]]().map(bytes => DataPart(partName, new String(bytes, "utf-8"))))
        .flatMap { data =>
        Cont({
          case Input.El(_) => Done(MaxDataPartSizeExceeded(partName), Input.Empty)
          case in => Done(data, in)
        })
      }
  }

