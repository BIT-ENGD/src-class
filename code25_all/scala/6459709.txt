  case class MyClass(name: String)
  def getMyClass(id : String) = {
      //For now ignore the id field
      Some(Seq(MyClass("test1"), MyClass("test2"), MyClass("test3"), MyClass("test4"), MyClass("test5")))
  }

  def getHeader() = {
    Map(
      "n" -> List(Map("s"->"t"), Map("s"->"t"), Map("s"->"t")),
      "o" -> List(Map("s"->"t"), Map("s"->"t"), Map("s"->"t")),
      "id" -> "12345"
    )
  }
  def castToString(any: Option[Any]): Option[String] = {
    any match {
      case Some(value: String) => Some(value)
      case _ => None
    }
  }

  val h = getHeader()

  for{
    id <- castToString(h.get("id")) //I hate I have to do this but the map is a Map[String,Any]
    m <- getMyClass(id)  //This strips the Some from the Some(Seq[MyClass])
    item <- m     //XXXXXXXX Compile errors
    oList <- h.get("o")
    nList <- h.get("n")

  } yield {
    (oList, nList, item)
  }

C:\temp\s.scala:28: error: type mismatch;
 found   : Seq[(java.lang.Object, java.lang.Object, this.MyClass)]
 required: Option[?]
        item <- m
             ^

