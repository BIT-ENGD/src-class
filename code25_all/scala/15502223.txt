$ g8 ajhager/libgdx-sbt-project
package [my.game.pkg]: 
name [Game]: 
api_level [17]: 
scala_version [2.10.0]: 

Applied ajhager/libgdx-sbt-project.g8 in game

$ cd game
$ echo "sbt.version=0.12.2" > project/build.properties
$ sbt
Detected sbt version 0.12.2
Starting sbt: invoke with -help for other options
[info] Loading global plugins from /home/user/.sbt/plugins
[info] Loading project definition from /home/user/test2/game/project
[info] Updating {file:/home/user/test2/game/project/}default-f30402...
[info] Resolving org.scala-sbt#precompiled-2_10_0;0.12.2 ...
[info] Done updating.
[info] Compiling 1 Scala source to /home/user/test2/game/project/target/scala-2.9.2/sbt-0.12/classes...
[info] Set current project to android (in build file:/home/user/test2/game/)
> update-gdx
[info] Pulling libgdx-nightly-latest
[warn] This may take a few minutes...
[info] Extracting common libs
[info] Extracting desktop libs
[info] Extracting ios libs
[info] Extracting android libs
[info] Update complete
[success] Total time: 25 s, completed 19.03.2013 15:09:04
> project android
[info] Set current project to android (in build file:/home/user/test2/game/)
> android:start-device
[info] Updating {file:/home/user/test2/game/}android...                                                                                                                                                                                          
[info] Resolving org.scala-lang#scala-library;2.10.0 ...
[info] Done updating.                                                                                                                                                                                                                        
[info] Compiling 1 Scala source and 1 Java source to /home/user/test2/game/android/target/scala-2.10/classes...                                                                                                                                  
ProGuard, version 4.8                                                                                                                                                                                                                              
ProGuard is released under the GNU General Public License. You therefore                                                                                                                                                                           
must ensure that programs that link to it (org.scalasbt.androidplugin, ...)                                                                                                                                                                        
carry the GNU General Public License as well. Alternatively, you can                                                                                                                                                                               
apply for an exception with the author of ProGuard.                                                                                                                                                                                                
Reading program directory [/home/user/test2/game/android/target/scala-2.10/classes]                                                                                                                                                              
Reading program directory [/home/user/test2/game/common/target/scala-2.10/classes] (filtered)                                                                                                                                                    
Reading program jar [/home/user/test2/game/android/src/main/libs/gdx-backend-android.jar] (filtered)                                                                                                                                             
Reading program jar [/home/user/test2/game/common/lib/gdx.jar] (filtered)                                                                                                                                                                        
Reading program jar [/home/user/.sbt/boot/scala-2.10.0/lib/scala-library.jar] (filtered)                                                                                                                                                         
Reading library jar [/home/user/android-sdks/platforms/android-17/android.jar]                                                                                                                                                                   
Note: com.badlogic.gdx.scenes.scene2d.ui.TableToolkit accesses a method 'setWidget(com.badlogic.gdx.scenes.scene2d.Actor)' dynamically                                                                                                             
  Maybe this is program method 'com.badlogic.gdx.scenes.scene2d.ui.ScrollPane { void setWidget(com.badlogic.gdx.scenes.scene2d.Actor); }'
Note: scala.concurrent.forkjoin.ForkJoinPool accesses a declared field 'ctl' dynamically
  Maybe this is program field 'scala.concurrent.forkjoin.ForkJoinPool { long ctl; }'
Note: scala.concurrent.forkjoin.ForkJoinPool accesses a declared field 'parkBlocker' dynamically
Note: scala.concurrent.forkjoin.ForkJoinPool$WorkQueue accesses a declared field 'runState' dynamically
  Maybe this is program field 'scala.concurrent.forkjoin.ForkJoinPool { int runState; }'
  Maybe this is program field 'scala.concurrent.forkjoin.ForkJoinPool$WorkQueue { int runState; }'
Note: scala.concurrent.forkjoin.LinkedTransferQueue accesses a declared field 'head' dynamically
  Maybe this is program field 'com.badlogic.gdx.utils.PooledLinkedList { com.badlogic.gdx.utils.PooledLinkedList$Item head; }'
  Maybe this is program field 'scala.collection.immutable.ListSet$Node { java.lang.Object head; }'
  Maybe this is program field 'scala.concurrent.forkjoin.LinkedTransferQueue { scala.concurrent.forkjoin.LinkedTransferQueue$Node head; }'
  Maybe this is program field 'scala.util.parsing.combinator.PackratParsers$LR { scala.Option head; }'
Note: scala.concurrent.forkjoin.LinkedTransferQueue accesses a declared field 'tail' dynamically
  Maybe this is program field 'com.badlogic.gdx.utils.PooledLinkedList { com.badlogic.gdx.utils.PooledLinkedList$Item tail; }'
  Maybe this is program field 'scala.collection.Iterator$$anon$17 { scala.collection.Iterator tail; }'
  Maybe this is program field 'scala.concurrent.forkjoin.LinkedTransferQueue { scala.concurrent.forkjoin.LinkedTransferQueue$Node tail; }'
Note: scala.concurrent.forkjoin.LinkedTransferQueue accesses a declared field 'sweepVotes' dynamically
  Maybe this is program field 'scala.concurrent.forkjoin.LinkedTransferQueue { int sweepVotes; }'
Note: scala.concurrent.forkjoin.LinkedTransferQueue$Node accesses a declared field 'item' dynamically
  Maybe this is program field 'scala.concurrent.forkjoin.LinkedTransferQueue$Node { java.lang.Object item; }'
Note: scala.concurrent.forkjoin.LinkedTransferQueue$Node accesses a declared field 'next' dynamically
  Maybe this is program field 'com.badlogic.gdx.utils.PooledLinkedList$Item { com.badlogic.gdx.utils.PooledLinkedList$Item next; }'
  Maybe this is program field 'com.badlogic.gdx.utils.Predicate$PredicateIterator { java.lang.Object next; }'
  Maybe this is program field 'scala.collection.immutable.Page { scala.collection.immutable.Page next; }'
  Maybe this is program field 'scala.collection.immutable.RedBlackTree$TreeIterator { scala.collection.immutable.RedBlackTree$Tree next; }'
  Maybe this is program field 'scala.collection.mutable.DefaultEntry { java.lang.Object next; }'
  Maybe this is program field 'scala.collection.mutable.DoubleLinkedList { scala.collection.mutable.Seq next; }'
  Maybe this is program field 'scala.collection.mutable.LinkedEntry { java.lang.Object next; }'
  Maybe this is program field 'scala.collection.mutable.LinkedHashSet$Entry { java.lang.Object next; }'
  Maybe this is program field 'scala.collection.mutable.LinkedList { scala.collection.mutable.Seq next; }'
  Maybe this is program field 'scala.collection.mutable.OpenHashMap$OpenEntry { java.lang.Object next; }'
  Maybe this is program field 'scala.collection.mutable.UnrolledBuffer$Unrolled { scala.collection.mutable.UnrolledBuffer$Unrolled next; }'
  Maybe this is program field 'scala.collection.parallel.AdaptiveWorkStealingForkJoinTasks$WrappedTask { scala.collection.parallel.AdaptiveWorkStealingTasks$WrappedTask next; }'
  Maybe this is program field 'scala.collection.parallel.AdaptiveWorkStealingThreadPoolTasks$WrappedTask { scala.collection.parallel.AdaptiveWorkStealingTasks$WrappedTask next; }'
  Maybe this is program field 'scala.concurrent.Channel$LinkedList { scala.concurrent.Channel$LinkedList next; }'
  Maybe this is program field 'scala.concurrent.forkjoin.ForkJoinTask$ExceptionNode { scala.concurrent.forkjoin.ForkJoinTask$ExceptionNode next; }'
  Maybe this is program field 'scala.concurrent.forkjoin.LinkedTransferQueue$Node { scala.concurrent.forkjoin.LinkedTransferQueue$Node next; }'
  Maybe this is program field 'scala.reflect.NameTransformer$OpCodes { scala.reflect.NameTransformer$OpCodes next; }'
  Maybe this is program field 'scala.runtime.PolyMethodCache { scala.runtime.MethodCache next; }'
  Maybe this is program field 'scala.util.parsing.combinator.Parsers$NoSuccess { scala.util.parsing.input.Reader next; }'
  Maybe this is program field 'scala.util.parsing.combinator.Parsers$Success { scala.util.parsing.input.Reader next; }'
  Maybe this is program field 'scala.xml.PrefixedAttribute { scala.xml.MetaData next; }'
  Maybe this is program field 'scala.xml.UnprefixedAttribute { scala.xml.MetaData next; }'
Note: scala.concurrent.forkjoin.LinkedTransferQueue$Node accesses a declared field 'waiter' dynamically
  Maybe this is program field 'scala.concurrent.forkjoin.LinkedTransferQueue$Node { java.lang.Thread waiter; }'
Note: the configuration keeps the entry point 'com.badlogic.gdx.Game { void setScreen(com.badlogic.gdx.Screen); }', but not the descriptor class 'com.badlogic.gdx.Screen'
Note: the configuration keeps the entry point 'com.badlogic.gdx.backends.android.AndroidApplication { void initialize(com.badlogic.gdx.ApplicationListener,boolean); }', but not the descriptor class 'com.badlogic.gdx.ApplicationListener'
Note: the configuration keeps the entry point 'com.badlogic.gdx.backends.android.AndroidApplication { void initialize(com.badlogic.gdx.ApplicationListener,com.badlogic.gdx.backends.android.AndroidApplicationConfiguration); }', but not the descriptor class 'com.badlogic.gdx.ApplicationListener'
Note: the configuration keeps the entry point 'com.badlogic.gdx.backends.android.AndroidApplication { android.view.View initializeForView(com.badlogic.gdx.ApplicationListener,boolean); }', but not the descriptor class 'com.badlogic.gdx.ApplicationListener'
Note: the configuration keeps the entry point 'com.badlogic.gdx.backends.android.AndroidApplication { android.view.View initializeForView(com.badlogic.gdx.ApplicationListener,com.badlogic.gdx.backends.android.AndroidApplicationConfiguration); }', but not the descriptor class 'com.badlogic.gdx.ApplicationListener'
Note: the configuration keeps the entry point 'com.badlogic.gdx.backends.android.AndroidApplication { void addLifecycleListener(com.badlogic.gdx.LifecycleListener); }', but not the descriptor class 'com.badlogic.gdx.LifecycleListener'
Note: the configuration keeps the entry point 'com.badlogic.gdx.backends.android.AndroidApplication { void removeLifecycleListener(com.badlogic.gdx.LifecycleListener); }', but not the descriptor class 'com.badlogic.gdx.LifecycleListener'
Note: the configuration keeps the entry point 'com.badlogic.gdx.backends.android.AndroidAudio { com.badlogic.gdx.audio.Music newMusic(com.badlogic.gdx.files.FileHandle); }', but not the descriptor class 'com.badlogic.gdx.files.FileHandle'
Note: the configuration keeps the entry point 'com.badlogic.gdx.backends.android.AndroidAudio { com.badlogic.gdx.audio.Sound newSound(com.badlogic.gdx.files.FileHandle); }', but not the descriptor class 'com.badlogic.gdx.files.FileHandle'
Note: the configuration keeps the entry point 'com.badlogic.gdx.backends.android.AndroidDaydream { void initialize(com.badlogic.gdx.ApplicationListener,boolean); }', but not the descriptor class 'com.badlogic.gdx.ApplicationListener'
Note: the configuration keeps the entry point 'com.badlogic.gdx.backends.android.AndroidDaydream { void initialize(com.badlogic.gdx.ApplicationListener,com.badlogic.gdx.backends.android.AndroidApplicationConfiguration); }', but not the descriptor class 'com.badlogic.gdx.ApplicationListener'
Note: the configuration keeps the entry point 'com.badlogic.gdx.backends.android.AndroidDaydream { android.view.View initializeForView(com.badlogic.gdx.ApplicationListener,boolean); }', but not the descriptor class 'com.badlogic.gdx.ApplicationListener'
Note: the configuration keeps the entry point 'com.badlogic.gdx.backends.android.AndroidDaydream { android.view.View initializeForView(com.badlogic.gdx.ApplicationListener,com.badlogic.gdx.backends.android.AndroidApplicationConfiguration); }', but not the descriptor class 'com.badlogic.gdx.ApplicationListener'
Note: the configuration keeps the entry point 'com.badlogic.gdx.backends.android.AndroidDaydream { void addLifecycleListener(com.badlogic.gdx.LifecycleListener); }', but not the descriptor class 'com.badlogic.gdx.LifecycleListener'
Note: the configuration keeps the entry point 'com.badlogic.gdx.backends.android.AndroidDaydream { void removeLifecycleListener(com.badlogic.gdx.LifecycleListener); }', but not the descriptor class 'com.badlogic.gdx.LifecycleListener'
Note: the configuration keeps the entry point 'com.badlogic.gdx.backends.android.AndroidFileHandle { AndroidFileHandle(android.content.res.AssetManager,java.lang.String,com.badlogic.gdx.Files$FileType); }', but not the descriptor class 'com.badlogic.gdx.Files$FileType'
Note: the configuration keeps the entry point 'com.badlogic.gdx.backends.android.AndroidFileHandle { AndroidFileHandle(android.content.res.AssetManager,java.io.File,com.badlogic.gdx.Files$FileType); }', but not the descriptor class 'com.badlogic.gdx.Files$FileType'
Note: the configuration keeps the entry point 'com.badlogic.gdx.backends.android.AndroidFiles { com.badlogic.gdx.files.FileHandle getFileHandle(java.lang.String,com.badlogic.gdx.Files$FileType); }', but not the descriptor class 'com.badlogic.gdx.Files$FileType'
Note: the configuration keeps the entry point 'com.badlogic.gdx.backends.android.AndroidGraphics { boolean setDisplayMode(com.badlogic.gdx.Graphics$DisplayMode); }', but not the descriptor class 'com.badlogic.gdx.Graphics$DisplayMode'
Note: the configuration keeps the entry point 'com.badlogic.gdx.backends.android.AndroidGraphicsDaydream { boolean setDisplayMode(com.badlogic.gdx.Graphics$DisplayMode); }', but not the descriptor class 'com.badlogic.gdx.Graphics$DisplayMode'
Note: the configuration keeps the entry point 'com.badlogic.gdx.backends.android.AndroidGraphicsLiveWallpaper { boolean setDisplayMode(com.badlogic.gdx.Graphics$DisplayMode); }', but not the descriptor class 'com.badlogic.gdx.Graphics$DisplayMode'
Note: the configuration keeps the entry point 'com.badlogic.gdx.backends.android.AndroidInput { AndroidInput(com.badlogic.gdx.Application,android.content.Context,java.lang.Object,com.badlogic.gdx.backends.android.AndroidApplicationConfiguration); }', but not the descriptor class 'com.badlogic.gdx.Application'
Note: the configuration keeps the entry point 'com.badlogic.gdx.backends.android.AndroidInput { void getTextInput(com.badlogic.gdx.Input$TextInputListener,java.lang.String,java.lang.String); }', but not the descriptor class 'com.badlogic.gdx.Input$TextInputListener'
Note: the configuration keeps the entry point 'com.badlogic.gdx.backends.android.AndroidInput { void getPlaceholderTextInput(com.badlogic.gdx.Input$TextInputListener,java.lang.String,java.lang.String); }', but not the descriptor class 'com.badlogic.gdx.Input$TextInputListener'
Note: the configuration keeps the entry point 'com.badlogic.gdx.backends.android.AndroidInput { void setInputProcessor(com.badlogic.gdx.InputProcessor); }', but not the descriptor class 'com.badlogic.gdx.InputProcessor'
Note: the configuration keeps the entry point 'com.badlogic.gdx.backends.android.AndroidInput { boolean isPeripheralAvailable(com.badlogic.gdx.Input$Peripheral); }', but not the descriptor class 'com.badlogic.gdx.Input$Peripheral'
Note: the configuration keeps the entry point 'com.badlogic.gdx.backends.android.AndroidInput$3 { AndroidInput$3(com.badlogic.gdx.backends.android.AndroidInput,java.lang.String,java.lang.String,com.badlogic.gdx.Input$TextInputListener); }', but not the descriptor class 'com.badlogic.gdx.Input$TextInputListener'
Note: the configuration keeps the entry point 'com.badlogic.gdx.backends.android.AndroidInput$4 { AndroidInput$4(com.badlogic.gdx.backends.android.AndroidInput,java.lang.String,java.lang.String,com.badlogic.gdx.Input$TextInputListener); }', but not the descriptor class 'com.badlogic.gdx.Input$TextInputListener'
Note: the configuration keeps the entry point 'com.badlogic.gdx.backends.android.AndroidInput$SensorListener { AndroidInput$SensorListener(com.badlogic.gdx.backends.android.AndroidInput,com.badlogic.gdx.Input$Orientation,float[],float[]); }', but not the descriptor class 'com.badlogic.gdx.Input$Orientation'
Note: the configuration keeps the entry point 'com.badlogic.gdx.backends.android.AndroidInputFactory { com.badlogic.gdx.backends.android.AndroidInput newAndroidInput(com.badlogic.gdx.Application,android.content.Context,java.lang.Object,com.badlogic.gdx.backends.android.AndroidApplicationConfiguration); }', but not the descriptor class 'com.badlogic.gdx.Application'
Note: the configuration keeps the entry point 'com.badlogic.gdx.backends.android.AndroidInputThreePlus { AndroidInputThreePlus(com.badlogic.gdx.Application,android.content.Context,java.lang.Object,com.badlogic.gdx.backends.android.AndroidApplicationConfiguration); }', but not the descriptor class 'com.badlogic.gdx.Application'
Note: the configuration keeps the entry point 'com.badlogic.gdx.backends.android.AndroidLiveWallpaper { void initialize(com.badlogic.gdx.ApplicationListener,com.badlogic.gdx.backends.android.AndroidApplicationConfiguration); }', but not the descriptor class 'com.badlogic.gdx.ApplicationListener'
Note: the configuration keeps the entry point 'com.badlogic.gdx.backends.android.AndroidLiveWallpaper { void addLifecycleListener(com.badlogic.gdx.LifecycleListener); }', but not the descriptor class 'com.badlogic.gdx.LifecycleListener'
Note: the configuration keeps the entry point 'com.badlogic.gdx.backends.android.AndroidLiveWallpaper { void removeLifecycleListener(com.badlogic.gdx.LifecycleListener); }', but not the descriptor class 'com.badlogic.gdx.LifecycleListener'
Note: the configuration keeps the entry point 'com.badlogic.gdx.backends.android.AndroidLiveWallpaperService { void offsetChange(com.badlogic.gdx.ApplicationListener,float,float,float,float,int,int); }', but not the descriptor class 'com.badlogic.gdx.ApplicationListener'
Note: the configuration keeps the entry point 'com.badlogic.gdx.backends.android.AndroidNet { void sendHttpRequest(com.badlogic.gdx.Net$HttpRequest,com.badlogic.gdx.Net$HttpResponseListener); }', but not the descriptor class 'com.badlogic.gdx.Net$HttpRequest'
Note: the configuration keeps the entry point 'com.badlogic.gdx.backends.android.AndroidNet { void sendHttpRequest(com.badlogic.gdx.Net$HttpRequest,com.badlogic.gdx.Net$HttpResponseListener); }', but not the descriptor class 'com.badlogic.gdx.Net$HttpResponseListener'
Note: the configuration keeps the entry point 'com.badlogic.gdx.backends.android.AndroidNet { com.badlogic.gdx.net.ServerSocket newServerSocket(com.badlogic.gdx.Net$Protocol,int,com.badlogic.gdx.net.ServerSocketHints); }', but not the descriptor class 'com.badlogic.gdx.Net$Protocol'
Note: the configuration keeps the entry point 'com.badlogic.gdx.backends.android.AndroidNet { com.badlogic.gdx.net.ServerSocket newServerSocket(com.badlogic.gdx.Net$Protocol,int,com.badlogic.gdx.net.ServerSocketHints); }', but not the descriptor class 'com.badlogic.gdx.net.ServerSocketHints'
Note: the configuration keeps the entry point 'com.badlogic.gdx.backends.android.AndroidNet { com.badlogic.gdx.net.Socket newClientSocket(com.badlogic.gdx.Net$Protocol,java.lang.String,int,com.badlogic.gdx.net.SocketHints); }', but not the descriptor class 'com.badlogic.gdx.Net$Protocol'
Note: the configuration keeps the entry point 'com.badlogic.gdx.backends.android.AndroidNet { com.badlogic.gdx.net.Socket newClientSocket(com.badlogic.gdx.Net$Protocol,java.lang.String,int,com.badlogic.gdx.net.SocketHints); }', but not the descriptor class 'com.badlogic.gdx.net.SocketHints'
Note: the configuration keeps the entry point 'com.badlogic.gdx.backends.android.AndroidServerSocket { AndroidServerSocket(com.badlogic.gdx.Net$Protocol,int,com.badlogic.gdx.net.ServerSocketHints); }', but not the descriptor class 'com.badlogic.gdx.Net$Protocol'
Note: the configuration keeps the entry point 'com.badlogic.gdx.backends.android.AndroidServerSocket { AndroidServerSocket(com.badlogic.gdx.Net$Protocol,int,com.badlogic.gdx.net.ServerSocketHints); }', but not the descriptor class 'com.badlogic.gdx.net.ServerSocketHints'
Note: the configuration keeps the entry point 'com.badlogic.gdx.backends.android.AndroidServerSocket { com.badlogic.gdx.net.Socket accept(com.badlogic.gdx.net.SocketHints); }', but not the descriptor class 'com.badlogic.gdx.net.SocketHints'
Note: the configuration keeps the entry point 'com.badlogic.gdx.backends.android.AndroidSocket { AndroidSocket(com.badlogic.gdx.Net$Protocol,java.lang.String,int,com.badlogic.gdx.net.SocketHints); }', but not the descriptor class 'com.badlogic.gdx.Net$Protocol'
Note: the configuration keeps the entry point 'com.badlogic.gdx.backends.android.AndroidSocket { AndroidSocket(com.badlogic.gdx.Net$Protocol,java.lang.String,int,com.badlogic.gdx.net.SocketHints); }', but not the descriptor class 'com.badlogic.gdx.net.SocketHints'
Note: the configuration keeps the entry point 'com.badlogic.gdx.backends.android.AndroidSocket { AndroidSocket(java.net.Socket,com.badlogic.gdx.net.SocketHints); }', but not the descriptor class 'com.badlogic.gdx.net.SocketHints'
Note: the configuration keeps the entry point 'com.badlogic.gdx.backends.android.AndroidSocket { void applyHints(com.badlogic.gdx.net.SocketHints); }', but not the descriptor class 'com.badlogic.gdx.net.SocketHints'
Note: the configuration keeps the entry point 'com.badlogic.gdx.files.FileHandle { FileHandle(java.lang.String,com.badlogic.gdx.Files$FileType); }', but not the descriptor class 'com.badlogic.gdx.Files$FileType'
Note: the configuration keeps the entry point 'com.badlogic.gdx.files.FileHandle { FileHandle(java.io.File,com.badlogic.gdx.Files$FileType); }', but not the descriptor class 'com.badlogic.gdx.Files$FileType'
Note: the configuration keeps the entry point 'com.badlogic.gdx.files.FileHandle { void copyTo(com.badlogic.gdx.files.FileHandle); }', but not the descriptor class 'com.badlogic.gdx.files.FileHandle'
Note: the configuration keeps the entry point 'com.badlogic.gdx.files.FileHandle { void moveTo(com.badlogic.gdx.files.FileHandle); }', but not the descriptor class 'com.badlogic.gdx.files.FileHandle'
Note: the configuration keeps the entry point 'com.badlogic.gdx.files.FileHandle { void copyFile(com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.files.FileHandle); }', but not the descriptor class 'com.badlogic.gdx.files.FileHandle'
Note: the configuration keeps the entry point 'com.badlogic.gdx.files.FileHandle { void copyFile(com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.files.FileHandle); }', but not the descriptor class 'com.badlogic.gdx.files.FileHandle'
Note: the configuration keeps the entry point 'com.badlogic.gdx.files.FileHandle { void copyDirectory(com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.files.FileHandle); }', but not the descriptor class 'com.badlogic.gdx.files.FileHandle'
Note: the configuration keeps the entry point 'com.badlogic.gdx.files.FileHandle { void copyDirectory(com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.files.FileHandle); }', but not the descriptor class 'com.badlogic.gdx.files.FileHandle'
Note: the configuration keeps the entry point 'com.badlogic.gdx.utils.Pool { void freeAll(com.badlogic.gdx.utils.Array); }', but not the descriptor class 'com.badlogic.gdx.utils.Array'
Note: there were 57 unkept descriptor classes in kept class members.
  You should consider explicitly keeping the mentioned classes
  (using '-keep').
Note: there were 10 accesses to class members by means of introspection.
  You should consider explicitly keeping the mentioned class members
  (using '-keep' or '-keepclassmembers').
Note: You're ignoring all warnings!
Preparing output jar [/home/user/test2/game/android/target/classes.min.jar]
  Copying resources from program directory [/home/user/test2/game/android/target/scala-2.10/classes]
  Copying resources from program directory [/home/user/test2/game/common/target/scala-2.10/classes] (filtered)
  Copying resources from program jar [/home/user/test2/game/android/src/main/libs/gdx-backend-android.jar] (filtered)
  Copying resources from program jar [/home/user/test2/game/common/lib/gdx.jar] (filtered)
  Copying resources from program jar [/home/user/.sbt/boot/scala-2.10.0/lib/scala-library.jar] (filtered)
[info] Dexing /home/user/test2/game/android/target/classes.dex
    (skipping file '.gitkeep' due to ANDROID_AAPT_IGNORE pattern '.*')
[info] Packaging /home/user/test2/game/android/target/android-1.0.apk

sbt
>project desktop
>run

[error] ERROR: ld.so: object '/opt/lib/libmediaclient.so' from /etc/ld.so.preload cannot be preloaded: ignored.
[error] error: device not found
[error] - waiting for device -

sbt android:start-device

$ ps aux|grep adb
user    3293  0.0  0.0   4960  1168 pts/1    S+   15:37   0:00 /home/user/androidsdks/platform-tools/adb -d install -r  /home/user/test2/game/android/target/android-1.0.apk
user    3297  0.0  0.0  22376  1500 pts/1    Sl+  15:37   0:00 adb fork-server server
user    3298  0.0  0.0      0     0 pts/1    Z+   15:37   0:00 [adb] <defunct>

adb kill-server
adb start-server
sbt android:start-device

