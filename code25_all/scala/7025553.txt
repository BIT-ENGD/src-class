val m: Map[x.type#S, x.type#S] forSome { val x: T }
val m: Map[t#S, t#S] forSome { type t <: T with Singleton }
trait Type {
  type S
}

class Concrete extends Type {
  type S = Double
}

trait BaseWorks {
  type T <: Type
  val m: t#S forSome { type t <: T with Singleton }
}

class Works extends BaseWorks {
  override type T = Concrete
  override val m = 0.0
}

trait BaseError {
  type T <: Type
  val m: x.type#S forSome { val x: T }
}

class Error extends BaseError {
  override type T = Concrete
  override val m = 0.0
}

BaseWorks
BaseError
error: overriding value m in trait BaseError of type Error.this.x.S forSome { val x: => Error.this.T }; value m has incompatible type
f2
Derived
abstract trait Type {
  type T1
  type T2
  type P = (T1, T2)
}

class ConcreteType extends Type {
  type T1 = Double
  type T2 = Double
}

abstract class Base {
  type T <: Type
  type TP = T#P
  def f1(v: TP): TP
  def f2(v: T#P): T#P
  def f3(v: T#P): T#P
}

class Derived extends Base {
  override type T = ConcreteType
  override def f1(v: TP): TP = v
  override def f2(v: T#P): T#P = v
  override def f3(v: TP): TP = v
}

f3
