trait DocDB[O] {
    def searchFor[I] (docs: Iterable[I], queryStrategy: QueryStrategy[I, DocDB[_]]): Iterable[(I,O)]
}
trait QueryStrategy[I, +F <: DocDB[_]]

class In  // class of input documents
class Out // class of output documents
// MyDocDB
object MyDocDB extends DocDB[Out] {
    def searchFor[I] (docs: Iterable[I], queryStrategy: QueryStrategy[I, DocDB[_]]) = List()
}
// MyQueryStrategy for In and MyDocDB
implicit object MyQueryStrategy extends QueryStrategy[In, MyDocDB.type]

implicit def listExt[I] (items: Iterable[I]) = new {
    def findAt[O, F <: DocDB[O]](docDB: F) = new {
        def apply(implicit queryStrategy: QueryStrategy[I, F]): Iterable[(I,O)] = {
            docDB.searchFor[I](items, queryStrategy)
        }
    }
}

val out1: Iterable[(In, Out)] = List[In]() findAt MyDocDB

error: inferred type arguments [Nothing,test.StackOverflow.MyDocDB.type] do not conform to method findAt's type parameter bounds [O,F <: test.StackOverflow.DocDB[O]]
val out1: Iterable[(In, Out)] = List[In]() findAt MyDocDB

Nothing
Out
O
Out
val out2: Iterable[(In, Out)] = List[In]().findAt[Out, MyDocDB.type](MyDocDB).apply(MyQueryStrategy)

implicit def listExt[I] (items: Iterable[I]) = new {
    def findAt[F <: DocDB](docDB: F)(implicit queryStrategy: QueryStrategy[I, F]): Iterable[(I,F#O)] = {
        docDB.searchFor[I](items, queryStrategy)
    }
}

val out1: Iterable [(In,Out)] = List[In]() findAt MyDocDB

