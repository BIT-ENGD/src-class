class Circle (x: Float, y: Float, subdivisions: Int, radius: Float) extends WorldObject(x, y) {

  def subs = subdivisions
  def r = radius
  val d = r + r

  def makePoints() : List[Glyph] = { 
    val step = PConstants.TWO_PI / subdivisions
    val points = List.make(subdivisions, new Glyph())

    for(i <- 0 to subdivisions - 1) {
      points(i) position (PApplet.cos(step * i) * r + xPos, PApplet.sin(step * i) * r + yPos)
    }

    points
  }

  val points: List[Glyph] = makePoints()

  override def draw() {
    applet fill 0
    applet stroke 255
    applet ellipse(x, y, d, d)
    applet fill 255

    points map(_.update())
  }

}

class Glyph(x: Float, y: Float) extends WorldObject(x, y){
    def this() = this(0, 0)

    override def draw() {
      applet ellipse(xPos, yPos, 10, 10)
    }
}

object WorldObject {

}

abstract class WorldObject(var xPos: Float, var yPos: Float) {
  def this() = this(0, 0)
  def x = xPos
  def y = yPos

  def update() {
    draw()
  }

  def draw()

  def position(x: Float, y: Float) {
    xPos = x
    yPos = y
  }

  def move(dx: Float, dy: Float) {
    xPos += dx
    yPos += dy
  }
}

println
makePoints()
Circle.draw()
makePoints()
x=430.9017 y=204.89435
x=400 y=300
fill
make
make
fill
make
fill
  /** Create a list containing several copies of an element.
   *
   *  @param n    the length of the resulting list
   *  @param elem the element composing the resulting list
   *  @return     a list composed of n elements all equal to elem
   */
  @deprecated("use `fill' instead", "2.8.0")
  def make[A](n: Int, elem: A): List[A] = {
    val b = new ListBuffer[A]
    var i = 0
    while (i < n) {
      b += elem
      i += 1
    }
    b.toList
  }

fill
  /** Produces a $coll containing the results of some element computation a number of times.
   *  @param   n  the number of elements contained in the $coll.
   *  @param   elem the element computation
   *  @return  A $coll that contains the results of `n` evaluations of `elem`.
   */
  def fill[A](n: Int)(elem: => A): CC[A] = {
    val b = newBuilder[A]
    b.sizeHint(n)
    var i = 0
    while (i < n) {
      b += elem
      i += 1
    }
    b.result
  }

