ParseSMSPlans (STRING sDir)
{
STRING sFile;
STRING sDirSMSPlan = sDir + "sms_plans\";
STRING sDirPlan = sDir + "plan\";
STRING sDirDeal = sDir + "deal\";
STRING sDirProduct = sDir + "product\";
STRING sLine, sType, sName;
HFILE hIn;
FILEINFO fiFile;
LIST OF FILEINFO lfInfo = SYS_GetDirContents (sDirSMSPlan);
       ...
}

my $grammar = q{

#-----------------identifiers and datatypes-------------------#

    identifier : /[a-z]\w+/
    binops : '+' | '-' | '/' | '*' | '%' | '**'
    lbinops: '!' | '<' | '>' | '>='| '<='| '&&'| '||' | '=='
    integer: /\d+/ {print "hello $item[-1]" if $::debugging;}
    number : /(\d+|\d*\.\d+)/ {print "hello $item[-1]" if $::debugging;}
    string : /"(([^"]*)(\\")?)*"/
    operation : number binops number operation(s?)
    datatype : /[a-zA-Z]\w*/
    definition : datatype expression(s) #{print "hello $item[-1]" if $::debugging;}
                |datatype expression(s) "=" expression(s) #{print "hello $item[-1] = $item[-2]" if $::debugging;}
    statement : ifexp | elsexp | elseifexp |forexp | feachexp | whexp | swcexp


#------------------Expressed Values-----------------------------#
    program : expression
    expression :  number {print $item[1] if $::debugging}
                | integer
                | assignment
                | operation
                | identifier binops expression
                | number binops expression

#------------------Conditionals---------------------------------------#

    ifexp  : 'if' '(' expression(s) ')' '{' expression(s) '}' elsexp(?)
    elsexp : 'else' '{' expression(s) '}'
    elseifexp: 'else' 'if' '(' expression(s) ')' '{' expression(s) '}'
    forexp : 'for' '(' expression ';' expression ';' expression ')' '{' expression(s)  }'
           | 'for' assignment 'to' number expression(s) | 'for' assignment 'to' number '{' expression(s) '}'
    feachexp : 'for each' expression 'in' expression '{' expression(s) '}'
    whexp  : 'while' '(' expression ')' '{' expression(s) '}'
    casest : 'case' expression(s /,/) ':'
    swcexp : 'switch' identifier '{' casest(s) '}' expression(s) 'default'
    assignment : identifier(s) '=' expression
};

