for $input (@inputs) {
  push @threads, start_thread($input);
}

for $thread (@threads) {
   wait_for_external_event();
   $thread->kick_thread_out_of_loop();
   $result = $thread->result();
   print $result;
}

sub my_thread {
  my $input = shift;
  while(1) {
    my $result = compute($best_result_so_far,$input);
    if($result > $best_result_so_far) {
      $best_result_so_far = $result;
    }
  }
  # The thread got kicked out of the loop
  return $best_result_so_far;
  do_some_cleanup_that_is_slow();
  exit thread;
}

for $input (@inputs) {
  push @threads, start_thread($input);
}

for $thread (@threads) {
   wait_for_external_event();
   $result = $thread->result();
   $thread->kill("KILL");
   print $result;
}

package ThreadObj;

sub my_thread {
  my $self = shift;
  my $input = shift;

  local $SIG{KILL} = sub {
    do_slow_cleanup();
    threads->exit();
  };

  while(1) {
    my $result = compute($best_result_so_far,$input);
    if($result > $self->{'best_result_so_far'}) {
      $self->{'best_result_so_far'} = $result;
    }
  }
}

sub result {
  my $self = shift;
  wait until (defined $self->{'best_result_so_far'});
  return $self->{'best_result_so_far'};
}

