use strict;
my %Hash = ();
my $logName = "MyLogName.Log";
open (LOG, '<', $logName) or die ("Couldn't open log ".$logName);

while (my $line = <LOG>) {
  chomp $line;
  if ($line =~ m/.*-t\s+(.+?),\s+(.+?)$/ix) {
    # This print statement shows that I have correctly extracted what I want.
    print ("Key::".$1."::Value::".$2."\n");
    my $key = $1;
    chomp $key;
    my $value = $2;
    chomp $value;
    $Hash{$key} = $value;

  }
}
close LOG;

#This shows the hash has been filled correctly. It shows all the keys and values
# I expect to see.
while ( (my $newkey, my @newvalue) = each %Tests) {
  print "Key##".$newkey."##NewValue:".$Tests{$newkey}."\n";
}

open (FILE, '<', "file.csv') or die ("Couldn't open csv file");

while (my $newLine = <FILE>) {
  chomp $newLine;
  if ($newLine =~ m/^(.+?),\s+(.+?)\s*?(.+?)$/ix) {
    #This print statment verifies I've captured them correctly
    print $1."::".$2."::".$3."\n";
    my $val1 = $1;
    my $val2 = $2;  #This is the same as the key in %Hash
    my $val3 = $3;
    #For good measure... 
    print $val1."::".$val2."::".$val3."\n";

    my $oldVal = $Hash{$val2};
    print "oldVal::".$Hash{$val2}." ";  #This line prints only the space
    print "\$oldVal::".$oldVal."\n";    #This line prints only the newline

    # Intent: put oldVal, val1, and val3 in an array and replace the old value
    # in %Hash with the array, so I'd have a hash of arrays. 
  }
}
close FILE;

