#!/usr/bin/perl -w

use strict;
use Util;
use Heap;
use HuffTree;

my $heap = Heap->new;
my $test = 3;
$heap->add($test); # <--------ERROR HERE-----------

package Heap;

use strict;
use warnings;

use POSIX ();

sub new {
  my $class = shift;
  my $self = { "aref" => [""],
           "next" => 1,
           @_};
  bless $self, $class;
}


sub print {
  my $self = shift;
  my $next = $self->{"next"};
  my $aref = $self->{"aref"};
  print "array => @$aref\n";
  print "next => $next\n";
}


sub compare {
  my ($self, $i, $j) = @_;
  my $x = $self->{"aref"}[$i];
  my $y = $self->{"aref"}[$j];

  if (!defined $x) {
    if (!defined $y) {
      return 0;
    } else {
      return -1;
    }
  }
  return 1 if !defined $y;
  return $x->priority <=> $y->priority;
}


sub swap {
  my ($self, $i, $j) = @_;
  my $aref = $self->{"aref"};
  ($aref->[$i], $aref->[$j]) = ($aref->[$j], $aref->[$i]);
}


sub add {
  my ($self, $value) = @_;
  my $i = $self->{"next"};
  $self->{"aref"}[$i] = $value;

  while ($i > 1) {
    my $parent = POSIX::floor($i/2);
    last if $self->compare($i, $parent) <= 0;
    $self->swap($i, $parent);
    $i = $parent;
  }
  $self->{"next"}++;
}


sub reheapify {
  my ($self, $i) = @_;
  my $left = 2 * $i;
  my $right = 2 * $i + 1;

  my $winleft = $self->compare($i, $left) >= 0;
  my $winright = $self->compare($i, $right) >= 0;
  return if $winleft and $winright;

  if ($self->compare ($left, $right) > 0) {
    $self->swap($i, $left);
    $self->reheapify($left);
  } else {
    $self->swap($i, $right);
    $self->reheapify($right);
  }
}


sub remove {
  my $self = shift;
  my $aref = $self->{"aref"};

  my $result = $aref->[1];
  $aref->[1] = pop @$aref;
  $self->{"next"}--;

  $self->reheapify(1);
  return $result;
}


sub empty {
  my $self = shift;
  return $self->{"next"} == 1;
}

1;

package HuffTree;

    use warnings;
    use strict;

use Pair;
our @ISA = "Pair";


sub priority {
  my $self = shift;

  # lowest count highest priority
  return -$self->{frequency}; 
}


sub left {
  my $self = shift;
  return $self->{left};
}


sub right {
  my $self = shift;
  return $self->{right};
}

1;

package Pair;

use warnings;
use strict;

sub new {
  my $class = shift;
  my $self = { @_ };
  bless $self, $class;
}


sub letter {
  my $self = shift;
  return $self->{letter};
}


sub frequency {
  my $self = shift;
  return $self->{frequency};
}


sub priority {
  my $self = shift;
  return $self->{frequency};
}

1;

package Util;

use strict;
use warnings;

sub croak { die "$0: @_: $!\n"; }


sub load_arg_file {
  my $path_name = shift @ARGV;
  my $fh;
  open($fh, $path_name) || croak "File not found.\n";
  return $fh;
}

1;

