lazy
builders
coerce
package My::Foo;
use Moose;
has x => (
    is => 'rw',
    isa => 'ArrayRef | Int',
    required => 1
);

around "x" => sub {
    my $orig = shift;
    my $self = shift;
    my $val = $self->$orig(@_);
    unless(ref($val)) {
        # Do the cocerion
        $val = [ map { 1 } 1..$val ];
        sleep(1); # in my case this is expensive
    }
    return $val;
}; 
1;

my $foo = My::Foo->new( x => 4 );
is_deeply $foo->x, [ 1, 1, 1, 1 ], "x converted from int to array at call time";

package My::ArrayFromInt;
use Moose;
use Moose::Util::TypeConstraints;
subtype 'My::ArrayFromInt::Inner',
    as 'ArrayRef[Int]';
coerce 'My::ArrayFromInt::Inner',
    from 'Int',
    via { return [ (1) x $_ ] };
has uncoerced => (is => 'rw', isa => 'Any', required => 1); 
has value => (
    is      => 'rw',
    isa     => 'My::ArrayFromInt::Inner',
    builder => '_buildValue',
    lazy    => 1,
    coerce  => 1
);
sub _buildValue {
    my ($self) = @_; 
    return $self->uncoerced;
}
1;
package My::Foo;
use Moose;
use Moose::Util::TypeConstraints;
subtype 'My::ArrayFromInt::Lazy' => as class_type('My::ArrayFromInt');
coerce 'My::ArrayFromInt::Lazy',
    from 'Int',
    via { My::ArrayFromInt->new( uncoerced => $_ ) };
has x => (
    is => 'rw',
    isa => 'My::ArrayFromInt::Lazy',
    required => 1,
    coerce => 1
);
1;

$foo->x->value
My::ArrayFromInt
::Lazy
$foo->x->value
