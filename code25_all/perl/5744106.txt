use strict;
use warnings;
use vars qw($VERSION @ISA @EXPORT @EXPORT_OK %EXPORT_TAGS);

#
# function MergePolygonCircle
#
# parameters
#   Polygon - 2 dimensional array reference
#   Circle - 2 dimensional array reference
#   CircleCenter - array
#   Radius - circle radius float
#
# returns - nuthin
#
sub MergePolygonCircle
{
    my ($Polygon, $Circle, $CircleCenter, $Radius) = @_;
    my $BuffIndex = 0;
    my $SegIndex = 0;
    my $FirstBuffIndex = -1;
    my $FirstCircIndex = -1;
    my $EndBuffIndex = -1;
    my $EndCircIndex = -1;
    my $PolygonLength = @$Polygon; # de-referencing the polygon array to get its size
    my $CircleLength = @$Circle;

    # check to see if the center point of the circle is inside the polygon
    if(GetDistance(@$Polygon[0][0], @$Polygon[0][1], @$CircleCenter[0], @$Ci   rcleCenter[1]) <= $Radius)
    {
        # at this point, the opposite side can only be outside of this circle
        my $Offset = ceil($PolygonLength / 2)-1;

        # remove the end point
        my $EndPoint = pop(@$Polygon);
        # extract the section before the offset
        my $Points = splice(@$Polygon, 0, $Offset);
        # put the points back at the beginning
        splice(@$Polygon, $PolygonLength - $Offset - 1, 0, @$Points);

        # reapply the end point
        push(@$Polygon, @$Polygon[0]);
    }

    # Find the start and end intersections
    for($BuffIndex = 0; $BuffIndex < $PolygonLength-1; $BuffIndex++)
    {
        for($SegIndex = 0; $SegIndex < $CircleLength-1; $SegIndex++)
        {
            if(SegmentsIntersect(@$Polygon[$BuffIndex][0], @$Po   lygon[$BuffIndex][1], @$Polygon[$BuffIndex+1][0], @$Polygon[$BuffIndex+1][1],
                            @$Circle[$SegIndex][0], @$Circle[$SegIndex][1], @$Circle[$SegIndex+1][0], @$Circle[$SegIndex+1][1]))
            {
                if($FirstBuffIndex == -1)
                {
                    $FirstBuffIndex = $BuffIndex;
                    $FirstCircIndex = $SegIndex;
                    continue;
                }
                else
                {
                    if($SegIndex != $FirstCircIndex)
                    {
                        $EndBuffIndex = $BuffIndex;
                        $EndCircIndex = $SegIndex;
                    }
                }
            }

            if($FirstBuffIndex > -1 && $EndBuffIndex > -1) break;
        }
        if($FirstBuffIndex > -1 && $EndBuffIndex > -1) break;
    }

    if($FirstBuffIndex > -1 && $EndBuffIndex > -1 && $FirstCircIndex > -1 && $End   CircIndex > -1)
    {
        $FirstBuffIndex++;
        $EndBuffIndex++;
        $FirstCircIndex++;
        if($FirstCircIndex < $EndCircIndex) $EndCircIndex++;

        # remove redundant segments in the main buffer
        splice(@$Polygon, $FirstBuffIndex, ($EndBuffIndex - $FirstBuffIndex));
        # insert the new segments
        if($FirstCircIndex < $EndCircIndex)
        {
            # remove the tail
            $Tail = splice(@$Polygon, $FirstBuffIndex);
            # re-join here
            push(@$Polygon,
                splice(@$PolyCircle, $FirstCircIndex, $EndCircIndex - $FirstCircIndex)),
                @$Tail);
        }
        if($EndCircIndex < $FirstCircIndex)
        {
            # remove the tail
            $Tail = splice(@$Polygon, $FirstBuffIndex);
            $CircTop = splice(@$PolyCircle, $FirstCircIndex);
            $CircTail = splice(@$PolyCircle, 0, $EndCircIndex);
            # stitch them all together
            push(@$Polygon, @$CircTop, @$CircTail, @$Tail);
        }
    }
};

"my" variable $PolygonLength masks earlier declaration in same scope
Global symbol "$BuffIndex" requires explicit package name
Global symbol "$PolygonLength" requires explicit package name
Global symbol "$SegIndex" requires explicit package name
Global symbol "$CircleLength" requires explicit package name
Global symbol "$Polygon" requires explicit package name

