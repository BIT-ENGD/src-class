function parse_git_dirty {
  # TODO make git status response a variable
  # [branch+] : working dir has staged changes
  if [[ $(git status 2> /dev/null | grep "to be committed") ]]
  then S=$S"$(tput setaf 2)+$(tput sgr0)"
  fi
  # [branch+] : working dir has unstaged changes
  if [[ $(git status 2> /dev/null | grep "not staged for commit") ]]
  then S=$S"$(tput setaf 1)+$(tput sgr0)"
  fi
  # [branch+] : working dir has untracked files
  if [[ $(git status 2> /dev/null | grep "tracked files") ]]
  then S=$S"$(tput setaf 1)+$(tput sgr0)"
  fi
  # [branch<] : local branch is behind origin
  if [[ $(git status 2> /dev/null | grep "Your branch is behind") ]]
  then S=$S"$(tput setaf 5)<$(tput sgr0)"
  fi
  # [branch>] : local branch is ahead origin
  if [[ $(git status 2> /dev/null | grep "branch is ahead of") ]]
  then S=$S"$(tput setaf 5)>$(tput sgr0)"
  fi
  # [branch<>] : branches have diverged
  if [[ $(git status 2> /dev/null | grep "have diverged") ]]
  then S=$S"$(tput setaf 5)<>$(tput sgr0)"
  fi
  echo $S
}
function parse_git_branch {
  git branch --no-color 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/\1/'
}
function show_git_branch {
  if [[ $(parse_git_branch) ]]
  then echo "$(tput setaf 2)($(tput sgr0)$(parse_git_branch)$(parse_git_dirty)$(tput setaf 2))$(tput sgr0)"
  fi
}
export PS1="\u\[$(tput setaf 2)\]@\[$(tput sgr0)\]\h\[$(tput setaf 2)\]:\[$(tput sgr0)\]\W\[\$(show_git_branch)\] "

