local Bricks = display.newGroup() -- static object
local Events = require("Events")
local Levels = require("Levels")
local sound = require("Sound")
local physics = require("physics")
local Sprites = require("Sprites")
local Func = require("Func")


local brickSpriteData = 
{
    {
        name = "brick",
        frames = {Sprites.brick}
    },

    {
        name = "brick2",
        frames = {Sprites.brick2}
    },

    {
        name = "brick3",
        frames = {Sprites.brick3}
    },

}

-- animation table
local brickAnimations = {}

Sprites:CreateAnimationTable
{
    spriteData = brickSpriteData,
    animationTable = brickAnimations
}

-- get size from temp object for later use
local tempBrick = display.newImage('red_apple_20.png',300,500)
--local tempBrick = display.newImage('cheryGreen2.png',300,500)
local brickSize =
{
    width = tempBrick.width, 
    height = tempBrick.height
}
--tempBrick:removeSelf( )


----------------
-- Rubble -- needs to be moved to its own file
----------------

local rubbleSpriteData =
{
    {
        name = "rubble1",
        frames = {Sprites.rubble1}
    },

    {
        name = "rubble2",
        frames = {Sprites.rubble2}
    },

    {
        name = "rubble3",
        frames = {Sprites.rubble3}
    },

    {
        name = "rubble4",
        frames = {Sprites.rubble4}
    },

    {
        name = "rubble5",
        frames = {Sprites.rubble5}
    },

}

local rubbleAnimations = {}
Sprites:CreateAnimationTable
{
    spriteData = rubbleSpriteData,
    animationTable = rubbleAnimations
}

local totalBricksBroken = 0 -- used to track when level is complete
local totalBricksAtStart = 0

-- contains all brick objects
local bricks = {}


local function CreateBrick(data)

    -- random brick sprite
    local obj = display.newImage('red_apple_20.png')
    local objGreen = display.newImage('cheryGreen2.png')
    obj.name = "brick"
    obj.x = data.x --or display.contentCenterX
    obj.y = data.y --or 1000
    obj.brickType = data.brickType or 1
    obj.index = data.index

    function obj:Break()

        totalBricksBroken =  totalBricksBroken + 1
        bricks[self.index] = nil
        obj:removeSelf( )
        sound.play(sound.breakBrick)

    end

    function obj:Update()
        if(self == nil) then
            return
        end 

        if(self.y > display.contentHeight - 20) then
            obj:Break()
        end 
    end 
    if(obj.brickType ==1) then
        physics.addBody( obj, "static", {friction=0.5, bounce=0.5 } )
    elseif(obj.brickType == 2) then
        physics.addBody( objGreen,"static",{friction=0.2, bounce=0.5, density = 1 } )
    end 

    return obj
end

local currentLevel = testLevel
-- create level from bricks defined in an object
-- this allows for levels to be designed
local function CreateBricksFromTable(level)

    totalBricksAtStart = 0
    local activeBricksCount = 0
    for yi=1, #level.bricks do
        for xi=1, #level.bricks[yi] do
            -- create brick?
            if(level.bricks[yi][xi] > 0) then
                local xPos
                local yPos
                if(level.align == "center") then
                    --1100-((99*16)*0.5)
                    xPos = display.contentCenterX- ((level.columns * brickSize.width) * 0.5/3) + ((xi-1) * level.xSpace)--display.contentCenterX 
                    --xPos = 300 +(xi * level.xSpace)
                    yPos = 100 + (yi * level.ySpace)--100
                else
                    xPos = level.xStart + (xi * level.xSpace)
                    yPos = level.yStart + (yi * level.ySpace)
                end

                local brickData = 
                {
                    x = xPos,
                    y = yPos,
                    brickType = level.bricks[yi][xi],
                    index = activeBricksCount+1
                }
                bricks[activeBricksCount+1] = CreateBrick(brickData)

                activeBricksCount = activeBricksCount + 1

            end

        end 

    end

    totalBricks = activeBricksCount
    totalBricksAtStart = activeBricksCount


end

-- create bricks for level --> set from above functions, change function to change brick build type
local CreateAllBricks = CreateBricksFromTable
-- called by a timer so I can pass arguments to CreateAllBricks
local function CreateAllBricksTimerCall()
    CreateAllBricks(Levels.currentLevel)
end 
-- remove all brick objects from memory
local function ClearBricks()

    for i=1, #bricks do
        bricks[i] = nil
    end

end
-- stuff run on enterFrame event
function Bricks:Update()

-- update individual bricks
    if(totalBricksAtStart > 0) then
        for i=1, totalBricksAtStart do
            -- brick exists?
            if(bricks[i]) then
                bricks[i]:Update()
            end 
        end 
    end
    -- is level over?
    if(totalBricksBroken == totalBricks) then
        Events.allBricksBroken:Dispatch()
    end

end
----------------
-- Events
----------------
function Bricks:allBricksBroken(event)
    -- cleanup bricks
    ClearBricks()
    local t = timer.performWithDelay( 1000, CreateAllBricksTimerCall)
    --CreateAllBricks()
    totalBricksBroken = 0       

    -- play happy sound for player to enjoy
    sound.play(sound.win)

    print("You Win!")
end
Events.allBricksBroken:AddObject(Bricks)
CreateAllBricks(Levels.currentLevel)
return Bricks

local Events = require("Events")
local Levels = {}
local function MakeLevel(data)
    local level = {}
    level.xStart = data.xStart or 100
    level.yStart = data.yStart or 100
    level.xSpace = data.xSpace or 23
    level.ySpace = data.ySpace or 23
    level.align = data.align or "center"
    level.columns = data.columns or #data.bricks[1]
    level.bricks = data.bricks --> required
    return level
end
Levels.test4 = MakeLevel
{
    bricks =
    {
        {0,2,0,0,2,0,0,2,0},
        {0,0,2,0,2,0,2,0,0},
        {0,0,0,0,2,0,0,0,0},
        {1,1,2,1,1,1,2,1,1},
        {0,0,0,0,1,0,0,0,0},
        {0,0,0,0,1,0,0,0,0},
        {0,0,0,0,1,0,0,0,0},
    }
}

Levels.test5 = MakeLevel
{
    bricks =
    {       
                    {0,0,0,1,0,0,0,0},
                     {0,0,1,0,1,0,0,0},
                     {0,0,1,0,1,0,0,0},
                     {0,1,0,0,0,1,0,0},
                     {0,1,1,1,1,1,0,0},
                     {1,0,0,0,0,0,1,0},
                     {1,0,0,0,0,0,1,0},
                     {1,0,0,0,0,0,1,0},
                     {1,0,0,0,0,0,1,0}
    }
}
-- Levels.test6 = MakeLevel2
-- {
--  bricks =
--  {
----A         "a" = {{0,0,0,1,0,0,0,0},
--                   {0,0,1,0,1,0,0,0},
--                   {0,0,1,0,1,0,0,0},
--                   {0,1,0,0,0,1,0,0},
--                   {0,1,1,1,1,1,0,0},
--                   {1,0,0,0,0,0,1,0},
--                   {1,0,0,0,0,0,1,0},
--                   {1,0,0,0,0,0,1,0},
--                   {1,0,0,0,0,0,1,0}},
----B
--            "b" = {{1,1,1,1,0,0,0},
--                   {1,0,0,0,1,0,0},
--                   {1,0,0,0,1,0,0},
--                   {1,0,0,0,1,0,0},
--                   {1,1,1,1,0,0,0},
--                   {1,0,0,0,1,0,0},
--                   {1,0,0,0,0,1,0},
--                   {1,0,0,0,0,1,0},
--                   {1,1,1,1,1,0,0}},
--...........
--.......
--...
-- --Z
--             "z"= {{1,1,1,1,1,1,1,0},
--                   {0,0,0,0,0,1,0,0},
--                   {0,0,0,0,1,0,0,0},
--                   {0,0,0,0,1,0,0,0},
--                   {0,0,0,1,0,0,0,0},
--                   {0,0,1,0,0,0,0,0},
--                   {0,0,1,0,0,0,0,0},
--                   {0,1,0,0,0,0,0,0},
--                   {1,1,1,1,1,1,1,0}} 
--  }
-- }
-- stores all levels in ordered table so that one can be selected randomly by index
Levels.levels = 
{
    --Levels.test4,
     Levels.test5
    -- Levels.test6,
}
function Levels:GetRandomLevel()
    return self.levels[math.random(#Levels.levels)]
end
Levels.notPlayedYet = {}
Levels.currentLevel = Levels:GetRandomLevel()
-- Events
function Levels:allBricksBroken(event)
    self.currentLevel = Levels:GetRandomLevel()
end
Events.allBricksBroken:AddObject(Levels)
return Levels

