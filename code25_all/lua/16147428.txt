block.lua
base.lua
main.lua

array index 1 is beyond array bounds:1..1 

array index 800 is beyond array bounds:1..159 

array index 800 is beyond array bounds:1..159 

array index 4000 is beyond array bounds:1..159

blockGroup:insert(blockNum,self.block)

--MAIN.LUA--

function gameOver()
  Runtime:removeEventListener("enterFrame", onEnterFrame)
  Runtime:removeEventListener("enterFrame", movePlayer)

  layers:removeSelf()
  layers = nil

  enemyCount = 0

   for i = 1,#allEnemys do
     timer.cancel(allEnemys[i].clock)
     Runtime:removeEventListener( "enterFrame", allEnemys[i] )
     display.remove(allEnemys[i].image)
     allEnemys[i].image=nil
   end
     allEnemys=nil

cleanupBlocks()
   end
----------------------------------------------------------------------
              -- LEVEL UP --
 ----------------------------------------------------------------------
function levelUp(level)
enemyCount = 0

local enemys = require("modules.enemy")
    if allEnemys ~= nil then
      for i = 1,#allEnemys do
           timer.cancel(allEnemys[i].clock)
           Runtime:removeEventListener( "enterFrame", allEnemys[i] )
           display.remove(allEnemys[i].image)
           allEnemys[i].image=nil
      end
    end
           allEnemys=nil
 cleanupBlocks()
 levels()

 end
----------------------------------------------------------------------
              -- LEVELS --
----------------------------------------------------------------------
function levels(level)

function createInvader(x, y, row)
  for j = 1, 2 do
    for i = 1, 2 do
      if allEnemys == nil then
       allEnemys = {}
      else
       enemysCount=#allEnemys
      end
      allEnemys[#allEnemys + 1] = enemys:new()
      allEnemys[#allEnemys ]:init(i * 60, j * 70 + 70,j) 
      allEnemys[#allEnemys ]:start()
    end
  end
end
createInvader()

--[[function createBases1()

local base = require("modules.base")
  for i = 1, 4 do
    base:new()
    base:init(i * 180 - 130, 850)
  end
end  ]]--

createBases()
end

local block = {}
local block_mt = { __index = block}
local scene = scene
local blockGroup = display.newGroup()
local blockNum = 0


function block:new() -- constructor
local group = {}
return setmetatable( group, block_mt )
end

function block:init(xloc,yloc) --initializer
-- Create attributes

self.block = display.newRect( xloc,yloc,10,10)
self.block:setFillColor ( 2, 255, 14  )

blockNum = blockNum + 1
blockGroup:insert(blockNum,self.block)

local blockCollisionFilter = { categoryBits = 128, maskBits = 387}
physics.addBody( self.block,  "static", {filter = blockCollisionFilter})
self.count = 1

end
function cleanupBlocks()

--[[ print(blockNum, blockGroup.numChildren)
for i=1,blockGroup.numChildren do
blockGroup[1]:removeSelf()
blockGroup[1] = nil
end  ]]--
print(blockNum, blockGroup.numChildren)
while blockGroup.numChildren>0 do

  display.remove(blockGroup[1])
  blockGroup[1]=nil
end

end

function block:start()
---  Create Listeneres
 self.block:addEventListener( "collision", self )
 scene:addEventListener('base_block_event', self)
end

return block

local base = {}
local base_mt = { __index = base}
local scene = scene

local block = require("modules.block")

function base:new() -- constructor
local group = {}
return setmetatable( group, base_mt )
end

function base:init(xloc, yloc) --initializer
-- Create attributes
local base

for j = 1, 4 do
    for i = 1, 10 do
        base = block:new()
        base:init(xloc+i * 10,yloc+j * 10)
        base:start()

    end
end

end

return base

