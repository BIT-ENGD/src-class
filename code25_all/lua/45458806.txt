parents = {2,3,13,5,12,7,11,9,10,11,12,13,14,0}

function create_node(parent, i, created, root)
  if created[i] ~= nil then
        return
  end
    print(i)
--    print(parent)
--  Create a new node and set created[i]
    local new_node = Tree()
    new_node.idx = i
    created[i] = new_node


--    If 'i' is root, change root pointer and return
    if parent[i] == 0 then
       root[1] = created[i] -- root[1] denotes root of the tree

       return
    end

--    If parent is not created, then create parent first
    if created[parent[i]] == nil  then
        create_node(parent, parent[i], created, root )
    end
    print(i)

--    Find parent pointer
    local p = created[parent[i]]
    print (p)

    if #p.children <=2 then
      print(p.idx)
      print(created[i].idx)
      p.add_child(created[i])
    end

end

function read_postorder_parent_tree(parents)
    n = #parents

--    Create and array created[] to keep track 
--    of created nodes, initialize all entries as None
    created = {}

    root = {}
    for i=1, 1 do
        create_node(parents, i, created, root)
    end
    return root[1]
end

create_note
Tree
local Tree = torch.class('Tree')

function Tree:__init()
  self.parent = nil
  self.num_children = 0
  self.children = {}
end

function Tree:add_child(c)

  print(c)
  c.parent = self
  self.num_children = self.num_children + 1
  self.children[self.num_children] = c
end

p.add_child(created[i])
nil
c
nil
created[i]
p
nil
./Tree.lua:16: attempt to index local 'c' (a nil value)
stack traceback:
    ./Tree.lua:16: in function 'add_child'
    main.lua:120: in function 'create_node'
    main.lua:109: in function 'create_node'
    main.lua:109: in function 'create_node'
    main.lua:109: in function 'create_node'
    main.lua:134: in function 'read_postorder_parent_tree'
    main.lua:153: in function 'main'
    main.lua:160: in main chunk
    [C]: in function 'dofile'
    ...3rto/torch/install/lib/luarocks/rocks/trepl/scm-1/bin/th:150: in main chunk
    [C]: at 0x00405d50

