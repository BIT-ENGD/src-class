    -- detect initial collision
    if mathy.hasCollided(player, platform) then

        local playerBoundaries = player:boundaries()

        -- list of intersections between platform and player
        local bottomBoundary = mathy.bottomBoundary( playerBoundaries, platform )
        local topBoundary = mathy.topBoundary( playerBoundaries, platform )
        local rightBoundary = mathy.rightBoundary( playerBoundaries, platform )
        local leftBoundary = mathy.leftBoundary( playerBoundaries, platform )

        local smallestDist = ""
        local smallestBoundary
        local boundaries = {
            bottom = bottomBoundary,
            top = topBoundary,
            right = rightBoundary,
            left = leftBoundary
        }

        -- get the smallest intersection (thats the side we're probably closest to)
        for direction, boundary in pairs(boundaries) do
            if not smallestBoundary then
                smallestBoundary = boundary
                smallestDist = direction
            end

            if smallestBoundary > boundary then
                smallestBoundary = boundary
                smallestDist = direction
            end
        end

        -- reverse effects depending on collision location
        if smallestDist == "bottom" then
            player.desiredPos:add(diffX, -bottomBoundary)
            player.velocity.y = 0
            player.onGround = true
        elseif smallestDist == "top" then
            player.velocity.y = 250
            player.desiredPos:add(0, topBoundary)
        elseif smallestDist == "right" then
            player.desiredPos:add(-rightBoundary, 0)
        elseif smallestDist == "left" then
            player.desiredPos:add(leftBoundary, 0)
        end
    end

