-- https://github.com/g-truc/glm/blob/master/glm/gtc/matrix_transform.inl#L317
function mat4.project(obj, view, projection, viewport)
    local position = { obj.x, obj.y, obj.z, 1 }
    position = view * position
    position = projection * position

    position[1] = position[1] / position[4] * 0.5 + 0.5
    position[2] = position[2] / position[4] * 0.5 + 0.5
    position[3] = position[3] / position[4] * 0.5 + 0.5
    position[4] = position[4] / position[4] * 0.5 + 0.5

    position[1] = position[1] * viewport[3] + viewport[1]
    position[2] = position[2] * viewport[4] + viewport[2]

    return vec3(position[1], position[2], position[3])
end

-- https://github.com/g-truc/glm/blob/master/glm/gtc/matrix_transform.inl#L338
function mat4.unproject(win, view, projection, viewport)
    local inverse = (projection * view):inverse()
    local position = { win.x, win.y, win.z, 1 }
    position.x = (position.x - viewport[1]) / viewport[3]
    position.y = (position.y - viewport[2]) / viewport[4]

    position[1] = position[1] * 2 - 1
    position[2] = position[2] * 2 - 1
    position[3] = position[3] * 2 - 1
    position[4] = position[4] * 2 - 1

    position = inverse * position

    position[1] = position[1] / position[4]
    position[2] = position[2] / position[4]
    position[3] = position[3] / position[4]
    position[4] = position[4] / position[4]

    return vec3(position[1], position[2], position[3])
end

-- Get projection from cubes
local viewport = { 0, 0, 1280, 720 }
for _, cube in ipairs(self.cubes) do
    local model = cpml.mat4()
        :translate(cube.position)
        :rotate(cube.orientation.x, { 1, 0, 0 })
        :rotate(cube.orientation.y, { 0, 1, 0 })
        :rotate(cube.orientation.z, { 0, 0, 1 })
        :scale(cube.scale)

    local projection = cpml.mat4.project(
        cube.position,
        self.camera.view:transpose(),
        self.camera.projection:transpose(),
        viewport
    )
end

