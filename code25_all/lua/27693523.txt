require "CiderDebugger";
-- Add a global background
local background = display.newImage("xmasbg.jpg",160, 240,300,480)

local function removeFlake(target)
        target:removeSelf()
        target = nil
end

local function spawnSnowFlake()
        local flake = display.newImage("snowflake.png")
        --group:insert(flake)
        flake.x = math.random(display.contentWidth)
        flake.y = -2
        local wind = math.random(80) - 40
        transition.to(flake,{time=math.random(3000) + 3000, y = display.contentHeight + 2, x = flake.x + wind, onComplete=removeFlake})
        --group:insert(flake)
end

local function makeSnow(event)
      if math.random(10) == 1 then -- adjust speed here by making the random number higher or lower
            spawnSnowFlake()
      end
      return true
end

Runtime:addEventListener("enterFrame",makeSnow)

-- Initialize our global variables
--local globals = require( "globals" )

-- main.lua
local storyboard = require( "storyboard" )
storyboard.purgeOnScreenChange = true
storyboard.gotoScene( "menu_scene" )

local storyboard = require( "storyboard" )

local scene = storyboard.newScene()
local hohoho = audio.loadSound("xmas.wav")

-- Clear previous scene
storyboard.removeAll()

-- local forward references should go here --
local function buttonHit(event)
    audio.play(hohoho)
    storyboard.gotoScene(event.target.goto, {effect = "slideRight"})

end

---------------------------------------------------------------------------------
-- BEGINNING OF YOUR IMPLEMENTATION
---------------------------------------------------------------------------------


-- Called when the scene's view does not exist:
function scene:createScene( event )
  local group = self.view

--local background = display.newImage("xmasbg.jpg",160, 240,300,480)
--group:insert(background)
local hohoho = audio.loadSound("xmas.wav")
--group:insert(hohoho)
local bgMusic = audio.loadSound("bgmusic.wav")
--group:insert(bgMusic)
local calendarButton = display.newImage("calendarButton.png", 160, 170)
group:insert(calendarButton)
calendarButton:addEventListener("tap", buttonHit)
calendarButton.goto = "calendar_scene"

local creditsButton = display.newImage("creditsButton.png", 160, 250)
group:insert(creditsButton)
creditsButton:addEventListener("tap", buttonHit)
creditsButton.goto = "credits_scene"

local sound = display.newImage("speaker117.png", 290, 495)
group:insert(sound)

local backgroundMusicChannel = audio.play( bgMusic, { channel=1, loops=-1, fadein=5000 } )

--Until Xmas Text
local xmasText = display.newText("Until Christmas", 0, 0, native.systemFontBold, 30)
xmasText: setTextColor( 0, 0,.75)
xmasText.x, xmasText.y = 160, 80
group:insert(xmasText)


--The number of days remaining
local dayText = display.newText( "", 0, 0, native.systemFontBold, 30 )
dayText:setTextColor( 0, 0, .75)
dayText.x, dayText.y = 55, 45
group:insert(dayText)

--The number of hours remaining
local hourText = display.newText( "", 0, 0, native.systemFontBold, 30 )
hourText:setTextColor( 0, 0, .75)
hourText.x, hourText.y = 160, 45
group:insert(hourText)

--The number of minutes remaining
local minutesText = display.newText( "", 0, 0, native.systemFontBold, 30 )
minutesText:setTextColor( 0, 0, .75)
minutesText.x, minutesText.y = 255, 45
group:insert(minutesText)

-- Create labels to indicate what the numbers mean
local dayLabel = display.newText( "Days", 0, 0, native.systemFont, 30 )
dayLabel:setTextColor( 0, 0, .75 )
dayLabel.x = 60; dayLabel.y = 5
group:insert(dayLabel)

local hourLabel = display.newText( "Hours", 0, 0, native.systemFont, 30)
hourLabel:setTextColor( 0, 0, .75 )
hourLabel.x = 160; hourLabel.y = 5
group:insert(hourLabel)

local minuteLabel = display.newText( "Mins", 0, 0, native.systemFont, 30 )
minuteLabel:setTextColor( 0, 0, .75 )
minuteLabel.x = 260; minuteLabel.y = 5
group:insert(minuteLabel)

--Function to update the countdown clock
local function updateTime()
local time = os.date("*t")

local daysLeft = 358 - time.yday
if (daysLeft < 10) then
daysLeft = "0" .. daysLeft
end
dayText.text = daysLeft

local hoursLeft = 23 - time.hour
if (hoursLeft < 10) then
hoursLeft = "0" .. hoursLeft
end
hourText.text = hoursLeft

local minutesLeft = 60 - time.min
if (minutesLeft < 10) then
minutesLeft = "0" .. minutesLeft
end
minutesText.text = minutesLeft


end

--Update the time once immediately to display the correct time
updateTime()

-- Update the clock once per second
local clockTimer = timer.performWithDelay( 1000, updateTime, -1 )

--[[function calendarButton:tap(event)
    audio.play(hohoho)
    calendarButton:removeSelf()
    display.newImage("pushedCalendarButton.png", 160, 170)
end--]]

--[[function creditsButton:tap(event)
    storyboard.gotoScene("credits_scene")
    audio.play(hohoho)
    creditsButton:removeSelf()
    --display.newImage("pushedCreditsButton.png", 160, 250)
end]]--

function sound: tap(event)
    --[[if(self.status == "playing") then
        sound:removeSelf()
        display.newImage("mute.png", 290, 495)
        audio.pause()
        self.status = "paused"

    elseif(self.status == "paused") then
        display.newImage("speaker117.png", 290, 495)
        audio.play()
        --self.status = "paused"



    end--]]


    sound:removeSelf()
    display.newImage("mute.png", 290, 495)
    audio.stop()
end



--[[local function removeFlake(target)
        target:removeSelf()
        target = nil
end

local function spawnSnowFlake()
        local flake = display.newImage("snowflake.png")
        --group:insert(flake)
        flake.x = math.random(display.contentWidth)
        flake.y = -2
        local wind = math.random(80) - 40
        transition.to(flake,{time=math.random(3000) + 3000, y = display.contentHeight + 2, x = flake.x + wind, onComplete=removeFlake})
        --group:insert(flake)
end

local function makeSnow(event)
      if math.random(10) == 1 then -- adjust speed here by making the random number higher or lower
            spawnSnowFlake()
      end
      return true
end



Runtime:addEventListener("enterFrame",makeSnow)--]]
calendarButton:addEventListener("tap", calendarButton)
--creditsButton:addEventListener("tap", creditsButton)
sound:addEventListener("tap", sound)

end


-- Called BEFORE scene has moved onscreen:
function scene:willEnterScene( event )
  local group = self.view

end


-- Called immediately after scene has moved onscreen:
function scene:enterScene( event )
  local group = self.view

end


-- Called when scene is about to move offscreen:
function scene:exitScene( event )
  local group = self.view

end


-- Called AFTER scene has finished moving offscreen:
function scene:didExitScene( event )
  local group = self.view

end


-- Called prior to the removal of scene's "view" (display view)
function scene:destroyScene( event )
  local group = self.view

end


-- Called if/when overlay scene is displayed via storyboard.showOverlay()
function scene:overlayBegan( event )
  local group = self.view
  local overlay_name = event.sceneName  -- name of the overlay scene

end


-- Called if/when overlay scene is hidden/removed via storyboard.hideOverlay()
function scene:overlayEnded( event )
  local group = self.view
  local overlay_name = event.sceneName  -- name of the overlay scene

end

---------------------------------------------------------------------------------
-- END OF YOUR IMPLEMENTATION
---------------------------------------------------------------------------------

-- "createScene" event is dispatched if scene's view does not exist
scene:addEventListener( "createScene", scene )

-- "willEnterScene" event is dispatched before scene transition begins
scene:addEventListener( "willEnterScene", scene )

-- "enterScene" event is dispatched whenever scene transition has finished
scene:addEventListener( "enterScene", scene )

-- "exitScene" event is dispatched before next scene's transition begins
scene:addEventListener( "exitScene", scene )

-- "didExitScene" event is dispatched after scene has finished transitioning out
scene:addEventListener( "didExitScene", scene )

-- "destroyScene" event is dispatched before view is unloaded, which can be
-- automatically unloaded in low memory situations, or explicitly via a call to
-- storyboard.purgeScene() or storyboard.removeScene().
scene:addEventListener( "destroyScene", scene )

-- "overlayBegan" event is dispatched when an overlay scene is shown
scene:addEventListener( "overlayBegan", scene )

-- "overlayEnded" event is dispatched when an overlay scene is hidden/removed
scene:addEventListener( "overlayEnded", scene )

---------------------------------------------------------------------------------

return scene

local storyboard = require( "storyboard" )
local scene = storyboard.newScene()
local hohoho = audio.loadSound("xmas.wav")

-- Clear previous scene
storyboard.removeAll()

-- local forward references should go here --

levels = 
{   
1, 2, 2, 2 ,2,  --1 means level is open to  be played (level.png)
2, 2, 2, 2, 2,  --2 means level is locked (locked.png)
2, 2, 2, 2, 2,  --3 means level is completed (greenchecked.png)
2, 2, 2, 2, 2,
2, 2, 2, 2, 2,
}

images ={
    { getFile = "gift.png", types = "play"},
    { getFile = "lock.png", types = "locked"},
    { getFile = "greenchecked.png", types = "done"}
}

local function buttonHit(event)
    storyboard.gotoScene ( event.target.destination, {effect = "slideLeft"} )
        audio.play(hohoho)
    print( event.target.destination)
        return true
end
---------------------------------------------------------------------------------
-- BEGINNING OF YOUR IMPLEMENTATION
---------------------------------------------------------------------------------


-- Called when the scene's view does not exist:
function scene:createScene( event )
  local group = self.view

    local levelIndex = 0
            for i=0,4 do
               for j=1,5 do

                    tablePlace =   i*5 + j  
                    levelIndex = levelIndex + 1
                    local imagesId = levels[levelIndex] 
                    levelImg = display.newImageRect (images[imagesId].getFile , 50, 50 )
                    levelImg.x = -22 + (j*62)
                    levelImg.y  = 130+ (i*70)
                    levelImg.anchorY = .8
                    group:insert(levelImg)

                    local levelText = display.newText(tablePlace,0,0,native.systemFont,28)
                    levelText.x = -22 + (j*62)
                    levelText.y = 125+ (i*70)
                    group:insert(levelText)

                    levelImg.destination = "level0"..tostring(tablePlace)

                    if images[imagesId].types ~= "locked" then
                    levelImg:addEventListener("tap", buttonHit)
                    end
                end
            end

    local heading = display.newText("Christmas Countdown", 0, 0, native.systemFontBold, 31)
        heading: setTextColor( .75, 0, 0)
        heading.x, heading.y = 160, 35
        group:insert(heading)

        local backButton = display.newImage("backButton.png", 43, 495)
        group:insert(backButton)
        backButton:addEventListener("tap", buttonHit)
        backButton.destination = "menu_scene"
end


-- Called BEFORE scene has moved onscreen:
function scene:willEnterScene( event )
  local group = self.view

end


-- Called immediately after scene has moved onscreen:
function scene:enterScene( event )
  local group = self.view

end


-- Called when scene is about to move offscreen:
function scene:exitScene( event )
  local group = self.view

end


-- Called AFTER scene has finished moving offscreen:
function scene:didExitScene( event )
  local group = self.view

end


-- Called prior to the removal of scene's "view" (display view)
function scene:destroyScene( event )
  local group = self.view

end


-- Called if/when overlay scene is displayed via storyboard.showOverlay()
function scene:overlayBegan( event )
  local group = self.view
  local overlay_name = event.sceneName  -- name of the overlay scene

end


-- Called if/when overlay scene is hidden/removed via storyboard.hideOverlay()
function scene:overlayEnded( event )
  local group = self.view
  local overlay_name = event.sceneName  -- name of the overlay scene

end

---------------------------------------------------------------------------------
-- END OF YOUR IMPLEMENTATION
---------------------------------------------------------------------------------

-- "createScene" event is dispatched if scene's view does not exist
scene:addEventListener( "createScene", scene )

-- "willEnterScene" event is dispatched before scene transition begins
scene:addEventListener( "willEnterScene", scene )

-- "enterScene" event is dispatched whenever scene transition has finished
scene:addEventListener( "enterScene", scene )

-- "exitScene" event is dispatched before next scene's transition begins
scene:addEventListener( "exitScene", scene )

-- "didExitScene" event is dispatched after scene has finished transitioning out
scene:addEventListener( "didExitScene", scene )

-- "destroyScene" event is dispatched before view is unloaded, which can be
-- automatically unloaded in low memory situations, or explicitly via a call to
-- storyboard.purgeScene() or storyboard.removeScene().
scene:addEventListener( "destroyScene", scene )

-- "overlayBegan" event is dispatched when an overlay scene is shown
scene:addEventListener( "overlayBegan", scene )

-- "overlayEnded" event is dispatched when an overlay scene is hidden/removed
scene:addEventListener( "overlayEnded", scene )

---------------------------------------------------------------------------------

return scene

local storyboard = require( "storyboard" )
local scene = storyboard.newScene()

local widget = require ("widget")
local calendar_scenefile = require ("calendar_scene")


-- local forward references should go here --

local completegameBtn


local function buttonHit(event)
    storyboard.gotoScene (  event.target.destination, {effect = "slideLeft"} )
    return true
end


-- Called when the scene's view does not exist:
function scene:createScene( event )
    local group = self.view

    local title = display.newText( "Level 1", 0, 0, "Helvetica", 38 )
    title.x = 160
    title.y = display.screenOriginY + 40
    group:insert(title)

    local backBtn = display.newText(  "Back", 0, 0, "Helvetica", 25 )
    backBtn.x = display.screenOriginX + 50
    backBtn.y = display.contentHeight - 30 
    backBtn.destination = "calendar_scene" 
    backBtn:addEventListener("tap", buttonHit)
    group:insert(backBtn)
end


-- Called immediately after scene has moved onscreen:
function scene:enterScene( event )
    local group = self.view

        local function btnClicked (event)
    --levelProgress = levelProgress + 1
    levels[1] = 3
    levels[2] = 1
    completegameBtn.destination = "calendar_scene" 
    completegameBtn:addEventListener("tap", buttonHit)
    end

    completegameBtn = widget.newButton { label = "Complete game", onRelease=btnClicked}
    completegameBtn.x = 160
    completegameBtn.y = 240
    group:insert (completegameBtn)
end

-- Called when scene is about to move offscreen:
function scene:exitScene( event )
    local group = self.view

    -- INSERT code here (e.g. stop timers, remove listeners, unload sounds, etc.)
    -- Remove listeners attached to the Runtime, timers, transitions, audio tracks

end

-- Called prior to the removal of scene's "view" (display group)
function scene:destroyScene( event )
    local group = self.view

    -- INSERT code here (e.g. remove listeners, widgets, save state, etc.)
    -- Remove listeners attached to the Runtime, timers, transitions, audio tracks

end



---------------------------------------------------------------------------------
-- END OF YOUR IMPLEMENTATION
---------------------------------------------------------------------------------

-- "createScene" event is dispatched if scene's view does not exist
scene:addEventListener( "createScene", scene )

-- "enterScene" event is dispatched whenever scene transition has finished
scene:addEventListener( "enterScene", scene )

-- "exitScene" event is dispatched before next scene's transition begins
scene:addEventListener( "exitScene", scene )

-- "destroyScene" event is dispatched before view is unloaded, which can be
-- automatically unloaded in low memory situations, or explicitly via a call to
-- storyboard.purgeScene() or storyboard.removeScene().
scene:addEventListener( "destroyScene", scene )


---------------------------------------------------------------------------------

return scene

