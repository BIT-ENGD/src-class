display.setStatusBar( display.HiddenStatusBar )

local posX, posY = 100, 200
local sizeX, sizeY = 40, 40
local posX1, posY1 = 150, 200
local posx, posy = 10, 50

local container = display.newRoundedRect( posX, posY, sizeX, sizeY, 3 )
container:setFillColor( 0,0,255 )
container.strokeWidth = 3
container:setStrokeColor(100, 100, 100)

local container2 = display.newRoundedRect( posX1, posY1, sizeX, sizeY, 3 )
container:setFillColor( 0,0,255 )
container2.strokeWidth = 3
container2:setStrokeColor(100, 100, 100)



local myObject = display.newImage("letters/B.png" , 150, 10)
local myObject2 = display.newImage("letters/a.png" , 10, 10)
local myObject3 = display.newImage("letters/C.png" , 200, 10)

-- touch listener function
function myObject:touch( event )
    if event.phase == "began" then

        self.markX = self.x    -- store x location of object
        self.markY = self.y    -- store y location of object

    elseif event.phase == "moved" then

        local x = (event.x - event.xStart) + self.markX
        local y = (event.y - event.yStart) + self.markY

        self.x, self.y = x, y    -- move object based on calculations above

        if (((x >= ((sizeX/2) + posX - ((2/3) * sizeX))) and (y >= ((sizeY/2) + posY - ((1/3) * sizeY))) and (x <= ((sizeX/2) + posX + ((2/3) * sizeX))) and (y <= ((sizeY/2) + posY + ((1/3) * sizeY)))) or ((x >= ((sizeX/2) + posX - ((1/3) * sizeX))) and (y >= ((sizeY/2) + posY - ((2/3) * sizeY))) and (x <= ((sizeX/2) + posX + ((1/3) * sizeX))) and (y <= ((sizeY/2) + posY + ((2/3) * sizeY)))) or ((x >= ((sizeX/2) + posX - ((1/2) * sizeX))) and (y >= ((sizeY/2) + posY - ((1/2) * sizeY))) and (x <= ((sizeX/2) + posX + ((1/2) * sizeX))) and (y <= ((sizeY/2) + posY + ((1/2) * sizeY))))) then
            container:setFillColor( 0,0,255 )
        else
            container:setFillColor( 0,0,255 )
        end

    elseif event.phase == "ended" then

        local x = (event.x - event.xStart) + self.markX
        local y = (event.y - event.yStart) + self.markY

        -- main condition: I calculated 3 areas to atract the object to the target container, 2 areas that atract it when it's 1/3 in the target and 1 area that atract it when it's 1/4 in the target
        if (((x >= ((sizeX/2) + posX - ((2/3) * sizeX))) and (y >= ((sizeY/2) + posY - ((1/3) * sizeY))) and (x <= ((sizeX/2) + posX + ((2/3) * sizeX))) and (y <= ((sizeY/2) + posY + ((1/3) * sizeY)))) or ((x >= ((sizeX/2) + posX - ((1/3) * sizeX))) and (y >= ((sizeY/2) + posY - ((2/3) * sizeY))) and (x <= ((sizeX/2) + posX + ((1/3) * sizeX))) and (y <= ((sizeY/2) + posY + ((2/3) * sizeY)))) or ((x >= ((sizeX/2) + posX - ((1/2) * sizeX))) and (y >= ((sizeY/2) + posY - ((1/2) * sizeY))) and (x <= ((sizeX/2) + posX + ((1/2) * sizeX))) and (y <= ((sizeY/2) + posY + ((1/2) * sizeY))))) then
            self.x, self.y = posX + (sizeX/2), posY + (sizeY/2);
        end

    end

    return true
end

---------------------------------------------------------------------------
--------------------------test---------------------------------------------
---------------------------------------------------------------------------
-- touch listener function
function myObject2:touch( event )
    if event.phase == "began" then

        self.markX = self.x    -- store x location of object
        self.markY = self.y    -- store y location of object

    elseif event.phase == "moved" then

        local x = (event.x - event.xStart) + self.markX
        local y = (event.y - event.yStart) + self.markY

        self.x, self.y = x, y    -- move object based on calculations above
        if (((x >= ((sizeX/2) + posX1 - ((2/3) * sizeX))) and (y >= ((sizeY/2) + posY1 - ((1/3) * sizeY))) and (x <= ((sizeX/2) + posX1 + ((2/3) * sizeX))) and (y <= ((sizeY/2) + posY1 + ((1/3) * sizeY)))) or ((x >= ((sizeX/2) + posX1 - ((1/3) * sizeX))) and (y >= ((sizeY/2) + posY1 - ((2/3) * sizeY))) and (x <= ((sizeX/2) + posX1 + ((1/3) * sizeX))) and (y <= ((sizeY/2) + posY1 + ((2/3) * sizeY)))) or ((x >= ((sizeX/2) + posX1 - ((1/2) * sizeX))) and (y >= ((sizeY/2) + posY1 - ((1/2) * sizeY))) and (x <= ((sizeX/2) + posX1 + ((1/2) * sizeX))) and (y <= ((sizeY/2) + posY1 + ((1/2) * sizeY))))) then
            container2:setFillColor( 0,0,255 )
        else
            container2:setFillColor( 0,0,255 )
        end

    elseif event.phase == "ended" then

        local x = (event.x - event.xStart) + self.markX
        local y = (event.y - event.yStart) + self.markY

        -- main condition: I calculated 3 areas to atract the object to the target container, 2 areas that atract it when it's 1/3 in the target and 1 area that atract it when it's 1/4 in the target
        if (((x >= ((sizeX/2) + posX1 - ((2/3) * sizeX))) and (y >= ((sizeY/2) + posY1 - ((1/3) * sizeY))) and (x <= ((sizeX/2) + posX1 + ((2/3) * sizeX))) and (y <= ((sizeY/2) + posY1 + ((1/3) * sizeY)))) or ((x >= ((sizeX/2) + posX1 - ((1/3) * sizeX))) and (y >= ((sizeY/2) + posY1 - ((2/3) * sizeY))) and (x <= ((sizeX/2) + posX1 + ((1/3) * sizeX))) and (y <= ((sizeY/2) + posY1 + ((2/3) * sizeY)))) or ((x >= ((sizeX/2) + posX1 - ((1/2) * sizeX))) and (y >= ((sizeY/2) + posY1 - ((1/2) * sizeY))) and (x <= ((sizeX/2) + posX1 + ((1/2) * sizeX))) and (y <= ((sizeY/2) + posY1 + ((1/2) * sizeY))))) then
            self.x, self.y = posX1 + (sizeX/2), posY1 + (sizeY/2);
        end

    end

    return true
end
------------------------------------------------------------------------------
-------------------------------------------------------------------------------
function myObject3:touch( event )
    if event.phase == "began" then

        self.markX = self.x    -- store x location of object
        self.markY = self.y    -- store y location of object

    elseif event.phase == "moved" then

        local x = (event.x - event.xStart) + self.markX
        local y = (event.y - event.yStart) + self.markY

        self.x, self.y = x, y    -- move object based on calculations above
        if (((x >= ((sizeX/2) + posX1 - ((2/3) * sizeX))) and (y >= ((sizeY/2) + posY1 - ((1/3) * sizeY))) and (x <= ((sizeX/2) + posX1 + ((2/3) * sizeX))) and (y <= ((sizeY/2) + posY1 + ((1/3) * sizeY)))) or ((x >= ((sizeX/2) + posX1 - ((1/3) * sizeX))) and (y >= ((sizeY/2) + posY1 - ((2/3) * sizeY))) and (x <= ((sizeX/2) + posX1 + ((1/3) * sizeX))) and (y <= ((sizeY/2) + posY1 + ((2/3) * sizeY)))) or ((x >= ((sizeX/2) + posX1 - ((1/2) * sizeX))) and (y >= ((sizeY/2) + posY1 - ((1/2) * sizeY))) and (x <= ((sizeX/2) + posX1 + ((1/2) * sizeX))) and (y <= ((sizeY/2) + posY1 + ((1/2) * sizeY))))) then
            container2:setFillColor( 0,0,255 )
        else
            container2:setFillColor( 0,0,255 )
        end

    elseif event.phase == "ended" then

        local x = (event.x - event.xStart) + self.markX
        local y = (event.y - event.yStart) + self.markY

        -- main condition: I calculated 3 areas to atract the object to the target container, 2 areas that atract it when it's 1/3 in the target and 1 area that atract it when it's 1/4 in the target
        if (((x >= ((sizeX/2) + posX1 - ((2/3) * sizeX))) and (y >= ((sizeY/2) + posY1 - ((1/3) * sizeY))) and (x <= ((sizeX/2) + posX1 + ((2/3) * sizeX))) and (y <= ((sizeY/2) + posY1 + ((1/3) * sizeY)))) or ((x >= ((sizeX/2) + posX1 - ((1/3) * sizeX))) and (y >= ((sizeY/2) + posY1 - ((2/3) * sizeY))) and (x <= ((sizeX/2) + posX1 + ((1/3) * sizeX))) and (y <= ((sizeY/2) + posY1 + ((2/3) * sizeY)))) or ((x >= ((sizeX/2) + posX1 - ((1/2) * sizeX))) and (y >= ((sizeY/2) + posY1 - ((1/2) * sizeY))) and (x <= ((sizeX/2) + posX1 + ((1/2) * sizeX))) and (y <= ((sizeY/2) + posY1 + ((1/2) * sizeY))))) then
            self.x, self.y = posX1 + (sizeX/2), posY1 + (sizeY/2);

        end

    end

    return true
end

myObject:addEventListener( "touch", myObject )
myObject3:addEventListener( "touch", myObject3 )
myObject2:addEventListener( "touch", myObject2)

