def iterate_conway_closed(universe_t0, n_iter=1, display=False):
# This function is similar to your iterate_conway_open function
# but instead of adding a zero guard ring it should add a 
# ‘wrapping ring’ as explained earlier.  Use the same apply_rules
# function as part 1) to actually apply the rules once you have
# padded the universe.  
# Note that unlike the always 0 guard ring for an open universe
# the wrapping ring will need updating after every call to
# apply rules to reflect changes in the universe

height, width=universe_t0.shape
universe_array=numpy.zeros((height+2, width+2), dtype=numpy.uint8)
universe_array[1:-1, 1:-1]=universe_t0

def count(n_iter):
    n=0
    while n<= n_iter:
        yield n
        n+=1

for n in range(0,n_iter):
    universe_array[:1,1:-1]=universe_t0[-1:,:] # Maps the bottom row
    universe_array[0,1:-1]=universe_t0[-1:,0:]# Maps the top row
    universe_array[1:-1,0]=universe_t0[:,0]# Maps the left column
    universe_array[1:-1,-1]=universe_t0[:,-1]# Maps the right column
    universe_array[0,0]=universe_t0[-1,0]# Maps the bottom left corner
    universe_array[0,-1]=universe_t0[-1,-1]# Maps the bottom right corner
    universe_array[-1,0]=universe_t0[0,0]# Maps the top left corner
    universe_array[-1,-1]=universe_t0[0,-1]# Maps the top right corner      

for i in range(0, n_iter):
    universe_array=apply_rules(universe_array)


if display==True:
    b_print(universe_array)

return universe_array[1:-1, 1:-1]

