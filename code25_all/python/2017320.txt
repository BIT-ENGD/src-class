#!C:\Python31\mystuff
# Filename : my_backup_v1.py

import os
import time
# backing up a couple small files that I made
source = [r'C:\AB\a', r'C:\AB\b'] 

#my back up directory
target_dir = 'C:\\Backup' 

#name of back up file
target = target_dir + os.sep + time.strftime('%Y%m%d%H%M%S') + '.zip'


zip_command = "zip -qr {0} {1}".format(target,' '.join(source))

print(zip_command)

if os.system(zip_command) == 0:
    print('Successful backup to', target)
else:
    print('Backup failed!')
    print('source files are', source)
    print('target directory is', target_dir)
    print('target is', target)

zip -qr C:\Backup\20100106143030.zip C:\AB\a C:\AB\b
Backup failed!
source files are ['C:\\AB\\a', 'C:\\AB\\b']
target directory is C:\Backup
target is C:\Backup\20100106143030.zip

>>> zip -qr C:\Backup\20100106143030.zip C:\AB\a C:\AB\b
SyntaxError: invalid syntax (<pyshell#17>, line 1)

>>> help(zip)
Help on class zip in module builtins:

class zip(object)
 |  zip(iter1 [,iter2 [...]]) --> zip object
 |  
 |  Return a zip object whose .__next__() method returns a tuple where
 |  the i-th element comes from the i-th iterable argument.  The .__next__()
 |  method continues until the shortest iterable in the argument sequence
 |  is exhausted and then it raises StopIteration.
 |  
 |  Methods defined here:
 |  
 |  __getattribute__(...)
 |      x.__getattribute__('name') <==> x.name
 |  
 |  __iter__(...)
 |      x.__iter__() <==> iter(x)
 |  
 |  __next__(...)
 |      x.__next__() <==> next(x)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __new__ = <built-in method __new__ of type object at 0x1E1B8D80>
 |      T.__new__(S, ...) -> a new object with type S, a subtype of T

>>> zip (r'C:AB\a')
<zip object at 0x029CE8C8>

