import threading, time

class runParallelTest():
    def __init__(self):
        pass

    def runList(self, functionList):
        threadList = []
        for functionListIndex in range(0, len(functionList)):
            newThread = threading.Thread(target=lambda:self._run_parallel_job(functionList[functionListIndex]))
            newThread.start()
            threadList.append(newThread)
            # sleep delay that makes it all work fine.
            #time.sleep(2)

        # We wait for all the threads to complete and if any of them
        # doesn't we report a failure.
        for thread in threadList:
            thread.join(3600*24) # 1 day better be enough
            if thread.isAlive() == True:
                raise Exception("thread.isAlive==True")

    def _run_parallel_job(self, function):
        results = function()
        # store the results in a threadsafe way in self
        # (I promise I'm using semaphores)

def f(x):
    print "f(%d) run" % x
    return x

if __name__ == '__main__':
    rp = runParallelTest()

    functionList = [
        lambda:f(0),
        lambda:f(1),
        lambda:f(2),
        lambda:f(3),
        lambda:f(4),
        lambda:f(5),
        lambda:f(6),
        lambda:f(7),
        ]

    rp.runList(functionList)

> python thread_problem.py
f(0) run
 f(1) run
f(2) run
 f(4) run
f(5) run
f(5) run
f(6) run
f(7) run
>

