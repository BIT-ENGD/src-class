/*
 * A number of helper functions used for managing events.
 * Many of the ideas behind this code originated from
 * Dean Edwards' addEvent library.
 */
jQuery.event = {

    // Bind an event to an element
    // Original by Dean Edwards
    add: function( elem, types, handler, data ) {
        if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
            return;
        }

        // TODO :: Use a try/catch until it's safe to pull this out (likely 1.6)
        // Minor release fix for bug #8018
        try {
            // For whatever reason, IE has trouble passing the window object
            // around, causing it to be cloned in the process
            if ( jQuery.isWindow( elem ) && ( elem !== window && !elem.frameElement ) ) {
                elem = window;
            }
        }
        catch ( e ) {}

        if ( handler === false ) {
            handler = returnFalse;
        } else if ( !handler ) {
            // Fixes bug #7229. Fix recommended by jdalton
            return;
        }

        var handleObjIn, handleObj;

        if ( handler.handler ) {
            handleObjIn = handler;
            handler = handleObjIn.handler;
        }

        // Make sure that the function being executed has a unique ID
        if ( !handler.guid ) {
            handler.guid = jQuery.guid++;
        }

        // Init the element's event structure
        var elemData = jQuery._data( elem );

        // If no elemData is found then we must be trying to bind to one of the
        // banned noData elements
        if ( !elemData ) {
            return;
        }

        var events = elemData.events,
            eventHandle = elemData.handle;

        if ( !events ) {
            elemData.events = events = {};
        }

        if ( !eventHandle ) {
            elemData.handle = eventHandle = function( e ) {
                // Handle the second event of a trigger and when
                // an event is called after a page has unloaded
                return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
                    jQuery.event.handle.apply( eventHandle.elem, arguments ) :
                    undefined;
            };
        }

        // Add elem as a property of the handle function
        // This is to prevent a memory leak with non-native events in IE.
        eventHandle.elem = elem;

        // Handle multiple events separated by a space
        // jQuery(...).bind("mouseover mouseout", fn);
        types = types.split(" ");

        var type, i = 0, namespaces;

        while ( (type = types[ i++ ]) ) {
            handleObj = handleObjIn ?
                jQuery.extend({}, handleObjIn) :
                { handler: handler, data: data };

            // Namespaced event handlers
            if ( type.indexOf(".") > -1 ) {
                namespaces = type.split(".");
                type = namespaces.shift();
                handleObj.namespace = namespaces.slice(0).sort().join(".");

            } else {
                namespaces = [];
                handleObj.namespace = "";
            }

            handleObj.type = type;
            if ( !handleObj.guid ) {
                handleObj.guid = handler.guid;
            }

            // Get the current list of functions bound to this event
            var handlers = events[ type ],
                special = jQuery.event.special[ type ] || {};

            // Init the event handler queue
            if ( !handlers ) {
                handlers = events[ type ] = [];

                // Check for a special event handler
                // Only use addEventListener/attachEvent if the special
                // events handler returns false
                if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
                    // Bind the global event handler to the element
                    if ( elem.addEventListener ) {
                        elem.addEventListener( type, eventHandle, false );

                    } else if ( elem.attachEvent ) {
                        elem.attachEvent( "on" + type, eventHandle );
                    }
                }
            }

            if ( special.add ) {
                special.add.call( elem, handleObj );

                if ( !handleObj.handler.guid ) {
                    handleObj.handler.guid = handler.guid;
                }
            }

            // Add the function to the element's handler list
            handlers.push( handleObj );

            // Keep track of which events have been used, for global triggering
            jQuery.event.global[ type ] = true;
        }

        // Nullify elem to prevent memory leaks in IE
        elem = null;
    },

    global: {},

    // Detach an event or set of events from an element
    remove: function( elem, types, handler, pos ) {
        // don't do events on text and comment nodes
        if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
            return;
        }

        if ( handler === false ) {
            handler = returnFalse;
        }

        var ret, type, fn, j, i = 0, all, namespaces, namespace, special, eventType, handleObj, origType,
            elemData = jQuery.hasData( elem ) && jQuery._data( elem ),
            events = elemData && elemData.events;

        if ( !elemData || !events ) {
            return;
        }

        // types is actually an event object here
        if ( types && types.type ) {
            handler = types.handler;
            types = types.type;
        }

        // Unbind all events for the element
        if ( !types || typeof types === "string" && types.charAt(0) === "." ) {
            types = types || "";

            for ( type in events ) {
                jQuery.event.remove( elem, type + types );
            }

            return;
        }

        // Handle multiple events separated by a space
        // jQuery(...).unbind("mouseover mouseout", fn);
        types = types.split(" ");

        while ( (type = types[ i++ ]) ) {
            origType = type;
            handleObj = null;
            all = type.indexOf(".") < 0;
            namespaces = [];

            if ( !all ) {
                // Namespaced event handlers
                namespaces = type.split(".");
                type = namespaces.shift();

                namespace = new RegExp("(^|\\.)" +
                    jQuery.map( namespaces.slice(0).sort(), fcleanup ).join("\\.(?:.*\\.)?") + "(\\.|$)");
            }

            eventType = events[ type ];

            if ( !eventType ) {
                continue;
            }

            if ( !handler ) {
                for ( j = 0; j < eventType.length; j++ ) {
                    handleObj = eventType[ j ];

                    if ( all || namespace.test( handleObj.namespace ) ) {
                        jQuery.event.remove( elem, origType, handleObj.handler, j );
                        eventType.splice( j--, 1 );
                    }
                }

                continue;
            }

            special = jQuery.event.special[ type ] || {};

            for ( j = pos || 0; j < eventType.length; j++ ) {
                handleObj = eventType[ j ];

                if ( handler.guid === handleObj.guid ) {
                    // remove the given handler for the given type
                    if ( all || namespace.test( handleObj.namespace ) ) {
                        if ( pos == null ) {
                            eventType.splice( j--, 1 );
                        }

                        if ( special.remove ) {
                            special.remove.call( elem, handleObj );
                        }
                    }

                    if ( pos != null ) {
                        break;
                    }
                }
            }

            // remove generic event handler if no more handlers exist
            if ( eventType.length === 0 || pos != null && eventType.length === 1 ) {
                if ( !special.teardown || special.teardown.call( elem, namespaces ) === false ) {
                    jQuery.removeEvent( elem, type, elemData.handle );
                }

                ret = null;
                delete events[ type ];
            }
        }

        // Remove the expando if it's no longer used
        if ( jQuery.isEmptyObject( events ) ) {
            var handle = elemData.handle;
            if ( handle ) {
                handle.elem = null;
            }

            delete elemData.events;
            delete elemData.handle;

            if ( jQuery.isEmptyObject( elemData ) ) {
                jQuery.removeData( elem, undefined, true );
            }
        }
    },

    // bubbling is internal
    trigger: function( event, data, elem /*, bubbling */ ) {
        // Event object or event type
        var type = event.type || event,
            bubbling = arguments[3];

        if ( !bubbling ) {
            event = typeof event === "object" ?
                // jQuery.Event object
                event[ jQuery.expando ] ? event :
                // Object literal
                jQuery.extend( jQuery.Event(type), event ) :
                // Just the event type (string)
                jQuery.Event(type);

            if ( type.indexOf("!") >= 0 ) {
                event.type = type = type.slice(0, -1);
                event.exclusive = true;
            }

            // Handle a global trigger
            if ( !elem ) {
                // Don't bubble custom events when global (to avoid too much overhead)
                event.stopPropagation();

                // Only trigger if we've ever bound an event for it
                if ( jQuery.event.global[ type ] ) {
                    // XXX This code smells terrible. event.js should not be directly
                    // inspecting the data cache
                    jQuery.each( jQuery.cache, function() {
                        // internalKey variable is just used to make it easier to find
                        // and potentially change this stuff later; currently it just
                        // points to jQuery.expando
                        var internalKey = jQuery.expando,
                            internalCache = this[ internalKey ];
                        if ( internalCache && internalCache.events && internalCache.events[ type ] ) {
                            jQuery.event.trigger( event, data, internalCache.handle.elem );
                        }
                    });
                }
            }

            // Handle triggering a single element

            // don't do events on text and comment nodes
            if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 ) {
                return undefined;
            }

            // Clean up in case it is reused
            event.result = undefined;
            event.target = elem;

            // Clone the incoming data, if any
            data = jQuery.makeArray( data );
            data.unshift( event );
        }

        event.currentTarget = elem;

        // Trigger the event, it is assumed that "handle" is a function
        var handle = jQuery._data( elem, "handle" );

        if ( handle ) {
            handle.apply( elem, data );
        }

        var parent = elem.parentNode || elem.ownerDocument;

        // Trigger an inline bound script
        try {
            if ( !(elem && elem.nodeName && jQuery.noData[elem.nodeName.toLowerCase()]) ) {
                if ( elem[ "on" + type ] && elem[ "on" + type ].apply( elem, data ) === false ) {
                    event.result = false;
                    event.preventDefault();
                }
            }

        // prevent IE from throwing an error for some elements with some event types, see #3533
        } catch (inlineError) {}

        if ( !event.isPropagationStopped() && parent ) {
            jQuery.event.trigger( event, data, parent, true );

        } else if ( !event.isDefaultPrevented() ) {
            var old,
                target = event.target,
                targetType = type.replace( rnamespaces, "" ),
                isClick = jQuery.nodeName( target, "a" ) && targetType === "click",
                special = jQuery.event.special[ targetType ] || {};

            if ( (!special._default || special._default.call( elem, event ) === false) &&
                !isClick && !(target && target.nodeName && jQuery.noData[target.nodeName.toLowerCase()]) ) {

                try {
                    if ( target[ targetType ] ) {
                        // Make sure that we don't accidentally re-trigger the onFOO events
                        old = target[ "on" + targetType ];

                        if ( old ) {
                            target[ "on" + targetType ] = null;
                        }

                        jQuery.event.triggered = event.type;
                        target[ targetType ]();
                    }

                // prevent IE from throwing an error for some elements with some event types, see #3533
                } catch (triggerError) {}

                if ( old ) {
                    target[ "on" + targetType ] = old;
                }

                jQuery.event.triggered = undefined;
            }
        }
    },

    handle: function( event ) {
        var all, handlers, namespaces, namespace_re, events,
            namespace_sort = [],
            args = jQuery.makeArray( arguments );

        event = args[0] = jQuery.event.fix( event || window.event );
        event.currentTarget = this;

        // Namespaced event handlers
        all = event.type.indexOf(".") < 0 && !event.exclusive;

        if ( !all ) {
            namespaces = event.type.split(".");
            event.type = namespaces.shift();
            namespace_sort = namespaces.slice(0).sort();
            namespace_re = new RegExp("(^|\\.)" + namespace_sort.join("\\.(?:.*\\.)?") + "(\\.|$)");
        }

        event.namespace = event.namespace || namespace_sort.join(".");

        events = jQuery._data(this, "events");

        handlers = (events || {})[ event.type ];

        if ( events && handlers ) {
            // Clone the handlers to prevent manipulation
            handlers = handlers.slice(0);

            for ( var j = 0, l = handlers.length; j < l; j++ ) {
                var handleObj = handlers[ j ];

                // Filter the functions by class
                if ( all || namespace_re.test( handleObj.namespace ) ) {
                    // Pass in a reference to the handler function itself
                    // So that we can later remove it
                    event.handler = handleObj.handler;
                    event.data = handleObj.data;
                    event.handleObj = handleObj;

                    var ret = handleObj.handler.apply( this, args );

                    if ( ret !== undefined ) {
                        event.result = ret;
                        if ( ret === false ) {
                            event.preventDefault();
                            event.stopPropagation();
                        }
                    }

                    if ( event.isImmediatePropagationStopped() ) {
                        break;
                    }
                }
            }
        }

        return event.result;
    },

    props: "altKey attrChange attrName bubbles button cancelable charCode clientX clientY ctrlKey currentTarget data detail eventPhase fromElement handler keyCode layerX layerY metaKey newValue offsetX offsetY pageX pageY prevValue relatedNode relatedTarget screenX screenY shiftKey srcElement target toElement view wheelDelta which".split(" "),

    fix: function( event ) {
        if ( event[ jQuery.expando ] ) {
            return event;
        }

        // store a copy of the original event object
        // and "clone" to set read-only properties
        var originalEvent = event;
        event = jQuery.Event( originalEvent );

        for ( var i = this.props.length, prop; i; ) {
            prop = this.props[ --i ];
            event[ prop ] = originalEvent[ prop ];
        }

        // Fix target property, if necessary
        if ( !event.target ) {
            // Fixes #1925 where srcElement might not be defined either
            event.target = event.srcElement || document;
        }

        // check if target is a textnode (safari)
        if ( event.target.nodeType === 3 ) {
            event.target = event.target.parentNode;
        }

        // Add relatedTarget, if necessary
        if ( !event.relatedTarget && event.fromElement ) {
            event.relatedTarget = event.fromElement === event.target ? event.toElement : event.fromElement;
        }

        // Calculate pageX/Y if missing and clientX/Y available
        if ( event.pageX == null && event.clientX != null ) {
            var doc = document.documentElement,
                body = document.body;

            event.pageX = event.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
            event.pageY = event.clientY + (doc && doc.scrollTop  || body && body.scrollTop  || 0) - (doc && doc.clientTop  || body && body.clientTop  || 0);
        }

        // Add which for key events
        if ( event.which == null && (event.charCode != null || event.keyCode != null) ) {
            event.which = event.charCode != null ? event.charCode : event.keyCode;
        }

        // Add metaKey to non-Mac browsers (use ctrl for PC's and Meta for Macs)
        if ( !event.metaKey && event.ctrlKey ) {
            event.metaKey = event.ctrlKey;
        }

        // Add which for click: 1 === left; 2 === middle; 3 === right
        // Note: button is not normalized, so don't use it
        if ( !event.which && event.button !== undefined ) {
            event.which = (event.button & 1 ? 1 : ( event.button & 2 ? 3 : ( event.button & 4 ? 2 : 0 ) ));
        }

        return event;
    },

    // Deprecated, use jQuery.guid instead
    guid: 1E8,

    // Deprecated, use jQuery.proxy instead
    proxy: jQuery.proxy,

    special: {
        ready: {
            // Make sure the ready event is setup
            setup: jQuery.bindReady,
            teardown: jQuery.noop
        },

        live: {
            add: function( handleObj ) {
                jQuery.event.add( this,
                    liveConvert( handleObj.origType, handleObj.selector ),
                    jQuery.extend({}, handleObj, {handler: liveHandler, guid: handleObj.handler.guid}) );
            },

            remove: function( handleObj ) {
                jQuery.event.remove( this, liveConvert( handleObj.origType, handleObj.selector ), handleObj );
            }
        },

        beforeunload: {
            setup: function( data, namespaces, eventHandle ) {
                // We only want to do this special case on windows
                if ( jQuery.isWindow( this ) ) {
                    this.onbeforeunload = eventHandle;
                }
            },

            teardown: function( namespaces, eventHandle ) {
                if ( this.onbeforeunload === eventHandle ) {
                    this.onbeforeunload = null;
                }
            }
        }
    }
};

