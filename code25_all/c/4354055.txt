 if(font_info.flags & FONT_LOWERCASE_ONLY)
  ch = tolower(ch);
 if(font_info.flags & FONT_UPPERCASE_ONLY)
  ch = toupper(ch);

#define FONT_LOWERCASE_ONLY  1
#define FONT_UPPERCASE_ONLY  2

struct FontEntry
{
 int id;
 unsigned char width, height;
 const char *name;
 const char *lookup;
 const char *data;
 int flags;
};

struct FontEntry fonts[NUM_FONTS + 1] = {
 { 0, 8, 14, "Outlined8x14", &font_lookup_outlined8x14, &font_data_outlined8x14, 0 },
 { 1, 8, 8, "Outlined8x8", &font_lookup_outlined8x8, &font_data_outlined8x8, FONT_UPPERCASE_ONLY }, 
 { 2, 8, 8, "Tiny5x5", 0, 0, 0 }, // not yet implemented
 { -1 } // ends font table
};

void write_char(char ch, unsigned int x, unsigned int y, int flags, int font)
{
 int i, yy, addr_temp, row, row_temp, xshift;
 uint16_t and_mask, or_mask, level_bits;
 struct FontEntry font_info;
 char lookup;
 fetch_font_info(ch, font, &font_info, &lookup);
    // ...
}

int fetch_font_info(char ch, int font, struct FontEntry *font_info, char *lookup)
{
 // First locate the font struct.
 if(font > SIZEOF_ARRAY(fonts))
  return 0; // font does not exist, exit.
 // Load the font info; IDs are always sequential.
 *font_info = fonts[font];
 // Locate character in font lookup table. (If required.)
 if(lookup != NULL)
 {
  *lookup = font_info->lookup[ch];
  if(lookup == 0xff)
   return 0; // character doesn't exist, don't bother writing it.
 }
 return 1;
}

