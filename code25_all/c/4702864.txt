expand': undefined reference to
number=0xbffff3f2 "6900101001") at pro.c:80
    list = 0xffffffff

number=0xbffff3f2 "6900101001", name=0x804b6e0 "Irgaedggfs",

    number = "6900101001"
    name = 0x804b6e0 "Irgaedggfs"
    time = 6943

typedef struct 
{
     int length;        
     struct  List *head;    
} HashTable;

  //resolving collisions using linked lists - chaining
typedef struct 
{
     char *number;
     char *name;
     int time;
     struct List *next;
}List;



HashTable* expand( HashTable* h )
{    
          HashTable* new;
          int n;
          List *node,*next;
          PrimesIndex++;
          int new_size= primes[PrimesIndex];        /* double the size,odd length */

          if (!(new=malloc((sizeof( List*))*new_size))) return NULL;

          for(n=0; n< h->length; ++n) {
                for(node=h[n].head; node; node=next) {
                      add (new, node->number, node->name,node->time);
                      next=node->next;
                      free(node);
                }
          }
          free(h);
          return new;
}


int add ( HashTable* hashtable,char number[10],char* name,int time)
{
     List *new_elem;
    int hashval=hash (hashtable,number);

    new_elem=hashtable[hashval].head;
    if(hashtable[hashval].length>0) 
    {                   
          if ((lookup (hashtable,hashval,number))!=NULL) {return 0;}    
    }

    if (!(new_elem=malloc(sizeof(struct  List)))){ return -1;}

    //insert values for the new elem
    new_elem->number=strdup(number);    
    new_elem->name=strdup(name);
    new_elem->time=time;

    hashtable[hashval].head=new_elem;
    new_elem->next=NULL;
    hashtable[hashval].length++;

    /* rehash existing entries if necessary */
    if( TableSize(hashtable)>= 2*size]) 
    {    
         hashtable = expand(hashtable);
         if (hashtable ==NULL){
           return 0;
         }

    }
    return 1;
}



List *lookup ( HashTable *h ,int hashval,char number[10])
{
    List *list=h[hashval].head;
    for(list; list!=NULL; list=list->next){
            if (strcmp(number,list->number)==0)  //**SEGMENTATION**!!!!
                return list;

    }
    return NULL;
}

