struct buf *bufPtr = malloc((sizeof(struct buf))*(MAX_FILE_SIZE));

(sizeof(struct buf))*(MAX_FILE_SIZE)
#define MAX_SIZE_PER_FILE 0x4000000
FILE *fp;
struct buf *bufPtr = malloc((sizeof(struct buf))*(MAX_FILE_SIZE));

k1[0]=0x0000;

k1[1]=0x0000;

while(k1[0] != 0xffff)

{

    while(k1[1] != 0xffff)

    {
                //something different happens in the below line, but has noting to do with segmentation errors
                bufPtr[i].a[1] = k[1]
                //occurs on all variables of the struct

                if( write_count + sizeof(struct buf) >= sizeof(struct buf)*MAX_FILE_SIZE ) {

                     write_count = 0;

                     sprintf( filename, "keys%d", file_idx );

                     file_idx++;

                     fp = fopen(filename, "wb");
                     printf("test1");
                     fwrite(bufPtr, sizeof(struct buf)*(MAX_FILE_SIZE),1,fp);
                     fclose(fp);
                     free(bufPtr);

                  }
                write_count += sizeof(struct buf);
                k1[1]++;

                counter++;

     }
     write_count += sizeof(struct buf);

     k1[1]++;

     i++;

struct buf{

    unsigned short a[2];

     unsigned short b[2];

};

Program received signal:  “EXC_BAD_ACCESS”.
sharedlibrary apply-load-rules all
(gdb) 

bufPtr[counter].a[0] = a1[0];

