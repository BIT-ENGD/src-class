#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

// Data Structures
typedef struct process{
    char    jobName;
    int     arrivalTime;
    int     execTime;
    struct process *next;
} P;

typedef struct result{
    char Name;
    struct result *next;
} result;
// End of Data Structures

int quantum;
int jobCounts=0;
int ResponseTime=0;
double timeEsp=0;

// Function Prototypes
int gettimeofday(struct timeval *tp, void * tzp);
void add_to_process_list(P **List,P *data);
void add_to_result_list(result **List,char name);
P *readData(char* fileName);
void writeData(result *res,char *out);
P *removeFromList(P **head,P **El);
int jobCount(P *head);
double get_time(void);
// End of Function Prototypes

int main(int argc,char *argv[]){
    P *pList=NULL,*tmpNode=NULL;
    result *RR_result=NULL,*JR=NULL;
    double start, stop;
    int counter=0;

    printf("Reading Data ... ");
    pList=readData(argv[1]);
    printf("Complete\n");
    jobCounts=jobCount(pList);

    start = get_time();

    printf("Algorithm Started ...\n");
    if(pList!=NULL){
        tmpNode=pList;

        while(tmpNode!=NULL){
            if(tmpNode->arrivalTime<=counter){
                JR=(result *)malloc(sizeof(result *));
                printf("Giving Quantum to %c\n",tmpNode->jobName);
                Sleep(quantum*1000); //simulate process time
                add_to_result_list(&RR_result,tmpNode->jobName);
                tmpNode->execTime-=quantum;
                if(tmpNode->execTime==0){
                    ResponseTime+=((get_time()-start)-tmpNode->arrivalTime);
                    tmpNode=removeFromList(&pList,&tmpNode);
                }else
                    tmpNode=tmpNode->next;
                counter++;
            }else
                tmpNode=tmpNode->next;
        }

        printf("Algorithm Finished.\n");
        stop= get_time();
        timeEsp=(stop-start);
        printf("Writing data ... ");
        writeData(RR_result,argv[2]);
        printf("Completed.\n");
        return 0;
    }else{
        return 1;
    }

}

void add_to_process_list(P **List,P *data){
    P *new=malloc(sizeof(P));
    new->arrivalTime=data->arrivalTime;
    new->execTime=data->execTime;
    new->jobName=data->jobName;

    if((*List)==NULL){
        new->next=new;
        *List=new;
    }else{
        P *tmp;
        tmp=*List;
        while(tmp->next!=(*List)) tmp=tmp->next;
        tmp->next=new;
        new->next=*List;
    }
}

void add_to_result_list(result **List,char name){
    result *new=malloc(sizeof(result));
    new->Name=name;
    new->next=NULL;

    if(*List==NULL){
        *List=new;
    }else{
        result *tmp;
        tmp=*List;
        while(tmp->next!=NULL) tmp=tmp->next;
        tmp->next=new;
    }
}

P *readData(char* fileName){
    P *head=NULL,*cur=NULL;
    char Name[20],tmp[255];
    int AT,ET;
    FILE *iF;

    if((iF=fopen(fileName,"r"))>0){
        fgets(tmp,255,iF);
        sscanf(tmp,"Interval:%d\n",&quantum);
        fgets(tmp,255,iF); //waste

        while(!feof(iF) &&  fgets(tmp,255,iF)){
            sscanf(tmp,"%20c %20d %20d",Name,&AT,&ET);
            cur=(P *)malloc(sizeof(P *));
            cur->jobName=Name[0];
            cur->arrivalTime=AT;
            cur->execTime=ET;
            add_to_process_list(&head,cur);
        }

        fclose(iF);
        return head;
    }else{
        printf("Fatal error:\n\tError openning input file.\n");
        return NULL;
    }
}

void writeData(result * res ,char *out){
    result *tmp=res;
    FILE *oF;
    int tmpCounter=1;
    double throughput=jobCounts/timeEsp;
    double RR=ResponseTime/jobCounts;

    if((oF=fopen(out,"w"))>0){
        fprintf(oF,"%-15s %-15s\n","Job Name","Execution Time");
        while(tmp!=NULL){
            if(tmp->next!=NULL && tmp->Name==tmp->next->Name)
                tmpCounter++;
            else{
                fprintf(oF,"%-15c %-15d\n",tmp->Name,tmpCounter*quantum);
                tmpCounter=1;
            }
            tmp=tmp->next;
        }
        fprintf(oF,"Response Time: %0.2f\n",RR);
        fprintf(oF,"Throghput: %0.2f\n",throughput);

        fclose(oF);
    }else{
        printf("Fatal error:\n\tError openning output file.\n");
    }
}


P *removeFromList(P **head,P **El){
    P *tmp=*head;
    if((*El)->next==*El){
        free(*El);
        return NULL;
    }else{
        while(tmp->next!=NULL && tmp->next!=*El) tmp=tmp->next;
        tmp->next=tmp->next->next;
        free(*El);
        return tmp->next;
    }
}

int jobCount(P *head){
    P *tmp=head;
    int count=1;
    if(tmp->next==tmp){
        return 1;
    }

    while(tmp->next!=head) {
        tmp=tmp->next;
        count++;
    }
    return count;
}


double get_time(void){
    struct timeval stime;
    gettimeofday (&stime, (struct timezone*)0);
    return (stime.tv_sec+((double)stime.tv_usec)/1000000);
}

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

// Data Structures
typedef struct process{
    char    jobName;
    int     arrivalTime;
    int     execTime;
    struct process *next;
} P;

typedef struct result{
    char Name;
    struct result *next;
} result;
// End of Data Structures

int quantum;
int jobCounts=0;
int ResponseTime=0;
double timeEsp=0;

// Function Prototypes
int gettimeofday(struct timeval *tp, void * tzp);
void add_to_process_list(P **List,P *data);
void add_to_result_list(result **List,char name);
P *readData(char* fileName);
void writeData(result *res,char *out);
P *removeFromList(P **head,P **El);
int jobCount(P *head);
double get_time(void);
// End of Function Prototypes

int main(){
    P *pList=NULL,*tmpNode=NULL;
    result *RR_result=NULL,*JR=NULL;
    double start, stop;
    int counter=0;
    char *in="input.txt";
    char *out="output.txt";

    printf("Reading Data ... ");
    pList=readData(in);
    printf("Complete\n");
    jobCounts=jobCount(pList);

    start = get_time();

    printf("Algorithm Started ...\n");
    if(pList!=NULL){
        tmpNode=pList;

        while(tmpNode!=NULL){
            if(tmpNode->arrivalTime<=counter){
                JR=(result *)malloc(sizeof(result *));
                printf("Giving Quantum to %c\n",tmpNode->jobName);
                Sleep(quantum*1000); //simulate process time
                add_to_result_list(&RR_result,tmpNode->jobName);
                tmpNode->execTime-=quantum;
                if(tmpNode->execTime==0){
                    ResponseTime+=((get_time()-start)-tmpNode->arrivalTime);
                    tmpNode=removeFromList(&pList,&tmpNode);
                }else
                    tmpNode=tmpNode->next;
                counter++;
            }else
                tmpNode=tmpNode->next;
        }

        printf("Algorithm Finished.\n");
        stop= get_time();
        timeEsp=(stop-start);
        printf("Writing data ... ");
        writeData(RR_result,out);
        printf("Completed.\n");
        return 0;
    }else{
        return 1;
    }

}

void add_to_process_list(P **List,P *data){
    P *new=malloc(sizeof(P));
    new->arrivalTime=data->arrivalTime;
    new->execTime=data->execTime;
    new->jobName=data->jobName;

    if((*List)==NULL){
        new->next=new;
        *List=new;
    }else{
        P *tmp;
        tmp=*List;
        while(tmp->next!=(*List)) tmp=tmp->next;
        tmp->next=new;
        new->next=*List;
    }
}

void add_to_result_list(result **List,char name){
    result *new=malloc(sizeof(result));
    new->Name=name;
    new->next=NULL;

    if(*List==NULL){
        *List=new;
    }else{
        result *tmp;
        tmp=*List;
        while(tmp->next!=NULL) tmp=tmp->next;
        tmp->next=new;
    }
}

P *readData(char* fileName){
    P *head=NULL,*cur=NULL;
    char Name[20],tmp[255];
    int AT,ET;
    FILE *iF;

    if((iF=fopen(fileName,"r"))>0){
        fgets(tmp,255,iF);
        sscanf(tmp,"Interval:%d\n",&quantum);
        fgets(tmp,255,iF); //waste

        while(!feof(iF) &&  fgets(tmp,255,iF)){
            sscanf(tmp,"%20c %20d %20d",Name,&AT,&ET);
            cur=(P *)malloc(sizeof(P *));
            cur->jobName=Name[0];
            cur->arrivalTime=AT;
            cur->execTime=ET;
            add_to_process_list(&head,cur);
        }

        fclose(iF);
        return head;
    }else{
        printf("Fatal error:\n\tError openning input file.\n");
        return NULL;
    }
}

void writeData(result * res ,char *out){
    result *tmp=res;
    FILE *oF;
    int tmpCounter=1;
    double throughput=jobCounts/timeEsp;
    double RR=ResponseTime/jobCounts;

    if((oF=fopen(out,"w"))>0){
        fprintf(oF,"%-15s %-15s\n","Job Name","Execution Time");
        while(tmp!=NULL){
            if(tmp->next!=NULL && tmp->Name==tmp->next->Name)
                tmpCounter++;
            else{
                fprintf(oF,"%-15c %-15d\n",tmp->Name,tmpCounter*quantum);
                tmpCounter=1;
            }
            tmp=tmp->next;
        }
        fprintf(oF,"Response Time: %0.2f\n",RR);
        fprintf(oF,"Throghput: %0.2f\n",throughput);

        fclose(oF);
    }else{
        printf("Fatal error:\n\tError openning output file.\n");
    }
}


P *removeFromList(P **head,P **El){
    P *tmp=*head;
    if((*El)->next==*El){
        free(*El);
        return NULL;
    }else{
        while(tmp->next!=NULL && tmp->next!=*El) tmp=tmp->next;
        tmp->next=tmp->next->next;
        free(*El);
        return tmp->next;
    }
}

int jobCount(P *head){
    P *tmp=head;
    int count=1;
    if(tmp->next==tmp){
        return 1;
    }

    while(tmp->next!=head) {
        tmp=tmp->next;
        count++;
    }
    return count;
}


double get_time(void){
    struct timeval stime;
    gettimeofday (&stime, (struct timezone*)0);
    return (stime.tv_sec+((double)stime.tv_usec)/1000000);
}

