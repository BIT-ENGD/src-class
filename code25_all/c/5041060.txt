#include<curses.h>
#include<strings.h>
#include<unistd.h> 
#include<stdlib.h>

/*Implements a Scrolling headband that takes a string argument and continously scrolls*/               
int main(int argc, char* argv[])
{
    /*A Substring function to return substring of a string*/
    char *substr(const char *src, int start, int len);
    /*Appends a character to the Given string*/
    void append(char* s, char c);
    /***Check if the argument is invalid***/
    if(argc!=2)
    {
        puts("Invalid number of arguments: Usage:headband <String>");
    }
    /**Get headtext from the string argument argv[1]**/
    char *headtext = argv[1];

    /*headband(headtext);*/
    /*temporary variable to store strings as execution progresses*/
    char temp[100];
    /*Counter for streaming and scolling headband text*/
    int count = 0;
    /*Placeholder for temporary headband text*/
    char hold[100];
    int i;
    /*maximum x and y co-ordinates of the Screen*/
    int max_x,max_y;
    /*Initialize screen for ncurses*/
    initscr();
    /*Don't show cursor*/
    curs_set(0);
    /*Get terminal console dimensions*/
    getmaxyx(stdscr, max_y, max_x);
    /*Get console width set to default console screen width=80*/
    int consolewidth = max_x;
    /*Clear the screen*/
    clear();
    /*Set the first value as end of String for the momment*/
    temp[0] = '\0';
    /*Run this loop continuously to keep scrolling*/
    for (;;)
    {
        for(i=0; i < strlen(headtext); i++)
        {
            count++;
            /*Append headband text character by character to string hold*/
            append(temp, headtext[i]);
            move(0,consolewidth - count);
            if (consolewidth - count > 0)
            {
                mvaddstr(0,console_width-count,temp);
                refresh();
            }
            else if (consolewidth - count == 0)
            {
                strcpy(hold, temp);
                char q;
                int com = i;
                for(;;)
                {
                    /*Scroll text by triming one character at a time*/ 
                    /*from the left, then adding that character to the*/
                    /*right side of the text*/
                    com = com + 1;
                    if (com < strlen(headtext))
                    {
                        q = headtext[com];
                    }
                    else
                    {
                        com = 0;
                        q = headtext[com];
                        //q = hold[0];
                    }
                    strcpy(hold, substr(hold, 1, strlen(hold) - 1));
                    append(hold, q);
                    move(0,0);
                    clear();
                    mvaddstr(0,0,hold);
                    refresh();
                    usleep(50);
                }
            }
            usleep(50);
        }
    }
    return 0;
}

/*A Substring function to return substring of a string*/
char * substr(const char *src, int start, int len) 
{   
    char *dest = malloc(len+1);   
    if (dest) 
    {
        memcpy(dest, src+start, len);     
        dest[len] = '\0';   
    }   
    return dest;
}

/*Appends a character to the Given string*/
void append(char s[], char c)
{
    int len = strlen(s);
    s[len] = c;
    s[len+1] = '\0';
}

