// this is the bit that gets a line from the child
if( fgets( line, MAX_LINE_LENGTH, fpin ) == NULL ) {
    if( ferror(fpin) ) {
        perror("error on stream fpin");
    }
    free( line );
    return FAIL;
}

// set up pipes
int readPipe[2]; // child -> parent communication
int writePipe[2]; // parent -> child communication
int errorPipe[2]; // child -> parent, to check for errors in exec

/* create pipe */
pipe( readPipe ); // error if return val < 1 for any
pipe( writePipe );
pipe( errorPipe );
pid_t pid; /* process id when we fork */
pid = fork(); /* create new child */

if( pid == 0 ) { /* pid == 0 indicates child process */

    // close unused fds
    close( PARENT_READ );
    close( PARENT_WRITE );
    close( errorPipe[0] );

    dup2( CHILD_READ, 0 ); // replace stdin with pipe in
    dup2( CHILD_WRITE, 1 ); // replace stdout with pipe out

    /* replace child process with program to run */
    execvp(args[0], args);

    // if we get here, exec failed so inform the parent
    char *error_message = "exec failed";
    write( errorPipe[1], error_message, strlen(error_message)+1 );
    exit(-1);

} 

