    int jacobi_gpu(double A[], double Q[], 
           double tol, long int dim){
  int nrot, p, q, k, tid;
  double c, s;
  double *mc, *vc, *res;
  int i,kc;
  double vc1, vc2;

  mc   = (double *)malloc(2 * dim * sizeof(double));
  vc   = (double *)malloc(2 * dim * sizeof(double));
  vc   = (double *)malloc(dim * dim * sizeof(double));

  if( mc == NULL || vc == NULL){
    fprintf(stderr, "pb allocation matricre\n");
    exit(1);
  }

  nrot = 0;

  for(k = 0; k < dim - 1; k++){

    eye(mc, dim);
    eye(vc, dim);

    for(tid = 0; tid < floor(dim /2); tid++){
      p = (tid + k)%(dim - 1);
      if(tid != 0)
    q = (dim - tid + k - 1)%(dim - 1);
      else
    q = dim - 1;

      printf("p = %d | q = %d\n", p, q);
      if(fabs(A[p + q*dim]) > tol){

    nrot++;
    symschur2(A, dim, p, q, &c, &s);


    mc[2*tid] = p;                                               vc[2 * tid] = c;
    mc[2*tid + 1] = q;                                           vc[2*tid + 1] = -s;
    mc[2*tid + 2*(dim - 2*tid) - 2] = p;                         vc[2*tid + 2*(dim - 2*tid)   - 2 ] = s;
    mc[2*tid + 2*(dim - 2*tid) - 1] = q;                         vc[2 * tid + 2*(dim - 2*tid) - 1 ] = c;



    }
    }

    for( i = 0; i< dim; i++){
      for(kc=0; kc < dim; kc++){
    if( kc < floor(dim/2)) {
      vc1 = vc[2*kc + i*dim];
      vc2 = vc[2*kc + 2*(dim - 2*kc) - 2];
    }else {
      vc1 = vc[2*kc+1 + i*dim];
      vc2 = vc[2*kc - 2*(dim - 2*kc) - 1];
    }
    res[kc + i*dim] = A[mc[2*kc] + i*dim]*vc1 + A[mc[2*kc + 1] + i*dim]*vc2;
      }
    }

    zero(A, dim);

    for( i = 0; i< dim; i++){
      for(kc=0; kc < dim; k++){
    if( k < floor(dim/2)){
      vc1 = vc[2*kc + i*dim];
      vc2 = vc[2*kc + 2*(dim - 2*kc) - 2];
    }else {
      vc1 = vc[2*kc+1 + i*dim];
      vc2 = vc[2*kc - 2*(dim - 2*kc) - 1];
    }
    A[kc + i*dim] = res[mc[2*kc] + i*dim]*vc1 + res[mc[2*kc + 1] + i*dim]*vc2;
      }
    }


    affiche(mc,dim,2,"Matrice creuse");
    affiche(vc,dim,2,"Valeur creuse");

  }

  free(mc);
  free(vc);
  free(res);
  return nrot;
}

    jacobi_gpu.c: In function ‘jacobi_gpu’:
jacobi_gpu.c:103: error: array subscript is not an integer
jacobi_gpu.c:103: error: array subscript is not an integer
jacobi_gpu.c:118: error: array subscript is not an integer
jacobi_gpu.c:118: error: array subscript is not an integer
make: *** [jacobi_gpu.o] Erreur 1

res[kc + i*dim] = A[mc[2*kc] + i*dim]*vc1 + A[mc[2*kc + 1] + i*dim]*vc2;

A[kc + i*dim] = res[mc[2*kc] + i*dim]*vc1 + res[mc[2*kc + 1] + i*dim]*vc2;

