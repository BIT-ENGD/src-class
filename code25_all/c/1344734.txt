#define __WIN32__

#include "erl_driver.h"

typedef struct {
    ErlDrvPort port;
} erl_driver_bridge_data;

static ErlDrvData bridge_start(ErlDrvPort port, char *buff) {
    erl_driver_bridge_data* d =
        (erl_driver_bridge_data*)driver_alloc(sizeof(erl_driver_bridge_data));
    d->port = port;
    return (ErlDrvData)d;
}

static void bridge_stop(ErlDrvData data) {
    driver_free((char*)data);
}

static void bridge_output(ErlDrvData data, char *buff, int bufflen) {
    erl_driver_bridge_data* d = (erl_driver_bridge_data*)data;
}

ErlDrvEntry erl_driver_bridge_entry = {
    NULL,               /* F_PTR init, N/A */
    bridge_start,       /* L_PTR start, called when port is opened */
    bridge_stop,        /* F_PTR stop, called when port is closed */
    bridge_output,      /* F_PTR output, called when erlang has sent */
    NULL,               /* F_PTR ready_input */
    NULL,               /* F_PTR ready_output */
    "erl_driver_bridge", /* char *driver_name, the argument to open_port */
    NULL,               /* F_PTR finish, called when unloaded */
    NULL,               /* Not used */
    NULL,               /* F_PTR control, port_command callback */
    NULL,               /* F_PTR timeout, reserved */
    NULL,               /* F_PTR outputv, reserved */
    NULL,               /* F_PTR ready_async */
    NULL,               /* F_PTR flush */
    NULL,               /* F_PTR call */
    NULL,               /* F_PTR event */
    ERL_DRV_EXTENDED_MARKER,
    ERL_DRV_EXTENDED_MAJOR_VERSION,
    ERL_DRV_EXTENDED_MINOR_VERSION,
    0,
    NULL,               /* Reserved -- Used by emulator internally */
    NULL,               /* F_PTR process_exit */
};

DRIVER_INIT(erl_driver_bridge) {
    return &erl_driver_bridge_entry;
}

case erl_ddll:load_driver(".", erl_driver_bridge) of
    ok -> ok;
    {error, Error} -> erl_ddll:format_error(Error)
end.

