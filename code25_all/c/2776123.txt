#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>

typedef struct tree_node   
{
int value;
int weight;
struct tree_node *left; 
struct tree_node *right; 
} TREE_NODE;
   TREE_NODE *create_tree(int list[], int size);
TREE_NODE *search_pos_to_insert(TREE_NODE *root, int value, int *left_or_right);    
//     this is the problematic function */
void inorder(TREE_NODE *root); /* Inorder Traversing */
TREE_NODE *temp;
int main()
{
TREE_NODE *root; /* Pointer to the root of the BST */
int values[] = {10, 5, 3, 4, 1, 9, 6, 7, 8, 2}; /* Values for BST */
int size = 10, tree_weight;

root = create_tree(values, 10);
printf("\n");

inorder(root); /* Inorder BST*/
system("PAUSE");
}


TREE_NODE *search_pos_to_insert(TREE_NODE *root, int value, int *left_or_right)
{
if(root !=NULL)
{
temp = root;
if(value >root->value)
{
    *left_or_right=1;
    *search_pos_to_insert(root->right, value, left_or_right);   
}
else
{
    *left_or_right=0;
    *search_pos_to_insert(root->left, value, left_or_right);
}
}
else

return temp;/* THIS IS THE PROBLEM (1) */


}
TREE_NODE *create_tree(int list[], int size)
{
TREE_NODE *new_node_pntr, *insert_point, *root = NULL;
int i, left_or_right;

/* First Value of the Array is the root of the BST */
new_node_pntr = (TREE_NODE *) malloc(sizeof(TREE_NODE));
new_node_pntr->value = list[0]; 
new_node_pntr->weight = 0;
new_node_pntr->left = NULL;
new_node_pntr->right = NULL;
root = new_node_pntr; 
/* Now the rest of the arrat. */
for (i = 1; i < size; i++)
{
/* THIS IS THE PROBLEM (2) */

    insert_point = search_pos_to_insert(root, list[i], &left_or_right); 

    /* insert_point just won't get the return from temp */
    new_node_pntr = (TREE_NODE *) malloc(sizeof(TREE_NODE));
    new_node_pntr->value = list[i];
    new_node_pntr->weight = 0;
    new_node_pntr->left = NULL;
    new_node_pntr->right = NULL;
    if (left_or_right == 0)
        insert_point->left = new_node_pntr;
    else
        insert_point->right = new_node_pntr;
}
return(root);
}


void inorder(TREE_NODE *root)
{
if (root == NULL)
    return;
inorder(root->left);
printf("Value: %d, Weight: %d.\n", root->value, root->weight);
inorder(root->right);
}

