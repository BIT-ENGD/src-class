0: first line of first command.  
0: second line of first command.  
1: first line of second command.  
0: third line of first command.  
1: second line of second command.  

#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include <sys/types.h>
#include <sys/time.h> 
#include "readline.h"

/* Fetches the number of commands in parameters. Number of Commas + 1 */
int getNbCmd(char ** argv)
{
    int nbCmd = 1;
    int i = 0;    
    while(argv[i] != '\0')
    {
        if(strcmp(argv[i], ",") == 0)
            nbCmd++;
        i++;
    }
    return nbCmd;
}


/* Fills the Command Array */
void getCommandes(char *** tbCmd, int argc, char ** argv)
{    
    int indexArgv = 1;
    int indexCmd = 0;
    int indexTbCmd = 0;        

    char ** cmd = (char **)malloc(argc*sizeof(char *));
    if(indexArgv < argc)
    {
        if(strcmp(argv[indexArgv], "--tick") == 0)
            indexArgv = 3;
    }

    while (indexArgv < argc)
    {
        if(strcmp(argv[indexArgv], ",") == 0)
        {    
            cmd[indexCmd] = (char *) 0;
            tbCmd[indexTbCmd] = cmd;
            free(cmd);
            cmd = (char **)malloc(argc*sizeof(char *));

            indexTbCmd++;
            indexCmd = 0;
        }
        else
        {
            char * arg;
            arg = argv[indexArgv];
            cmd[indexCmd] = arg;        

            indexCmd++;
        }
        indexArgv++;
    }

    cmd[indexCmd] = (char *) 0;
    tbCmd[indexTbCmd] = cmd;
    free(cmd);        
}

int main (int argc, char ** argv)
{
    int nbCmds = getNbCmd(argv);    
    int tick = -1;    

    char *** tbCmd = (char ***) malloc (nbCmds*sizeof(char **));

    if(argc > 3)
    {
        if(strcmp(argv[1], "--tick") == 0)
            tick = atoi(argv[2]);
    }

    getCommandes(tbCmd, argc, argv);

    int i,j;

    pid_t pidM[nbCmds];    
    int p[nbCmds][2];

    for (i = 0;i < nbCmds;i++)
    {            
        if ( pipe( p[i] ) != 0 ){ perror( "pipe()" ); exit(1); }
    }

    for (i = 0;i < nbCmds;i++)
    {    
        // fork() to get child process        
        pidM[i] = fork();    

        if ( pidM[i] < 0 ){ perror( "fork()" ); exit(1); }
        //Child Processing
        else if (pidM[i] == 0)
        {
            close(p[i][0]);
            dup2(p[i][1], STDOUT_FILENO);

            int ret;
            ret = execvp(tbCmd[i][0], tbCmd[i]);
            perror("execvp()");
        }
    }

    // Parent Processing
    for (i = 0;i < nbCmds;i++)
    {
        close(p[i][1]);
    }

    char * buffer;
    int retval = 1;
    int boolAfficher = 0;
    int nbNull = 0;        

    fd_set set;
    struct timeval timeout;

    /* Initialize the file descriptor set. */
    FD_ZERO (&set);
    for (i = 0;i < nbCmds;i++)
    {
        FD_SET (p[i][0], &set);            
    }

    while(nbNull < nbCmds)
    {
        if(tick >= 0)
        {
            timeout.tv_sec = (unsigned int)tick;
            timeout.tv_usec = 0;
            retval = select (FD_SETSIZE,&set, NULL, NULL, &timeout);                
        }
        else
            retval = select (FD_SETSIZE,&set, NULL, NULL, NULL);

        if(retval == 0)
        {
            if(boolAfficher == 0 && tick >= 0)
            {
                printf(".\n");
                boolAfficher = 1;
            }                
        }
        else if(retval > 0)
        {            
            for (i = 0;i < nbCmds;i++)
            {
                if(FD_ISSET(p[i][0], &set))
                {
                    buffer = readline(p[i][0]);
                    if(buffer[0] != '\0')
                    {
                        printf("%d: %s", i, buffer);
                    }
                    else
                    {
                        FD_CLR(p[i][0], &set);                            
                        nbNull++;
                    }
                }
                else
                    printf("Not ISSET[%d]\n", i);

                free(buffer);
            }                
        }
        else
            perror("select()");
    }

    wait(NULL);
    free(tbCmd);
    exit(0);
}

