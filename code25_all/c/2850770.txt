#include <SDL/SDL.h>
#include <SDL_opengl.h>

size_t sx=600, sy=600, bpp=32;

void render(void) {
    glEnable(GL_DEPTH_TEST);                                // enable depth testing

    glClearColor(0.0f, 0.0f, 0.0f, 0.0f);                   // clear to black
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);     // clear color/depth buffer
    glLoadIdentity();                                       // reset modelview matrix

    glColor3b(255, 0, 0);                                   // red
    glLineWidth(3.0);                                       // line width=3
    glRecti(10, 10, sx-10, sy-10);                          // draw rectangle

    glFlush();
    SDL_GL_SwapBuffers();
}

int input(void) {
    SDL_Event event;
    while (SDL_PollEvent(&event))
        if (event.type == SDL_QUIT || (event.type == SDL_KEYUP && event.key.keysym.sym == SDLK_ESCAPE)) return 0;
    return 1;
}

int main(int argc, char *argv[]) {
    SDL_Surface* surf;

    if (SDL_Init(SDL_INIT_EVERYTHING) != 0) return 0;
    if (!(surf = SDL_SetVideoMode(sx, sy, bpp, SDL_HWSURFACE|SDL_DOUBLEBUF))) return 0;

    glViewport(0, 0, sx, sy);           // reset the viewport to new dimensions
    glMatrixMode(GL_PROJECTION);        // set projection matrix to be current
    glLoadIdentity();                   // reset projection matrix
    glOrtho(0, sx, sy, 0, -1.0, 1.0);   // create ortho view
    glMatrixMode(GL_MODELVIEW);         // set modelview matrix
    glLoadIdentity();                   // reset modelview matrix

    for (;;) {
        if (!input()) break;
        render();
        SDL_Delay(10);
    }

    SDL_FreeSurface(surf);
    SDL_Quit();
    exit(0);
}

#include <SDL/SDL.h>
#include <SDL_opengl.h>

size_t sx=600, sy=600, bpp=32;

void render(void) {
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

    glLoadIdentity();                                       // set location in front of camera
    glTranslated(0, 0, -10);

    glBegin(GL_QUADS);                                      // draw a square
        glColor3d(1, 0, 0);
        glVertex3d(-2,  2,  0);
        glVertex3d( 2,  2,  0);
        glVertex3d( 2, -2,  0);
        glVertex3d(-2, -2,  0);
    glEnd();

    glFlush();
    SDL_GL_SwapBuffers();
}

int input(void) {
    SDL_Event event;
    while (SDL_PollEvent(&event))
        if (event.type == SDL_QUIT || (event.type == SDL_KEYUP && event.key.keysym.sym == SDLK_ESCAPE)) return 0;
    return 1;
}

int main(int argc, char *argv[]) {
    SDL_Surface *surf;

    if (SDL_Init(SDL_INIT_EVERYTHING) != 0) return 0;
    if (!(surf = SDL_SetVideoMode(sx, sy, bpp, SDL_OPENGL))) return 0;

    glViewport(0, 0, sx, sy);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluPerspective(45.0, (float)sx / (float)sy, 1.0, 100.0);
    glMatrixMode(GL_MODELVIEW);

    glClearColor(0, 0, 0, 1);
    glClearDepth(1.0);
    glEnable(GL_DEPTH_TEST);

    for (;;) {
        if (!input()) break;
        render();
        SDL_Delay(10);
    }

    SDL_FreeSurface(surf);
    SDL_Quit();
    return 0;
}

