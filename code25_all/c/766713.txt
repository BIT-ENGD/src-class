typedef struct MexFunArgs {
  int nrhs;
  const mxArray *prhs[];
} MexFunArgs;

/* ... now within the mexFunction ... */

MexFunArgs mfa;

mfa.prhs = prhs;

typedef struct MexFunArgs {
  int nrhs;
  const mxArray **prhs;
} MexFunArgs;

typedef struct MexFunArgs {
  int nrhs;
  const mxArray *(*prhs)[];
} MexFunArgs;

(mxArray *(*)[])

#include <pthread.h>
#include <unistd.h>
#include <mex.h>

typedef struct MexFunArgs {
  int nrhs;
  mxArray *(*prhs)[];
} MexFunArgs;

void *do_thread(void *args) {
  MexFunArgs *mfa = (MexFunArgs*) args;

  mexCallMATLAB(0, NULL, mfa->nrhs, *mfa->prhs, "disp");

  pthread_exit(NULL);
}

void mexFunction(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[]) {
  int num;

  if (nrhs < 1)
    mexErrMsgTxt("not enough input arguments");
  else
    num = mxGetScalar(prhs[0]);

  MexFunArgs mfa;

  mfa.nrhs = nrhs;
  mfa.prhs = &prhs[1]; /* <-- threads.c:29: warning: assignment from incompatible pointer type */

  pthread_t threads[num];

  int rc, t;
  for (t = 0; t < num; t++) {
    mexPrintf("In main: creating thread %d\n", t);
    rc = pthread_create(&threads[t], NULL, do_thread, (void *) &mfa);
    if (rc)
      mexErrMsgTxt("Problem with return code from pthread_create()");
  }
  return;
}

