#include        <stdio.h>
#include        <stdlib.h>
#include        <string.h>
#include        <limits.h>
#include        <unistd.h>
/* #define DEBUG */
static int    flip( int a)
{
        int b;
        b = a;
        b ^= 0x000C;
        return b;
}

static void    trace ( char * szMessage )
{
#ifdef DEBUG
     if (szMessage != NULL)
     {
       printf("DEBUG Message %s\n",szMessage);
     }
#endif
    return;
}

int     main(int argc, char     *argv[]) {

        FILE    *fp = NULL;
        int     ch=(char) 0;
        int     foundnl=0;
        char    shellpath[4096]; /* what happened to PATH_MAX? */
        char    *ptest;
        FILE    *pipe = NULL;

        /* TODO REMOVE memset(bangline, 0, sizeof(bangline)); */

        trace("STARTING");
        trace(argv[0]);
        trace("ARGUMENT");

        /* get the shell environment variable */
        ptest = getenv("SHELL");
        if (ptest == NULL)
        {
            trace("could not get shell environment variable");
            return (EXIT_FAILURE);
        }
        else
        {
            strcpy(shellpath, getenv("SHELL"));
            trace(shellpath);
        }

        if ((argc >=1) && (argv[1]!=NULL))
        {
            trace(argv[1]);
        }
        else
        {
            trace("(null)");
        }

        if (argc == 2) {
                fp = fopen(argv[1],"r");
                if (fp == NULL) {
                        fprintf(stderr,"Unable to open file %s. Exiting.\n",argv[1]);
                        exit(EXIT_FAILURE);
                }
        }
        else
        {
               printf("Usage: %s <filename>\n",argv[0]);
               exit (EXIT_SUCCESS);
        }

        /* strip out the bangline which is not encryped */
        while ((ch = fgetc(fp)) != EOF) {
              if (ch == 10)
              {
                 foundnl = 1;
                 break;
              }
        }


        if (foundnl!=1)
        {
           (void) fclose(fp);
           trace("FOUND NO NEWLINE BEFORE END OF FIRST LINE");
           return (EXIT_SUCCESS);
        }


        pipe = popen(shellpath, "w");
        if (pipe == NULL)
        {
            trace("popen failed");
            (void) fclose(fp);
            return (EXIT_FAILURE);
        }
        else
        {
            trace("writing string to pipe");

            while ((ch = fgetc(fp)) != EOF) {
               (void) fputc(flip(ch),pipe);
            }
/*            (void) fputc(EOF,pipe); */
        }

        if (pipe != NULL)
           (void) pclose(pipe);
        if (fp != NULL)
           (void) fclose(fp);
        exit (EXIT_SUCCESS);
}

#include        <stdio.h>
#include        <stdlib.h>
#include        <string.h>

static int    flip( int a)
{
        int b;
        b = a;
        b ^= 0x000C;
        return b;
}

int     main(int argc, char     *argv[]) {

        FILE    *fp = NULL, *fpOut=NULL;
        int             ch;

        char szOutputFileName[2000];
        strcpy(szOutputFileName,"");


        if (argc == 2) {
                fp = fopen(argv[1],"r");
                if (fp == NULL) {
                        fprintf(stderr,"Unable to open file %s. Exiting.\n",argv[1]);
                        exit(EXIT_FAILURE);
                }
        }
        else
        {
               printf("Usage: %s <filename>\n",argv[0]);
               exit (EXIT_SUCCESS);
        }

        strcpy(szOutputFileName, argv[1]);
        strcat(szOutputFileName, ".bin");

        fpOut = fopen(szOutputFileName,"wt");
        if (fpOut == NULL)
        {
             fprintf(stderr,"Unable to open file %s.  Exiting.\n",szOutputFileName);
             if (fp)
                 (void) fclose(fp);
             exit(EXIT_FAILURE);
        }

        /* print the header */
        fprintf(fpOut,"#!/usr/bin/shelldecrypt\n");

        /* read until the end of file, encrypting characters and writing them out to target file */
        while ((ch = fgetc(fp)) != EOF) {
              (void) fputc(flip(ch),fpOut);
        }
        if (fp)
           (void) fclose(fp);
        if (fpOut)
           (void) fclose(fpOut);

        return(EXIT_SUCCESS);
}

