char buf;
  int r;
  r = read(fileR, &buf, 1);
  if(r == 0){//file is empty
   cout<<"Empty"<<endl;
   lseek(fileR, 0, SEEK_SET);
   msgbuf.mtype = subProcessCount+1;
   msgbuf.mtext[0] = whichPid;
   sendAndCheck(queue, 3);
  }else{
   //cout<<whichPid<<" writing "<<buf<<" to pipe"<<endl;
   cout<<"Closing pipe[0]"<<endl;
   close(comPipe[0]);
   if(write(comPipe[1], &buf, 1) == -1){
    switch(errno){
     case EACCES: cout<<"EACCESS"; break;
     case EIDRM: cout<<"EIDRM"; break;
     case ENOENT: cout<<"ENOENT"; break;
     case ENOMEM: cout<<"ENOMEM"; break;
     case ENOSPC: cout<<"ENOSPC"; break;
     case EFAULT: cout<<"EFAULT"; break;
     case EINTR: cout<<"EINTR"; break;
     case EINVAL: cout<<"EINVAL"; break;
     case EPIPE: cout<<"EPIPE"; break;
     case EAGAIN: cout<<"EAGAIN"; break;
     case EBADF: cout<<"EBADF"; break;
     case EFBIG: cout<<"EFBIG"; break;
     case EIO: cout<<"EIO"; break;
     default: cout<<"writefail"<<endl; break;
    }
   }else{
    cout<<"written";
   }
   close(comPipe[1]);
   cout<<"Closing pipe[1]"<<endl;
  }

 close(comPipe[1]);   
 cout<<"Closing pipe[1]"<<endl;
 outfifo = open(pathBuf.mtext, O_WRONLY );
while(1){
r = read(comPipe[0], &buffer, BUF_SIZE);
cout<<"Buffer size: "<<r<<endl;
write(outfifo, &buffer, r);
if(r < BUF_SIZE){
  break;
 }
}
close(comPipe[0]);
cout<<"Closing pipe[0]"<<endl;
close(outfifo);

