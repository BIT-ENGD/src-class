int main(void)
{
    int n, fd1[2], fd2[2];
    pid_t pid;
    char line[100];

    if (pipe(fd1) < 0 || pipe(fd2) < 0)
    {
        printf("Pipe error\n");
        return 1;
    }

    // create the first child
    pid = fork();

    if (pid < 0)
        printf("Fork Error\n");
    else if (pid == 0)  // child segment
    {
        close(fd1[1]);  // close write end
        read(fd1[0], line, 17); // read from pipe
        printf("Child reads the message: %s", line);

        return 0;
    }
    else    // parent segment
    {
        close(fd1[0]);  // close read end
        write(fd1[1], "\nHello 1st World\n", 17);   // write to pipe

        // fork a second child
        pid = fork();

        if (pid < 0 )
            printf("Fork Error\n");
        else if (pid == 0) // child gets return value 0 and executes this block
            // this code is processed by the child process only
        {
            close(fd2[1]);  // close write end
            read(fd2[0], line, 17); // read from pipe
            printf("\nChild reads the message: %s", line);
        }
        else
        {
            close(fd2[0]);  // close read end
            write(fd2[1], "\nHello 2nd World\n", 17);   // write to pipe

            if (wait(0) != pid)
                printf("Wait error\n");
        }

        if (wait(0) != pid)
            printf("Wait error\n");

    }

    // code executed by both parent and child
    return 0;
}   // end main

./fork2 
Child reads the message:  Hello 1st World 
Wait error

Child reads the message:  Hello 2nd World 
Wait error

