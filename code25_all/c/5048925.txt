#include<stdio.h>
#include<stdlib.h>
typedef struct struct_node
{
        int data;
        struct struct_node *next;
}node;
typedef node* list;
list st=NULL;
list prev;
list insert(list);
list delete(list);
void display(list);
int n;
main()
{
    int ch;
    while(1)
    {
        printf("MENU\n");
        printf("----\n");
        printf("1.INSERT\n");
        printf("2.DELETE\n");
        printf("3.PRINT\n");
        printf("4.EXIT\n");
        printf("ENTER YOUR CHOICE:");
        scanf("%d",&ch);
        switch(ch)
        {
            case 1:
                st=insert(st);
                printf("NEW NODE INSERTED SUCCESSFULLY\n");
                break;
            case 2:
                st=delete(st);
                printf("\nDELETION SUCCESSFUL.CONTENTS ARE:\n");
                display(st);
                break;
            case 3:
                display(st);
                break;
            case 4:
                exit(0);
            default:
                printf("IT IS INVALID CHOICE\n");
                exit(0);
        }
    }
}   
void display(list temp)
{

    sleep(100);
    printf("THE LINKED LIST\n");
    printf("---------------\n");
    while(temp)
    {
        printf("%d\n",temp->data);
        temp=temp->next;
    }

}
list insert(list temp)
{
    list new;
    int i=0;
    int first=0;
    int ch;
    list prev,current;
    printf("ENTER THE DATA TO INSERT:");
    scanf("%d",&n);
    printf("MENU\n");
    printf("----\n");
    printf("1.INSERT AT FIRST\n");
    printf("2.INSERT AT LAST \n");
    printf("3.INSERT AT THE MIDDLE\n");
    printf("ENTER YOUR CHOICE:");
    scanf("%d",&ch);
    switch(ch)
    {
            case 1:
            new=(list)malloc(sizeof(list));
            new->data=n;    
            new->next=temp;
            st=new;
            return st;
            break;
        case 2:
            st=temp;
            while(temp->next!=NULL)
                temp=temp->next;
            new=(list)malloc(sizeof(list));
            temp->next=new;
            new->data=n;
            new->next=NULL;
            return st;
            break;
        case 3:
            new=(list)malloc(sizeof(list));
                new->data=n;
            st=temp;
            while(temp->next!=NULL)
            {
                ++i;
                prev=temp;
                if(prev->data < n)
                {
                    ++first;
                    current=prev->next;
                    if(current->data > n)
                    {
                        new->next=current;
                        prev->next=new;
                        return st;
                    }
                }
                temp=temp->next;
            }
            if(i==0)
            {
                if(temp->data < n)
                {
                    temp->next=new;
                    new->data=n;
                    new->next=NULL;
                }
                else
                {
                    new->next=temp;
                    temp->next=NULL;
                    st=new;
                }
            }
            else
            {
                if(first==0)
                {
                    new->next=temp;
                    new->data=n;
                    return st;
                }
                temp->next=new;
                new->data=n;
                new->next=NULL;
            }                       
            return st;
            break;
            default:
                printf("INVALID CHOICE\n");
                break;
                }                           
}
list delete(list temp)
{
    int ch;
    int val;
    display(st);
    printf("MENU\n");
    printf("1.DELETE THE FROM FIRST\n");
    printf("2.DELETE FROM LAST NODE\n");
    printf("3.DELETE FROM THE MIDDLE\n");
    printf("ENTER YOUR OPTION:");
    scanf("%d",&ch);
    switch(ch)
    {
        case 1:
            temp=temp->next;
            st=temp;
            return st;
            break;
        case 2:
            st=temp;
            prev=st;
            while(temp->next!=NULL)
            {
                prev=temp;
                temp=temp->next;
            }
            prev->next=NULL;
            return st;
            break;
        case 3:
            st=temp;
            prev=st;
                    printf("ENTER THE DATA TO BE REMOVED\n");
            scanf("%d",&val);
            while(temp->data!=val)
            {
                prev=temp;
                temp=temp->next;
            }
            prev->next=temp->next;
            return st;
            break;
        default:
            printf("INVALID CHOICE\n");
            exit(0);
    }

}

./a.out 
MENU
----
1.INSERT
2.DELETE
3.PRINT
4.EXIT
ENTER YOUR CHOICE:1
ENTER THE DATA TO INSERT:1
MENU
----
1.INSERT AT FIRST
2.INSERT AT LAST 
3.INSERT AT THE MIDDLE
ENTER YOUR CHOICE:1
NEW NODE INSERTED SUCCESSFULLY
MENU
----
1.INSERT
2.DELETE
3.PRINT
4.EXIT
ENTER YOUR CHOICE:3
THE LINKED LIST
---------------
1
MENU
----
1.INSERT
2.DELETE
3.PRINT
4.EXIT
ENTER YOUR CHOICE:4

Flat profile:

Each sample counts as 0.01 seconds.
 no time accumulated

  %   cumulative   self              self     total           
 time   seconds   seconds    calls  Ts/call  Ts/call  name    
  0.00      0.00     0.00        1     0.00     0.00  display
  0.00      0.00     0.00        1     0.00     0.00  insert

 %         the percentage of the total running time of the
time       program used by this function.

cumulative a running sum of the number of seconds accounted
 seconds   for by this function and those listed above it.

 self      the number of seconds accounted for by this
seconds    function alone.  This is the major sort for this
           listing.

calls      the number of times this function was invoked, if
           this function is profiled, else blank.

 self      the average number of milliseconds spent in this
ms/call    function per call, if this function is profiled,
       else blank.

 total     the average number of milliseconds spent in this
ms/call    function and its descendents per call, if this 
       function is profiled, else blank.

name       the name of the function.  This is the minor sort
           for this listing. The index shows the location of
       the function in the gprof listing. If the index is
       in parenthesis it shows where it would appear in
       the gprof listing if it were to be printed.

