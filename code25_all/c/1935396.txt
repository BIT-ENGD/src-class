...
int loadF ( const char *filename, plist_t pl, int size, int createFlag ) {
    FILE *pFile = NULL;
    pnode_t pn = NULL;
    int fsize;
    int total;
    int i;

    // Get file stream.
    pFile = fopen ( filename, "rb" );
    if ( !pFile ) { // File does not exist.
        if ( createFlag ) {
            if ( !createF ( filename ) ) {
                return 0;   // fail
            }
        } else {    // abort
            perror ( "loadF:fopen" );
            return 0;
        }
    }

    // Confirm that we have opened the file stream.
    if ( !pFile ) {
        pFile = fopen ( filename, "rb" );
        if ( !pFile ) {
            perror ( "loadF:fopen:" );
            return 0;
        }
    }

    // Check if list has not been initialized.
    if ( pl == NULL ) {
        fclose ( pFile );
        pFile = NULL;
        return 0;   // abort
    }

    // Get the size of the file.
    fseek ( pFile, 0, SEEK_END );
    fsize = ftell ( pFile );
    rewind ( pFile );

    // Check if the file is empty.
    if ( !fsize ) {
        fclose ( pFile );
        pFile = NULL;
        return 1;   // No data to load, continue.
    }

    // Get the total number of structures in the file.
    total = fsize / size;

    // Allocate memory for a node to transfer data.
    pn = (pnode_t) malloc ( sizeof (node_t) * sizeof (char) );
    if ( !pn ) {
        fclose ( pFile );
        pFile = NULL;
        perror ( "loadF:malloc" );
        return 0;
    }

    // Copy from file to list every structure.
    for ( i = 1; i <= total; i++ ) {
        if ( feof ( pFile ) ) {
            printf ( "OUT!" );
            break;
        }
        printf ( "g" );
        fread ( pn->key, size, 1, pFile );
        printf ( "f\n" );
        if ( ferror ( pFile ) ) {
            fclose ( pFile );
            pFile = NULL;
            perror ( "loadF:fread" );
            return 0;
        }
        addfirst ( pl, pn->key ); // Maybe we have to allocate memory with malloc every time?
        // Debug with a for loop in the nodes of the list to see if data are OK.
        printf ( "cid = %d\n", pl->head->key->card.cid );
        printf ( "limit = %5.2f\n", pl->head->key->card.limit );
        printf ( "balance = %5.2f\n", pl->head->key->card.balance );
    }

    // Close the stream.
    if ( pFile ) {
        fclose ( pFile );
        pFile = NULL;
    }

    // Deallocate transfer memory.
    if ( pn ) {
        free ( pn );
    }

    // Exit
    return 1;
}

int saveF ( const char *filename, plist_t pl, int size ) {
    FILE *pFile = NULL;     // Pointer to the file structure.
    pnode_t pn = NULL;      // Pointer to a node of a list.


    // Delete the specified file - on success it returns 0.
    if ( remove (filename) == -1 ) {
        perror ( "saveF:remove" );
        return 0;
    }

    // Re-create the file (but now is empty).
    if ( !createF (filename) ) {
        return 0;
    }

    // Get the file stream.
    pFile = fopen ( filename, "ab" );
    if ( !pFile ) {
        perror ( "saveF:fopen" );
        return 0;
    }

    // Check if list is not empty.
    if ( isEmpty ( pl ) ) {
        fclose ( pFile );
        pFile = NULL;
        return 0;           // Abort
    }

    // Traverse the list nodes and save the entity that the key points to.
    for ( pn = pl->head; pn != NULL; pn = pn->next ) {
        fwrite ( (pccms_t)(pn->key), size, 1, pFile );
        if ( ferror ( pFile ) ) {
            fclose ( pFile );
            pFile = NULL;
            perror ( "saveF:fwrite" );
            return 0;
        }
    }

    // Close the stream.
    if ( pFile ) {
        fclose ( pFile );
        pFile = NULL;
    }

    // Exit
    return 1;
}

