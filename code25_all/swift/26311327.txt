    function mapping(transform) {
        return function (reduce) {
            return function (result, input) {
                return reduce(result, transform(input));
            };
        };
    }


func mapping<T,U> ( transform:(T)-> T ) -> ( (U,T)-> ( (U,T)->U ) ) {

    return { ( transducer:(U,T) ) -> ( (U,T)->U ) in

        return { (initial:U,element:T) -> U in


            var transformedElement = transform(element);

            var  mInitial = transducer(initial,transformedElement); // this line is the problem

            return mInitial;
        }
}




    func addOne (a:Int) -> (Int) {
    return a+1;
}

func concat (c:Array<Int>,element:Int) -> (Array<Int>) {
    var collection = c;

    collection.append(element);

    return collection;

}

var example3 = [1,2,3].reduce([], concat( mapping ( addOne ) ) );

