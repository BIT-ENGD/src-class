// From NSJSONSerialization or similar and casted to an appropriate toplevel type (e.g. Dictionary). 
var parsedJson: Dictionary<String, AnyObject> = [ "int" : 1, "nested" : [ "bool" : true ] ]

class TypedObject {
    let stringValueWithDefault: String = ""
    let intValueRequired: Int
    let nestedBoolBroughtToTopLevel: Bool = false
    let combinedIntRequired: Int

    init(fromParsedJson json: NSDictionary) {
        if let parsedStringValue = json["string"] as? String {
            self.stringValueWithDefault = parsedStringValue
        }

        if let parsedIntValue = json["int"] as? Int {
            self.intValueRequired = parsedIntValue
        } else {
            // Raise an exception...?
        }

        // Optional-chaining is actually pretty nice for this; it keeps the blocks from nesting absurdly.
        if let parsedBool = json["nested"]?["bool"] as? Bool {
            self.nestedBoolBroughtToTopLevel = parsedBool
        }

        if let parsedFirstInt = json["firstInt"] as? Int {
            if let parsedSecondInt = json["secondInt"] as? Int {
                self.combinedIntRequired = parsedFirstInt * parsedSecondInt
            }
        }
        // Most succinct way to error if we weren't able to construct self.combinedIntRequired?
    }
}

TypedObject(fromParsedJson: parsedJson)

if
let
as?
let
