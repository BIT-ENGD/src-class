func netServiceDidResolveAddress(sender: NSNetService) {
   // Connect with Service
   if (self.connectWithService(sender, hostname: sender.hostName!)) {
       println("Connecting with service: domainName= \(sender.domain), type= \(sender.type), name= \(sender.name), onPort= \(sender.port) and hostname: \(sender.hostName!)");
   } else {
       println("Unable to connect with service: domainName= \(sender.domain), type= \(sender.type), name= \(sender.name), onPort= \(sender.port)");
   }
}

private func connectWithService(service: NSNetService, hostname: String) ->Bool {

    var isConnecting:Bool = false;



    if (self.browserSocket == nil || !(self.browserSocket?.isConnected)!) {

        // Initialize Socket

        self.browserSocket = GCDAsyncSocket(delegate: self, delegateQueue: dispatch_get_main_queue());



        // Connect

        while (!isConnecting){

            var error: NSError?;

            println("Connecting port : \(service.port) and hostname: \(hostname)");

            if (self.browserSocket.connectToHost(hostname, onPort: UInt16(service.port), error: &error)) {

                isConnecting = true;

            } else if (error != nil) {

                println("Unable to connect to address. Error \(error) with user info \(error?.userInfo)");

            }

        }

    } else {

        println("Connecting is: \(self.browserSocket.isConnected)");

        isConnecting = self.browserSocket.isConnected;

    }

    return isConnecting;

}

// GCDAsyncSocketDelegate methods

func socket(sock: GCDAsyncSocket!, didConnectToHost host: String!, port: UInt16) {
   println("Socket: \(sock) Did connect to host: \(host) on port:\(port)");

   // Start Reading
   sock.readDataToLength(UInt(sizeof(UInt64)), withTimeout: -1.0, tag: 0);
}

func socketDidDisconnect(sock: GCDAsyncSocket!, withError err: NSError!) {
   println("Socket \(sock) did disconnect with error \(err?)");

 }

    super.viewDidLoad()

    let barButton = UIBarButtonItem(title: "Stop Publishing", style: .Done, target: self, action: "stopPublishing");

    self.navigationItem.rightBarButtonItem = barButton;



    // Publish the service

    self.publishService();

}

// MARK: Button callbacks

private func publishService() {

    // Initialize GCDAsyncSocket

    self.socket = GCDAsyncSocket(delegate: self, delegateQueue: dispatch_get_main_queue());



    // Start listening for incoming connections

    var error: NSError?;

    if (self.socket.acceptOnPort(0, error: &error)) {

        // Initialize Service

        self.service = NSNetService(domain: "local.", type: "_mpstest._tcp", name: UIDevice.currentDevice().name, port:0);



        // Configure Service

        self.service.delegate = self;

        self.service.includesPeerToPeer = true;

        self.service.publishWithOptions(.ListenForConnections);

    } else {

        println("Unable to create socket. Error \(error?.description) with user info \(error?.userInfo)");

    }

}

func socket(sock: GCDAsyncSocket!, didConnectToHost host: String!, port: UInt16) {

func socketDidDisconnect(sock: GCDAsyncSocket!, withError err: NSError!) {

Service found is : <NSNetService 0x15e2f710> local. _mpstest._tcp. iPad 30
Connecting port : 50797 and hostname: iPad-30.local.
Connecting with service: domainName= local., type= _mpstest._tcp., name= iPad 30, onPort= 50797 and hostname: iPad-30.local.
Socket <GCDAsyncSocket: 0x15d80020> did disconnect with error Optional(Error Domain=kCFStreamErrorDomainNetDB Code=8 "nodename nor servname provided, or not known" UserInfo=0x15e3c7a0 {NSLocalizedDescription=nodename nor servname provided, or not known})
Connecting port : 50797 and hostname: iPad-30.local.
Connecting with service: domainName= local., type= _mpstest._tcp., name= iPad 30, onPort= 50797 and hostname: iPad-30.local.
Socket: <GCDAsyncSocket: 0x15e59c20> Did connect to host: 169.254.78.98 on port:50797
Socket <GCDAsyncSocket: 0x15e59c20> did disconnect with error Optional(Error Domain=GCDAsyncSocketErrorDomain Code=7 "Socket closed by remote peer" UserInfo=0x15e5b070 {NSLocalizedDescription=Socket closed by remote peer})

