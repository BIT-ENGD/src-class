class func setCertificate(certData: NSData, forKey keyName: String) -> Bool
    {
        var secCert = SecCertificateCreateWithData(kCFAllocatorDefault, certData)

        var keychainQueryDictionary: NSMutableDictionary = self.setupKeychainQueryDictionaryForKey(keyName)

        keychainQueryDictionary[kSecClassCertificate as NSString] = secCert.takeRetainedValue()

        // Protect the keychain entry so it's only valid when the device is unlocked
        keychainQueryDictionary[SecAttrAccessible] = kSecAttrAccessibleWhenUnlocked

        // Disable icloud sync of keychain data
        keychainQueryDictionary[kSecAttrSynchronizable as NSString] = kCFBooleanFalse

        let status: OSStatus = SecItemAdd(keychainQueryDictionary, nil)

        println(status)

        if status == errSecSuccess
        {
            return true
        }

        return false
    }

private class func setupKeychainQueryDictionaryForKey(keyName: String) -> NSMutableDictionary
    {
        // Setup dictionary to access keychain and specify we are using a generic password (rather than a certificate, internet password, etc)
        var keychainQueryDictionary: NSMutableDictionary = [SecClass:kSecClassGenericPassword]

        // Uniquely identify this keychain accessor
        keychainQueryDictionary[SecAttrService] = KeychainManager.serviceName

        // Uniquely identify the account who will be accessing the keychain
        var encodedIdentifier: NSData? = keyName.dataUsingEncoding(NSUTF8StringEncoding)

        keychainQueryDictionary[SecAttrGeneric] = encodedIdentifier

        keychainQueryDictionary[SecAttrAccount] = encodedIdentifier

        return keychainQueryDictionary
    }

