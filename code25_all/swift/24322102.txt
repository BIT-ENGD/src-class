p1.fillColor = SKColor.blackColor()
p1.name = p1Name
p1.physicsBody = SKPhysicsBody(circleOfRadius: 30)
p1.physicsBody.restitution = 1.0
p1.physicsBody.angularDamping = 0.0
p1.physicsBody.allowsRotation = false
p1.physicsBody.dynamic = true
p1.physicsBody.categoryBitMask = p1Category
p1.physicsBody.collisionBitMask = wallCategory | pCategory
p1.physicsBody.contactTestBitMask = pCategory

p1.position = CGPointMake(self.frame.width/2, self.frame.height/4)
self.addChild(p1)

puck.fillColor = SKColor.redColor()
puck.name = pName
puck.physicsBody = SKPhysicsBody(circleOfRadius: 25)
puck.physicsBody.restitution = 0.8
puck.physicsBody.angularDamping = 0.5
puck.physicsBody.linearDamping = 0.5
puck.physicsBody.allowsRotation = false
puck.physicsBody.usesPreciseCollisionDetection = true
puck.physicsBody.friction = 0.0
puck.physicsBody.dynamic = true
puck.physicsBody.categoryBitMask = pCategory
puck.physicsBody.collisionBitMask = wallCategory | p1Category
puck.physicsBody.contactTestBitMask = p1Category

puck.position = CGPointMake(self.frame.width/2, self.frame.height/2)
self.addChild(puck)

override func touchesBegan(touches: NSSet, withEvent event: UIEvent) {
    /* Called when a touch begins */

    for touch: AnyObject in touches {
        let location = touch.locationInNode(self)
        let body: SKPhysicsBody = self.nodeAtPoint(location).physicsBody
        if (body.node.name == self.p1Name) {
            self.fingerOnP1 = true
            self.p1.physicsBody.collisionBitMask = wallCategory
        }
    }
}

override func touchesMoved(touches: NSSet, withEvent event: UIEvent) {
    for touch: AnyObject in touches {
        let location = touch.locationInNode(self)
        let previousLocation = touch.previousLocationInNode(self)
        let body = self.nodeAtPoint(location).physicsBody
        if (body != nil && body.node != nil) {
            if (body.node.name == self.p1Name && self.fingerOnP1 == true) {
                let paddle = self.childNodeWithName(p1Name) as SKShapeNode

                var paddleX: Int = Int(paddle.position.x) + Int(location.x - previousLocation.x)
                let _x: Int = Int(paddle.frame.width/2)
                paddleX = max(paddleX, _x)
                paddleX = min(paddleX, Int(self.size.width)-_x)

                var paddleY: Int = Int(paddle.position.y) + Int(location.y - previousLocation.y)
                let _y: Int = Int(paddle.frame.height/2)
                paddleY = max(paddleY, _y)
                paddleY = min(paddleY, Int(self.size.height)-_y)

                paddle.position = CGPointMake(CGFloat(paddleX), CGFloat(paddleY))
            }
        }
    }
}

override func touchesEnded(touches: NSSet, withEvent event: UIEvent) {
    var onP1 = false
    for touch: AnyObject in touches {
        let location = touch.locationInNode(self)
        if (self.nodeAtPoint(location) == p1) {
            onP1 = true
        }
    }

    if (onP1 == true) {
        self.fingerOnP1 == false
        self.p1.physicsBody.collisionBitMask = wallCategory | pCategory
    }
}

func didBeginContact(contact: SKPhysicsContact) {
    var firstBody: SKPhysicsBody!
    var secondBody: SKPhysicsBody!

    if (contact.bodyA.categoryBitMask > contact.bodyB.categoryBitMask) {
        firstBody = contact.bodyA
        secondBody = contact.bodyB
    }
    else {
        firstBody = contact.bodyB
        secondBody = contact.bodyA
    }

    if (firstBody.categoryBitMask == p1Category && secondBody.categoryBitMask == pCategory) {
        if (self.fingerOnP1) {
            NSLog("hit", nil)
            secondBody.applyImpulse(CGVectorMake(20, 0))
        }
    }

}

