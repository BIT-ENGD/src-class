func fetchAvailableProducts() {

    let productID:NSSet = NSSet(object: self.produto_value);

    let productsRequest:SKProductsRequest = SKProductsRequest(productIdentifiers: productID);

    productsRequest.delegate = self;

    productsRequest.start();

}

func productsRequest (request: SKProductsRequest, didReceiveResponse response: SKProductsResponse) {

    var count : Int = response.products.count

    if (count>0) {

        var validProducts = response.products

         validProduct = response.products[0] as SKProduct

        if (validProduct.productIdentifier == self.produto_value) {

            println(validProduct.localizedTitle)

            println(validProduct.localizedDescription)

            println(validProduct.price)

            purchaseMyProduct()

        } else {

            println(validProduct.productIdentifier)

        }

    } else {

        println("nothing")

    }

}



func canMakePurchases() -> Bool

{

    return SKPaymentQueue.canMakePayments()

}



func purchaseMyProduct() {

    if (self.canMakePurchases() && validProduct != nil) {

        println("Purchases are allowed ...")

        var payment: SKPayment = SKPayment(product: validProduct)

        var defaultQueue: SKPaymentQueue  = SKPaymentQueue ()

        defaultQueue.addTransactionObserver(self)

        defaultQueue.addPayment(payment)

    } else {



var alert = UIAlertController(title: "MyApp", message:stringLocate.getString("PURCHASE_FAILED"), preferredStyle: UIAlertControllerStyle.Alert)

        alert.addAction(UIAlertAction(title: "OK", style: UIAlertActionStyle.Default, handler: nil))

        self.presentViewController(alert, animated: true, completion: nil)

        blackScreenTopConstraint.constant = 3000

    }

}


func paymentQueue(queue: SKPaymentQueue!, updatedTransactions transactions: [AnyObject]!)    {

    for transaction:AnyObject in transactions {

        if let trans:SKPaymentTransaction = transaction as? SKPaymentTransaction{

            switch trans.transactionState {

            case .Restored:

                SKPaymentQueue.defaultQueue().finishTransaction(transaction as SKPaymentTransaction)

                isPro = true

                blackScreenTopConstraint.constant = 3000

                updateMyLayout()

                break;

            case .Purchased:

                SKPaymentQueue.defaultQueue().finishTransaction(transaction as SKPaymentTransaction)

                isPro = true

                blackScreenTopConstraint.constant = 3000

                updateMyLayout()

                break;

            case .Deferred:

var alert = UIAlertController(title: "MyApp", message:stringLocate.getString("PURCHASE_FAILED"), preferredStyle: UIAlertControllerStyle.Alert)



                alert.addAction(UIAlertAction(title: "OK", style: UIAlertActionStyle.Default, handler: nil))

                self.presentViewController(alert, animated: true, completion: nil)

                blackScreenTopConstraint.constant = 3000 

               break

            case .Failed:

var alert = UIAlertController(title: "MyApp", message:stringLocate.getString("PURCHASE_FAILED"), preferredStyle: UIAlertControllerStyle.Alert)



                alert.addAction(UIAlertAction(title: "OK", style: UIAlertActionStyle.Default, handler: nil))

                self.presentViewController(alert, animated: true, completion: nil)

                blackScreenTopConstraint.constant = 3000

                break;

            default:

                break;

            }

        }

    }



}

