protocol SizeEnum {
    var length : Double? { get } // Length should be >= 0 - has to be an Optional for errors
}

enum SizesEnum : SizeEnum {
    case Short(length : Double) // 0 <= length <= maxShort
    case Long(length : Double) // length > maxShort
    private static let maxShort =  1.0
    var length : Double? {
    get {
        switch self {
        case let .Short(length):
            if length >= 0 && length <= SizesEnum.maxShort { // Need to error check every access
                return length
            }
        case let .Long(length):
            if length > SizesEnum.maxShort { // Need to error check every access
                return length
            }
        }
        return nil // There was an error
    }
    }
}

SizesEnum.Short(length: 0.5).length // [Some 0.5]
SizesEnum.Short(length: 2).length // nil
SizesEnum.Long(length: 2).length // [Some 2.0]
SizesEnum.Long(length: -1).length // nil

protocol SizeStruct {
    var length : Double { get } // Length should be >= 0 - is *not* an Optional
}

struct SizesStruct : SizeStruct {
    static func Short(length : Double) -> SizeStruct? {
        if length >= 0 && length <= maxShort { // Check at creation only
            return SizesStruct(length)
        }
        return nil
    }
    static func Long(length : Double) -> SizeStruct? {
        if length > maxShort { // Check at creation only
            return SizesStruct(length)
        }
        return nil
    }
    let length : Double
    private static let maxShort = 1.0
    private init(_ length : Double) {
        self.length = length
    }
}

SizesStruct.Short(0.5)?.length // [Some 0.5]
SizesStruct.Short(2)?.length // nil
SizesStruct.Long(2)?.length // [Some 2.0]
SizesStruct.Long(-1)?.length // nil

Optional
of
class Opt { // Note only Some stores the value, not None
    //class let None = Opt() - class variables not supported in beta 4!
    class Some<T> : Opt {
        let value : T
        init(_ value : T) {
            self.value = value
        }
    }
    private init() {} // Stop any other ways of making an Opt
}

Opt.Some(1).value // 1

enum
Optional
Some
None
Int
String
enum
class Barcode { // Note seperate storage for each case
    class UPCABarcode : Barcode {
        let type : Int, l : Int, r : Int, check : Int
        private init(type : Int, l : Int, r : Int, check : Int) {
            (self.type, self.l, self.r, self.check) = (type, l, r, check)
        }
    }
    class func UPCA(#type : Int, l : Int, r : Int, check : Int) -> UPCABarcode? {
        if ok(type: type, l: l, r: r, check: check) {
            return UPCABarcode(type: type, l: l, r: r, check: check)
        }
        return nil
    }
    class func QRCode(#s : String) -> Barcode? { // Have not expanded this case; use same pattern as UPCA
        return Barcode()
    }
    private init() {} // Prevent any other types of Barcode
    class func ok(#type : Int, l : Int, r : Int, check : Int) -> Bool {
        return true // In practice has to check supported type, range of L and R, and if check digit is correct
    }
}

Barcode.UPCA(type: 0, l: 1, r: 2, check: 3)

enum
Barcode
Barcode
Barcode
UPCA
QRCode
UPCA
enum
