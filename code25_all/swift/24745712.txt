_.each
_.each({foo: true, bar: false}, function(value, key) {...}
_.each([true, false], function(value, key) {...}

for (indexInt, (key, value)) enumerate(["foo": true]) {...}
for (key, value) enumerate([true]) {...}

Array
Dictionary
for (indexInt, (key, value)) enumerate(["foo": true]) {...}
for (indexInt, (key, value)) enumerate([("foo", true")]) {...}

func each<C: Collection>(collection: C, fn: (Any, Any) -> ()) -> C {
    // On next line... Error: Tuple pattern cannot match values of the non-tuple type 'C.GeneratorType.Element'
    for (_, (k, v)) in enumerate(collection) {
        if let innerV = collection[innerK] {
            fn(innerV, k)
        }
    }
    return collection
}
var ret = each(["foo":true, "bar":false]) { println("Key \($1), Value:\($0)") }

func eachDictionary<K,V>(collection: Dictionary<K, V>, fn: (V, K) -> ()) -> Dictionary<K, V> {
    for (_, (k, v)) in enumerate(collection) {
        fn(v, k)
    }
    return collection
}
var retDictionary = eachDictionary(["foo":true, "bar":false]) { println("Key \($1), Value:\($0)") }

func each<V>(collection: V[], fn: (V, Int) -> ()) -> V[] {
    for (k, v) in enumerate(collection) {
        fn(v, k)
    }
    return collection
}
var retArray = each([true, false]) { println("Key \($1), Value:\($0)") }

(K,V)
[(V1,V2)]
(K, V)
(Any, Any)
func each<C: Collection>(collection: C, fn: (Any, Any) -> ()) -> C {
    for (k, v) in enumerate(collection) {
        if let (key, value) = v as? (Any, Any) {
            fn(value, key)
        } else {
            fn(v, k)
        }
    }
    return collection
}
var ret = each(["foo":true, "bar":false]) { println("1: Key \($1), Value:\($0)") }
var arr : String[] = []
var retOne = each(arr) { println("2: Key \($1), Value:\($0)") }
var retTwo = each([true, false]) { println("3: Key \($1), Value:\($0)") }

