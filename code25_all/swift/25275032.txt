func defVal<T where T:FloatingPointType, T:FloatLiteralConvertible>(T.Type) -> T {
    return 0.0
}

func defVal<T:IntegerLiteralConvertible>(T.Type) -> T {
    return 0
}

func doSomethingGeneric<T>(t:T) -> [T]
{
    let a = defVal(T) // Type 'T' does not conform to protocol FloatLiteralConvertible
    let b = a * a   // works
    return [t]
}

func doSomethingWithFloats<T
    where T:FloatingPointType, T:FloatLiteralConvertible>(t:T) -> [T]
{
    let a = defVal(T) // works
    let b = a * a // T is not convertible to UInt8
        // - need a floating point arithmetic type?

    let c = -a          // T is not convertible to Float
    let f:Float = -a    // T is not convertible to Float
    return [t]
}

protocol Initializable {}
extension Float : Initializable {}
extension Double : Initializable {}
extension CGFloat : Initializable {}

func doSomethingWithInitializable<T:Initializable>(t:T) -> [T]
{
    let a = defVal(T) // Type 'T' does not conform to protocol FloatLiteralConvertible
    let b = a * a   // works
    return [t]
}

