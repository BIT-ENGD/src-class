@IBAction func panning(sender: AnyObject) {
    pan.maximumNumberOfTouches = 1;
    pan.minimumNumberOfTouches = 1;

    var currentPoint:CGPoint = pan.locationInView(self);
    var midPoint:CGPoint = midpoint(previousPoint, p1: currentPoint);

    if(pan.state == UIGestureRecognizerState.Began){
        path.moveToPoint(currentPoint);
    } else if (pan.state == UIGestureRecognizerState.Changed){
        path.addQuadCurveToPoint(midPoint, controlPoint: previousPoint);

    }

    path.lineCapStyle = kCGLineCapRound;
    path.lineWidth = 10;

    previousPoint = currentPoint;

    self.setNeedsDisplay();




}

override func drawRect(rect: CGRect) {

    //println(pan.velocityInView(self));

    UIColor.redColor().setStroke();


    path.stroke();

}

@IBAction func sendImage(sender: AnyObject) {

    UIGraphicsBeginImageContext(self.bounds.size);
    var ctx:CGContextRef = UIGraphicsGetCurrentContext();
    self.layer.renderInContext(ctx);
    var saveImg = UIGraphicsGetImageFromCurrentImageContext();

    UIImageWriteToSavedPhotosAlbum(saveImg, self, Selector("image:didFinishSavingWithError:contextInfo:"), nil);

    UIGraphicsEndImageContext();


}

func image(image: UIImage, didFinishSavingWithError error: NSErrorPointer, contextInfo: UnsafePointer<()>) {
    dispatch_async(dispatch_get_main_queue(), {
        UIAlertView(title: "Success", message: "This image has been saved to your Camera Roll successfully", delegate: nil, cancelButtonTitle: "Close").show()
    })
}

func midpoint(p0:CGPoint, p1:CGPoint)->CGPoint{

    var retCG:CGPoint = CGPoint(x: (p0.x + p1.x) / 2.0, y: (p0.y + p1.y) / 2.0);

    return retCG;

}

