func panning(pan: UIPanGestureRecognizer) {

    self.view.bringSubviewToFront(pan.view!)
    var translation  = pan.translationInView(self.view)

    pan.view.center = CGPointMake(pan.view.center.x + translation.x, pan.view.center.y + translation.y)

    pan.setTranslation(CGPointZero, inView: self.view)


        let panGesture = UIPanGestureRecognizer(target: self, action: "panning:");
                }
}

    // loop from 0 to 50
    for i in 0...50 {

        // create a square object
        let square = UIView()
        square.frame = CGRect(x: 55, y: 300, width: 40, height: 40)
        square.backgroundColor = UIColor.redColor()
        self.view.addSubview(square)


        let recognizer = UIPanGestureRecognizer(target: self, action: "panning:");
        recognizer.delegate = self;
        square.addGestureRecognizer(recognizer)
        panGesture.delegate = self;

override func viewDidLoad() {
    super.viewDidLoad()
    // Do any additional setup after loading the view, typically from a nib.

    srand48(Int(NSDate().timeIntervalSince1970))

    // loop from 0 to 5
    for i in 0...5 {

        // create a square
        let square = UIView()
        square.frame = CGRect(x: 55, y: 300, width: 40, height: 40)
        square.backgroundColor = UIColor.redColor()

        self.view.addSubview(square)
        //square.userInteractionEnabled = true;


        let recognizer = UIPanGestureRecognizer(target: self, action: "panning:");
        square.addGestureRecognizer(recognizer)



        // randomly create a value between 0.0 and 150.0
        let randomYOffset = CGFloat( drand48() * 150)

        // for every y-value on the bezier curve
        // add our random y offset so that each individual animation
        // will appear at a different y-position
        let path = UIBezierPath()
        path.moveToPoint(CGPoint(x: -16,y: 239 + randomYOffset))
        path.addCurveToPoint(CGPoint(x: 375, y: 239 + randomYOffset), controlPoint1: CGPoint(x: 136, y: 373 + randomYOffset), controlPoint2: CGPoint(x: 178, y: 110 + randomYOffset))

        // create the animation
        let anim = CAKeyframeAnimation(keyPath: "position")
        anim.path = path.CGPath
        anim.rotationMode = kCAAnimationRotateAuto
        anim.repeatCount = Float.infinity
        //anim.duration = 5.0

        // each square will take between 4.0 and 8.0 seconds
        // to complete one animation loop
        anim.duration = 4.0 + 3 * drand48()

        // stagger each animation by a random value
        // `290` was chosen simply by experimentation
        anim.timeOffset = 290 * drand48()


        // add the animation 
        square.layer.addAnimation(anim, forKey: "animate position along path")
    }
}


func panning(pan: UIPanGestureRecognizer) {

    if pan.state == .Began {
        println("pan began")
        self.view.bringSubviewToFront(pan.view!)

    } else if pan.state == .Changed {

        println("pan state changed")

        var translation  = pan.translationInView(self.view)

        pan.view?.center = CGPointMake(pan.view!.center.x + translation.x, pan.view!.center.y + translation.y)

        pan.setTranslation(CGPointZero, inView: self.view)

        println("translation")

    }
}

