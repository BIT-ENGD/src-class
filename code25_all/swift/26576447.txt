let transitionManager = TransitionManager()


override func viewDidLoad() {
    super.viewDidLoad()

    transitionManager.sourceViewController = self

    // Do any additional setup after loading the view.
}

override func prepareForSegue(segue: UIStoryboardSegue, sender: AnyObject!) {

    let dest = segue.destinationViewController as UIViewController
    dest.transitioningDelegate = transitionManager
    transitionManager.destViewController = dest

}

class TransitionManager: UIPercentDrivenInteractiveTransition,UIViewControllerAnimatedTransitioning, UIViewControllerTransitioningDelegate,UIViewControllerInteractiveTransitioning {

    var interactive = false
    var presenting = false

    var panGesture : UIPanGestureRecognizer!

    var sourceViewController : UIViewController! {
        didSet {

            panGesture = UIPanGestureRecognizer(target: self, action: "gestureHandler:")
            sourceViewController.view.addGestureRecognizer(panGesture)

        }
    }


    func gestureHandler(pan : UIPanGestureRecognizer) {

        let translation = pan.translationInView(pan.view!)

        let d =  translation.x / pan.view!.bounds.width * 0.5        

        switch pan.state {

        case UIGestureRecognizerState.Began :

            interactive = true

            sourceViewController.performSegueWithIdentifier("segueIdentifier", sender: self)


        case UIGestureRecognizerState.Changed :

            self.updateInteractiveTransition(d)

        default :

            interactive = false

            if d > 0.2 || velocity.x > 0 {
                self.finishInteractiveTransition()
            }
            else {
                self.cancelInteractiveTransition()
            }
        }

    }

    func animateTransition(transitionContext: UIViewControllerContextTransitioning) {

        //Something....


        UIView.animateWithDuration(1.0, animations: {

            //Something....

            }, completion: {}

        })

    }

    func transitionDuration(transitionContext: UIViewControllerContextTransitioning) -> NSTimeInterval {
        return 1
    }

    // MARK: UIViewControllerTransitioningDelegate protocol methods

    func animationControllerForPresentedController(presented: UIViewController, presentingController presenting: UIViewController, sourceController source: UIViewController) -> UIViewControllerAnimatedTransitioning? {
        self.presenting = true
        return self
    }

    func animationControllerForDismissedController(dismissed: UIViewController) -> UIViewControllerAnimatedTransitioning? {
        self.presenting = false
        return self
    }

    func interactionControllerForPresentation(animator: UIViewControllerAnimatedTransitioning) -> UIViewControllerInteractiveTransitioning? {
        return self.interactive ? self : nil
    }

    func interactionControllerForDismissal(animator: UIViewControllerAnimatedTransitioning) -> UIViewControllerInteractiveTransitioning? {
        return self.interactive ? self : nil
    }





}

