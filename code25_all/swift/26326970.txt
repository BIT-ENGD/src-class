import Foundation
import Cocoa
import NetFS

func mountVolumeAsync(#username:String, #password:String, #ipadres:String, #proto:String, #mountpoint:String) -> Bool{
    var theURLPath: NSURL
    if username.lowercaseString == "guest" {
        println("Volume will be mounted as Guest user.....")
        let thestring = "\(proto)://\(ipadres)/\(mountpoint)"
        let theURLPath = NSURL(string:thestring)
        if theURLPath == nil {
            println("Path to file is invalid.")
            return false
        }
    } else {
        let thestring = "\(proto)://\(username):\(password)@\(ipadres)/\(mountpoint)"
        let theURLPath = NSURL( string:thestring)
        if theURLPath == nil {
            println("Path to file is invalid.")
            return false
        }
    }

    var mount_options = CFDictionaryCreateMutable( kCFAllocatorDefault, 0, nil, nil);

    if (mount_options != nil) {
        CFDictionarySetValue(mount_options, kNAUIOptionKey, kNAUIOptionNoUI);
        if username.lowercaseString == "guest" {
        CFDictionarySetValue( mount_options, kNetFSUseGuestKey, kCFBooleanTrue);
        }
    }

    var status = false
    /* ---- Objective C Code to port to Swift Code ------
    AsyncRequestID requestID = NULL;
    dispatch_queue_t queue =dispatch_get_main_queue();

    NetFSMountURLAsync(
        CFBridgingRetain(theURLPath),
        NULL,
        (__bridge CFStringRef) username,
        (__bridge CFStringRef) passwd,
        mount_options,
        NULL,
        &requestID,
        queue,
        ^(int status, AsyncRequestID requestID, CFArrayRef mountpoints) {
            NSLog(@"mounted: %d - %@", status, (__bridge NSArray *) mountpoints);
    });

    if (!status) {
        NSString *msg = [NSString stringWithFormat:@"[%@]  is not mounted! Check your params",mntpt];
        return NO;
    }
    */
    return status

}

(CFMutableDictionary!) open_options = 1 key/value pair {
  [0] =
<Execution was interrupted, reason: EXC_BAD_ACCESS (code=1, address=0x4f4955414e80).
The process has been returned to the state before expression evaluation.>

func mountVolumeAsync(#username:String, #password:String, #ipadres:String, #proto:String, #mountpoint:String) -> Bool{
var theURLPath: NSURL? = nil

if username.lowercaseString == "guest" {
    // "Volume will be mounted as Guest user....."
    let thestring = StringWithFormat("%@://%@/%@",proto,ipadres,mountpoint)
    let theURLPath = NSURL(string:thestring)
    if theURLPath == nil {
        println("Path to file is invalid.")
        return false
    }
} else {
    let thestring = StringWithFormat("%@://%@:%@@%@/%@",proto,username,password,ipadres,mountpoint)
    let theURLPath = NSURL(string:thestring)
    if theURLPath == nil {
        println("Path to file is invalid.")
        return false
    }
}

var mount_options = CFDictionaryCreateMutable( kCFAllocatorDefault, 0, nil, nil);
var open_options = CFDictionaryCreateMutable( kCFAllocatorDefault, 0, nil, nil);

if open_options != nil {
    CFDictionarySetValue(open_options,"kNAUIOptionKey","NoUI")
}

if (mount_options != nil) {
    //CFDictionarySetValue(mount_options,kNAUIOptionKey"UIOption")
    if username.lowercaseString == "guest" {
        let kNetFSUseGuestKey = "Guest"
        //CFDictionarySetValue( mount_options, kNetFSUseGuestKey, kCFBooleanTrue);
        CFDictionarySetValue(open_options,kNetFSUseGuestKey, "kCFBooleanTrue")
    }
}

var status = false
var requestID: AsyncRequestID = nil
let queue = dispatch_get_main_queue()

NetFSMountURLAsync(
    theURLPath,
    nil,
    username as NSString,
    password as NSString,
    mount_options,
    open_options,
    &requestID,
    queue)
        {(stat:Int32,  requestID:AsyncRequestID,  mountpoints:CFArray!) -> Void in
            println("mounted: \(stat) - \(mountpoints)")
        }

if status == false {
    let msg = "[\(mountpoint)  is not mounted! Check your params"
    println(msg)
    return false
}
}

