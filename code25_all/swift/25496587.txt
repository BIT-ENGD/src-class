    import Foundation
import UIKit
import QuartzCore

//----Global Variables----
var timerMode = "start"
var arrowButtonTapped = false
var timerButtonTouched = false
var currentView = "brew it"

//--------My Colors -----------
let colorGreen = UIColor(red: 0.310, green: 0.725, blue: 0.624, alpha: 1.000)
let colorLightGreen = UIColor(red: 211/255, green: 217/255, blue: 195/255, alpha: 100)
var colorRed = UIColor(red: 241/255, green: 93/255, blue: 79/255, alpha: 100)
let colorDarkBlue = UIColor(red: 27/255, green: 29/255, blue: 38/255, alpha: 1.0)
let colorOrange = UIColor(red: 241/255, green: 162/255, blue: 128/255, alpha: 1.0)
let colorTransparent = UIColor(red: 241/255, green: 162/255, blue: 128/255, alpha: 0.0)

//----Countdown times----
var countTime : NSTimeInterval = 6
var halfCountTime : NSTimeInterval = countTime * 0.5
var okCountTime : NSTimeInterval = 2


//---- End Global Variables ----

//let cup1Graphic = coffeeMugVector()
//let cup2Graphic = coffeeMugVector()
//let cup3Graphic = coffeeMugVector()
//let cup4Graphic = coffeeMugVector()
//let cup5Graphic = coffeeMugVector()
//let cup6Graphic = coffeeMugVector()



//Coffe Cups x Coffee Strength returns amount of coffee as an integer
class coffeeCalculator {
    var selectedCups = 0
    var cupSelect = false
    let coffeeStronger = 20
    var coffeeStrength = 15
    let coffeeWeaker = 15
    var water = 226

    //var cupAnimation = CSAnimationView(type:"morph", duration:0.5, delay:0)

    // What to do when a cup is selected
    func cupSelected() {
        if cupSelect == true{
            selectedCups++
        }
        else if selectedCups > 0{
            selectedCups--
        }
        println("\(selectedCups)")
    }

    //take coffee cups multiplied by coffee strength and return the amount as a string

    //Calcualte coffee and return an attributed string
    func coffeeTextOnly() ->String {
        var calculatedCoffee = selectedCups * coffeeStrength
        var coffeeToString = "\(calculatedCoffee)"
        return coffeeToString
    }

    func calculateCoffee() -> (NSMutableAttributedString) {
        var calculatedCoffee = selectedCups * coffeeStrength
        var coffeeToString = "\(calculatedCoffee)"

        //Convert the CoffeeCalculator output to an attributed string
        var coffeeText = NSMutableAttributedString(string:coffeeToString)

        //Part 2 set the font attributes for the lower case g
        var coffeeTypeFaceAttributes = [NSFontAttributeName : UIFont.systemFontOfSize(18)]

        //Part 3 create the "g" character and give it the attributes that you set up
        var coffeeG = NSMutableAttributedString(string:"g", attributes:coffeeTypeFaceAttributes)
        coffeeText.appendAttributedString(coffeeG)

        return (coffeeText)
    }

    //Calculate teh amount of water needed and return it as a string
    func calculateWater() -> (NSMutableAttributedString) {
        var calculatedWater = water * selectedCups
        var waterToString = "\(calculatedWater)"

        var waterText = NSMutableAttributedString(string:waterToString)

        //Part 2 set the font attributes for the lower case g
        var waterTypeFaceAttributes = [NSFontAttributeName : UIFont.systemFontOfSize(18)]

        //Part 3 create the "g" character and give it the attributes that you set up
        var waterG = NSMutableAttributedString(string:"g", attributes:waterTypeFaceAttributes)
        waterText.appendAttributedString(waterG)

        return (waterText)
    }
}

////----BEGIN GRAPHICS ----////


//----Main Timer (circle) Button----//
@IBDesignable
class timerButtonGraphics: UIView {
    override func drawRect(rect: CGRect) {
        var bounds = self.bounds
        var center = CGPoint()
        center.x = bounds.origin.x + bounds.size.width / 2
        center.y = bounds.origin.y + bounds.size.height / 2
        var radius = 31
        var path:UIBezierPath = UIBezierPath()
        path.addArcWithCenter(center, radius: CGFloat(radius), startAngle: CGFloat(0.0), endAngle: CGFloat(Float(M_PI) * 2.0), clockwise: true)
        path.strokeWithBlendMode(kCGBlendModeNormal, alpha: 0)
        path.lineWidth = 1
        if timerMode == "reset" || timerMode == "ok" {
            colorRed.setStroke()
            colorRed.setFill()
        }
        else {
            colorGreen.setStroke()
            colorGreen.setFill()
        }
        if timerButtonTouched == true {
                path.lineWidth = 2
                path.fill()
            }
        path.stroke()
    }
}


//------Arrow Button------//
@IBDesignable
class arrowButtonGraphic: UIView {
    override func drawRect(rect: CGRect) {
        var bezierPath = UIBezierPath()
        bezierPath.moveToPoint(CGPointMake(20.36, 2.68))
        bezierPath.addLineToPoint(CGPointMake(2.69, 20.23))
        bezierPath.addCurveToPoint(CGPointMake(2.69, 28.32), controlPoint1: CGPointMake(0.44, 22.46), controlPoint2: CGPointMake(0.44, 26.09))
        bezierPath.addCurveToPoint(CGPointMake(10.84, 28.32), controlPoint1: CGPointMake(4.94, 30.56), controlPoint2: CGPointMake(8.59, 30.56))
        bezierPath.addLineToPoint(CGPointMake(22.71, 16.53))
        bezierPath.addCurveToPoint(CGPointMake(26.29, 16.53), controlPoint1: CGPointMake(23.7, 15.55), controlPoint2: CGPointMake(25.3, 15.56))
        bezierPath.addLineToPoint(CGPointMake(38.16, 28.32))
        bezierPath.addCurveToPoint(CGPointMake(46.31, 28.32), controlPoint1: CGPointMake(40.41, 30.56), controlPoint2: CGPointMake(44.06, 30.56))
        bezierPath.addCurveToPoint(CGPointMake(46.31, 20.23), controlPoint1: CGPointMake(48.56, 26.09), controlPoint2: CGPointMake(48.56, 22.46))
        bezierPath.addLineToPoint(CGPointMake(28.64, 2.68))
        bezierPath.addCurveToPoint(CGPointMake(24.48, 1), controlPoint1: CGPointMake(27.49, 1.54), controlPoint2: CGPointMake(25.98, 0.98))
        bezierPath.addCurveToPoint(CGPointMake(20.36, 2.68), controlPoint1: CGPointMake(22.99, 0.99), controlPoint2: CGPointMake(21.5, 1.55))
        bezierPath.closePath()
        bezierPath.miterLimit = 4;

        colorGreen.setStroke()
        bezierPath.lineWidth = 1
        bezierPath.stroke()
        colorGreen.setFill()
        //Rotate arrow if on "weigh it" page
        if arrowButtonTapped == true {
            bezierPath.lineWidth = 2
            bezierPath.stroke()
        }
    }
}

//----Timer Baground Circle ----//
@IBDesignable
class timerBackgroundCircle: UIView {
    override func drawRect(rect: CGRect) {
        var ovalPath = UIBezierPath(ovalInRect: CGRectMake(0, 0, 238, 238))
        colorLightGreen.setFill()
        ovalPath.fill()
    }
}

//----Timer Bagkround Mask ----//
@IBDesignable
class timerMask: UIView {
    override func drawRect(rect: CGRect) {
        let colorGreen = UIColor(red: 0.310, green: 0.725, blue: 0.624, alpha: 1.000)
        let colorRed = UIColor(red: 241/255, green: 93/255, blue: 79/255, alpha: 100)
        let colorLightGreen = UIColor(red: 211/255, green: 217/255, blue: 195/255, alpha: 100)

        //The shape to mask out
        /*var ovalPath = UIBezierPath(ovalInRect: CGRect(x: 0, y: 0, width: 238, height: 238))
        colorGreen.setFill()
        ovalPath.fill()*/

        //The rectangle
        var bounds : CGRect = self.bounds
        var maskRect = CAShapeLayer()
        maskRect.frame = bounds
        //maskRect.fillColor = colorLightGreen.CGColor

        //The circle mask
        var maskCirclePath = UIBezierPath(ovalInRect: CGRect(x: 40, y: 150, width: 238, height: 238))
        maskCirclePath.appendPath(UIBezierPath(rect: bounds))
        //combine appended path to rectangle path
        maskRect.path = maskCirclePath.CGPath
        colorRed.setFill()
        maskCirclePath.fill()
        maskRect.fillRule = kCAFillRuleEvenOdd
        self.layer.mask = maskRect
    }
}

