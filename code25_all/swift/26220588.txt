class FirstClass
{
  // lots of small functions
  ...
  func doWork(){}

  //group function that takes a closure
  func transactionsA(workUnit : ()->(NSError?)) -> NSError?
  {
      //obtain access to shared resource
      ...    
      //do work 
      workUnit()
      //close access to shared resource
      ...   
  }

  func transactionsB(workUnit : (let instanceOfFirstClass)->(NSError?)) -> NSError?
  {
      //obtain access to shared resource
      ...    
      //do work 
      workUnit(self)    
      //close access to shared resource
      ...   
  }
}


class SecondClass
{
  let instanceOfFirstClass =  FirstClass()

  //first approach
  func doGroupWorkA()
  {
     instanceOfFirstClass.transactionsA() {[unowned self] () -> (Error?) in
        self.instanceOfFirstClass.doWork()
     }
   }

  //second approach
  func doGroupWorkA()
  {
     instanceOfFirstClass.transactionsB() {[unowned self] 
      (let  instanceOfFirstClass) -> (Error?) in
        //do the actual work via the smaller functions
        instanceOfFirstClass.doWork()
     }
   }

}

