IntegerType
_BuiltInIntegerLiteralConvertible
Int
init(_builtinIntegerLiteral value: Builtin.Int2048)

Builtin.Int2048
struct MyInt : Printable, Comparable, Hashable, IntegerArithmeticType, RandomAccessIndexType, BitwiseOperationsType, IntegerType {

    var int: Int = 0

    init(_ value: Int) {
        int = value
    }

    init(integerLiteral value: IntegerLiteralType) {
        int = value
    }

    // MARK: Printable

    var description: String {
        return "\(int)"
    }

    // MARK: Hashable

    var hashValue: Int {
        return int.hashValue
    }

    // MARK: IntegerArithmeticType

    func toIntMax() -> IntMax {
        return IntMax(int)
    }

    static func addWithOverflow(lhs: MyInt, _ rhs: MyInt) -> (MyInt, overflow: Bool) {
        let result = Int.addWithOverflow(lhs.int, rhs.int)
        return (MyInt(result.0), result.overflow)
    }

    static func subtractWithOverflow(lhs: MyInt, _ rhs: MyInt) -> (MyInt, overflow: Bool) {
        let result = Int.subtractWithOverflow(lhs.int, rhs.int)
        return (MyInt(result.0), result.overflow)
    }

    static func multiplyWithOverflow(lhs: MyInt, _ rhs: MyInt) -> (MyInt, overflow: Bool) {
        let result = Int.multiplyWithOverflow(lhs.int, rhs.int)
        return (MyInt(result.0), result.overflow)
    }

    static func divideWithOverflow(lhs: MyInt, _ rhs: MyInt) -> (MyInt, overflow: Bool) {
        let result = Int.divideWithOverflow(lhs.int, rhs.int)
        return (MyInt(result.0), result.overflow)
    }

    static func remainderWithOverflow(lhs: MyInt, _ rhs: MyInt) -> (MyInt, overflow: Bool) {
        let result = Int.remainderWithOverflow(lhs.int, rhs.int)
        return (MyInt(result.0), result.overflow)
    }

    // MARK: BitwiseOperationsType

    static var allZeros: MyInt {
        return MyInt(0)
    }

    // MARK: Strideable, RandomAccessIndexType

    typealias Distance = Int
    typealias Stride = Int

    func predecessor() -> MyInt {
        return MyInt(int - 1)
    }

    func successor() -> MyInt {
        return MyInt(int + 1)
    }

    func distanceTo(other: MyInt) -> Stride {
        return other.int - int
    }

    func advancedBy(n: Stride) -> MyInt {
        return MyInt(int + n)
    }
}

// MARK: Equatable

func ==(lhs: MyInt, rhs: MyInt) -> Bool { return lhs.int == rhs.int }

// MARK: Comparable

func <(lhs: MyInt, rhs: MyInt) -> Bool { return lhs.int < rhs.int }

// MARK: IntegerArithmeticType, ctd

func %(lhs: MyInt, rhs: MyInt) -> MyInt { return MyInt(lhs.int % rhs.int) }

func *(lhs: MyInt, rhs: MyInt) -> MyInt { return MyInt(lhs.int * rhs.int) }

func +(lhs: MyInt, rhs: MyInt) -> MyInt { return MyInt(lhs.int + rhs.int) }

func -(lhs: MyInt, rhs: MyInt) -> MyInt { return MyInt(lhs.int - rhs.int) }

func /(lhs: MyInt, rhs: MyInt) -> MyInt { return MyInt(lhs.int / rhs.int) }

// MARK: BitwiseOperationsType, ctd

func &(lhs: MyInt, rhs: MyInt) -> MyInt { return MyInt(lhs.int & rhs.int) }

func ^(lhs: MyInt, rhs: MyInt) -> MyInt { return MyInt(lhs.int ^ rhs.int) }

prefix func ~(x: MyInt) -> MyInt { return MyInt(~x.int) }

func |(lhs: MyInt, rhs: MyInt) -> MyInt { return MyInt(lhs.int | rhs.int) }

