//Notice the use of template template parameter
template <template <typename> class Callback>   
class A {
   Callback <A> m_func;
   public:
     A (Callback <A>  func):  m_func (func) {}
     void call () { m_func(*this);}

};

template <typename T>
struct MYCallback
{
   void operator () (const T&t) {}

};


void Test()
{
   typedef A<MYCallback> AType;

   MYCallback<AType> callback;
   AType a (callback);
   a.call ();

}

#include <tr1/functional>


class A {
   std::tr1::function <void (const A&)>  m_func;
   public:
     template <class Callback>
     A (Callback func) :  m_func (func) {}

     void call () { m_func(*this);}

};

template <class T>
struct My_callback
{
   void operator () (const T&t) {}

};

void Test ()
{
   My_callback <A> c;
   A a (c);
   a.call ();
}

