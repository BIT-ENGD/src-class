boost::detail::enum_base<T>
void fun(const boost::any& any)
boost::detail::enum_base<T>
#include <iostream>
#include <boost/any.hpp>
#include "boost/enum.hpp"


// this macro
BOOST_ENUM(boolean, 
    (True)
    (False) 
)

// expands to this enum model
namespace expanded
{
    class boolean : public boost::detail::enum_base<boolean>
    {
    public:
        enum domain
        {
            False,
            True,
        };

        BOOST_STATIC_CONSTANT(index_type, size = 2);

    public:
        boolean() {}
        boolean(domain index) : boost::detail::enum_base<boolean>(index) {}

        typedef boost::optional<boolean> optional;
        static optional get_by_name(const char* str)
        {
            if(strcmp(str, "False") == 0) return optional(False);
            if(strcmp(str, "True") == 0) return optional(True);
            return optional();
        }

    private:
        friend class boost::detail::enum_base<boolean>;
        static const char* names(domain index)
        {
            BOOST_ASSERT(static_cast<index_type>(index) < size);
            switch(index)
            {
            case False: return "False";
            case True: return "True";
            default: return "";
            }
        }
    };
}

BOOST_ENUM(boolean2, 
    (True2)
    (False2) 
)

/* I want to have a function to accept any enum class. How? */
void fun(const boost::any& any)
{
    /* How about boolean2 enum? How can I have a common pointer to point to enum class? */
    const boolean* d = boost::any_cast<boolean *>(any);

    /* I want to use unofficial boost::enum, because it allows me to iterate through enum's members. */
    for (boolean::const_iterator iterator = d->begin(); iterator != d->end(); iterator++)
    {
        boolean x = *iterator;
        std::cout<< "Iterate through enum : "<< x<< std::endl;
    }
}


int main()
{
    boolean b = boolean::True;
    boolean2 b2 = boolean2::True2;

    /* Assume until this stage, during runtime, I have no clue b is either boolean or boolean2. */
    fun(&b);
    /*
     * Runtime error occur here.
     * throw enable_current_exception(enable_error_info(e));
     */
    fun(&b2);

    getchar();
}

