struct Int
{
   int *_int;
   ~Int(){ delete _int; }
};

void holdReference(boost::shared_ptr<Int>, int*) {} // helper

boost::shared_ptr<int> fun()
{
   boost::shared_ptr<Int> a ( new Int ); 
   // I get 'a' from some please else, and want to convert it
   a->_int = new int;

   return boost::shared<int>( a->_int, boost::bind(&holdReference, a, _1) );

}

#include <boost/shared_ptr.hpp>
#include <boost/bind.hpp>

// the case looks more or less like this
// this class is in some dll an I don't want to use this class all over my project
// and also avoid coppying the buffer
class String_that_I_dont_have 
{
    char * _data; // this is initialized in 3rd party, and released by their shared pointer

public:
    char * data() { return _data; }
};


// this function I created just to hold reference to String_that_I_dont_have class 
// so it doesn't get deleted, I want to get rid of this
void holdReferenceTo3rdPartyStringSharedPtr( boost::shared_ptr<String_that_I_dont_have>, char *) {}


// so I want to use shared pointer to char which I use quite often 
boost::shared_ptr<char> convert_function( boost::shared_ptr<String_that_I_dont_have> other) 
// 3rd party is using their own shared pointers, 
// not the boost's ones, but for the sake of the example ...
{
    return boost::shared_ptr<char>( 
        other->data(), 
        boost::bind(
            /* some in place here instead of holdReference... */
            &holdReferenceTo3rdPartyStringSharedPtr   , 
            other, 
            _1
        )
    );
}

int main(int, char*[]) { /* it compiles now */ }

// I'm just looking for more elegant solution, for declaring the function in place

