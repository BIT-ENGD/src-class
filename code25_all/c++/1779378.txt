#include <iostream>
#include <string>
#include <fstream>
#include <iomanip>
using namespace std;

//customer struct
struct customer
{
    int id;
    string fname, lname;
    double totalQuantity, totalPurchases, totalProfit;
};

//Error Codes
const int INPUT_FILE_FAIL_NO_CONTINUE = 2;
const int INPUT_FILE_DATA_ERROR = 3;

//Global Constants
const int arraySize = 200;
const int numType = 5; //# of the types of coffee we currently offer

//Coffee prices per pound
const double colombWhole = 3.75;
const double colombRetail = 4.85;
const double konaWhole = 4.25;
const double konaRetail = 5.25;
const double ethiopWhole = 4.30;
const double ethiopRetail = 5.75;
const double jamaWhole = 5.25;
const double jamaRetail = 7.75;
const double brazWhole = 4.65;
const double brazRetail = 5.90;

//Function prototypes
int readData (ifstream &infile, customer carray[], int size);
//PRE:  The address of the ifstream object, the addres of the array of customer structs and the size of
//      the array is passed in
//POST: All of the customer data is read in AND the totalQuantity, totalPurchases and totalProfit for
//      each customer is calculated. The number of records read is returned.

void sortData (customer carray[], int recordcount, int sortfield);
//PRE:  The address of the array of customers, the number of customer records in the array and the field
//      on which to be sorted is passed into the function.
//POST: The array is sorted on the basis of the specified field in ascending order

int findMax (const customer carray[], int startRange, int recordcount, int sortfield);
//PRE:  The address of the array of customers, the field to sort on and a range of values is passed in
//POST: The address of the largest value is returned




int main()
{
    //Array of customer structs
    customer crecords[arraySize];

    //Initialize the members of our struct to zero
    for (int i = 0; i < arraySize; i++)
    {
        crecords[i].totalProfit = 0;
        crecords[i].totalPurchases = 0;
        crecords[i].totalQuantity = 0;
    }

    //Declare filestream objects
    ifstream ifile;
    ofstream ofile1, ofile2, ofile3;

    //user responses
    char pquit = 'Y';
    char specAnother; 
    int sortby;
    string ifilename;

    //Ask user for name of input file
    cout << "Please enter the name of the input file: " ;
    cin >> ifilename;

    //Attempt to open the input file
    ifile.open(ifilename.c_str());
    while (ifile.fail())
    {
        cout    << endl << "The input file could not be found. Would you like to specify " 
                << "another file?" << endl << "(Enter Y or N):";
        cin     >> specAnother; //Ask user if they want to specify another

        if (specAnother == 'N' || specAnother == 'n')
        {   
            exit(INPUT_FILE_FAIL_NO_CONTINUE);
        }
        else
        {
            cout    << endl << "Please enter the name of the new input file: " ;
            cin     >>  ifilename;
        }

        ifile.clear(); //Clear the flags, else the input file fail flag will perpetually return true
        ifile.open(ifilename.c_str());

    } 

    //File opened successfully, let's begin reading in data and also keep track of the # of 
    //records read
    int numRec = readData(ifile, crecords, arraySize); 
    cout << "Finished reading " << numRec << " records" << endl;


    do
    {
        //Ask user how they would like to sort the data for the report
        cout    << endl << "What would you like to sort on?" << endl;
        cout    << "1) Sort by POUNDS bought" << endl
                << "2) Sort by PURCHASE AMOUNT" << endl
                << "3) Sort by PROFIT" << endl;

        cin     >> sortby;
        if (sortby > 3 || sortby < 1)
        {
            cout    << "You entered an invalid sorting method, try again" << endl
                    << "Enter an option:";
            cin     >> sortby;
        }

        cout    << "You entered " << sortby << endl;
    }

    //Sort Data
    sortData(carray, numRec, sortby);
    return 0;
}

//Function Definitions
int readData (ifstream &infile, customer carray[], int size)
{
    int x = 0, coffeeType, quantity;
    double currentSale, internalCost, profitOnSale;
    while (infile >> carray[x].id && x < size)
    {
        infile >> carray[x].fname >> carray[x].lname;
        while (infile >> coffeeType && coffeeType != 0)
        {
            infile >> quantity;
            switch(coffeeType)
            {
            case 1:
                carray[x].totalQuantity += quantity;
                currentSale = quantity * colombRetail;
                carray[x].totalPurchases += currentSale;
                internalCost = quantity * colombWhole;
                profitOnSale = currentSale - internalCost;
                carray[x].totalProfit += profitOnSale;
                break;

            case 2:
                carray[x].totalQuantity += quantity;
                currentSale = quantity * konaRetail;
                carray[x].totalPurchases += currentSale;
                internalCost = quantity * konaWhole;
                profitOnSale = currentSale - internalCost;
                carray[x].totalProfit += profitOnSale;
                break;

            case 3:
                carray[x].totalQuantity += quantity;
                currentSale = quantity * ethiopRetail;
                carray[x].totalPurchases += currentSale;
                internalCost = quantity * ethiopWhole;
                profitOnSale = currentSale - internalCost;
                carray[x].totalProfit += profitOnSale;
                break;

            case 4:
                carray[x].totalQuantity += quantity;
                currentSale = quantity * jamaRetail;
                carray[x].totalPurchases += currentSale;
                internalCost = quantity * jamaWhole;
                profitOnSale = currentSale - internalCost;
                carray[x].totalProfit += profitOnSale;
                break;

            case 5:
                carray[x].totalQuantity += quantity;
                currentSale = quantity * brazRetail;
                carray[x].totalPurchases += currentSale;
                internalCost = quantity * brazWhole;
                profitOnSale = currentSale - internalCost;
                carray[x].totalProfit += profitOnSale;
                break;

            default:
                cout    <<"The input file contains an undeclared coffee type at record " << x 
                        <<"Program terminating!" << endl; 
                //return exit(INPUT_FILE_DATA_ERROR);

            }
        }

        x++;    //At this point, we have encountered our sentinel value of 0 that indicates the end of our
        //customer record. Let's move on to the next customer.        
    }

    return x;
}

int findMax (const customer carray[], int startRange, int recordcount, int sortfield)
{
    int maxLoc = startRange;
    switch(sortfield)
    {
    case 1:

        for (int i = startRange + 1; i <= recordcount; i++)
        {
                if (carray[maxLoc].totalQuantity < carray[i].totalQuantity)
                maxLoc = i;
        }

    case 2:

        for (int i = startRange + 1; i <= recordcount; i++)
        {
            if (carray[maxLoc].totalPurchases < carray[i].totalPurchases)
                maxLoc = i;
        }

    case 3:

        for (int i = startRange + 1; i <= recordcount; i++)
        {
            if (carray[maxLoc].totalProfit < carray[i].totalProfit)
                maxLoc = i;
        }    
    }

    return maxLoc;
}




void sortData (customer carray[], int recordcount, int sortfield)
{
    for (int i = 0; i < recordcount ; i++)
    {
        int max = findMax(carray, i, recordcount, sortfield);
        swap(carray[i], carray[max]);
    }
}

