#include <iostream>
#include <boost/spirit.hpp>

using namespace boost::spirit;

struct my_closure : public closure<my_closure, std::size_t> {
member1 size;
};

struct my_grammar : public grammar<my_grammar> {
template <typename ScannerT>
struct definition {
    typedef rule<ScannerT> rule_type;
    typedef rule<ScannerT, my_closure::context_t> closure_rule_type;

    closure_rule_type header;
    rule_type payload;
    rule_type top;

    definition(const my_grammar &self)
    {
        using namespace phoenix;
        header = uint_p[header.size = arg1];
        payload = repeat_p(header.size())[anychar_p][assign_a(self.result)];
        top = header >> str_p("\r\n") >> payload;
    }

    const rule_type &start() const { return top; }
};

my_grammar(std::string &p_) : result(p_) {}
std::string &result;
};

int
main(int argc, char **argv)
{
const std::string content = "12\r\nTest Payload";
std::string payload;
my_grammar g(payload);
if (!parse(content.begin(), content.end(), g).full) {
    std::cerr << "there was a parsing error!\n";
    return -1;
}
std::cout << "Payload: " << payload << std::endl;
return 0;
}

