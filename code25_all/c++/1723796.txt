class B
{
public:
    virtual double f( double x ) = 0;
};

class D1 : public B
{
public:
    double f( double x ) const 
    {
    return 0.0;
    }
};    

class D2 : public B
{    
public:
    double f( double x ) const 
    {
    return 1.0;
    }
};

class F {
public:
    virtual double f( double x ) = 0;
};

class G {
public:
    virtual double g( double x ) = 0;
};

class H {
public:
    virtual double h( double x ) = 0;
};

class N {};

template<class T1, class T2=N, class T3=N>
class Feature : public T1 , public T2 , public T3
{
};

template<class T1, class T2>
class Feature<T1,T2,N> : public T1, public T2
{
};

template<class T1>
class Feature<T1,N,N> : public T1
{
};

//Supp for Supports/Implements
class SuppFandG : public Feature<F,G>
{
public:
    double f( double x ) { return 0.0; }
    double g( double x ) { return 1.0; } 
};

class SuppFandH : public Feature<F,H>
{
public:
    double f( double x ) { return 0.0; }
    double h( double x ) { return 1.0; } 
};

class SuppFandGandH : public Feature<F,G,H>
{
public:
    double f( double x ) { return 0.0; }
    double g( double x ) { return 1.0; }
    double h( double x ) { return 2.0; }
};

int main()
{
    Feature<F,G>* featureFandGPtr;
    Feature<F,H>* featureFandHPtr;
    Feature<H,F>* featureHandFPtr;
    Feature<F,G,H>* featureFandGandHPtr;

    SuppFandGandH suppFandGandH;
    featureFandGandHPtr = &suppFandGandH;

    //featureFandGPtr = featureFandGandHPtr; //Illegal. static_cast illegal too.
    //the reason to do this is that I would like to pass a pointer to an object 
    //of type Feature<F,G,H> to a function (or constructor) that expects a pointer to Feature<F,G> 
    featureFandGPtr = reinterpret_cast< Feature<F,G>* >( featureFandGandHPtr );
    featureFandHPtr = reinterpret_cast< Feature<F,H>* >( featureFandGandHPtr );
    featureHandFPtr = reinterpret_cast< Feature<H,F>* >( featureFandGandHPtr );

    featureFandGPtr->f( 1.0 );
    featureFandGandHPtr->h( 1.0 );
}

//This will not work, Visual studio 2008 professional crash.
template<class T1, class T2=N, class T3=N>
class Feature : public Feature<T1,T2> , public Feature<T1,T3> , public Feature<T2,T3>
{
};

template<class T1, class T2>
class Feature<T1,T2,N> : public Feature<T1>, public Feature<T2>
{
};

template<class T1>
class Feature<T1,N,N> : public T1
{
};

