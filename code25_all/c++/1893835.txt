#include "stdafx.h"
#include "Token.h"

//I would like this enum to be inside class Number
enum Number_enm {ZERO, ONE, TWO, THREE, FOUR, FIVE, SIX, SEVEN, EIGHT, NINE};

class Number : public Token<Number_enm>//and this template parameter to be Number::Number_enm
{
private:

public:
    Number(const Number_enm& num)
    try:
    Token(num)
    {   }
    catch(...)
    {
        cerr << "Error in Number::Number(const Number_enm&).";
        return;
    }

    Number(const char num)
    try:
    Token(static_cast<Number_enm>(num & 0xf)) //get number value from char
    {
#ifdef DEBUG_
    cout << "Converting ctor, from char to Token.\n";
#endif
    }
    catch(...)
    {
        cerr << "Error in Number::Number(const char num).";
        return;
    }

};

#pragma once

/*Abstract class*/
template<class T>
class Token
{
    typedef T value_type;
private:
    value_type my_data_;
protected:
    /*Token()
    try: my_data_()
    {   }
    catch(...)
    {
        cerr << "Error in Token<T>::Token().";
        return;
    }*/
    Token(const value_type value)
        try:
    my_data_(value)
    {   }
    catch(...)
    {
        cerr << "Error in Token<T>::Token(const value_type&).";
        return;
    }
    /*Token(const Token& value): my_data(value)
    {   }*/
    Token& operator=(const Token& right)
    {
#ifdef DEBUG_
        cout << "Token& operator=(const Token& right).\n";
#endif
        my_data = right;
        return my_data;
    }
public:
    T get() const
    {
        return my_data_;
    }
    T set(const T& new_value)
    {
        T old = my_data_;
        my_data_ = new_value;
        return old;
    }
};

