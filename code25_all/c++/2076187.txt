class plugin
{
public:
    virtual std::string getName(); 

protected:
    std::vector<std::string> refList;
};

template<typename T> class pluginLoader 
{
    public: pluginLoader(std::string path);
    // initializes private mPath string with path to dylib

    bool open(); 
    // opens the dylib and looks up the createInstance function. Returns true if successful, false otherwise

    T * create_instance(); 
    // Returns a new instance of T, NULL if unsuccessful
}; 

class host
{
public:
      addPlugin(int id, plugin * plug);
      sendToPlugin(); // this is the problem method
      static host * me;

private:
     std::vector<plugin *> plugins; // or vector<shared_ptr<plugin> > or vector<refptr<plugin> >
};

host * host::me;
pascal OSErr HandleSpeechDoneAppleEvent(const AppleEvent *theAEevt, AppleEvent *reply, SRefCon refcon) {
         // this is all boilerplate taken straight from an apple sample except for the host::me->ae_callback line
         OSErr status = 0;
         Result result = 0;
         // get the result
         if (!status) {
             host::me->ae_callback(result);
         }
         return status;
}
void host::ae_callback(Result result) {
       OSErr err;
       // again, boilerplate apple code
   // grab information from result
       if (!err)
         sendToPlugin();
}
void host::sendToPlugin() {
       // calling *any* method in plugin results in failure regardless of what I do
}

