struct  A
{
    A();
    virtual ~A();

    virtual void    Foo() =0;
};

struct  E;
struct  F;

struct  B:  public A
{
    B();
    virtual ~B();

    virtual void    Bar(E*) =0;
    virtual void    Bar(F*) =0;
};

struct  C:  public B
{
    C();
    virtual ~C();

    void    Bar(E*);
};

struct  D:  public C
{
    D();
    virtual ~D();

    void    Foo();
    void    Bar(F*);
};

struct  E:  public A
{
    E();
    virtual ~E();

    void    Foo();
    /* ... */
};

struct  F:  public A
{
    F();
    virtual ~F();

    void    Foo();
    /* ... */
};

template <class _Base>
struct  G:  public _Base
{
    G(const _Base &b)
    :   _Base(b)
    {}

    virtual ~G()
    {}

    using _Base::Bar; // doesn't help
    /* ... */
};

typedef std::list<E*> EList;
typedef std::list<F*> FList;
EList es;
FList fs;

G<D> player(D());

es.push_back(new E); // times many
fs.push_back(new F); // times many

for(EList::iterator i0(es.begin()), i1(es.end()); i0 != i1; ++i0)
{
  player.Bar(*i0);
}

for(FList::iterator i0(fs.begin()), i1(fs.end()); i0 != i1; ++i0)
{
  player.Bar(*i0);
}

