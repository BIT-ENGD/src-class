class SocketHandle
{
public:
    SocketHandle()
    {
        m_pSocket = NULL;
        m_pService = NULL;
    }

    ~SocketHandle()
    {
        delete m_pSocket;
        delete m_pService;
    }

    void connect(const char* host, const char* port)
    {
        if (m_pSocket || m_pService)
            return;

        m_pService = new boost::asio::io_service();

        tcp::resolver resolver(*m_pService);
        tcp::resolver::query query(tcp::v4(), host, port);
        tcp::resolver::iterator endpoint_iterator = resolver.resolve(query);
        tcp::resolver::iterator end;

        m_pSocket = new tcp::socket(*m_pService);

        boost::system::error_code error = boost::asio::error::host_not_found;

        while (error && endpoint_iterator != end)
        {
            (*m_pSocket).close();
            (*m_pSocket).connect(*endpoint_iterator++, error);
        }

        if (error)
            throw ...
    }

    tcp::socket* operator->()
    {
        return m_pSocket;
    }

private:
     tcp::socket *m_pSocket;
     boost::asio::io_service *m_pService;
};

size_t recv(char *data, size_t size)
{
    boost::system::error_code error;
    size_t len = (*m_pSocket)->read_some(boost::asio::buffer(data, size), error);

    if (error)
               throw ...

    return len;
}

