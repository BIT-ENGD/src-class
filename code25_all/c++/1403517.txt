stack::stack(int capacity)
{   
  items = new item[capacity];

  if ( items == NULL ) {
    throw "Cannot Allocoate Sufficient Memmory";
    exit(1); 
  }
  maxSize = capacity;
  top       = -1;
}

class stack
{
  stack(int capacity);
  ~stack(void);
...
  private:
    int maxSize; // is for the item stack
    int top;     // is the top of the stack
    struct item {
      int n;
    };
    item        *items;                 

  public:
    friend ostream& operator<<(ostream& out, stack& q)
  ...

bool stack::pushFront( const int n )
{
     if ( top >= maxSize-1 ) 
{
    throw "Stack Full On Push";
    return false;
}
else 
{
    ++top;
    items[top].n = n;
}
return true;
}

// just a textbook example here:
stack::~stack(void)
{
  delete [] items;

  items    = NULL;
  maxSize = 0;
  top      = -1;
}

ostream& operator<<(ostream& out, stack& q)
{
    if ( q.top <= 0 ) // bad check for empty or full node
    out << endl << "stack: empty" << endl << endl;
    else
        for ( int x = 0; x < q.maxSize; x++ )
        {
            out << q.items[x].n; // try to print elements
        }
    return out;
}

