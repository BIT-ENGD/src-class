class A {
  public:
    void a() {}
};

class B {
  public:
    void b() {}
};

class C: public A, public B {
  public:
    void c() {}
};

C* foo = new C();
foo->b();

`... undefined reference to 'C::b(void)'`

C* foo = new C();
foo->B::b();

#include "container.h"
#include "identifiers.h"

class Creature: public Identifiers, public Container {
  public:
    Creature( void );
    Creature( const Creature& ref );
    virtual ~Creature( void );
};

class Identifiers {
  public:
    Identifiers( void );
    Identifiers( const Identifiers& ref );
    ~Identifiers( void );
};

class Container {
  public:
    Container( std::string (Object::*getName)( void ) const );
    Container( const Container& ref );
    ~Container( void );

    void  add( Object* object );
    void  add( const std::list<Object*>& objects );
    void  remove( Object* object );
    void  remove( const std::list<Object*>& objects );
};

Container::Container( std::string (Object::*getName)( void ) const ) {
  _getName = getName;
  return;
}

Container::Container( const Container& ref ) {
  _getName = ref._getName;
  return;
}

Container::~Container( void ) {
  while ( !objectList().empty() ) {
    delete objectList().front();
    objectList().pop_front();
  }
  return;
}

void Container::add( Object* object ) {
  objectList().push_back( object );
  return;
}

void Container::add( const std::list<Object*>& objects ) {
  objectList().insert( objectList().end(), objects.begin(), objects.end() );
  return;
}

void Container::remove( Object* object ) {
  objectList().remove( object );
  return;
}

void Container::remove( const std::list<Object*>& objects ) {
  for ( std::list<Object*>::const_iterator it = objects.begin(); it != objects.end(); ++it ) {
    remove( *it );
  }
  return;
}

bool CmdWear::execute( Creature* creature, const std::string& args ) {
  std::list<Object*> objects;
  Object* removed = NULL;
  std::string error;

  objects = creature->searchObjects( args );

  for ( std::list<Object*>::iterator it = objects.begin(); it != objects.end(); ++it ) {
    if ( creature->wear( *it, error, removed ) ) {
      creature->remove( *it );
    }
  }

  return true;
}

creature->Container::remove( *it );

PROJECT     = symphony
CPPC        = g++
FLAGS_DEV   = -ggdb3 -ansi -Wall -Werror -pedantic-errors
LIBS        = `pcre-config --libs` `mysql_config --libs`
SRC_DIR     = src
OBJ_DIR     = obj
BIN_DIR     = .
SRC_FILES  := $(wildcard $(SRC_DIR)/*.cpp)
OBJ_FILES  := $(patsubst src/%.cpp,obj/%.o,$(SRC_FILES))

dev: $(OBJ_FILES)
  $(CPPC) $(LIBS) $(FLAGS_DEV) $(OBJ_FILES) -o $(BIN_DIR)/$(PROJECT)

$(OBJ_DIR)/%.o: $(SRC_DIR)/%.cpp
  $(CPPC) -c $(FLAGS_DEV) $< -o $@

