using namespace boost;
template<typename K, typename V>
class node {
protected:
    class empty_node : public node<K,V> {
    public:
        bool is_empty(){ return true; }
        const shared_ptr<K> key() const { throw empty_node_exception; }
        const shared_ptr<V> value() const { throw empty_node_exception; }
        const shared_ptr<node<K,V>> left() const { throw empty_node_exception; }
        const shared_ptr<node<K,V>> right() const { throw empty_node_exception; }
        const shared_ptr<node<K,V>> add(const shared_ptr<K> &key, const shared_ptr<V> &value) const {
            return shared_ptr<node<K,V>>();
        }
        const shared_ptr<node<K,V>> remove(const shared_ptr<K> &key) const { throw empty_node_exception; }
        const shared_ptr<node<K,V>> search(const shared_ptr<K> &key) const { return shared_ptr<node<K,V>>(this); }
    };
    static shared_ptr<node<K,V>> m_empty;
public:
    virtual bool is_empty() = 0;
    virtual const shared_ptr<K> key() = 0;
    virtual const shared_ptr<V> value() = 0;
    virtual const shared_ptr<node<K,V>> left() = 0;
    virtual const shared_ptr<node<K,V>> right() = 0;
    virtual const shared_ptr<node<K,V>> add(const shared_ptr<K> &key, const shared_ptr<V> &value) = 0;
    virtual const shared_ptr<node<K,V>> remove(const shared_ptr<K> &key) = 0;
    virtual const shared_ptr<node<K,V>> search(const shared_ptr<K> &key) = 0;


    static shared_ptr<node<K,V>> empty(){
        if(NULL == m_empty.get()){
            m_empty.reset(new empty_node());
        }
        return m_empty;
    }
};

