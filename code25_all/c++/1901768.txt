class Token_
{
public:
    virtual char operator*()const = 0;//this fnc cannot run implicitly
protected:
    Token_()
    {   }
    Token_(const Token_&);
    Token_& operator=(const Token_&);
};

class Operator : public Token_
    {
    public:
    Operator(const char ch):my_data_(token_cast<Operator_enm>(ch))
    {   }
    Operator_enm get()const
    {
        return my_data_;
    }
    Operator_enm set(const Operator_enm& value)
    {
        Operator_enm old_value = get();
        my_data_ = value;
        return old_value;
    }
    char operator*()const//this operator has to be invoke explicitly
    {
        return static_cast<char>(my_data_);
    }
private:
    Operator_enm my_data_;
};

template<class R>
R Calculator::expr_()const
{
    Token_* token = read_buffer_();
    switch (*token)//here if I use explicit call of operator*() it works
    {
    case PLUS:
        {
            R result ;//not defined yet
            return result;
        }
    case MINUS:
        {
            R result ;//not defined yet
            return result;
        }
    default:
        cerr << "Bad expr token.";
    }

}

