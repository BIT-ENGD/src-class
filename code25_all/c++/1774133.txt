bool hash::remove(char const * const symbol, stock &s,
int& symbolHash, int& hashIndex, int& usedIndex)
{
 symbolHash = this->hashStr( symbol ); // hash to try to reduce our search.
         hashIndex = symbolHash % maxSize;
         usedIndex = hashIndex;

 if (     hashTable[hashIndex].symbol != NULL &&
  strcmp( hashTable[hashIndex].symbol , symbol ) == 0 ) 
 {
  delete hashTable[hashIndex].symbol;
  hashTable[hashIndex].symbol = NULL; 
  return true;
 }
 for ( int myInt = 0; myInt < maxSize; myInt++ )
 {
  ++usedIndex %= maxSize;
  if ( hashTable[usedIndex].symbol != NULL &&
    strcmp( hashTable[usedIndex].symbol , symbol ) == 0 )
   {
    delete hashTable[usedIndex].symbol;
    hashTable[usedIndex].symbol = NULL;
    return true; 
  }
 }
 return false;
}

s = &hashTable[usedIndex];
delete s.symbol;
s.symbol = NULL;
hashTable[usedIndex] = &s;

private:
 friend class stock;
 int isAdded; // Will contain the added hash index.
 // Test for empty tables.
 // Can possibly make searches efficient.
 stock *hashTable; // the hashtable will hold all the stocks in an array

};

hash::hash(int capacity) : isAdded(0),
hashTable(new stock[capacity]) // allocate array with a fixed size
{
 if ( capacity < 1 ) exit(-1);

    maxSize = capacity;

 // We can initialize our attributes for the stock
 // to NULL, and test for that when searching.
 for ( int index = 0; index < maxSize; index++ )
 {
  hashTable[index].name = NULL;
  hashTable[index].sharePrice = NULL;
  hashTable[index].symbol = NULL;
 }
}

private:

 const static int maxSize; // holds the capacity of the hash table minus one
 date  priceDate; // Object for the date class. Holds its attributes.
 char *symbol;
 char *name;
 int   sharePrice;
 };

s = &hashTable[usedIndex];
delete s.symbol;
s.symbol = NULL;
hashTable[usedIndex] = &s;

