/*
Adds the specified data to the back of the list.
*/
template<typename T, class COMPFUNCTOR>
void List<T, COMPFUNCTOR>::append(T* d)
{
    if(tail != NULL)
    {//If not an empty list, simply alter the tail.
        tail->setNext(new ListNode<T>(d));
        tail = tail->getNext();
    }
    else
    {//If an empty list, alter both tail and head.
        head = tail = new ListNode<T>(d);
    }
    size++;
};

/*
Adds a copy of the specified data to the back of the list.
*/
template<typename T, class COMPFUNCTOR>
void List<T, COMPFUNCTOR>::append(const T& d)
{
    this->append(new T(d));
};

int main(int argc, char** argv)
{
    parser = new Arguments(argc, argv); //Uses a map<char, list<string>>; no direct  bugs, insertion works fine.
    if(parser->flagSet('f'))
    {
        printf("%s\n", parser->getArg('f').getFirst().str.c_str());
    }
    return 0;
}

/*
Destroys the List and all data inside it.
*/
template<typename T, class COMPFUNCTOR>
List<T, COMPFUNCTOR>::~List()
{
    while(head != NULL)
    {
        ListNode<T>* tmp = head; //Set up for iteration.
        head = head->getNext();
        if(tmp->getData() != NULL) //Delete this node's data then the node itself.
            delete tmp->getData();
        delete tmp;
    }
};

    /*
    Create a ListNode with the specified neighbor.
    */
    template<typename T>
    ListNode<T>::ListNode(T* d, ListNode<T>::ListNode* neighbor)
    {
        data = d;
        next = neighbor;
    }

    /*
    Deletes the ListNode.
    */
    template<typename T>
    ListNode<T>::~ListNode()
    {
        next = NULL;
        if(data != NULL)
            delete data;
        data = NULL; 
    }

