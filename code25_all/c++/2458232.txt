//Device is an object of class Serial
while( device->isOpen() && !terminate )
{
    unsigned int readed = 0;
    unsigned long error = ERROR_SUCCESS;
    unsigned char* data = device->read( &readed, &error );

    if( error==ERROR_SUCCESS )
    {
        //If data received, deliver to upper level
        if( readed>0 )
        {
            QByteArray output( (const char*)data, (signed int)readed );
            emit dataArrived( output, readed );
        }
    }
    else
    {
         //unrelated stuff
    }

    //Here I manage the writting issue
    //Only when nothing is received, and Upper layer wants to send a frame
    //(Upper layer only will mark as something to send when it detects a valid frame)
    if( readed==0 )
    {
         out_lock.lock();
         //If something to send...
         if( something_to_send > 0 )
         {
            if( device->write( output_buffer, output_size, &error ) )
            { //things...
            }
         }
     }
}

::ClearCommError( handle, &dwErrors, &stat);
if( stat.cbInQue )
{
    //If there's something to read, read it, please note the bytes to read parameter, here 1.
    bool ok = ::ReadFile( handle, buffer_in, 1, &bytes_read, &ov_reader );
    if( !ok )
    {
         DWORD _error = ::GetLastError();
         if( _error == ERROR_IO_PENDING )
         {
             DWORD result = ::WaitForMultipleObjects( 2, waiters, FALSE,INFINITE );
             switch( result )
             {     //Eventshutdown
                   case WAIT_OBJECT_0:  /*code omitted*/break;
                   case WAIT_OBJECT_0+1:   ok = ::GetOverlappedResult( handle, &ov_reader, &bytes_read, true );
                                           //check ok value omitted
                                           break;
             } 
         } 
    }
}

if( bytes_read>0 )
{
   *size = bytes_read;
}

readed
WaitForMultipleObjects
