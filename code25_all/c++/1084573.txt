#include <iostream.h>
#include <conio.h>
#include <stdio.h>
#include <stdlib.h>
#include <alloc.h>
#include <time.h>
#include <math.h>
#include "vdsim.h"
void gen01dat( long, int);
void cnv_encd(int g[], long,int,int);
int main()
{
long data_len=10;
int *out_array;
long input_len=5;
int g[2][3];

    void gen01dat(data_len,*out_array);

    int in_array=*out_array;
  void cnv_encd(g,input_len,in_array,*out_array);
  cout<<"the out_array 2 is :\t"<<*out_array<<endl;


  void gen01dat( long data_len, int *out_array ) {

     long t;            /* time */

     /* re-seed the random number generator */
     randomize();

     /* generate the random data and write it to the output array */
     for (t = 0; t < data_len; t++)
          *( out_array + t ) = (int)( rand() / (RAND_MAX / 2) > 0.5 );

}

void cnv_encd(int g[2][k],long input_len, int *in_array,int *out_array)
{

     int m;                     /* K - 1 */
     long t, tt;                /* bit time, symbol time */
     int j, k;                  /* loop variables */
     int *unencoded_data;       /* pointer to data array */
     int shift_reg[K];          /* the encoder shift register */
     int sr_head;               /* index to the first elt in the sr */
     int p, q;                  /* the upper and lower xor gate outputs */

     m = K - 1;

     /* read in the data and store it in the array */
     for (t = 0; t < input_len; t++)
          *(unencoded_data + t) = *(in_array + t);

     /* zero-pad the end of the data */
     for (t = 0; t < m; t++) {
          *(unencoded_data + input_len + t) = 0;
     }

     /* Initialize the shift register */
     for (j = 0; j < K; j++) {
          shift_reg[j] = 0;
     }

     sr_head = 0;

     /* initialize the channel symbol output index */
     tt = 0;

     for (t = 0; t < input_len + m; t++) {
          shift_reg[sr_head] = *( unencoded_data + t );
          p = 0;
          q = 0;
          for (j = 0; j < K; j++) {
                k = (j + sr_head) % K;
                p ^= shift_reg[k] & g[0][j];
                q ^= shift_reg[k] & g[1][j];
          }

          /* write the upper and lower xor gate outputs as channel symbols */
          *(out_array + tt) = p;
          tt = tt + 1;
          *(out_array + tt) = q;
          tt = tt + 1;


          sr_head -= 1;    /* equivalent to shifting everything right one place */
          if (sr_head < 0) /* but make sure we adjust pointer modulo K */
                sr_head = m;

     }

     /* free the dynamically allocated array */
     free(unencoded_data);

}

    return 0;
}

error: size of 'gen01'is unknown or zero in function main()
error: size of 'cnv_encd'is unknown or zero in function main()

