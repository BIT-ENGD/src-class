class Bar { //The default class that define behavior
};

template <typename T = Bar>
class Foo {
  public:
    Foo(T* t = 0) t_(t) {
      if (t_ == 0) t_ = new T();
    }
    ~Foo() { 
      delete t_;
    }
}

Foo foo;

class Bar1 { };

Foo<Bar1> foo(new Bar1()); // This is OK
Bar1 b;
Foo<Bar1> foo(&b); // Error, b is not dynamically allocated

    ~Foo() { 
      if (t_ is owned by this object) delete t_;
    }

Foo foo(new Bar(1, 2, etc..));
//or this:
Bar bar(1, 2, etc..);
Foo foo(bar);

int main() {
  Bar1 bar1(1,2,3);
  Foo foo(&bar1);
  return 0;
}

