g++ -pipe -W -Wall -fopenmp -ggdb3 -DDEBUG -fno-omit-frame-pointer  -c -o test.o ../../src/test.cc  
In file included from ../../src/test.cc:50:  
../../src/feature_haar.h:14: error: field ‘_count’ has incomplete type  

#include "feature_count.h"  
#include "feature_random_counts.h"  
#include "feature_corner.h"  
#include "feature_haar.h" // line 50  

#ifndef FEATURE_HAAR_H  
#define FEATURE_HAAR_H  

#include "misc.h"  
#include "feature.h"  
#include "vignette.h"  
#include "feature_count.h"  
#include <cassert>  

class FeatureHaar: public Feature    
{  
 public:  

  FeatureCount _count;// line 14  
...  
}  
#endif  

#ifndef FEATURE_COUNT_H  
#define FEATURE_COUNT_H  

#include "misc.h"  
#include "feature.h"  
#include "random_rect.h"  
//#include "feature_integral_img.h"  


class FeatureCount: public Feature {  

  public:  

   RandomRect _rect;  


   char _type[buffer_size];  


   // This method returns an upper-caps string to identify the feature  
   const char *name() ;  

   FeatureCount();  


   FeatureCount( int width, int height, const char *type = "black-count", float WHRatio=-1, int roi_x=0, int roi_y=0, int roi_w=0, int roi_h=0 );  


   ~FeatureCount();  




   // compute features from original data i.e. image  
   void compute(double *integral_image, double *feature);  


   // IO  
   void write_humanreadable(ostream *out);  
   void write(ostream *out);  
   void read(istream *in):  
 };  


#endif  

 #ifndef FEATURE_H  
 #define FEATURE_H  

 #include "misc.h"  
 #include "vignette.h"  


 class Feature {// generate the feature from the original data of an example, not responsible for holding the feature.  
 public:  
   int _dim;  


   // We need a virtual destructor since there are virtual methods  
   virtual ~Feature();  

   // This method returns an upper-caps string to identify the feature  
   virtual const char *name() = 0;  


   // write the data into files  
  static void write_matrix_data(double ** features, int *labels, int nb_examples, int dim, const char * filename);  
  static void write_index_data(double ** features,int *labels, int nb_examples, int dim, const char * filename);  
  static void write_compact_data(double ** features, int *labels, int nb_examples, int dim, const char * filename);  



   // compute features from original data i.e. image  
   virtual void compute(Vignette *vignette, double * feature); // this function/class not responsible for allocating/deallocation memory for array feature  
   virtual void compute(double *integral_image, double *feature);  



 // feature preprocessing  

   // scaling each feature s.t. its sample max = 1 and min = 0   
   static void scale_features(double *Data, int dim, double *scales_min, double *scales_max);  
   static void compute_linear_scale(double **Data, int size, int dim, double *scales_min, double *scales_max);  

   // standardize each feature s.t. its sample mean = 0 and sample standard deviation = 1  
   static void standardize_features(double *Data, int dim, double *mean, double *std);  
   static void compute_standardization(double **Data, int size, int dim, double *mean, double *std);  


 };  

 #endif  

