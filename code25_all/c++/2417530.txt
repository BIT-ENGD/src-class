const int OP_LOAD = 3;
const int OP_STORE = 4;
const int OP_ADD = 5;
...

const int OP_LOCATION_MULTIPLIER = 100;

mem[0] = OP_LOAD * OP_LOCATION_MULTIPLIER + ...;
mem[1] = OP_ADD * OP_LOCATION_MULTIPLIER + ...;

operand = memory[ j ] % OP_LOCATION_MULTIPLIER;
operation = memory[ j ] / OP_LOCATION_MULTIPLIER;

int main()
{
    const int READ = 10;
    const int WRITE = 11;
    const int LOAD = 20;
    const int STORE = 21;
    const int ADD = 30;
    const int SUBTRACT = 31;
    const int DIVIDE = 32;
    const int MULTIPLY = 33;
    const int BRANCH = 40;
    const int BRANCHNEG = 41;
    const int BRANCHZERO = 41;
    const int HALT = 43;

    int mem[100] = {0}; //Making it 100, since simpletron contains a 100 word mem.

    int operation; //taking the rest of these variables straight out of the book seeing as how they were italisized.

    int operand;

    int accum = 0; // the special register is starting at 0

    int j;




    // This is for part a, it will take in positive variables in a sent-controlled loop and compute + print their sum. Variables from example in text.
    memory [0] = 1010;

    memory [01] = 2009;

    memory [02] = 3008;

    memory [03] = 2109;

    memory [04] = 1109;

    memory [05] = 4300;

    memory [06] = 1009;

    j = 0; //Makes the variable j start at 0.

    while ( true )
    {

        operand = memory[ j ]%100; // Finds the op codes from the limit on the memory (100)
        operation = memory[ j ]/100;

        //using a switch loop to set up the loops for the cases
        switch ( operation ){
            case 10: //reads a variable into a word from loc. Enter in -1 to exit
                cout <<"\n Input a positive variable:  ";
                cin >> memory[ operand ]; break;

            case 11: // takes a word from location
                cout << "\n\nThe content at location " << operand   << "is " << memory[operand]; break;

            case 20:// loads
                accum = memory[ operand ]; break;

            case 21: //stores
                memory[ operand ] = accum; break;

            case 30: //adds
                accum += mem[operand]; break;


            case 31: // subtracts
                accum-= memory[ operand ]; break;

            case 32: //divides
                accum /=(memory[ operand ]); break;

            case 33: // multiplies
                accum*= memory [ operand ]; break;

            case 40: // Branches to location
                j = -1; break;

            case 41: //branches if acc. is < 0
                if (accum < 0)
                j = 5; 
                break;

            case 42: //branches if acc = 0
                if (accum == 0)
                    j = 5; 
                break;

            case 43: // Program ends
                exit(0); break;
    }
    j++;
    }
return 0;
}

