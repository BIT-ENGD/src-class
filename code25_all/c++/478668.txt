using namespace std;  

class base {  
  public:
    int data1;  

    friend class boost::serialization::access;  

    void serialize(boost::archive::polymorphic_iarchive & ar, 
                   const unsigned int file_version) {  
        ar & data1;  
    }  

    void serialize(boost::archive::polymorphic_oarchive & ar, 
                   const unsigned int file_version){  
        ar & data1;  
    }  

  public:  
    base() {};  
    base(int _d) : data1(_d) {}  
    virtual void foo() const {std::cout << "base" << std::endl;}  
};  

class derived : public base {  
  public:  
    int data2;  

    friend class boost::serialization::access;  

    void serialize(boost::archive::polymorphic_iarchive & ar, 
                   const unsigned int file_version) {  
        ar & boost::serialization::base_object<base>(*this) & data2;  
    }  

    void serialize(boost::archive::polymorphic_oarchive & ar, 
                   const unsigned int file_version){  
        ar & boost::serialization::base_object<base>(*this) & data2;  
    }  

  public:  
    derived() {};  
    derived(int _b, int _d) : base(_b), data2(_d) {}  
    virtual void foo() const {std::cout << "derived" << std::endl;}  
};  

int main(int argc, char *argv[]) {  
    // client  
    const base *b1 = new derived(1, 2);  

    std::ostringstream oss;  
    boost::archive::polymorphic_text_oarchive oa(oss);  
    oa << *b1;  

    // server  
    base *b2 = new derived(3, 4);  

    std::istringstream iss(oss.str());  
    boost::archive::polymorphic_text_iarchive ia(iss);  
    ia >> *b2;  

    // prints 1, ok  
    cout << b2->data1 << endl;  

    // prints 4, why wasn't the derived class data written?
    cout << (dynamic_cast<derived*>(b2))->data2 << endl;  

    return 0;  
}  

