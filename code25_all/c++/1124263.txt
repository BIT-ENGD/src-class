class __declspec(dllexport) EditArticleManagerFactory : public NamedClassFactory<SCEditArticleManager>,
   public SCBLEditArticle:ICOMEditArticleManagerFactory
{
public:
   STDMETHODIMP CreateManager(BSTR bstrName, SCBLEditArticle::ICOMEditArticleManager** pEditArticleManager);

}


interface ICOMEditArticleManagerFactory : IUnknown
       {
          HRESULT CreateManager([in]BSTR bstrName, [out]ICOMEditArticleManager** pEditArticleManager);      
       }

STDMETHODIMP EditArticleManagerFactory::CreateManager(BSTR bstrName,     SCBLEditArticle::ICOMEditArticleManager** pEditArticleManager)
  {
      manager = factory->createManager(bstrName);
       return manager->QueryInterface(__uuidof(SCBLEditArticle::ICOMEditArticleManager), (void**)&pEditArticleManager);
   }

function CreateManager(bstrName: wideString; pEditArticleManager: ICOMEditArticleManager): HResult; stdcall; external 'SCBLEditArticle.dll';

procedure CreateManager;
var
   hr:HResult;
   mCOMEditArticleManager: ICOMEditArticleManager;
begin
   hr := CreateManager('MANAGER1', mCOMEditArticleManager);
end;

EditArticleManagerFactory.h : 

IMPLEMENT_UNKNOWN_NODELETE(EditArticleManagerFactory) BEGIN_INTERFACE_TABLE(EditArticleManagerFactory) IMPLEMENTS_INTERFACE(SCBLEditArticle::ICOMEditArticleManagerFactory) END_INTERFACE_TABLE()

Inttable.cpp:
define IMPLEMENT_UNKNOWN_NODELETE(ClassName) \

STDMETHODIMP QueryInterface(REFIID riid, void **ppv) \ { \ HRESULT hr = InterfaceTableQueryInterface(this, GetInterfaceTable##ClassName(), riid, ppv);\ __if_exists(InheritedQueryInterface##ClassName) { if ( FAILED(hr) ) hr = InheritedQueryInterface##ClassName(riid, ppv); } \ return hr; \ }\ STDMETHODIMP_(ULONG) AddRef(void) { return 2; } \ STDMETHODIMP_(ULONG) Release(void) { return 1; }

