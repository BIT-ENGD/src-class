#define D3DCALL(a) { auto __ = a; if (FAILED(__)) DXTrace(__FILE__, __LINE__, __, WIDEN(#a), TRUE); }

D3DCALL(spriteeffect->SetTechnique(spritetechnique));
D3DCALL(spriteeffect->Begin(&passes, NULL));
D3DCALL(spriteeffect->BeginPass(0)); // We know this is zero.
D3DCALL(sprite->Begin(D3DXSPRITE_OBJECTSPACE | D3DXSPRITE_DO_NOT_ADDREF_TEXTURE | D3DXSPRITE_SORT_TEXTURE | D3DXSPRITE_ALPHABLEND | D3DXSPRITE_SORT_DEPTH_FRONTTOBACK));
RenderAndCleanUp(common->sprites);
D3DCALL(sprite->End());
D3DCALL(spriteeffect->EndPass());
D3DCALL(spriteeffect->End());

// Contains the HLSL for sprites.

// Based on transform.fx, by Frank Luna.

// FX parameter (global variable to the shader).
uniform extern float4x4 gWVP;

// Structure
struct OutputVS
{
      float4 posH : POSITION0;
float4 color : COLOR0;
};

// Vertex shader
OutputVS SpriteVS(float3 post : POSITION0,
    float4 col : COLOR0)
{
  // Zero out our output.
  OutputVS outVS = (OutputVS)0;

  outVS.posH = mul(float4(post, 1.0f), gWVP); // Transform
   outVS.color = col;

  // Done--return the output.
  return outVS;
}

// Pixel shader - take the original colour of the pixel and just return it. Nothing fancy.
float4 SpritePS( float4 col : COLOR0 ) : COLOR
{
   return col;
}

technique Sprite
{
  pass P0
  {
        // Specify the vertex and pixel shader associated
        // with this pass.
        vertexShader = compile vs_3_0 SpriteVS();
        pixelShader  = compile ps_3_0 SpritePS();
  }
}

