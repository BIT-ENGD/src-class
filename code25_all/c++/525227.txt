#include <iostream>
#include <GL/glut.h>
#include "ImageProcessor.h"
#include "BitmapImage.h"

using namespace std;

DWORD WINAPI openglThread( LPVOID param );
void InitGL();
void Reshape( GLint newWidth, GLint newHeight );
void Display( void );

BitmapImage* b;
ImageProcessor ip;


int main( int argc, char *argv[] ) {
    DWORD threadID;
    b = new BitmapImage();

    CreateThread( 0, 0, openglThread, NULL, 0, &threadID );

    while( true ) {
        char choice;
        string path = "TestImages\\";
        string filename;
        cout << "Enter filename: ";
        cin >> filename;
        path += filename;
        b = new BitmapImage( path );
        Display();

        cout << "1) Invert" << endl;
        cout << "2) Line Thin" << endl;
        cout << "Enter choice: ";
        cin >> choice;

        if( choice == '1' ) {
            ip.InvertColour( *b );
        }
        else {
            ip.LineThinning( *b );
        }
        Display();
    }

    return 0;
}


void InitGL() {
    int argc = 1;
    char* argv[1];
    argv[0] = new char[20];
    strcpy( argv[0], "main" );

    glutInit( &argc, argv );

    glutInitDisplayMode( GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH);
    glutInitWindowPosition( 0, 0 );
    glutInitWindowSize( 800, 600 );
    glutCreateWindow( "ICIP Program - Character recognition using line thinning, Hilbert curve, and wavelet approximation" );

    glutDisplayFunc( Display );
    glutReshapeFunc( Reshape );

    glClearColor(0.0,0.0,0.0,1.0);

    glEnable(GL_DEPTH_TEST);
}


void Reshape( GLint newWidth, GLint newHeight ) {
    /*  Reset viewport and projection parameters  */
    glViewport( 0, 0, newWidth, newHeight );
}


void Display( void ) {
    glClear (GL_COLOR_BUFFER_BIT); // Clear display window.
    b->Draw();
    glutSwapBuffers();
}


DWORD WINAPI openglThread( LPVOID param ) {
    InitGL();
    glutMainLoop();
    return 0;
}

void BitmapImage::Draw() {
    cout << "Drawing" << endl;
    if( _loaded ) {
        glBegin( GL_POINTS );
            for( unsigned int i = 0; i < _height * _width; i++ ) {
                glColor3f( _bitmap_image[i*3] / 255.0, _bitmap_image[i*3+1] / 255.0, _bitmap_image[i*3+2] / 255.0 );
                // invert the y-axis while drawing
                glVertex2i( i % _width, _height - (i / _width) );
            }
        glEnd();
    }
}

