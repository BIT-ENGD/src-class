void foo(const std::string& bar)
{
    ...
}

void foo(const int& bar)
{
    ...
}

template <typename T>
class Foo
{
  public:

    // Good for complex types, bad for small types
    void bar(const T& baz);   

    // Good for small types, but will needlessly copy complex types
    void bar2(T baz);             
};

void bar(const_nocopy<T>::type baz);

