BST::BST(int capacity) : items(new item[capacity]), size(0)
{
     // define the constructor to the BST Class.
}

void BST::insert (const data& aData)
{
    if ( items[root].empty ) // make the first data the root.
    {
        items[root].theData = aData;
        items[root].empty = false;
        size++;
    }
    else if ( items[root].theData.getName() < aData )
    {
        items[leftChild].theData = aData; // will be overwritten...
        this->insert(aData);
    }
    else if ( aData < items[root].theData.getName() )
    {
        items[rightChild].theData = aData;
        this->insert(aData);
    }   
}   

class BST
{ 
public:
    BST(int capacity = 5);
    BST(const BST& aTable);

    void insert(const data& aData);
         ....
 private:
    int size;  // size of the ever growing/expanding tree :)

    struct item
    {
        bool empty;
        data theData;
    };

    item  * items;    // The tree array
    int   rightChild; // access to the RHS
    int   leftChild;  // access to the LHS
    int   root;   // index to the root
};

data::data(char const * const name) : name(new char[strlen(name)+1])
{
    if (name)
    {
        strcpy(this->name , name);
    }  
    else this->name = NULL;
}

data& data::operator=(const data& data2)
{ 
    if ( this != &data2 ) // check for selfassignment
    {
        delete [] name;
        name = NULL;

        this->name = new char[strlen(data2.name)+1];
        strcpy(this->name , data2.name);
    }
    return *this;
     }

bool operator< (const data& d1, const data& d2)
{
    if ( strcmp( d1.getName(), d2.getName() ) == -1 )
    {
        return false;
    }
    else if ( strcmp( d1.getName(), d2.getName() ) == 1 )
    {
        return true;
    }
    return false; // if they are equal return false
}    

