enum Flag
{
    A_flag,
    B_flag
};

class T_proxy
{
public:
    T_proxy(const T& t, Flag f) : t_(t), flag_(f) {}
    operator T() const {return t_;}
    Flag flag() const {return flag_;}
    class Compare
    {
    public:
        Compare(Flag f) : matchFlag_(f) {}
        operator() (const T_proxy& tp) {return tp.flag() == matchFlag_;}
    private:
        Flag matchFlag_;
    };
private:
    T t_;
    Flag flag_;
};

class AB_list
{
public:
    typedef T_proxy::Compare Compare;
    typedef vector<T_proxy>::iterator iterator;
    typedef boost::filter_iterator<Compare, iterator> sub_iterator;
    void insert(const T& val, Flag f) {data_.insert(T_proxy(val, f));}
    // other methods...

    // whole sequence
    iterator begin() {return data_.begin();}
    iterator end() {return data_.end();}

    // just A
    sub_iterator begin_A() {return sub_iterator(Compare(A_flag), begin(), end());
    sub_iterator end_A() {return sub_iterator(Compare(A_flag), end(), end());

    // just B is basically the same
private:
    vector<T_proxy> data_;
};


// usage
AB_list mylist;
mylist.insert(T(), A_flag);
for (AB_list::sub_iterator it = mylist.begin_A(); it != mylist.end_A(); ++it)
{
    T temp = *it; // T_proxy is convertible to T
    cout << temp;
}

