R3Mesh.cpp: In copy constructor 'R3Mesh::R3Mesh(const R3Mesh&)':
R3Mesh.cpp:79: error: no matching function for call to 'R3Mesh::CreateHalfEdge(R3MeshVertex*&, R3MeshFace*&, R3MeshHalfEdge*&, R3MeshHalfEdge*&)'
R3Mesh.h:178: note: candidates are: R3MeshHalfEdge* R3Mesh::CreateHalfEdge(const R3MeshVertex*&, const R3MeshFace*&, const R3MeshHalfEdge*&, const R3MeshHalfEdge*&)
R3Mesh.cpp: In constructor 'R3MeshHalfEdge::R3MeshHalfEdge(const R3MeshVertex*&, const R3MeshFace*&, const R3MeshHalfEdge*&, const R3MeshHalfEdge*&)':
R3Mesh.cpp:1477: error: invalid conversion from 'const R3MeshVertex*' to 'R3MeshVertex*'
R3Mesh.cpp:1477: error: invalid conversion from 'const R3MeshFace*' to 'R3MeshFace*'
R3Mesh.cpp:1477: error: invalid conversion from 'const R3MeshHalfEdge*' to 'R3MeshHalfEdge*'
R3Mesh.cpp:1477: error: invalid conversion from 'const R3MeshHalfEdge*' to 'R3MeshHalfEdge*'

struct R3MeshHalfEdge {
  // Constructors
  R3MeshHalfEdge(void);
  R3MeshHalfEdge(const R3MeshHalfEdge& half_edge);
  R3MeshHalfEdge(const R3MeshVertex*& vertex, const R3MeshFace*& face, 
                 const R3MeshHalfEdge*& opposite, const R3MeshHalfEdge*& next);


  R3MeshVertex *vertex;
  R3MeshFace *face;
  R3MeshHalfEdge *opposite;
  R3MeshHalfEdge *next;
  int id;
};

R3MeshHalfEdge *R3Mesh::
CreateHalfEdge(const R3MeshVertex*& vertex, const R3MeshFace*& face,
               const R3MeshHalfEdge*& opposite, const R3MeshHalfEdge*& next)
{
  // Create half_edge
  R3MeshHalfEdge *half_edge = new R3MeshHalfEdge(vertex, face, opposite, next);

  // Set half_edge ID
  half_edge->id = half_edges.size();

  // Add to list
  half_edges.push_back(half_edge);

  // Return half_edge
  return half_edge;
}

R3MeshHalfEdge::
R3MeshHalfEdge(const R3MeshVertex*& vertex, const R3MeshFace*& face,
                             const R3MeshHalfEdge*& opposite, const R3MeshHalfEdge*& next)
  : vertex(vertex),                    
    face(face),
    opposite(opposite),
    next(next),
    id(0)
{
}

   for(int i=0; i<mesh.NFaces(); i++)
  {
    R3MeshFace *f = mesh.Face(i);
    vector<R3MeshVertex *> face_vertices; // assume vertices are stored in order around the perimeter of the face
    for(unsigned int j = 0; j<f->vertices.size(); j++)
    {
      R3MeshVertex *v1 = f->vertices[j];
      R3MeshVertex *v2;
      if(j==f->vertices.size()-1)
        v2 = f->vertices[0];
      else
        v2 = f->vertices[j+1];

      int v1_id = v1->id;
          int v2_id = v2->id;
          R3MeshHalfEdge *next = NULL;
          R3MeshHalfEdge *opposite = NULL;          
          R3MeshHalfEdge *half_edge = CreateHalfEdge(v1, f, opposite, next);  

        }

... }

