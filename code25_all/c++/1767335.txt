bool BST::retrieve(const char *key, data& aData) const
{
    for ( int i = 0; i < maxSize / 2; i++ )
    {//iterate
        if (! items[2*i+1].empty &&//proceed
              items[2*i+1].theData.getName() < key )
        {// then search leftward
            if ( items[2*i+1].theData == key )
            {
                aData.setName(key);
                return true;
            }
        }
        else if (! items[2*i+2].empty && 
                   items[2*i+2].theData.getName() > key )
        {   // then search rightward
            if ( items[2*i+2].theData == key )
            {
                aData.setName(key);
                return true;
            }
        }
    }// reiterate on condition.
    return false;
}

bool BST::remove(const char* key)
{   
    this->retrieve(key, items[Position].theData );
         // get the position of the node we want to delete.
         if ( items[2*Position+1].empty &&
              items[2*Position+2].empty )
         {
             // then it is a leaf.
         }
}

BST::BST(int capacity) : items(new item[capacity]), Position(0), 
leftChild(0), rightChild(0), maxSize(capacity), size(0), isLeaf(0)
{

}

int isLeaf
isLeaf = 2*i+1;
isleaf = 2*i+2
isLeaf
