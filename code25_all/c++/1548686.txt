make_fn()
wrap()
struct X {};

template<class C, typename T1, bool (C::*F)(T1)>
inline // there are more for T1..TN
bool wrap(C* c, X x) 
{
    return (c->*F)(process<T1>(x));
}

template<class C, typename T1, bool (C::*F)(T1)> 
inline // there are more for T1..TN
boost::function<bool (C*, X)> make_fn(F f) // <- problem here, F is not a type
{
    return boost::bind(&wrap<C, T1, F>, _1, _2);
}

F
make_fn()
struct A 
{
    bool f1(bool) { return true; }
};

void test()
{
    A a;
    X x;
    make_fn(&A::f1)(&a, x);
}

bool invoke(C* c, const char* const functionName, int argCount, X* args);

throw
