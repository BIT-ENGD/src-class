Examples: +++12 200 3 4 becomes (((12+3)+3)+4)
+++12 2000 3 4 becomes (((12+20004)+3)+4)
+++12 20005 3 4 becomes (((12+20004)+3)+4)
+++12 20005 3 45 becomes (((12+20004)+3)+45)
+++12 20005 3 456 becomes (((12+20004)+3)+()

#include "EParse.h"
#include <iostream>
#include <iomanip>


EParse::EParse( char* s )
{
    this->s = s;
    len = strlen( s );
}

void EParse::showParsed()
{
    parse( s, 0, len, new std::queue< char* >(), new std::queue< char >() );
}

void EParse::parse( char* str, int beg, int len, std::queue< char* > *n, std::queue< char > *ex )
{
    //ex is for mathematical expressions (+, -, etc.), n is for numbers
    if( beg == len )
    {
        if( ex->size() > n->size() )
        {
            std::cout << "Malformed expression. Too many mathematical expressions to too few numbers." << std::endl;
            std::cout << ex->size() << " mathematical expressions." << std::endl;
            std::cout << n->size() << " number(s)." << std::endl;
            return;
        }
        else
        {
            std::string *s = new std::string();
            output( n, ex, 0, s );
            std::cout << s->c_str();
            return;
        }
    }

    if( str[ beg ] == ' ' && beg != ( len - 1 ) )
        beg++;
    if( num( str[ beg ] ) )
    {
        std::string *s = new std::string();
        getNum( s, str, beg, len );
        //std::cout << s->c_str() << std::endl;
        n->push( const_cast< char* >( s->c_str() ) );
        delete s;
        parse( str, beg, len, n, ex );
    }
    else if( mathexp( str[ beg ] ) )
    {
        ex->push( str[ beg ] );
        parse( str, beg + 1, len, n, ex );
    }
}

void EParse::getNum( std::string *s, char* str, int &beg, int len )
{
    if( num( str[ beg ] ) )
    {
        char *t = new char[ 1 ];
        t[ 0 ] = str[ beg ];
        s->append( t );
        beg += 1;
        getNum( s, str, beg, len );
    }
}

bool EParse::num( char c )
{
    return c == '0' || c == '1' || c == '2' || c == '3' || c == '4' ||
    c == '5' || c == '6' || c == '7' || c == '8' || c == '9';
}

bool EParse::mathexp( char c )
{
    return c == '+' || c == '*' || c == '/' || c == '%' || c == '-';
}

void EParse::output( std::queue< char* > *n, std::queue< char > *ex, int beg, std::string *str )
{
    if( ex->empty() )
    {
        return;
    }

    char *t = new char[1];
    t[ 0 ] = ex->front();
    ex->pop();
    if( beg == 0 )
    {
        str->insert( 0, "(" );
        str->append( n->front() );
        beg += 1 + strlen( n->front() );
        n->pop();
        str->append( t );
        str->append( n->front() );
        str->append( ")" );
        beg += 2 + strlen( n->front() );
        n->pop();
    }       
    else 
    {
        str->insert( 0, "(" );
        str->insert( beg, t );
        str->insert( beg + 1, n->front() );
        beg += 1 + strlen( n->front() );
        str->insert( beg, ")" );
        n->pop();
        beg++;
    }

    //ex->pop();
    output( n, ex, beg + 1, str );
    //std::cout << str << std::endl;
}

