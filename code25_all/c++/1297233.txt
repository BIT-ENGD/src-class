// main.cpp
wineries->insert(winery("Lopez Island Vinyard", "San Juan Islands", 7, 95));

//winery.cpp
winery::winery(const char * const name, const char * const location,
               const int acres, const int rating)
  : name( new char[strlen(name)+1] )
  , location( new char[strlen(location)+1] )
  , acres( 0 ), rating( 0 )
{

}

this
list::insert( const winery &winery )
void list::insert(const winery& winery)
{
    node *NodePtr = new node( winery );
    // NodePtr->item has the garbage.
    NodePtr->item = winery;
}

list::node::node( const winery& winery )
{
    // This works because I have a default constructor for the winery object
    // and *only* for that reason...
    // How can I use the node constructor without having to use a default constructor for the winery class?
}

name
location
acres
rating
winery::winery()
{
    // do nothing default constructor   
    // only here so I can add the &winery to the node constructor..
}

winery::~winery()
{
    delete location;
    delete name;
    // your code here
}

const char * const winery::getName() const
{   
    //winery *wine_t = new winery();
    const char cName[5] = "four";
    // just to see if it still gives garbage..
    return cName
}

const char * const winery::getLocation() const
{
    // return one of winery's private members.
    // It *will* crash when this function is called.
    // *That* might be the issue with **garbage values** return location;
}

// list.h
#ifndef _LIST_
#define _LIST_

#include <ostream>
#include "winery.h"

using namespace std;

class list
{
public:
    list(void);             // constructor
    virtual ~list(void);    // destructor
    ...
    void insert(const winery& winery);
    winery * const find(const char * const name) const;


private:
    struct node
    {
            node(const winery& winery);     // constructor
        winery item;
        node * nextByName;
        node * nextByRating;
        };

    node * headByName;
    node * headByRating;
};

#endif // _LIST_

