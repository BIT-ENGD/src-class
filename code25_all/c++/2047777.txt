remove
elementIds
struct my_list
meshElem
meshElem->elem
elemId = meshElem->elem->id;
elemId
0 to elementIds
elemId
struct my_list lst
lst[elemId]
doSomething ()
0 to elementIds
lst->number
someArray[i]
0 to N
appendElement
next
struct my_list lst
struct my_list
 {
  int  number;
  struct my_list *prev;
  struct my_list *next;
 }

void doSomething(void){
     const int N = 50000;
     const int elementIds = 10000;
     int i, elemId, node_i;     
     struct my_list *lst;     
     lst = new struct my_list[elementIds];
     int someArray[12];

     meshElem = mesh->next;     

     for(i=0; i<=elementIds; i++) {
        lst[i].num = 0;
        lst[i].next   = NIL;
        lst[i].prev  = NIL;
      }      

    while(meshElem != NIL){
        // Element id (int) 
        // Note that any elemId will be in range [0 - elemId ]
        elemId = meshElem->elem->id;

        // Do some operations to populate "lst"    
        // Note that 'lst' gets values ONLY for certain 
        // values of i
        for (i = 0; i<=N; i++){        
            // if certain conditions are satisfied, 
            // it updates the  linked list element 
            // lst[meshIdx]. foo1(), foo2() are just some conditions...

            if (foo1()){
               appendElement(someArray[i], &lst[meshIdx])
               }
            else if (foo2()){
               appendElement(someArray[i], &lst[meshIdx])           
            }
        }          

      meshElem = meshelem->next;

  } // End of while(meshElem != NIL)

  // Clean up the linked list lst 
  // by removing unassigned items. 

   struct my_list *lst_2

   for(i=1; i<=N; i++) {
     lst_2 = &lst[i];
     while( lst != NIL ) {      
      if( lst->next != NIL && lst->next->number == 0 ) {
        delete lst_2->next;
        lst_2->next = NIL;
      } // end of if loop
      lst = lst_2->next;

    } // end of while while( lst != NIL )

  } // End of for(i=1; i<=N; i++)


  //  Do some more stuff that uses struct my_list lst
  for(i=1;i<=elementIds;i++) {

      while( lst[i] != NIL && (node_i = lst[i]->number) ) {
            if( node_i == 0) {
              lst[i] = lst[i]->next; 
              continue;
            }
            // Use this "node_i" index in some other arrays to
            // do more stuff. 
            //..
            //..
            //..
            lst[i] = lst[i]->next;    
      }

}


void appendElement(int n, struct my_list *lst) {
  int exists = 0;
  while( lst->next != NIL ) {
    if( lst->number == n ) {
    exists = 1;
    lst=lst->next;
  }
  if( exists < 1 ) {
    lst->number = n2;
    insertElemAfter(lst, 0);
  }
}

