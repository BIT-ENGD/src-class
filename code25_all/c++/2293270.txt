template <typename T>
class Foo {
  public:
    virtual void Method1() { }
    virtual void Method1(int a) { }
    virtual void Method2() { }
    virtual void Method2(int a) { }
    //... lots of other methods
};

template <typename T>
class Bar : public Foo<T> {
  public:
    using Foo<T>::*; //redefine all inherited methods from Foo
    virtual void Method1(int a) { }
    virtual void Method2(int a) { }
    //other methods overloading..
};

template <typename T>
class Bar : public Foo<T> {
  public:
    using Foo<T>::Method1
    using Foo<T>::Method2
    //... lots of other methods

    virtual void Method1(int a) { }
    virtual void Method2(int a) { }
    //other methods overloading..
};

int main() {
  Bar<int> b;
  b.Method1();
  b.Method2();
  //... lots of other methods

  //This obviously works without the 'using' keyword:
  Foo<int>* f = &b;
  f->Method1();
  f->Method2();
  //etc
  return 0;
}

