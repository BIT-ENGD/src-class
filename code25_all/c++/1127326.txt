void CMyClass::ConnectEvents(IHTMLElement* pElem)
{
    HRESULT hr;
    IConnectionPointContainer* pCPC = NULL;
    IConnectionPoint* pCP = NULL;
    DWORD dwCookie;

    // Check that this is a connectable object.
    hr = pElem->QueryInterface(IID_IConnectionPointContainer, (void**)&pCPC);

    if (SUCCEEDED(hr))
    {
        // Find the connection point.
        hr = pCPC->FindConnectionPoint(DIID_HTMLElementEvents2, &pCP);

        if (SUCCEEDED(hr))
        {
            // Advise the connection point.
            // pUnk is the IUnknown interface pointer for your event sink
            hr = pCP->Advise(pUnk, &dwCookie);

            if (SUCCEEDED(hr))
            {
                // Successfully advised
            }

            pCP->Release();
        }

        pCPC->Release();
    }
} 

class ATL_NO_VTABLE CMyClass:
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CSecurMailBHO, &CLSID_MyClass>,
    public IObjectWithSiteImpl<CMyClass>,
    public IDispatchImpl<ISecurMailBHO, &IID_IMyClass, &LIBID_MyClassLib, /*wMajor =*/ 1, /*wMinor =*/ 0>,
    public IDispEventImpl<1, CMyClass, &DIID_DWebBrowserEvents2, &LIBID_SHDocVw, 1, 1>, //Safe alternative to Invoke
    public IDispEventImpl<2, CMyClass, &DIID_HTMLElementEvents2, &LIBID_MSHTML, 4, 0>
{
.
.
.
BEGIN_SINK_MAP(CMyClass)
     SINK_ENTRY_EX(1, DIID_DWebBrowserEvents2, DISPID_DOCUMENTCOMPLETE, OnDocumentComplete)//Do stuff OnDocumentComplete
     SINK_ENTRY_EX(1, DIID_DWebBrowserEvents2, DISPID_BEFORENAVIGATE2, BeforeNavigate2)//Handle BeforeNavigate2

     SINK_ENTRY_EX(2, DIID_HTMLElementEvents2, DISPID_HTMLELEMENTEVENTS2_ONSCROLL, OnScroll)//Handle OnScroll Event

END_SINK_MAP()
.
.

}

