void BST::insert( const data &aData )
{
     item *y = &items[root_index];   // Algorithm calls for NULL assignment..
     item *x = &items[root_index]; 

while ( ! items[root_index].empty )
{
    y->theData = x->theData; // Ptrs are required or else a crash occurs.
    if ( aData < x->theData )
    {
        x->leftChild = aData;
    }
    else
    {
        x->rightChild = items[root_index].theData;
    } 

    // what is p[z] = y? is it outside the looping scheme?

    root_index++; // and make the new child the root?   
}
    if ( y->empty ) 
    {
        items[root_index].theData = aData;
        items[root_index].empty = false;
    }
    else if ( aData < y->theData )
    {
        y->leftChild = aData; 
    // If we already have a left/right child...make it the root? re-cmpr?
              }
    else
    {
        y->rightChild = items[root_index].theData;
    }

  }

