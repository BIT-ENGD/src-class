struct Node {
    char         letter;
    ItemType     item;
    List<Node> * branches;
};

Node * root;
int    size;

ItemType put(KeyType newKey, ItemType newItem) {
    Node * currentNode = root;
    if (isEmpty()) {

        //So build a new key
        for (int levelIndex = 1; ((int) (newKey.length()) - levelIndex) >= 0; ++levelIndex) {
            currentNode->branches = new List<Node>;
            Node * tempNode = new Node;
            tempNode->letter = newKey.at(levelIndex - 1);
            currentNode->branches->add(*tempNode);
            currentNode = tempNode;
        }
        //Store
        currentNode->item = newItem;
        ++size;
        return NULL; //The former item.

    } else {
        //Begin
        return puttanesca(newKey, newItem, *(currentNode->branches), 1, 1);
    }
}

ItemType puttanesca(KeyType newKey, ItemType newItem, List<Node> & tempList, int listIndex, int levelIndex) {
    Node currentNode = tempList.get(listIndex);

    //Am I at the right node? (searching)
    if (newKey.at(levelIndex - 1) == currentNode.letter) { //Yes, I am.
        //Is this a leaf node?
        if (currentNode.branches == NULL) {

            //Key does not already exist
            if (newKey.length() != levelIndex) {
                //So build a new key
                for (; ((int) (newKey.length()) - levelIndex) >= 0; ++levelIndex) {
                    currentNode.branches = new List<Node>;
                    Node * tempNode = new Node;
                    tempNode->letter = newKey.at(levelIndex - 1);
                    currentNode.branches.add(*tempNode);
                    currentNode = *tempNode;
                }
                //Store
                currentNode.item = newItem;
                ++size;
                return NULL; //The former item.

            } else { //Key matched!
                //Replace with new item
                ItemType currentItem = currentNode.item;
                currentNode.item = newItem;
                return currentItem; //which is actually the now old item after the previous statement
            }
        } else { //Not a leaf, keep going
            //Go to the next level and start from the first index
            ItemType currentItem = puttanesca(newKey, newItem, currentNode.branches, 1, levelIndex + 1);
            if (currentItem == NULL) {
                //Key found to be inexistant
                //So build a new key - create new sibling
                Node * tempNode = new Node;
                tempNode->letter = newKey.at(levelIndex - 1);
                currentNode.branches.add(*tempNode);
                currentNode = *tempNode;

                //Continue building key - extend sibling
                for (++levelIndex; ((int) (newKey.length()) - levelIndex) >= 0; ++levelIndex) {
                    currentNode.branches = new List<Node>;
                    Node * tempNode = new Node;
                    tempNode->letter = newKey.at(levelIndex - 1);
                    currentNode.branches.add(*tempNode);
                    currentNode = *tempNode;
                }
                //Store
                currentNode.item = newItem;
                ++size;
                return NULL; //The former item

            } else {
                return currentItem; //The former item;
            }
        }
    } else { //Wrong node
        if (tempList.getLength() > listIndex) {
            return puttanesca(newKey, newItem, tempList, ++listIndex, levelIndex);

        } else {//End of the line, chump
            return NULL; //Tell parent you failed
        }
    }
}

