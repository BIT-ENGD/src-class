template <class key_t, class ipdc_t>
class ipdc_map_template_t : public ipdc_lockable_t
{
    ...
    typedef map<key_t,
            ipdc_t*,
            less<key_t>> map_t;
    ...

struct iterator : public map_t::iterator
{
    iterator() {}
    iterator(const map_t::iterator & it)
        : map_t::iterator(it) {}
    iterator(const iterator & it)
        : map_t::iterator(
            *static_cast<const map_t::iterator *>(&it)) {}
    operator key_t() {return ((this->operator*()).first);}           // I don't understand this.
    operator ipdc_t*() const {return ((this->operator*()).second);}  // or this.

};

iterator begin() {IT_ASSERT(is_owner()); return map.begin();}
iterator end() {return map.end();}

ipdc_map_template_t::iterator iter;
    for( iter = my_instance.begin();
             iter != my_instance.end();
         ++iter )
    {
        key_t my_key = ??????;
        ipdc_t *my_value = ??????;

    }

