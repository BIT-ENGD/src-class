test.cpp: In constructor 'Foo::descent::descent(int)':
test.cpp:46: error: invalid use of nonstatic data member 'Foo::index_'
test.cpp: In member function 'bool Foo::descent::operator()(std::string&)':
test.cpp:50: error: invalid use of nonstatic data member 'Foo::bars_'
test.cpp:50: error: invalid use of nonstatic data member 'Foo::index_'
test.cpp:51: error: invalid use of nonstatic data member 'Foo::index_'
test.cpp:51: error: invalid use of nonstatic data member 'Foo::bars_'
test.cpp:52: error: invalid use of nonstatic data member 'Foo::index_'

#include <math.h>
#include <string>
#include <vector>
#include <iostream>

#ifndef __generator_h__
#define __generator_h__

// generator/continuation for C++
// author: Andrew Fedoniouk @ terrainformatica.com
// idea borrowed from: "coroutines in C" Simon Tatham,
//                     http://www.chiark.greenend.org.uk/~sgtatham/coroutines.html

struct _generator
{
  int _line;
  _generator():_line(0) {}
};

#define $generator(NAME) struct NAME : public _generator

#define $emit(T) bool operator()(T& _rv) { \
                    switch(_line) { case 0:;

#define $stop  } _line = 0; return false; }

#define $yield(V)     \
        do {\
            _line=__LINE__;\
            _rv = (V); return true; case __LINE__:;\
        } while (0)
#endif

class Foo {
    int index_;
    std::vector<std::string> bars_;
    public:
    Foo() {
        index_ = 0;
        bars_.push_back("Foobar");
        bars_.push_back("Barfoo");
    }
    $generator(descent){
        int j;
        descent(int j) {
            index_+=j;
        }
        $emit(std::string)
            while(true) {
                $yield(bars_[index_++]);
                if(index_ >= bars_.size())
                    index_ = 0;
            }
        $stop;
    };
    //descent bar;
    void InitGenerator() { index_ = 0; }
};

using namespace std;

int main()
{
  //Foo::descent gen(1);
  //for(int n; gen(n);) // "get next" generator invocation
  //  cout << n << endl;
  return 0;
}

