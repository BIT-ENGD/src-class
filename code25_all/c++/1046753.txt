  S<void,int>  sv;  // uses Template at (2)

S<void,char> e2;   
//uses (1) when im thinking it would use (2) especialization as well

template<typename T> 
class Types { 
  public: 
    typedef int I; 
}; 

template<typename T, typename U = typename Types<T>::I> 
class S;                        // (1) 

template<> 
class S<void> {                 // (2) 
  public: 
    void f(); 
}; 

template<> class S<char, char> {}; // (3) 

template<> class S<char, 0>;    // ERROR: 0 cannot substitute U 

int main() 
{ 
    S<int>*      pi;   // OK: uses (1), no definition needed 
    S<int>       e1;   // ERROR: uses (1), but no definition available 
    S<void>*     pv;   // OK: uses (2) 
    S<void,int>  sv;   // OK: uses (2), definition available 
    S<void,char> e2;   // OK: uses (1), definition available 
    S<char,char> e3;   // ERROR: uses (3), but no definition available 
} 

