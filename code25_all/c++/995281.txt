//QSweep.cpp
 void QSweep:: createLoops(){ 

 std:: vector< int > orientationUE;
 if (test1)
     orientationUE.push_back(1);
 else
     orientationUE.push_back(-1);

 //QSweep.h
 class QSweep{
    ....
    std::vector< int > orientationUE;
    ....
 }

 //QSweep.cpp
 void QSweep:: createLoops(){
    if (test1)
     orientationUE.push_back(1);
    else
     orientationUE.push_back(-1);
 }

  class QSwepp{
  ....
  }

typedef Seq< vector<int> > MxInt2d;
class QSweep
{   
public:
  QSweep(){};
  QSweep(const MxDouble2d& myPoints, const MxInt2d& myEdges);
  void intersection();

  //data and functions for inserting the missing edges in the graph
  void completeGraph();   

  MxInt2d myEFCG;
  std::vector< int > vNoClone;
  std::vector< int > vEdge;

  ....

  int nbIntersections;
  MxInt2d sweepEvents;
  std::vector<double*> myIntersections;
};

 double* QSweep::computeIntersection(double m1, double b1, double m2, double b2){
double* v=new double[3];

v[0]= (b2-b1)/(m1-m2);
v[1]= (m1*b2-m2*b1)/(m1-m2);
v[2]=0.00;

return v;
 }


 double* QSweepComplete::findIntersection(edge_t edge1, edge_t edge2){
    double* vector=NULL;

        if (test2){
             return NULL;
        }
        else{
          vector=computeIntersection(m1,b1,m2,b2);
          return vector;
        }           
 }

 void QSweep:: intersection(){
   double* vector=NULL;
   vector=findIntersection(edge1,edge2);
   if (vector!=NULL){
     myIntersections.push_back(vector);
   }
 }

    int nbIntersections;

