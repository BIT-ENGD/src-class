 stock::stock(char const * const symbol, char const * const name, int sharePrice, date priceDate )
 : m_sharePrice( sharePrice )
 {
    if ( symbol )
    {
        size_t length = strlen( symbol ) +1;
        m_symbol = new char[length];
        strcpy_s( m_symbol, length, symbol );
    }
    else m_symbol = NULL;
    if ( name )
    {
            size_t length = strlen( name ) +1;
       m_name = new char[length];
       strcpy_s( m_name, length, name );
    }
    else m_name = NULL;

    dateObj = &priceDate;
 }

pragma once
#include <ostream>
using namespace std;

class date
  {
  public:
    typedef enum {INVALID, JANUARY, FEBRUARY, MARCH, APRIL, MAY, JUNE,
              JULY, AUGUST, SEPTEMBER, OCTOBER, NOVEMBER,DECEMBER}
    Month;

    date(Month month, int day, int year);
    date(const date& date);         // copy constructor
    date(void);                              // default constructor
    ~date(void);

    friend ostream& operator<<(ostream& out, const date& d);

 private:
    Month   month;
    int     day;
    int     year;
};

bool hashmap::get(char const * const symbol, stock& s) const
{
    int index = 0;
    // search for the stock associated with the symbol.
    while ( index < maxSize )
    {
        if ( hashTable[index].m_symbol == NULL ) 
        {
            index++;
        }
        else if ( strcmp( symbol, hashTable[index].m_symbol  ) == 0 )
        {
        //s = *hashTable; // call assignemnt overload
             s.m_name = hashTable[index].m_name; // has correct value
             s.dateObj = hashTable[index].dateObj; // GARBLE!
             s.m_sharePrice = hashTable[index].m_sharePrice; // correct 
             s.m_symbol = hashTable[index].m_symbol; // correct
             return true;
        }
    }
        return false;
    }

 #include "date.h"

 using namespace std;

 class stock
 {
  public:
    stock(char const * const symbol, char const * const name, int sharePrice, date priceDate);
    stock(const stock& s);  // copy constructor
    stock(void);                                     // default constructor
    char const * const getSymbol(void) const;
    stock& operator=(const stock& s);
    stock& operator=(stock const * const s);
    ~stock(void);

    // display column headers
    static void displayHeaders(ostream& out);

     friend ostream& operator<<(ostream& out, const stock& s);

     friend class hashmap;
     private:

     date *dateObj;
     char *m_symbol;
     char *m_name;
     int   m_sharePrice;

     static int   maxSize;
  };

 #include "stock.h"

 class hashmap
 {
  public:
hashmap(int capacity);
~hashmap(void);
bool get(char const * const symbol, stock& s) const;

    bool put(const stock& s, int& usedIndex, int& hashIndex, int& symbolHash);
    bool remove(char const * const symbol);

    friend ostream& operator<<(ostream& out, const hashmap& h);

private:
        static int hashStr(char const * const symbol);
    friend class stock;

    stock *hashTable;
 };

 #include "date.h"

 date::date(Month month, int day, int year)
 {
    this->month = month;
    this->day  = day;
    this->year = year;
 }

date::date(const date& date)
{
}

date::date()
{
    day = this->day;
    year = this->year;  
        month = this->month;
}

date::~date(void)
{

}

ostream& operator<<(ostream& out, const date& d)
{
   out << d.day << d.month << d.year << endl;
        return out;
}

