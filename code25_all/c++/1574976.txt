bool hashmap::get(char const * const symbol, stock& s) const
{
    int hashVal = this->hashStr( symbol );
    int initialHash = -1;

    while ( hashTable[hashVal].m_symbol != NULL )
    {   // try to find a match for the stock associated with the symbol.

        if ( initialHash == -1 )
        {
             initialHash = hashVal;
        }
        if ( strcmp( hashTable[hashVal].m_symbol, symbol ) == 0 )
        {
            s = &hashTable[hashVal];
            return true;
        }
        ++hashVal %= maxSize;
    }
    if ( hashTable[hashVal].m_symbol == NULL || hashVal == initialHash )
    {
         return false;
    }
    else return true;
}

bool hashmap::put(const stock& s, int& usedIndex, int& hashIndex, int& symbolHash)
{
    hashIndex = this->hashStr( s.m_symbol ); // Get remainder, Insert at that index.
    symbolHash = (int&)s.m_symbol;
    usedIndex = hashIndex;

    while ( hashTable[hashIndex].m_symbol != NULL )
    {
        ++usedIndex %= maxSize; // if necessary wrap index around
        if ( hashTable[usedIndex].m_symbol == NULL )
        {
            hashTable[usedIndex] = s;
            return true;
        }
        else if ( strcmp( hashTable[usedIndex].m_symbol , s.m_symbol ) == 0 )
        {
            return false; // prevent duplicate entry
        }
    }
    hashTable[hashIndex] = s; // insert if no collision 
    return true;
}

bool hashmap::remove(char const * const symbol)
{
    int hashVal = this->hashStr( symbol );
    int initialHash = -1;

    while ( hashTable[hashVal].m_symbol != NULL  )
    {
        if ( initialHash == -1 )
        {
            initialHash = hashVal;
        }
        if ( strcmp( hashTable[hashVal].m_symbol, symbol ) == 0 )
        {
            hashTable[hashVal].m_symbol = NULL;
            return true;
        }
        ++hashVal %= maxSize; // wrap around if needed
    }   // go to the next cell if not found

    if ( hashVal != initialHash && hashTable[hashVal].m_symbol != NULL )
    {
        return true;
    }
    return false;
}

int hashmap::hashStr(char const * const str)
{   
    size_t length = strlen( str );
    int hash = 0;
    for ( unsigned i = 0; i < length; i++ )
    {
         hash = 31 * hash + str[i];
    }
    return hash % maxSize;
 }

