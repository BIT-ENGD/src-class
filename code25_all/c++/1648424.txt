void WatchdogController::conscious_process_handler_start() {

    if ( debug ) cout << "WatchdogController: starting conscious process thread" << endl;

    cn_pr_thread_active = true;

    if ( pthread_create( &cn_pr_thread, NULL, conscious_process_handler, this ) < 0 ) {
        cn_pr_thread_active = false;
        throw WatchdogException( "Unable to start new thread" );
    }
}

void WatchdogController::conscious_process_handler_stop() {

    if ( debug ) cout << "WatchdogController: stopping conscious process thread" << endl;

    cn_pr_thread_active = false;

    int *retval;

    pthread_join( cn_pr_thread, ( void ** )&retval );

    if ( *retval < 0 ) {
        delete retval;
        string err = string( "Error returned by conscious_process_handler(): " ) + string( pthread_err );
        throw WatchdogException( err.c_str() );
    }

    delete retval;
}

throw WatchdogException( err.c_str() );

try {
        watchdog_controller->hardware_watchdog_stop();
        watchdog_controller->unconscious_process_handler_stop();
        watchdog_controller->conscious_process_handler_stop();
    }
    catch ( HardwareWatchdogException &e ) {
        cerr << "Error stopping hardware watchdog!" << endl;
        cerr << e.get_reason() << endl;
        string err = string( "Exception thrown by hardware watchdog controller" ) + string( e.get_reason() );
        if ( log ) write_log( err.c_str() );
        delete watchdog_controller;
        return -1;
    }
    catch ( WatchdogException &e ) {
        cerr << "Exception cought when exiting!" << endl;
        cerr << e.get_reason() << endl;
        string err = string( "Exception cought when exiting" ) + string( e.get_reason() );
        if ( log ) write_log( err.c_str() );
        delete watchdog_controller;
        return -1;
    }

cerr << e.get_reason() << endl;

class WatchdogException {

    public:

        /**
            @brief      Default constructor
        */
        WatchdogException() : reason() {
        }

        /**
            @brief      Overloaded constructor - setting the error message
            @param      why         Error message
        */
        WatchdogException( const char *why ) : reason( why ) {
        }

        /**
            @brief      The destructor
        */
        virtual ~WatchdogException() {
        }

        /**
            @brief      A getter for the error message
            @return     Returns a string containing error description
        */
        virtual std::string get_reason() const {
            return reason;
        }

    protected:

        /**
            @var        reason      String containing the error message
        */
        std::string reason;

};

