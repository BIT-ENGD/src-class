struct CELL {
private:
    static bool haslife;
static int x;
static int y;
public:

    static bool has_life()
    {
        return haslife;
    }

    static void set_coords(int xcoord, int ycoord)
    {
        x = xcoord;
        y = ycoord;
    }
    static void get_coords(int &xcoord, int &ycoord)
    {
        xcoord = x;
        ycoord = y;
    }


};


class cell_grid {
private:
static int cell_size;
static int cell_count_x;
static int cell_count_y;
CELL **cell;
public:
    cell_grid();
    cell_grid(unsigned int width,unsigned int height, unsigned int cellsize)
    {

        //set size based on cellsize

        this->cell_size = cellsize;
        this->cell_count_x = floor((double)width / this->cell_size);
        this->cell_count_y = floor((double)height / this->cell_size);


        this->cell = new CELL*[this->cell_count_y];

        for(int i = 0; i < this->cell_count_y; i++)
        {
            cell[i] = new CELL[this->cell_count_x];
        }

        for(int y = 0; y < this->cell_count_y; ++y)
        {
            for(int x = 0; x < this->cell_count_x; ++x)
            {
                int cur_x = x * this->cell_size;
                int cur_y = y * this->cell_size;
                this->cell[x][y].set_coords(cur_x,cur_y);
            }
        }

    } //end of constructor

    static int get_cell_size()
    {
        return cell_size;
    }
static void render(BITMAP *buff)
{
    circlefill(buff,70,70,60,makecol(27,37,0));

}


};

int main()
{
    start_allegro();
    cell_grid *grid = new cell_grid(scr_w,scr_h,10);
    grid->render(buffer);


        //Main Loop
    while (!done && !key[KEY_ESC]) //until 'X' pressed or ESC
{
//***** Start Main Code Here *****
    while (speed_counter > 0)
    {



                 //render the buffer to the screen

            blit(
            buffer,
            screen,
            0,0,0,0,
            scr_w,
            scr_h);

            clear_bitmap(buffer);

        speed_counter --;
    }
//***** End Main Code Here *****
rest(1); //Normalize cpu usage
}
    return 0;
}
END_OF_MAIN()

