struct Block {       
    int* offset;
    bool used;
    int size;
    Block(int* off=NULL, bool isUsed=false, int sz=0): offset(off), used(isUsed), size(sz) {}
    Block(const Block& b): offset(b.offset), used(b.used), size(b.size) {}
};

class BlockList {
    Block* first;
    int size;
public:
    BlockList(): first(NULL), size(0) {}
    void PushBack(const Block&);
    void DeleteBack();
    void PushMiddle(int, const Block&);
    void DeleteMiddle(int);
    int Size() const { return size; }
    void show();
    Block& operator[](int);
    Block* GetElem(int);
    void SetElem(int, const Block&);
    ~BlockList();
};

operator[]
Block& BlockList::operator\[\](int index) {
    try {
        if (index >= size)
            throw out_of_range("index out of range");
        else 
            return (first[sizeof(Block)*index]);
    }
    catch(exception& e) {
        cerr << e.what() << endl;
    }
}

void BlockList::PushBack(const Block& b) {
    if(!size) 
        first = new Block(b);
    else {
        Block* temp = new Block[size + 1];
        int i = 0;
        for (i = 0; i < size; i++) 
            temp[sizeof(Block)*i] = this->operator[](i);
        delete []first;
        temp += sizeof(Block);
        temp->offset = b.offset;
        temp->size = b.size;
        temp->used = b.used;
        first = temp;
    }
    size++;
}

PushBack
void BlockList::show() {
    for (int i = 0; i < size; i++) {
        Block current(operator[](i));
        cout << "off: " << current.offset << " size: " << current.size << endl;
    }
}

