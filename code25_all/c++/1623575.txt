template <typename T>
class _reference
{
private:
    T* p_;

public:

// !!! this assignment seems only to work, when T is no class template already...
void operator= (T* r)                   
{
    p_ = r;
}

// WHILE this ALWAYS works as well...
void simplySetIt (T* r)                 
{
    p_ = r;
}
};

template <typename T>
class _ref_vector : public _reference<vector<T> >
{
};

void test2 ()
{
_reference<vector<long> > ref_ptr2;
_ref_vector<long>         ref_ptr3;

ref_ptr2 = new vector<long>;                    // works fine.

ref_ptr3 = new vector<long>;                // BUT: THIS doesnt work
    ref_ptr3.simplySetIt (new vector<long>);    // WHILE: this works fine...
}

error C2679: binary '=' : no operator found which takes a right-hand operand of type 
'std::vector<_Ty> *' (or there is no acceptable conversion)

error: no match for 'operator=' in 'ptr3 = (((const stlp_std::allocator<long int>&)
((const stlp_std::allocator<long int>*)(& stlp_std::allocator<long int>()))), 
(((stlp_std::vector<long int, stlp_std::allocator<long int> >*)operator new(12u)), 
((<anonymous> != 0u) ? (<anonymous>->stlp_std::vector<_Tp, _Alloc>::vector [with 
_Tp = long int, _Alloc = stlp_std::allocator<long int>]
(<anonymous>), <anonymous>) : <anonymous>)))'

