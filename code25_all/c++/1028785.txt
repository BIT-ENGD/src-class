template<typename T>
class PointerWrapper
{
public:
    PointerWrapper( T const * _pointer ): m_pointer(_pointer) {}
    typedef T Type;
    T const * m_pointer;
};

template<typename T>
class SomeObject: public NoCopyOrAssign
{
public:
    SomeObject( void * _allocaBuffer, PointerWrapper<T> _source, int _count );
};

void Test( PointerWrapper<int> _array, int _count )
{
    SomeObject<int> object = MakeSomeObject( _array, _count );
    // do some work with object
};

#define MakeSomeObject(_wrappedPtr, _runtimeCount) \
    SomeObject(alloca(sizeof(_wrappedPtr::Type)*_runtimeCount), \
                    _wrappedPtr, _runtimeCount)

template<typename WrappedT>
SomeObject<typename WrappedT::Type> MakeSomeObject
    ( WrappedT _pointer, uint _runtimeCount )
{
    return SomeObject<typename WrappedT::Type>
        ( alloca(sizeof(typename WrappedT::Type)*_runtimeCount),
         _pointer, _runtimeCount );
}

