1>\takehome\main.cpp(39) : error C2065: 'j' : undeclared identifier
1>\takehome\main.cpp(44) : error C2065: 'j' : undeclared identifier
\takehome\main.cpp(45) : error C2065: 'j' : undeclared identifier
\takehome\main.cpp(76) : error C2065: 'j' : undeclared identifier
\takehome\main.cpp(80) : error C2065: 'j' : undeclared identifier

#include <iostream>
using namespace std;

int main()
{
 int memory[100]; //Making it 100, since simpletron contains a 100 word mem.

 int operation; //taking the rest of these variables straight out of the book seeing as how they were italisized.

 int operand;

 int accum = 0; // the special register is starting at 0

 int position = 0; //making the starting position to be 0.

 for ( int j = 0; j < 100; j++ ) //Simply stating that for int j is = to 0, j must be less than 100 because that is the memory limit, and for every pass-through, increment j.

  memory[j] = 0;


 // This is for part a, it will take in positive variables in a sent-controlled loop and compute + print their sum. These are random variables.
 memory [0] = 2942;

 memory [1] = 2342;

 memory [2] = 3523;

 memory [3] = 2031;

 memory [4] = 5000;

 memory [5] = 8080;

 memory [6] = 3425;

 j = 0; //Makes the variable j start at 0.

 while ( true )
 {

  memory[ j ]%100 = operand; // Finds the op codes from the limit on the memory (100)
  memory[ j ]%100 = operation;

  //using a switch loop to set up the loops for the cases
  switch ( operation ){
   case 1: //reads a variable into a word from loc.
    cout <<"\n Input a positive variable:  ";
    cin >> memory[ operand ]; break;

   case 2: // takes a word from location
    cout << "\n\nThe content at location " << operand << "is " << memory[operand]; break;

   case 3:// loads
    accum = memory[ operand ]; break;

   case 4: //stores
    memory[ operand ] = accum; break;

   case 5: //adds
    accum = accum + memory[ operand ]; break;


   case 6: // subtracts
    accum = accum - memory[ operand ]; break;

   case 7: //divides
    accum = accum / (memory[ operand ]); break;

   case 8: // multiplies
    accum = accum*memory [ operand ]; break;

   case 9: // Branches to location
    j = -1; break;

   case 10: //branches if acc. is < 0
    if (accum < 0)
    j = 5; break;

   case 11: //branches if acc = 0
    if (accum == 0); break;

   case 12: // Program ends
    exit(0); break;
 }
 j++;
 }
return 0;
}

