// Enrich with is enriching more than i want

public intefrace ICommand {
   void Execute();
}

// classes

public class A : ICommand {}
public class B : ICommand {}
public class MultiCommand : ICommand {
  public MultiCommand(ICommand[] commands) {}
}

// -- decorators
public DecoratorOne : ICommand {
  public DecoratorOne(Icommand toDecorate) {}
}

public DecoratorTwo : ICommand {
  public DecoratorOne(Icommand toDecorate) {}
}



// what i tried

 ForREquesedType<ICommand>()
    .TheDefaultIsConcreteType<A>
    .EnrichWith(x => new DecoratorOne(x)
    .EnrichWith(y => new DecoratorTwo(y)
    .CacheBy(InstanceScope.Singleton);

 InstanceOf<ICommand>()
    .TheDefault.Is.OfConcreteType<B>
    .EnrichWith(x => new DecoratorOne(x)
    .WithName("secondCommand")

            ForRequestedType<MultiCommand>()
                .TheDefault.Is.OfConcreteType<MultiCommand>()
                .TheArrayOf<ICommand>()
                .Contains(y =>
                              {
                                  y.TheDefault();
                                  y.TheInstanceNamed("secondCommand")
                              })
                .WithName("multi");

ObjectFactory.GetNamedInsance<ICommand>("secondCommand")
**new DecoratorOne(new DecorateOne(B)).
        RegisterInterceptor(new CommandDecoratorInterceptor());

        // this is the default that everyone hooks into
        ForRequestedType<ICOmmand>()
            .TheDefaultIsConcreteType<A>()
            .CacheBy(StructureMap.Attributes.InstanceScope.Singleton);

        InstanceOf<ICommand>()
            .Is.OfConcreteType<B>()
            .WithName("secondCommand");


        ForRequestedType<MultiCommand>()
            .TheDefault.Is.OfConcreteType<MultiCommand>()
            .TheArrayOf<ICommand>()
            .Contains(y =>
                          {
                              y.TheDefault();
                              y.TheInstanceNamed("secondCommand");
                          });

