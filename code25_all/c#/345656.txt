[Flags]
public enum LoggingCategories
{
    None = 0,
    ServiceEvents = 1, 
    ProcessingInformation = 2,
    ProcessingErrors = 4,
    UnexpectedErrors = 8
}

public interface ILogger
{
    void LogMessage(LoggingCategories category, string message);
}

public abstract class LoggerDecorator : ILogger
{
    private ILogger _decoratedLogger;
    private LoggingCategories _categories;

    protected LoggerDecorator(ILogger logger, LoggingCategories categories)
    {
        this._decoratedLogger = logger;
        this._categories = categories;
    }

    protected bool ShouldLogCategory(LoggingCategories category)
    {
        return ((this._categories & category) == category);
    }

    public virtual void LogMessage(LoggingCategories category, string message)
    {
        _decoratedLogger.LogMessage(category, message);
    }

}

public class ControlLogger : ILogger
{
    public ControlLogger()
    {
    }

    public void LogMessage(LoggingCategories category, string message)
    {
        Console.WriteLine(LoggingHelper.ConstructLog(category, message));
    }
}

try
{
    this._eventLog.WriteEntry(log, type);
}
catch (Exception)
{
    //Even if this logging fails, we do not want to halt any further logging/processing.
}

ILogger controlLogger = new ControlLogger();
ILogger windowsEventLogger = new WindowsEventLogger(controlLogger, windowsEventLogCategories, windowsEventLogSource);
ILogger emailLogger = new EmailLogger(windowsEventLogger, emailCategories, emailSubject, emailAddresses);
ILogger fileLogger = new FileLogger(emailLogger, fileCategories, logDirectory, logFileNamePrefix, logFileExtension);

this._logger = fileLogger;

