namespace LanIpAddresses
{
    class NetApi
    {
        [DllImport ( "Netapi32.dll", EntryPoint = "NetServerEnum" )]
        public static extern Int32 NetServerEnum (
            [MarshalAs (UnmanagedType.LPWStr)] String serverName,
            Int32 level,
            out IntPtr bufferPtr,
            UInt32 prefMaxLen,
            ref Int32 entriesRead,
            ref Int32 totalEntries,
            UInt32 serverType,
            [MarshalAs (UnmanagedType.LPWStr)] String domain,
            IntPtr handle );

        [DllImport ( "Netapi32.dll", EntryPoint = "NetApiBufferFree" )]
        public static extern UInt32 NetApiBufferFree ( IntPtr buffer );
    }


    class EnumerateLanMachines
    {
        public const UInt32 SUCCESS = 0;
        public const UInt32 FAIL = 234;
        public const UInt32 MAX_PREFERRED_LENGTH = 0xFFFFFFFF;
        //public ArrayList machines = new ArrayList ( );

        enum ServerTypes : uint
        {
            WorkStation = 0x00000001,
            Server = 0x00000002
        }

        [StructLayout ( LayoutKind.Sequential, CharSet = CharSet.Auto )]
        public struct MachineInfo
        {
            [MarshalAs ( UnmanagedType.U4 )]
            public UInt32 platformId;

            [MarshalAs ( UnmanagedType.LPWStr )]
            public String serverName;
        }

        public enum Platform
        { 
            PLATFORM_ID_DOS = 300,
            PLATFORM_ID_OS2 = 400,
            PLATFORM_ID_NT = 500,
            PLATFORM_ID_OSF = 600,
            PLATFORM_ID_VMS = 700
        }

        public void enumerateMachines ( )
        { 
            IntPtr buffer = new IntPtr();
            int totalEntries = 0;
            int entriesRead = 0;
            int result;

            result = NetApi.NetServerEnum ( null, 100, out buffer, MAX_PREFERRED_LENGTH, ref entriesRead, ref totalEntries, (uint) ServerTypes.WorkStation, null, IntPtr.Zero );

            MachineInfo machineInfo;

            if (result != FAIL)
            {
                Console.WriteLine ( "Succeeded!" );
                Console.WriteLine ( entriesRead );
                for (int i = 0; i < entriesRead; ++i)
                {
                    machineInfo = (MachineInfo) Marshal.PtrToStructure ( buffer, typeof ( MachineInfo ) );

                    //machines.Add ( machineInfo );
                    Console.WriteLine ( machineInfo.serverName );

                    buffer = (IntPtr) ( (ulong) buffer + (ulong) Marshal.SizeOf ( machineInfo ) );
                }

                NetApi.NetApiBufferFree ( buffer );
            }
        }
    }
}
namespace LanIpAddresses
{
    class Program
    {
        private static IPHostEntry ipHost;
        static ArrayList ipList;

        static void Main ( string[ ] args )
        {
            EnumerateLanMachines enumerate = new EnumerateLanMachines ( );

            enumerate.enumerateMachines ( );

            /*foreach (EnumerateLanMachines.MachineInfo o in enumerate.machines)
            {
                Console.WriteLine ( o.platformId + " " + o.serverName );
            }*/

            Console.ReadLine ( );
        }
    }
}

