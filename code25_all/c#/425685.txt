/// <summary>
/// Compares FileInfo objects based on the files full path.
/// This comparer is flawed in that it will only work correctly
/// on files with the same extension.
/// Though that could easily be fixed.
/// </summary>
private class FileInfoSorter : IComparer
{

    int IComparer.Compare(Object x, Object y)
    {
        FileInfo _x = x as FileInfo;
        FileInfo _y = y as FileInfo;

        // FYI: 
        //ExprFileVersion = new Regex("(.*)_([0-9]+)\\.[^\\.]+$", RegexOptions.Compiled);
        Match m1 = RegExps.ExprFileVersion.Match(_x.FullName);
        Match m2 = RegExps.ExprFileVersion.Match(_y.FullName);
        if (m1.Success && m2.Success) // we have versioned files
        {
            int n1;
            int n2;
            try
            {
                n1 = int.Parse(m1.Groups[2].Value);
            }
            catch (OverflowException ex)
            {
                // Don't know if this works.
                ex.Data["File"] = _x.FullName;
                throw;
            }

            try
            {
                n2 = int.Parse(m2.Groups[2].Value);
            }
            catch (OverflowException ex)
            {
                // Don't know if this works.
                ex.Data["File"] = _y.FullName;
                throw;
            }


            string s1 = m1.Groups[1].Value;
            string s2 = m2.Groups[1].Value;

            if (s1.Equals(s2))
            {
                return n1.CompareTo(n2); // compare numbers naturally. E.g. 11 > 6                        
            }
            else // not the same base file name. So the version does not matter.
            {
                return ((new CaseInsensitiveComparer()).Compare(_x.FullName, _y.FullName));
            }
        }
        else // not versioned
        {
            return ((new CaseInsensitiveComparer()).Compare(_x.FullName, _y.FullName));
        }
    }


}

    IComparer fiComparer = new FileInfoSorter();

        try
        {
            Array.Sort(filesOfExtInfo, fiComparer);
        }
        catch (OverflowException ex)
        {
            // Do not know yet if I can use ex.Data in this way.
            WriteStatusLineAsync("Error: Encountered too large a version number on file: " + ex.Data["File"]);
        }

    public class FileInfoSorter : IComparer
    {

        int IComparer.Compare(Object x, Object y)
        {
            FileInfo _x = x as FileInfo;
            FileInfo _y = y as FileInfo;

            Match m1 = RegExps.ExprFileVersion.Match(_x.FullName);
            Match m2 = RegExps.ExprFileVersion.Match(_y.FullName);
            if (m1.Success && m2.Success) // we have versioned files
            {

                string n1;
                string n2;
                n1 = m1.Groups[2].Value;
                n2 = m2.Groups[2].Value;

                string s1 = m1.Groups[1].Value;
                string s2 = m2.Groups[1].Value;

                int max = Math.Max(n1.Length, n2.Length);

                n1 = n1.PadLeft(max, '0');
                n2 = n2.PadLeft(max, '0');

                if (s1.Equals(s2)) // we have to compare the version
                    // which is now left-padded with 0s.
                {
                    return ((new CaseInsensitiveComparer()).Compare(n1, n2)); 
                }
                else // not the same base file name. So the version does not matter.
                {
                    return ((new CaseInsensitiveComparer()).Compare(_x.FullName, _y.FullName));
                }
            }
            else // not versioned
            {
                return ((new CaseInsensitiveComparer()).Compare(_x.FullName, _y.FullName));
            }
        }
    }

