socket = ss.accept();

BufferedImage image = videoCapture.getNextImage();

if (image != null) {
     OutputStream out = socket.getOutputStream();
     if (RAW) {
         image.getWritableTile(0, 0).getDataElements(0, 0, w$
                                                     image.releaseWritableTile(0, 0);
                                                     DataOutputStream dout = new DataOutputStream(new Bu$
                                                                                                  out));
         for (int i = 0; i < data.length; i++) {
             dout.writeInt(data[i]);
         }
         dout.close();
     } else {
         ImageIO.write(image, "JPEG", out);
     }
}

long read_count, total_read = 0;
while (total_read < readBufSize)


{
    read_count = read(sockd, &readBuf[total_read], readBufSize);
    if (read_count <= 0 || errno != 0)
    {
     char buffer[100];
     sprintf(buffer, "socket read errorno = %d", errno);
     LOGV(buffer);
     break;
    }
    total_read += read_count;
}

// If we read all of the data we expected, we will load the frame from the p$


if (total_read == readBufSize){
    frame = loadPixels(readBuf, width, height);}



Where readBufsize = width*height*sizeof(int); 
readBuf = (char*)malloc(readBufSize);

#import <Foundation/Foundation.h>
#import "AsyncSocket.h"

 @interface Captura : NSObject {
    NSString *ipserver;
    UInt16         port;
    NSError  *errPtr;
    AsyncSocket *socket;
    NSMutableData *socketData;
}
@property (nonatomic,retain) NSString *ipserver;
@property (retain)    AsyncSocket *socket;
@property (retain)    NSError *errPtr;
//will contain de data read from socket 
@property (retain)    NSMutableData *socketData; 

-(id)initWithIp:(NSString*)ip puerto:(UInt16)p;
-(BOOL)open; 
-(void)close;
-(void)beginRead;
- (UIImage*)getImage;
@end

#import "Captura.h"

@implementation Captura
@synthesize ipserver;
@synthesize socket;
@synthesize errPtr;
@synthesize socketData;

-(id)initWithIp:(NSString*)ip puerto:(UInt16)p{
    if (self = [super init]) {
        ipserver = ip;
        port     = p;
        socket = [[AsyncSocket alloc] initWithDelegate:self];
        socketData = [[NSMutableData alloc] init];
    }
    return self;
} 

//Connect 
-(BOOL)open{
    return [socket connectToHost:ipserver onPort:port error:&errPtr];
}

-(void)beginRead{
    NSLog(@"Begin Read");
    NSUInteger offset = [socketData length];
    [socket readDataWithTimeout:1
                            tag:0];
}

- (void)onSocket:(AsyncSocket *)sock didConnectToHost:(NSString *)host port:(UInt16)port{
    NSLog(@"Conectado al servidor");
} 

- (void)onSocket:(AsyncSocket *)sock didReadData:(NSData *)data withTag:(long)tag {
    NSLog(@"Data leida %u",[data length]);
    [socketData appendData:data];
    [self beginRead];
}

- (void)onSocketDidDisconnect:(AsyncSocket *)sock{
    [socketData release];
    [ipserver release];
    [socket release];
    NSLog(@"MutableData length %u", [socketData length]);
    NSLog(@"Socket Desconectado");
}

- (void)onSocket:(AsyncSocket *)sock willDisconnectWithError:(NSError *)err{
    NSLog(@"OcurriÃ³ un error desconectando.... %@",err);
}

- (UIImage*)getImage{
    NSData *data;
    [socketData getBytes:data length:320*480*sizeof(int)];
    NSLog(@"Data obtenida %@",[data length]);
    if ([socketData length]>320*480*sizeof(int)) {
        [socketData replaceBytesInRange:NSMakeRange(0,320*480*sizeof(int)) withBytes:NULL length:0];
    }
    if (data!=nil && [data length]) {
        UIImage *img = [[UIImage alloc] initWithData:data];
        [data release];
        return img;
    }
    [data release];
    return nil;
} 
@end

