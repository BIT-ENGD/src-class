                        ** STILL NOT WORKING **

accelX
accelY
mRadius
mRadius
float degrees = -atan2(accelX, accelY);
int x = cCentrePoint.x + mRadius * cos(degrees);
int y = cCentrePoint.y + mRadius * sin(degrees);

 mRadius = 5;
 mRange = NSMakeRange(0,60);

-(void) updateBall: (UIAccelerationValue) accelX 
                                  withY:(UIAccelerationValue)accelY
{

    float degrees = -atan2(accelX, accelY);
    int x = cCentrePoint.x + mRadius * cos(degrees);
    int y = cCentrePoint.y + mRadius * sin(degrees);

    //self.targetRect is rect of ball Object
    self.targetRect = CGRectMake(newX, newY, 8, 9);
    self.currentRect = self.targetRect;

    static NSDate *lastDrawTime;

    if(lastDrawTime!=nil)
    {
       NSTimeInterval secondsSinceLastDraw =
                    -([lastDrawTime timeIntervalSinceNow]);

       ballXVelocity = ballXVelocity + (accelX * secondsSinceLastDraw) 
               * [self isTouchedTrack:mRadius andRange:mRange];
       ballYVelocity = ballYVelocity + -(accelY * secondsSinceLastDraw) 
               * [self isTouchedTrack:mRadius andRange:mRange];

      distXTravelled = distXTravelled + secondsSinceLastDraw
                          * ballXVelocity * 50;
      distYTravelled = distYTravelled + secondsSinceLastDraw 
                          * ballYVelocity * 50;

      //Updating the ball rect  
      CGRect temp = self.targetRect;
      temp.origin.x += distXTravelled;
      temp.origin.y += distYTravelled;

      //calculating new radius after updating ball position
      int radius = (temp.origin.x - cCentrePoint.x) / 
                               cos(degreesToRadians(degrees));

     if( !NSLocationInRange(abs(radius),mRange))
     {
         //Colided with the tracks...Need a better logic here
      ballXVelocity = -ballXVelocity;
     }
     else
     {
           // Need a better logic here
       self.targetRect = temp; 
     }

  }

  [lastDrawTime release];
  lastDrawTime = [ [NSDate alloc] init];
}

