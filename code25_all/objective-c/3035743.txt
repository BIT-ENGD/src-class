- (void)getCustomersList
{
// make an operation so we can push it into the queue
SEL method = @selector(parseForData);
NSInvocationOperation *op = [[NSInvocationOperation alloc] initWithTarget:self  selector:method object:nil];
customersTempList = [[NSMutableArray alloc] initWithCapacity:20];// allocated list

[self.retrieverQueue addOperation:op];
[op release];
}

// return each recode 
// in parser .m class one of the condition in endElement where it shows a leak.

else if(0 == strncmp((const char *)localname, kCustomerElement, kCustomerElementLength)) 
{
    [customersTempList addObject:customer];
    printf("\n no of objects in temp list:%d", [customersTempList count]);
    if ([customersTempList count] == 20)
    {
        NSMutableArray* argsList = [customersTempList copy];//////////////////////here it is showing leak.
        printf("\n Calling reload data with %d new objects", [argsList count]);
        SEL selector = @selector(parser:addCustomerObject:);
        NSMethodSignature *sig = [(id)self.delegate methodSignatureForSelector:selector];
        if(nil != sig && [self.delegate respondsToSelector:selector]) {
            NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:sig];
            [invocation retainArguments];
            [invocation setTarget:self.delegate];
            [invocation setSelector:selector];
            [invocation setArgument:&self atIndex:2];
            [invocation setArgument:&argsList atIndex:3];
            [invocation performSelectorOnMainThread:@selector(invoke) withObject:NULL waitUntilDone:NO];

        }
        [customersTempList removeAllObjects];
    }
}

// returned the list after all the records are stored in the list
else if(0 == strncmp((const char *)localname, kCustomersElement, kCustomersElementLength)) {
                printf("\n Calling reload data with %d new objects", [customersTempList count]);
            NSMutableArray* argsList = [customersTempList copy];
    printf("\n Calling reload data with %d new objects", [argsList count]);

    SEL selector = @selector(parser:addCustomerObject:);
    NSMethodSignature *sig = [(id)self.delegate methodSignatureForSelector:selector];
    if(nil != sig && [self.delegate respondsToSelector:selector]) {
        NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:sig];
        [invocation retainArguments];
        [invocation setTarget:self.delegate];
        [invocation setSelector:selector];
        [invocation setArgument:&self atIndex:2];
        [invocation setArgument:&argsList atIndex:3];
        [invocation performSelectorOnMainThread:@selector(invoke) withObject:NULL waitUntilDone:NO];
    }
    [customersTempList removeAllObjects];

}
}

