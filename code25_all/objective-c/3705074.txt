glEnable(GL_TEXTURE_2D);
glEnable(GL_BLEND);
glBlendFunc(GL_ONE, GL_SRC_COLOR);

- (GLuint)textureFromPath:(NSString *)path
{
    GLuint texture;
    glGenTextures(1, &texture);

    UIImage *img = [[UIImage alloc] initWithContentsOfFile:path];

    if (!img) {
        NSLog(@"Image \"%@\" could not be loaded and was not bound", path);
        return 0;
    }

    CGImageRef cgimage = img.CGImage;

    float width = CGImageGetWidth(cgimage);
    float height = CGImageGetHeight(cgimage);
    CGRect bounds = CGRectMake(0, 0, width, height);
    CGColorSpaceRef colourSpace = CGColorSpaceCreateDeviceRGB();

    void *image = malloc(width * height * 4);
    CGContextRef context = CGBitmapContextCreate(image, width, height, 8, 4 * width, colourSpace, kCGImageAlphaPremultipliedLast);
    CGColorSpaceRelease(colourSpace);
    CGContextClearRect(context, bounds);
    CGContextTranslateCTM (context, 0, height);
    CGContextScaleCTM (context, 1.0, -1.0);
    CGContextDrawImage(context, bounds, cgimage);

    CGContextRelease(context);

    glBindTexture(GL_TEXTURE_2D, texture);

    glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR); 
    glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);

    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, image);    

    [img release];
    free(image);

    return texture;
}

void bufferHasBeenCreated() const {
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    glOrthof(-160.0f, 160.0f, -240.0f, 240.0f, -5.0f, 1.0f);
    glViewport(0, 0, 320, 480);

    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();

    glEnable(GL_TEXTURE_2D);
    glEnable(GL_BLEND);
    glBlendFunc(GL_ONE, GL_SRC_COLOR);
}

void render() {
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    glLoadIdentity();
    glClearColor(0.325f, 0.0f, 0.325f, 1.0f);

    glEnableClientState(GL_VERTEX_ARRAY);
    glEnableClientState(GL_TEXTURE_COORD_ARRAY);

    static float rot = 0.0f;

    glRotatef(rot, 0.0f, 0.0f, 1.0f);

    //glColor4f(0.0f, 0.0f, 1.0f, 1.0f);
    glBindTexture(GL_TEXTURE_2D, texture_[0]);

    GLenum err = glGetError();
    if (err != GL_NO_ERROR)
        printf("Error. glError: 0x%04X\n", err);

    glVertexPointer(2, GL_FLOAT, 0, pos[0]);
    glTexCoordPointer(2, GL_FLOAT, 0, black);
    glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);

    glVertexPointer(2, GL_FLOAT, 0, pos[1]);
    glTexCoordPointer(2, GL_FLOAT, 0, black);
    glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);

    glVertexPointer(2, GL_FLOAT, 0, pos[2]);
    glTexCoordPointer(2, GL_FLOAT, 0, black);
    glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);

    rot += 0.5f;

    glDisableClientState(GL_VERTEX_ARRAY);
    glDisableClientState(GL_TEXTURE_COORD_ARRAY);
}

