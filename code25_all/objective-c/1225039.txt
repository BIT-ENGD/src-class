#import <Foundation/Foundation.h>

enum {
    MazeCellEdgeWall = 0,
    MazeCellEdgeGate = 1,
    MazeCellEdgeExit = 2
};
typedef NSUInteger MazeCellEdge;

@interface MazeCell : NSObject {
    MazeCellEdge left;
    MazeCellEdge right;
    MazeCellEdge down;
    MazeCellEdge up;
    NSUInteger drawCount;
    NSUInteger row;
    NSUInteger column;
}
@property MazeCellEdge left;
@property MazeCellEdge right;
@property MazeCellEdge down;
@property MazeCellEdge up;
@property NSUInteger drawCount;
@property NSUInteger row;
@property NSUInteger column;

- (id)initWithLeft:(MazeCellEdge)newLeft
             right:(MazeCellEdge)newRight
                up:(MazeCellEdge)newUp
              down:(MazeCellEdge)newDown
               row:(NSUInteger)newRow
            column:(NSUInteger)newColumn;
@end

"warning: 'MazeView' may not respond to '-left'"
MazeCellEdgeWall
#import "MazeCell.h"

@implementation MazeCell

@synthesize left;
@synthesize right;
@synthesize down;
@synthesize up;
@synthesize drawCount;
@synthesize row;
@synthesize column;

-(id) init {
    if (self = [super init]) {
        right = MazeCellEdgeWall;
        up = MazeCellEdgeWall;
        left = MazeCellEdgeWall;
        down = MazeCellEdgeWall;
        drawCount = 0;
    }
    return self;
}

- (id)initWithLeft:(MazeCellEdge)newLeft
             right:(MazeCellEdge)newRight
                up:(MazeCellEdge)newUp
              down:(MazeCellEdge)newDown
               row:(NSUInteger)newRow
            column:(NSUInteger)newColumn
{
    if (self = [super init]) {
        left = newLeft;
        right = newRight;
        up = newUp;
        down = newDown;
        drawCount = 0;
        row = newRow;
        column = newColumn;
    }
    return self;
}
@end

#import "MazeView.h"
#import "MazeCell.h"
#import "NSMutableArray+Stack.h"

#define kCellSidesSize 80.0

@implementation MazeView

@synthesize maze;
@synthesize controller;
@synthesize interfaceOrientation;

- (id)initWithFrame:(CGRect)frame {
    if (self = [super initWithFrame:frame]) {
        interfaceOrientation = UIInterfaceOrientationPortrait;
        [self setBackgroundColor:[UIColor greenColor]];
        [self setUserInteractionEnabled:YES];
        [self setMaze:[[Maze alloc] initWithSize:MazeSizeMake(4, 6)]];
    }
    return self;
}

- (void)setMaze:(Maze *)newMaze {
    maze = newMaze;
    CGRect newFrame = [self frame];
    newFrame.size = CGSizeMake([newMaze size].width * kCellSidesSize,
                               [newMaze size].height * kCellSidesSize);
    [self setFrame:newFrame];
}

- (void)setInterfaceOrientation:(UIInterfaceOrientation)newOrientation {
    if (interfaceOrientation != newOrientation) {
        interfaceOrientation = newOrientation;
        CGRect oldFrame = [self frame];
        [self setFrame:CGRectMake(oldFrame.origin.y, oldFrame.origin.x,
                                  oldFrame.size.height, oldFrame.size.width)];
        [[self superview] setContentSize:[self frame].size];
    }
}

- (void)setController:(UIViewController *)newController {
    if (controller != newController) {
        controller = newController;
    }
}

- (void)drawRect:(CGRect)rect {
    CGContextRef context = UIGraphicsGetCurrentContext();
    NSUInteger columns = [[self maze] size].width;
    NSUInteger rows = [[self maze] size].height;

    CGContextSetRGBStrokeColor(context, 1.0, 1.0, 1.0, 1.0);
    CGContextSetLineWidth(context, kCellSidesSize - 2.0);
    CGContextSetLineJoin(context, kCGLineJoinRound);
    CGContextSetLineCap(context, kCGLineCapRound);

    BOOL isDrawing = NO;
    MazeCell *aCell;
    NSMutableArray *aStack = [[NSMutableArray alloc] init];
    NSUInteger row = 0;
    NSUInteger column = 0;

    while (YES) {
        aCell = [maze getCellInRow:row andColumn:column ofOrientation:interfaceOrientation];

        if (isDrawing) {
            CGContextAddLineToPoint(context, row * kCellSidesSize + kCellSidesSize / 2.0,
                                          column * kCellSidesSize + kCellSidesSize / 2.0);
        } else {
            isDrawing = YES;
            CGContextMoveToPoint(context,  row * kCellSidesSize + kCellSidesSize / 2.0,
                                        column * kCellSidesSize + kCellSidesSize / 2.0);
        }

        if ([aCell left] == MazeCellEdgeExit && [aCell drawCount] < 1) {
            //Warnings and errors
            [aCell setDrawCount:1];  //Warning
            column--;
        } else if ([aCell right] == MazeCellEdgeExit && [aCell drawCount] < 2) {
            //Warnings and errors
            [aCell setDrawCount:2];  //Warning
            column++;
        } else if ([aCell up] == MazeCellEdgeExit && [aCell drawCount] < 3) {
            //Warnings and errors
            [aCell setDrawCount:3];  //Warning
            row--;
        } else if ([aCell down] == MazeCellEdgeExit && [aCell drawCount] < 4) {
            //Warnings and errors
            [aCell setDrawCount:4];  //Warning
            row++;
        } else if ([aStack count] > 0) {
            aCell = [aStack pop];
            row = [aCell row];       //Warning
            column = [aCell column]; //Warning
            isDrawing = NO;
        } else {
            break;
        }
    }
    CGContextStrokePath(context);
    [aStack release];
}

@end

