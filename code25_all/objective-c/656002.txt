 - (void)MoveBalloons {

    for (CurBalloon=1; CurBalloon <= NumBalloons; ++CurBalloon) {

    //check for edge hCurBalloont
    if (uBalloon[CurBalloon].pos.y > 456) {
        uBalloon[CurBalloon].pos.y = 456;
        uBalloon[CurBalloon].Vel_y = -uBalloon[CurBalloon].Vel_y;
    }
    if (uBalloon[CurBalloon].pos.y < 24) {
        uBalloon[CurBalloon].pos.y = 24;
        uBalloon[CurBalloon].Vel_y = -uBalloon[CurBalloon].Vel_y;
    }
    if (uBalloon[CurBalloon].pos.x > 289) {
        uBalloon[CurBalloon].pos.x = 289;
        uBalloon[CurBalloon].Vel_x = -uBalloon[CurBalloon].Vel_x;
    }
    if (uBalloon[CurBalloon].pos.x < 31) {
        uBalloon[CurBalloon].pos.x = 31;
        uBalloon[CurBalloon].Vel_x = -uBalloon[CurBalloon].Vel_x;
    }

    //call loop to go through the balloons for each touch.
    //[self CollisionCheck];

        NSUInteger h;
        float dist, tempvelx, tempvely, temp2velx, temp2vely;;

        for (h=1; h <= NumBalloons; ++h) {
            //check if balloon is too close
            if (CurBalloon == h) { //skip the check ifit's the same balloon
            } else {
                dist = distanceBetweenPoints(uBalloon[CurBalloon].pos, uBalloon[h].pos);
                if (dist <= (kBalloonNear)) { //balloon's touching

                    tempvelx = uBalloon[CurBalloon].Vel_x;
                    tempvely = uBalloon[CurBalloon].Vel_y;
                    temp2velx = uBalloon[h].Vel_x;
                    temp2vely = uBalloon[h].Vel_y;

                    tempvelx = (uBalloon[CurBalloon].Vel_x - uBalloon[h].Vel_x) * (sinf(angleBetweenPoints(uBalloon[CurBalloon].pos,uBalloon[h].pos)))*(uBalloon[CurBalloon].Vel_x - uBalloon[h].Vel_x) * (sinf(angleBetweenPoints(uBalloon[CurBalloon].pos,uBalloon[h].pos))) - (uBalloon[CurBalloon].Vel_y - uBalloon[h].Vel_y) * sinf(angleBetweenPoints(uBalloon[CurBalloon].pos, uBalloon[h].pos)) * cosf(angleBetweenPoints(uBalloon[CurBalloon].pos, uBalloon[h].pos)) + uBalloon[h].Vel_x;

                    tempvely = (uBalloon[CurBalloon].Vel_y - uBalloon[h].Vel_y) * (cosf(angleBetweenPoints(uBalloon[CurBalloon].pos,uBalloon[h].pos))) * (uBalloon[CurBalloon].Vel_y - uBalloon[h].Vel_y) * (cosf(angleBetweenPoints(uBalloon[CurBalloon].pos,uBalloon[h].pos))) - (uBalloon[CurBalloon].Vel_x - uBalloon[h].Vel_x) * sinf(angleBetweenPoints(uBalloon[CurBalloon].pos, uBalloon[h].pos)) * cosf(angleBetweenPoints(uBalloon[CurBalloon].pos, uBalloon[h].pos)) + uBalloon[h].Vel_y;

                    temp2velx = (uBalloon[CurBalloon].Vel_x - uBalloon[h].Vel_x) * (cosf(angleBetweenPoints(uBalloon[CurBalloon].pos,uBalloon[h].pos))) * (uBalloon[CurBalloon].Vel_x - uBalloon[h].Vel_x) * (cosf(angleBetweenPoints(uBalloon[CurBalloon].pos,uBalloon[h].pos))) + (uBalloon[CurBalloon].Vel_y - uBalloon[h].Vel_y) * sinf(angleBetweenPoints(uBalloon[CurBalloon].pos, uBalloon[h].pos)) * cosf(angleBetweenPoints(uBalloon[CurBalloon].pos, uBalloon[h].pos)) + uBalloon[h].Vel_x;

                    temp2vely = (uBalloon[CurBalloon].Vel_y - uBalloon[h].Vel_y) * (sinf(angleBetweenPoints(uBalloon[CurBalloon].pos,uBalloon[h].pos)))*(uBalloon[CurBalloon].Vel_y - uBalloon[h].Vel_y) * (sinf(angleBetweenPoints(uBalloon[CurBalloon].pos,uBalloon[h].pos))) - (uBalloon[CurBalloon].Vel_x - uBalloon[h].Vel_x) * sinf(angleBetweenPoints(uBalloon[CurBalloon].pos, uBalloon[h].pos)) * cosf(angleBetweenPoints(uBalloon[CurBalloon].pos, uBalloon[h].pos)) + uBalloon[h].Vel_y;

                    uBalloon[CurBalloon].Vel_x = tempvelx;  
                    uBalloon[CurBalloon].Vel_y = tempvely;
                    uBalloon[h].Vel_x = temp2velx;  //set to old value of CurBalloon balloon.
                    uBalloon[h].Vel_y = temp2vely;

                }
            }
        }


    if (fabsf(uBalloon[CurBalloon].Vel_x) >= kBalloonMaxSpeed) uBalloon[CurBalloon].Vel_x = kBalloonMaxSpeed;
    if (fabsf(uBalloon[CurBalloon].Vel_y) >= kBalloonMaxSpeed) uBalloon[CurBalloon].Vel_y = kBalloonMaxSpeed;
    if (fabsf(uBalloon[CurBalloon].Vel_x) <= -kBalloonMaxSpeed) uBalloon[CurBalloon].Vel_x = -kBalloonMaxSpeed;
    if (fabsf(uBalloon[CurBalloon].Vel_y) <= -kBalloonMaxSpeed) uBalloon[CurBalloon].Vel_y = -kBalloonMaxSpeed;



    if (uBalloon[CurBalloon].Vel_y > KBalloonSpeed) { //if travellCurBalloonng fast, slow CurBalloont up fast to normal speed
        uBalloon[CurBalloon].Vel_y = uBalloon[CurBalloon].Vel_y - kBalloonSlowRate;
    }
    if (uBalloon[CurBalloon].Vel_x > KBalloonSpeed) { //if travellCurBalloonng fast, slow CurBalloont up fast to normal speed
        uBalloon[CurBalloon].Vel_x = uBalloon[CurBalloon].Vel_x - kBalloonSlowRate;
    }
    if (uBalloon[CurBalloon].Vel_y < KBalloonSpeed) { //if travellCurBalloonng fast, slow CurBalloont up fast to normal speed
        uBalloon[CurBalloon].Vel_y = uBalloon[CurBalloon].Vel_y + kBalloonSlowRate;
    }
    if (uBalloon[CurBalloon].Vel_x < KBalloonSpeed) { //if travellCurBalloonng fast, slow CurBalloont up fast to normal speed
        uBalloon[CurBalloon].Vel_x = uBalloon[CurBalloon].Vel_x + kBalloonSlowRate;
    }


    //slow to 0 if velocCurBalloonty CurBalloons CurBalloonnsCurBalloonde the slow rate
    if (fabsf(uBalloon[CurBalloon].Vel_x) <= kBalloonSlowRate) uBalloon[CurBalloon].Vel_x = 0;
    if (fabsf(uBalloon[CurBalloon].Vel_y) <= kBalloonSlowRate) uBalloon[CurBalloon].Vel_y = 0;

    uBalloon[CurBalloon].Vel_x = uBalloon[CurBalloon].Vel_x - kBalloonFallRate; //keep movCurBalloonng down     

    //add velocCurBalloonty to poCurBalloonnts
    uBalloon[CurBalloon].pos.y= uBalloon[CurBalloon].pos.y + uBalloon[CurBalloon].Vel_y;    
    uBalloon[CurBalloon].pos.x = uBalloon[CurBalloon].pos.x + uBalloon[CurBalloon].Vel_x;

    }
}

 CGFloat distanceBetweenPoints (CGPoint first, CGPoint second) {
    CGFloat deltaX = second.x - first.x;
    CGFloat deltaY = second.y - first.y;
    if ((deltaX*deltaX + deltaY*deltaY ) == -1) {
        return sqrtf(-.99);
    } else {
    return sqrtf(deltaX*deltaX + deltaY*deltaY );
    }
}

    CGFloat angleBetweenPoints(CGPoint first, CGPoint second) {

    if (first.x - second.x == 0)  {
        return (pi / 2);
    } else {
        return atanf((first.y-second.y) / (first.x - second.x));
    }

}

