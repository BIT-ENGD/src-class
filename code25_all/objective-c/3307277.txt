NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);
NSString *documentsDirectory = [paths objectAtIndex:0];

NSString *path = [documentsDirectory stringByAppendingPathComponent:@"TextWandiPhone.db3"];

//for second database
NSString *path1 = [documentsDirectory stringByAppendingPathComponent:@"UserName.db3"];


// Open the database. The database was prepared outside the application.
if (sqlite3_open([path UTF8String], &database) == SQLITE_OK) 
{
    // Get the primary key for all books.
    const char *sql = "SELECT CountryName FROM Country";

    sqlite3_stmt *statement = nil;
    // Preparing a statement compiles the SQL query into a byte-code program in the SQLite library.
    // The third parameter is either the length of the SQL string or -1 to read up to the first null terminator.        
    if (sqlite3_prepare_v2(database, sql, -1, &statement, NULL) == SQLITE_OK)
    {
    //  int success=sqlite3_step(statement);
        // We "step" through the results - once for each row.
        while(sqlite3_step(statement) == SQLITE_ROW) 
        {
    //  if(success == SQLITE_ROW) {
            //NSLog(@"value of success %d",success);

            // The second parameter indicates the column index into the result set.
            char *str = (char *)sqlite3_column_text(statement, 0);
            NSString *country = (str) ? [NSString stringWithUTF8String:str] : @"";
            //NSLog(@"value :%@",country);
                            //NSLog(@"after running query");

            //NSLog(@"after initializing array");
            [arrCountry addObject:country];
            //NSLog(@"after adding values");
            //[return arrCountry];

        }//while
        //NSLog(@"values of array %@",arrCountry);
    }//aft prepare

    sqlite3_finalize(statement);
}//aft open

    //for second database
    //else if (sqlite3_open([path1 UTF8String], &database1) == SQLITE_OK) 
if (sqlite3_open([path1 UTF8String], &database1) == SQLITE_OK) 
    {

        // Get the primary key for all books.
        const char *sql1 = "SELECT UserID FROM User";

        sqlite3_stmt *statement1=nil;
        // Preparing a statement compiles the SQL query into a byte-code program in the SQLite library.
        // The third parameter is either the length of the SQL string or -1 to read up to the first null terminator.
        int value1=sqlite3_prepare_v2(database1, sql1, -1, &statement1, NULL);
        NSLog(@"value of preparing stmt %d",value1);
        if ( value1== SQLITE_OK) 
        {
            //  int success=sqlite3_step(statement);
            // We "step" through the results - once for each row.
            while(sqlite3_step(statement1) == SQLITE_ROW) 
            {
                //  if(success == SQLITE_ROW) {
            //NSLog(@"value of success %d",success);

                // The second parameter indicates the column index into the result set.
                int userid = sqlite3_column_int(statement1, 0);
                //NSString *country = (str) ? [NSString stringWithUTF8String:str] : @"";
                //NSLog(@"value :%@",country);
                //NSLog(@"after running query");

                //NSLog(@"after initializing array");

                NSString *strUserId = [[NSNumber numberWithInt:userid] stringValue];


                [arrUser addObject:strUserId];


                //[return arrCountry];
            }
        NSLog(@"values of array %@",arrUser);
        }//aft prepare

    // "Finalize" the statement - releases the resources associated with the statement.

        //sqlite3_finalize(statement1);
}//aft opening 2nd database 

else {
    // Even though the open failed, call close to properly clean up resources.
    sqlite3_close(database);
    sqlite3_close(database1);
    NSAssert1(0, @"Failed to open database with message '%s'.", sqlite3_errmsg(database));
    NSAssert1(0, @"Failed to open database with message '%s'.", sqlite3_errmsg(database1));
    // Additional error handling, as appropriate...
}

