Exception Type:  EXC_BAD_ACCESS (SIGSEGV)
Exception Codes: 0x000000000000000d, 0x0000000000000000
Crashed Thread:  21

Thread 21 Crashed:
0   libSystem.B.dylib               0x00007fff8406a446 _mdns_query_callback + 275
1   libSystem.B.dylib               0x00007fff84057fc8 handle_query_response + 296
2   libSystem.B.dylib               0x00007fff84057433 DNSServiceProcessResult + 717
3   libSystem.B.dylib               0x00007fff84069cf3 _mdns_query_mDNSResponder + 1180
4   libSystem.B.dylib               0x00007fff84069090 _mdns_search + 1458
5   libSystem.B.dylib               0x00007fff840682f1 _mdns_addrinfo + 716
6   libSystem.B.dylib               0x00007fff84067373 search_addrinfo + 146
7   libSystem.B.dylib               0x00007fff84066d9c si_addrinfo + 1352
8   libSystem.B.dylib               0x00007fff840667ad getaddrinfo + 159
9   com.NZBVortex.NZBVortex         0x000000010002a4d7 -[CFNetworkStream getHostAddress:sockAddressIn:] + 152
10  com.NZBVortex.NZBVortex         0x000000010002a622 -[CFNetworkStream openBSDSocket::] + 252

-(bool)openBSDSocket:(NSString*)hostName:(int)port {
    struct sockaddr_in remoteAddr;

    remoteAddr.sin_family = AF_INET;
    remoteAddr.sin_port = htons(port);

    if ([self getHostAddress:hostName sockAddressIn:&remoteAddr]) {
        //some non-related code
    }
}

-(bool)getHostAddress:(NSString*)hostname sockAddressIn:(struct sockaddr_in*)result {
    struct addrinfo hints, *res, *iterateRes;
    int retval;

    memset (&hints, 0, sizeof (struct addrinfo));
    hints.ai_family = PF_UNSPEC;
    hints.ai_socktype = SOCK_STREAM;
    hints.ai_flags |= AI_CANONNAME;

    int maxLength = [hostname length]+1;
    const char hostNameC[maxLength];
    struct in_addr *inAddr;
    bool foundAddress = NO;

    if (hostNameC!=NULL) {
        [hostname getCString:(void*)&hostNameC maxLength:maxLength encoding:NSASCIIStringEncoding];

        retval = getaddrinfo (hostNameC, NULL, &hints, &res);
        if (retval == 0) {

            iterateRes = res;
            while (iterateRes && !foundAddress) {
                switch (iterateRes->ai_family)
                {
                    case AF_INET:
                        inAddr = &((struct sockaddr_in *) iterateRes->ai_addr)->sin_addr;
                        memcpy(&(result->sin_addr), inAddr, sizeof(inAddr));
                        foundAddress = YES;
                }
                iterateRes = iterateRes->ai_next;
            }
        }

        freeaddrinfo (res);
    }

    return foundAddress;
}

