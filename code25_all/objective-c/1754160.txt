NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];

//Get info about the currently active application.
NSWorkspace* workspace            = [NSWorkspace sharedWorkspace];
NSDictionary* currentAppInfo      = [workspace activeApplication];

//Get the PSN of the current application.
UInt32 lowLong                    = [[currentAppInfo objectForKey:@"NSApplicationProcessSerialNumberLow"] longValue];
UInt32 highLong                   = [[currentAppInfo objectForKey:@"NSApplicationProcessSerialNumberHigh"] longValue];
ProcessSerialNumber currentAppPSN = {highLong,lowLong};

//Grab window information from the window server.
CFArrayRef windowList             = CGWindowListCopyWindowInfo(kCGWindowListOptionOnScreenOnly, kCGNullWindowID);
ProcessSerialNumber myPSN         = {kNoProcess, kNoProcess};

//Loop through the windows, the window list is ordered from front to back.
for (NSMutableDictionary* entry in (NSArray*) windowList)
{
    int pid = [[entry objectForKey:(id)kCGWindowOwnerPID] intValue];
    GetProcessForPID(pid, &myPSN);

    //If the process of the current window in the list matches our process, get the front window number.
    if(myPSN.lowLongOfPSN == currentAppPSN.lowLongOfPSN && myPSN.highLongOfPSN == currentAppPSN.highLongOfPSN)
    {
        NSNumber *windowNumber    = [entry objectForKey:(id)kCGWindowNumber];
        windowNumber = [entry objectForKey:(id)kCGWindowNumber];
        NSString* applicationName = [entry objectForKey:(id)kCGWindowOwnerName];
        NSLog(@"Capture the window: %@ with window ID: %@.",applicationName,windowNumber);
        return applicationName;

        //Break because we only want the front window.
        break;
    }
}
CFRelease(windowList);
[pool release];

