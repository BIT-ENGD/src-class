 - (id) initWithSoundFile:(NSString *)file doesLoop:(BOOL)loops
{
 self = [super init];
 if (self != nil) 
 {  
  if(![self loadSoundFile:file doesLoop:loops])
   {
   debug(@"Failed to load the sound file: %@...", file);
   [self release];
   return nil;
  }
  self.sourceFileName = file;

  //temporary sound queue
  self.temporarySounds = [NSMutableArray array];

  //default volume/pitch
  self.volume = 1.0;
  self.pitch = 1.0;  
  }
 return self;
    }

- (BOOL) play
{

 if([self isPlaying]) //see if the base source is busy...
 {
  //if so, create a new source
  NSUInteger tmpSourceID;
  alGenSources(1, &tmpSourceID);

  //attach the buffer to the source
  alSourcei(tmpSourceID, AL_BUFFER, bufferID);
  alSourcePlay(tmpSourceID);

  //add the sound id to the play queue so we can dispose of it later
  [temporarySounds addObject: [NSNumber numberWithUnsignedInteger:tmpSourceID]];

  //a "callback" for when the sound is done playing +0.1 secs
  [self performSelector:@selector(deleteTemporarySource)
   withObject:nil
   afterDelay:(duration * pitch) + 0.1];

  return ((error = alGetError()) != AL_NO_ERROR);
 }

 //if the base source isn't busy, just use that one...

 alSourcePlay(sourceID);
 return ((error = alGetError()) != AL_NO_ERROR);
    }

- (void) setVolume:(ALfloat)newVolume
{
 volume = MAX(MIN(newVolume, 1.0f), 0.0f); //cap to 0-1
 alSourcef(sourceID, AL_GAIN, volume); 

 //now set the volume for any temporary sounds...

 for(NSNumber *tmpSourceID in temporarySounds)
 {
  //tmpSourceID is the source ID for the temporary sound
  alSourcef([tmpSourceID unsignedIntegerValue], AL_GAIN, volume);
 }
   } 

