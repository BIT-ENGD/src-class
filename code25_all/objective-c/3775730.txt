- (void)applicationDidEnterBackground:(UIApplication *)application {
    /*
     Use this method to release shared resources, save user data, invalidate timers, and store enough application state information to restore your application to its current state in case it is terminated later. 
     If your application supports background execution, called instead of applicationWillTerminate: when the user quits.
     */


 UIApplication*    app = [UIApplication sharedApplication];

    // Request permission to run in the background. Provide an
    // expiration handler in case the task runs long.
    NSAssert(bgTask == UIBackgroundTaskInvalid, nil);

    bgTask = [app beginBackgroundTaskWithExpirationHandler:^{
        // Synchronize the cleanup call on the main thread in case
        // the task actually finishes at around the same time.
        dispatch_async(dispatch_get_main_queue(), ^{

            if (bgTask != UIBackgroundTaskInvalid)
            {
                [app endBackgroundTask:bgTask];
                bgTask = UIBackgroundTaskInvalid;
            }
        });
    }];

    // Start the long-running task and return immediately.

    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{

        // Do the work associated with the task.

  locmanager = [[CLLocationManager alloc] init];
  [locmanager setDelegate:self];
  [locmanager setDesiredAccuracy:kCLLocationAccuracyBest];
  locmanager.distanceFilter = 20;
  [locmanager startUpdatingLocation];

  NSLog(@"App staus: applicationDidEnterBackground");
        // Synchronize the cleanup call on the main thread in case
        // the expiration handler is fired at the same time.
        dispatch_async(dispatch_get_main_queue(), ^{
            if (bgTask != UIBackgroundTaskInvalid)
            {
                [app endBackgroundTask:bgTask];
                bgTask = UIBackgroundTaskInvalid; 
            }
        });  
    });
 NSLog(@"backgroundTimeRemaining: %f", [[UIApplication sharedApplication] backgroundTimeRemaining]);
}

and

- (void)locationManager:(CLLocationManager *)manager didUpdateToLocation:(CLLocation *)newLocation fromLocation:(CLLocation *)oldLocation
{ 
 // Log the kind of accuracy we got from this
 NSLog(@"Accuracy-------- %f %f", [newLocation horizontalAccuracy], [newLocation verticalAccuracy]);

 CLLocationCoordinate2D loc = [newLocation coordinate];
 userCurrentLocation = newLocation;
 lat = loc.latitude;
 lon = loc.longitude;

 UILocalNotification *localNotif = [[UILocalNotification alloc] init];
    if (localNotif == nil)
        return;
 NSDate *now = [NSDate dateWithTimeIntervalSinceNow:10]; 

 NSLog(@"Now is %@",now); 

 localNotif.fireDate = now;

    localNotif.timeZone = [NSTimeZone defaultTimeZone];

 // Notification details
    localNotif.alertBody = [NSString stringWithFormat:@"Latitude = %f, Longitude = %f", lat, lon];
 // Set the action button
    localNotif.alertAction = @"View";

    localNotif.soundName = UILocalNotificationDefaultSoundName;
    localNotif.applicationIconBadgeNumber = 1;

 // Specify custom data for the notification
    NSDictionary *infoDict = [NSDictionary dictionaryWithObject:@"someValue" forKey:@"someKey"];
    localNotif.userInfo = infoDict;

 // Schedule the notification
    [[UIApplication sharedApplication] scheduleLocalNotification:localNotif];
    [localNotif release];

}

