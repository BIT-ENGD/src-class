sqlite3_stmt *statement;
NSMutableArray *foo_IDs = [[NSMutableArray alloc] init];
NSMutableArray *foo_Names = [[NSMutableArray alloc] init];
NSMutableArray *foo_IDsBySection = [[NSMutableArray alloc] init];
NSMutableArray *foo_NamesBySection = [[NSMutableArray alloc] init];

// Get data:
NSString *sql = @"select distinct p.foo_ID, p.foo_Name from foo as p ";
if (sqlite3_prepare_v2(...) == SQLITE_OK) {
    while (sqlite3_step(statement) == SQLITE_ROW) {
        int p_id;
        NSString *foo_Name;

        p_id = sqlite3_column_int(statement, 0);
        char *str2 = (char *)sqlite3_column_text(statement, 1);
        foo_Name = [NSString stringWithCString:str2];

        [foo_IDs addObject:[NSNumber numberWithInt:p_id]];
        [foo_Names addObject:foo_Name];
    }
    sqlite3_finalize(statement);
}

// Pass the array itself into another array:
// (normally there is more than one array in each array)
[foo_IDsBySection addObject: foo_IDs];
[foo_NamesBySection addObject: foo_Names];

[foo_IDs release];
[foo_Names release];

// Set some synthesized properties (of type NSArray, nonatomic, 
// retain) in controller:
controller.foo_IDsBySection = foo_IDsBySection;
controller.foo_NamesBySection = foo_NamesBySection;

[foo_IDsBySection release];
[foo_NamesBySection release];

