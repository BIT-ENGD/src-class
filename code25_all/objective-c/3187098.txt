#import <Foundation/Foundation.h>
#include <sqlite3.h>


@interface DataServices : NSObject {
    sqlite3 *db;
    int dbrc;
}

- (NSMutableArray *) recipeNames;

@end

#import "DataServices.h"
#import "MenuMakerAppDelegate.h"
#include <sqlite3.h>

@implementation DataServices

- (id)init {
    [super init];

    // my init stuff here

    // Get the database name
    const char *dbPathUtf8 = [((MenuMakerAppDelegate*)[UIApplication sharedApplication].delegate).dbFilePath UTF8String];
    // Open the database
    NSLog(@"opening db");
    sqlite3_open (dbPathUtf8, &db);
    NSLog(@"opened db");

    return self;
}

- (void)dealloc {
    // My dealloc stuff here
    NSLog(@"Closing DB");
    sqlite3_close(db);
    [super dealloc];
}

- (NSMutableArray *) recipeNames {
    // Create the empty array to return
    NSMutableArray *arr = [[[NSMutableArray alloc] init] autorelease];
    // The SQL
    NSString *sql = @"select recipe from recipes";
    const char *sqlUtf8 = [sql UTF8String];
    // Make the prepared statement (like C# SqlCommand)
    sqlite3_stmt *dbps;
    dbrc=sqlite3_prepare_v2(db, sqlUtf8, -1, &dbps, NULL); // FAILS HERE !!!
    if (dbrc) NSLog(@"Prepare!!! %d", dbrc);
    // Loop thru rows
    while (sqlite3_step(dbps) == SQLITE_ROW) {
        NSString *recipe = [NSString stringWithUTF8String:(char*)sqlite3_column_text(dbps,0)];
        [arr addObject:recipe];
    }
    // Get rid of the command
    sqlite3_finalize(dbps);
    // Return the array that was autoreleased before
    return arr;
}

@end

