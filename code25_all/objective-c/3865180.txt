NSString* fileName = [[self  
 documentsPath]stringByAppendingPathComponent:@"soundfile.caf"];

-(AudioFileID)openAudioFile:(NSString*)filePath
{
NSLog(@"openAudioFile");
AudioFileID outAFID;
// use the NSURl instead of a cfurlref cuz it is easier
NSURL * afUrl = [NSURL fileURLWithPath:filePath];
OSStatus result = AudioFileOpenURL((CFURLRef)afUrl, kAudioFileReadPermission, 0,  
 &outAFID); 
if (result != 0) NSLog(@"cannot open file: %@",filePath);
return outAFID;
}

-(UInt32)audioFileSize:(AudioFileID)fileDescriptor
{
NSLog(@"audioFileSize");
UInt64 outDataSize = 0;
UInt32 thePropSize = sizeof(UInt64);
OSStatus result = AudioFileGetProperty(fileDescriptor, 
    kAudioFilePropertyAudioDataByteCount, &thePropSize, &outDataSize);
if(result != 0) NSLog(@"cannot find file size");
return (UInt32)outDataSize;
}

- (NSError*) createAVAudioRecorder 
{
NSLog(@"creatAVAudioRecorder");

[audioRecorder release];
audioRecorder = nil;

NSString *destinationString = [[self 
documentsPath]stringByAppendingPathComponent:@"soundfile.caf"];

NSURL *destinationURL = [NSURL fileURLWithPath: destinationString];

NSMutableDictionary *recordSettings =[[NSMutableDictionary alloc] 
initWithCapacity:10];

[recordSettings setObject:[NSNumber numberWithInt: kAudioFormatLinearPCM] forKey: 
AVFormatIDKey];
float sampleRate = 44100; // 22050
[recordSettings setObject:[NSNumber numberWithFloat:sampleRate] forKey: 
AVSampleRateKey];
int NumChannels = 2; //stero or mono
[recordSettings setObject:[NSNumber 
numberWithInt:NumChannels]forKey:AVNumberOfChannelsKey];
int bitDepth = 16;
[recordSettings setObject:[NSNumber numberWithInt:bitDepth] 
forKey:AVLinearPCMBitDepthKey];
bool bigEndian = NO;
[recordSettings setObject:[NSNumber 
numberWithBool:bigEndian]forKey:AVLinearPCMIsBigEndianKey];
bool floatingSamples = NO;
[recordSettings setObject:[NSNumber 
numberWithBool:floatingSamples]forKey:AVLinearPCMIsFloatKey];


NSError *recorderSetupError = nil;
audioRecorder = [[AVAudioRecorder alloc] initWithURL:destinationURL 
settings:recordSettings error:&recorderSetupError]; 
[recordSettings release];

if (recorderSetupError) 
{
    NSLog(@"Record Setup Error");
    UIAlertView *cantRecordAlert = [[UIAlertView alloc] initWithTitle: @"Can't 
 record" message: [recorderSetupError localizedDescription]delegate: nil 
 cancelButtonTitle:@"OK" otherButtonTitles:nil];
    [cantRecordAlert show];
    [cantRecordAlert release];
    return recorderSetupError;
}
[audioRecorder prepareToRecord];

audioRecorder.delegate = self;

return recorderSetupError;
}

-(IBAction) startRecording
{
[self createAVAudioRecorder ];
if (! [self alertIfNoAudioInput]) 
    return;
[audioRecorder record];
}
-(IBAction) stopRecording
{
NSLog(@"stopRecording Method");
[audioRecorder stop];

