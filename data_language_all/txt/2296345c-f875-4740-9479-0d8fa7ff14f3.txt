Message-passing
Os processos podem comunicar entre si usando mensagens. 

Não existe a necessidade de possuírem memória partilhada
Mecanismos válidos quer para sistemas uniprocessor quer para sistemas multiprocessador

A comunicação é efetuada através de duas operações:

send
receive

Requer a existência de um canal de comunicação. Existem 3 implementações possíveis:

Endereçamento direto/indireto
Comunicação síncrona/assíncrona
Só o sender é que indica o destinatário
O destinatário não indica o sender
Quando existem caixas partilhadas, normalmente usam-se mecanismos com políticas de round-robin
Lê o processo $N$
Lê o processo $N+1$
etc...


No entanto, outros métodos podem ser usados


Automatic or explicit buffering

Direct vs Indirect
Symmetric direct communication
O processo que pretende comunicar deve explicitar o nome do destinatário/remetente:

Quando o sender envia uma mensagem tem de indicar o destinatário
send(P, message


O destinatário tem de indicar de quem quer receber (sender)
receive(P, message)



A comunicação entre os dois processos envolvidos é peer-to-peer, e é estabelecida automaticamente entre entre um conjunto de processos comunicantes, só existindo um canal de comunicação
Asymmetric direct communications
Só o sender tem de explicitar o destinatário:

send(P, message: 
receive(id, message): receive mensagens de qualquer processo

Comunicação Indireta
As mensagens são enviadas para uma mailbox (caixa de mensagens) ou ports, e o receiver vai buscar as mensagens a uma poll

send(M, message
receive(M, message)

O canal de comunicação possui as seguintes propriedades:

Só é estabelecido se o par de processos comunicantes possui uma mailbox partilhada
Pode estar associado a mais do que dois processos
Entre um par de processos pode existir mais do que um link (uma mailbox por cada processo)

Questões que se levantam. Se mais do que um processo tentar receber uma mensagem da mesma mailbox...

... é permitido?
Se sim. qual dos processos deve ser bem sucedido em ler a mensagem?



Implementação
Existem várias opções para implementar o send e receive, que podem ser combinadas entre si:

blocking send: o sender envia a mensagem e fica bloqueado até a mensagem ser entregue ao processo ou mailbox destinatária
nonblocking send: o sender após enviar a mensagem, continua a sua execução
blocking receive: o receiver bloqueia-se até estar disponível uma mensagem para si
nonblocking receiver: o receiver devolve a uma mensagem válida quando tiver ou uma indicação de que não existe uma mensagem válida quando não tiver

Buffering
O link pode usar várias políticas de implementação:

Zero Capacity: 
Não existe uma queue
O sender só pode enviar uma mensagem de cada vez. e o envio é bloqueante
O receiver lê uma mensagem de cada vez, podendo ser bloqueante ou não


Bounded Capacity:
A queue possui uma capacidade finita
Quando está cheia, o sender bloqueia o envio até possuir espaço disponível


Unbounded Capacity:
A queue possui uma capacidade (potencialmente) infinita
Tanto o sender como o receiver podem ser não bloqueantes



Bound-Buffer Problem usando mensagens

Message Passing in Unix/Linux
System V:

Existe uma fila de mensagens de diferentes tipos, representados por um inteiro
send bloqueante se não existir espaço disponível
A recepção possui um argumento para especificar o tipo de mensagem a receber:
Um tipo específico
Qualquer tipo
Um conjunto de tipos


Qualquer que seja a política de recepção de mensagens:
É sempre obtida a mensagem mais antiga de uma dado tipo(s)
A implementação do receive pode ser blocking ou nonblocking


System calls:
msgget
msgsnd
msgrcv
msgctl



POSIX

Existe uma priority queue
send bloqueante se não existir espaço disponível
receive obtêm a mensagem mais antiga com a maior prioridade
Pode ser blocking ou nonblocking


Funções:
mq_open
mq_send
mq_receive


