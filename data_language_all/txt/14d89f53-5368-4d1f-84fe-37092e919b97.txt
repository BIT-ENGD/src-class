Niedzielski C++ Course Lesson Summaries
Instructor:  Patrick M. Niedzielski patrick@pniedzielski.net
Unit 1 -- Introduction


1. Introduction: Goals for the course and logistics


2. What is C++?: A high-level view of the language, its
    design, and the designs it pushes you towards.  C++ gives you two
    tools: the ability to write code that is efficient and performs
    well, while at the same time building abstractions so you don't
    always have to think about that.  The four primary tools we have
    to build abstractions in C++ are functions, types,
    templates, and concepts.


3. Setting up a Development Environment: Looks at the C++
    compiler toolchain, as well as other useful tooling for
    development.  Then, gives two Hello, World! programs, shows how to
    compile them, and discusses their differences.


4. C++ Crash Course 1: Shows the basics of C++ code, without
    any abstraction.  The features presented here are all you need to
    write any program, but doing so is difficult.  Covers language
    control flow features, operators, compound data types, variables,
    literals, and namespaces.


5. C++ Crash Course 2: Introduces free functions in C++ and
    three abstractions from Boost that students may find useful.


6. C++ Crash Course 3: Shows how to build type abstractions
    using structs, type aliases, member functions, and access
    control.  Finally, briefly introduces references, with a note on
    efficiency.


7. C++ Crash Course 4: Motivates and explains function and
    type templates, with type and non-type template parameters.  Looks
    at specialization of templates based on types, and how this is
    similar to pattern matching.  Then, looks at concepts and how
    C++17 partially expresses them in the language.  This leads us
    into the ideas of generic programming and will shape the way we
    design software for the rest of this course.  Finally, hints at
    how templates enable type-level metaprogramming.


8. Stack Memory, Heap Memory, Lifetimes, and Moving: Explains
    the difference between the stack and the heap, shows how to
    allocate memory on the heap, covers lifetimes and then RAII, and
    introduces C++ move semantics.  We will introduce C++ lambda
    expressions.


Unit 2 -- Building Abstractions


9. Correct Software: We will look at ways to reason about our
    software's correctness, as well as ways to show it is correct.  We
    will look at runtime testing, static analysis, and dynamic
    analysis.  We will look at how to design software so it is easy to
    understand (and thus easy to show correct), and how to design
    software so it is easy to write tests for.  We will briefly
    mention TDD and various test programs.  Finally, we will look at
    the benefits that each way bring, both from a correctness
    standpoint and a maintainability standpoint.


8. The Standard Template Library: With basic knowledge of
    generic programming from the last unit, we look at a real library
    that is designed on this principle.  We focus on sequence
    containers and the standard algorithms, and use them to introduce
    the concepts of Iterators.  Then, we will write our own
    STL-compatible conservative_vector data structure and reason
    about its performance and efficiency.


9. Coupling and Cohesion: We used these two ideas without
    knowing it in the last lesson to give us the iterator abstraction
    that glues together containers and algorithms.  We will start to
    look at how we can use the principle of minimizing coupling and
    maximizing cohesion to design better software.


10. Value Types, Equality, and Identity


11. Documentation


12. Encapsulation, Invariants, Classes, and Open Abstractions


13. Designing Interfaces


14. Designing Systems


15. Case study: iostreams


16. Customization Dimensions


17. Object-Oriented Programming


18. Code Formatting


19. Functional Programming


20. Algebraic Structures


21. Concepts: We will compile the latest version of GCC which
    has language support for expressing constraints.  We will look at
    the previous version of concepts, Concepts C++0x, which didn't
    get voted in.  We will also compare concepts with Haskell
    typeclasses and Java interfaces and look at their similarities and
    differences.  Finally, we will look at Andrei Alexandrescu's
    recent talk on concepts, and look at how the C++ language
    addresses this, and how it may shape our designs.


22. Design Patterns


23. Type Erasure

