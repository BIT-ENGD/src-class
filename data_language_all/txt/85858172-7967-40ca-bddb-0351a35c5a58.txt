Creating a binary from Julia code
This section targets how to build an executable based on the custom sysimage so
that it can be run without having to explicitly start a Julia session.
Interacting with Julia through libjulia.
The way to interact with Julia without using the Julia executable itself is by
calling into the Julia runtime library (libjulia) from a C program.  A quite
detail set of docs for how this is done can be found at the embedding chapter
in the Julia manual and it
is recommended to read before reading on.  Since this is supposed to highlight
the interals of PackageCompilerX, will not use the conveniences shown in that
section (e.g. the julia-config.jl script) but it is good to know they exist.
A rough outline of the steps we will take to create an executable are:

Create our Julia app with a Base.@ccallable entry-point which means the Julia
  function can be called directly from C.
Create a custom sysimage to reduce latency (this is pretty much just doing
  part 1) and to hold the C-callable function from the first step.
Write an embedding wrapper in C that loads our custom sysimage, does some
  initialization and calls the entry point in the script.

A toy application
To have something concrete to work with we will create a very simple
application.  Keeping with the spirit of CSV parsing, we will create a small
app that parses a list of CSV files given as arguments to the app and prints
the size of the parsed result. The code for the app (MyApp.jl) is shown
below:

The function julia_main has been annotated with Base.@ccallable which means
that a function with the unmangled name will appear in the sysimage. This
function is just a small wrapper function that calls out to real_main which
does the actual work.  All the code that is executed is put inside a try-catch
block since the error will otherwise happen in the C-code where the backtrace
is not very good
To facilitate testing, we check if the file was directly
executed
and in that case, run the main function.  We can test (and time) the script on
the sample CSV file from the first tutorial
❯ time julia MyApp.jl FL_insurance_sample.csv
FL_insurance_sample.csv: 36634x18
julia MyApp.jl FL_insurance_sample.csv  12.51s user 0.38s system 104% cpu 12.385 total
Create the sysimage
As in the previous tutorial, we do a "sample run" of our app to record what
functions end up getting compiled.  Here, we simply run the app on the sample
CSV file since that should give good "coverage":
julia --startup-file=no --trace-compile=app_precompile.jl MyApp.jl "FL_insurance_sample.csv"
The create_sysimage.jl script look similar to before with the exception that
we added an include of the app file inside the anonymous module where the
precompiliation statements are evaluated in:

The sysimage is then created as before:

Windows-specific flags
For Windows we need to tell the linker to export all symbols via the flag -Wl,--export-all-symbols.
Otherwise, the linker will fail to find julia_main when we build the executable.
Creating the executable
Embedding code
The embedding script is the "driver" of the app. It initializes the julia
runtime, does some other initialization, calls into our julia_main and then
does some cleanup when it returns.  We can borrow a lot for this embedding
script from the embedding manual there are however some things we ne
ed to set up
"manually" that Julia usually does by itself when starting Julia.  This
includes assigning the PROGRAM_FILE variable as well as updating Base.ARGS
to contain the correct values. The script MyApp.c ends up looking like:

Building the executable
We now have all the pieces needed to build the executable; a sysimage and a driver script.
It is compiled as:
❯ gcc -DJULIAC_PROGRAM_LIBNAME=\"sys.so\" -o MyApp MyApp.c sys.so -O2 -fPIE \
    -I'/home/kc/julia/include/julia' \
    -L'/home/kc/julia/lib' \
    -ljulia \
    -Wl,-rpath,'/home/kc/julia/lib:$ORIGIN'
where we have added an rpath entry into the executable so that the julia
library can be found at runtime as well as the sys.so library ($ORIGIN means
to look in the same folder as the binary for shared libraries).

macOS considerations
On macOS, instead of $ORIGIN for the rpath, use @executable_path.
Windows considerations
On Windows, it is recommended to increase the size of the stack from the
default 1 MB to 8MB which can be done by passing the -Wl,--stack,8388608
flag.  Windows doesn't have (at least in an as simple way as Linux and macOS)
the concept of rpath.  The goto solution is to either set the PATH
environment variable to the Julia bin folder or alternatively copy paste all
the libraries in the Julia bin folder so they sit next to the executable.