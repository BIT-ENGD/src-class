Defining Operators as Functions

Mathematically, one can represent an operator Ô with the following definitions:

QuDirac allows us to define normal Julia functions that act like Ô using 
the @def_op macro:

Action of the operator's dual on Bras is well-defined by the definition of 
the operator on Kets, since < 1 | * Ô' == ( Ô * | 1 > )':
julia> d" < 2 | * a' "
Bra{KroneckerDelta,1,Float64} with 1 state(s):
  1.4142135623730951 ⟨ 1 |
To act the operator on a Bra (or its dual on a Ket), we need to define its action on the Bra:

The @def_op macro works for product bases as well:

For an example of an operator that throws its basis Kets into superpositions, 
here's a function emulating a Hadamard operator:


Grammar for the Definition String

The grammar of the string passed to @def_op is:


Defining action on Kets:
@def_op " $op_name | $label_args > = f($label_args...) "

where f is an arbitrary expanded function that takes in the $label_args and
  returns a Ket.


Defining action on Bras:
@def_op " < $label_args | $op_name  = f($label_args...) "

where f is an arbitrary expanded function that takes in the $label_args and
  returns a Bra.


Allowable syntax for the right-hand side of the equation
is exactly the same syntax allowed by d"...".

Generating Operator Representations

The operator-functions described in the previous example are no doubt useful, 
but they are just normal Julia functions, and so are quite limited when it comes 
to mimicking the behavior of actual quantum operators. For example, they can't 
be added or be factors of a tensor product (this functionality may indeed be implemented
in the future, however).
For those capabilities, we'll need to generate an OpSum representation in a basis. To do so, 
we can use the @rep_op macro. Here's a familiar example:

The @rep_op macro takes in a definition string, and an iterable of items to be used as basis labels.
The grammar and allowable syntax of the definition string is exactly that of the definition string passed 
to @def_op. The only difference between the two is that the @rep_op macro feeds in the given basis labels
to produce an OpSum.
To generate a representation on a product basis, one can provide multiple iterables to @rep_op.
Their cartesian product will then be used as the basis for the representation: 

Let's say I already have an operator-function defined, and want
to represent it in a basis. For example, take the Hadamard operator-function 
h, constructed in the previous section as:
julia
julia> @def_op " h | n > = 1/√2 * ( | 0 > + (-1)^n *| 1 > )"
h (generic function with 1 methods)
I can easily generate a representation for this function by using @rep_op and 
calling h on the right-hand side:
julia
julia> @rep_op " H | n > = h * | n > " 0:1
OpSum{KroneckerDelta,1,Float64} with 4 operator(s):
  0.7071067811865475 | 1 ⟩⟨ 0 |
  0.7071067811865475 | 0 ⟩⟨ 0 |
  0.7071067811865475 | 0 ⟩⟨ 1 |
  -0.7071067811865475 | 1 ⟩⟨ 1 |
The above strategy works to represent any operator-function. Just be aware that
the function and the actual representation need to have unique names:
julia
julia> @rep_op " h | n > = h * | n > " 0:1
ERROR: invalid redefinition of constant h
 in anonymous at no file:70