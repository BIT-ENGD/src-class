Generics

Generic type parameters are abstract stand-ins for concrete types.
Generics encompass:
generic type parameters
bounds
lifetimes
When we call the generic function, the code actually runs on the concrete 
  values that we pass in; generic types are locked into concrete types.
Generics have both input and output types: type parameters stand in for input types and associated types stand in for output types. Input types are specified with generic type parameters and output types are specified using associated types.

Generics
Generic coding is a tool used to minimize the amount of code and its duplication by generalizing types and functionalities to broader cases.
We can express properties of generics, such as their behavior or how they relate to other generics, without needing to know what will actually be in their place.
Being generic requires taking great care to specify over which types a generic type is actually considered valid. Most common use of generics is for Generic Type Parameters (GTP).
"Generic" also refers to anything that accepts generic type parameters (generic function, generic trait, etc.).
Items that can be generic:
- types (generic type parameters)
- functions
- impl blocks
- traits
- enums
- structs
- type aliases
Generic Type Parameter
A type parameter is specified as generic by declaring it before using it. It is declared inside the angle brackets: <A, B, ...>.
More commonly used name for GTP is T, even though the name can be any identifier, using "PascalCase" letter case style (like all the others non-primitive type names).
If a function accepts any type, it declares a GTP:
rust
fn foo<T>(param: T) { println!("nevermind"); }
The problem is, there is nothing to do with value of such (any) type inside the finction, so in order to group types by common behaviours or capabilities we must constrain them by using bounds.
If a name is first declared in angle-brackets, that name is considered as generic type when used, even if there is a concrete type by the same name:

Bounds
If the value of the input type is to be printed, then a function must specify type constraints by declaring that it accepts any type as long as its value is printable (i.e. that the type implements Display trait). This is called a type bound:
rust
fn foo<T: Display>(param: T) { println!("{}"); }
Structs

Enums
rust
// GTP must be declared first in angle brackets,
// AFTER the enum's name
enum Maybe<T> {
  Some: T,
  Nothing,
}
Functions
rust
// GTP must be declared first in angle brackets,
// AFTER the function's name
fn foo<T: Display>(param: T) { println!("{}"); }
Implementations

Traits
rust
// GTP must be declared first in angle brackets,
// AFTER the trait's name
trait Documentable<T> {}