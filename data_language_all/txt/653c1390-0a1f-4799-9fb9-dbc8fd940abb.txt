API
In this API docs, a resolver, resolver function, or ResolverFunction all refer to a function with the same signature as described on this documentation.
Contents

Utilities
combineResolvers()
pipeResolvers()
Field dependencies
isDependee()
resolveDependee()
resolveDependees()
example

Utilities
Generic resolver composition helpers.
combineResolvers()
js
combineResolvers(
  ...resolvers: Array<ResolverFunction>
): ResolverFunction
Combines resolver functions into one resolver in a first-result-returns manner: all resolvers will be called sequentially with the same initial arguments until one resolves to something other than undefined; when that happens, the resolved value will be returned and the remaining resolver functions will be ignored.
Useful for things like authorization and access control.
Sample:


pipeResolvers()
js
pipeResolvers(
  ...resolvers: Array<ResolverFunction>
): ResolverFunction
Combines resolver functions into one resolver in a piping manner: all resolvers will be called sequentially with the first argument (root) being the result of the previous resolver, and the rest being the initial provided argument. The last resolved value will be returned.

This is usually something that gets done using GraphQL nesting nature. Sometimes, though, you simply want to reuse logic for things that should not be available on your GraphQL API.

Sample:


allResolvers()
js
allResolvers(
  resolvers: Array<ResolverFunction>
): ResolverFunction
Combines a resolver array into one resolver that will resolve all in parallel and return and array of resolved values.

Field dependency tools
GraphQL currently does not support a field to depend on the resolved result of another field. For these situations, graphql-resolvers provides a suit of methods to allow for execution based field dependencies.
resolveDependee()
js
resolveDependee(
  dependeeName: string
): ResolverFunction
Factory for a resolver which would resolve a sibling field's value. If dependeeName field is not a Scalar, it will run it's resolver function.
resolveDependees()
js
resolveDependee(
  dependeeNames: Array<string>
): ResolverFunction
Same as resolveDependees, but resolves an array of dependees.
isDependee()
js
resolveDependee(
  resolver: ResolverFunction
): ResolverFunction
Wraps a resolver to identify it as being the resolver of a possible dependee field.
Even though this is not mandatory, it will help prevent a resolver to be executed more then once when using the field dependency system.
Field dependency example
Having a schema such as...

...where winningChoice field depends on the computed value of it's sibling field votes, you could write your resolvers as follows:
