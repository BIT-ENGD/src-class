UROSBridge
Connection and disconnection
UROSBridge could be used in Unreal Actors or in timers. To use it in actors, we need to add a smart pointer to ROSBridgeHandler first:

In Actor's BeginPlay() function, create handler instance and connect to the websocket server:

In Actor's Tick(float) function, add Handler->Process() function to let handler process incoming messages in the message queue.

In Actor's Logout or EndPlay function, add Handler->Disconnect() function before the parent class ends.

Publish Message
To publish message to a topic, we need to first advertise the topic in ROS bridge. In AROSActor's class definition, Add a ROSBridgePublisher smart pointer.

In AROSActor's BeginPlay() function, create the publisher using its type and topic, and then register it to the ROSBridgeHandler.

Subscribe to Topics
This plugin uses FROSBridgeSubscriber class interface to subscribe to topics. We need to extend a FROSBridgeSubscriber subclass for each topic we would like to subscribe to, implementing the constructor, destructor, ParseMessage function and Callback function.
Include Messages
In class header, the UROSBridge Message class header should be included. Then, define a 'Subscriber' subclass you will use to receive the topic messages.

Constructor
In class constructor, we need to call the parent class constructor to set type and topic for this subscriber.
cpp
FROSStringSubScriber::FROSStringSubScriber(const FString& InTopic):
    FROSBridgeSubscriber(InTopic, TEXT("std_msgs/String"))
    {      
    }
Destructor
Class destructors will be required if you need to do some cleaning work after the ROS bridge client disconnects.
FROSStringSubScriber::~FROSStringSubScriber()
{
};
ParseMessage
ParseMessage function is used by ROSBridgeHandler to convert a JSONObject to FROSBridgeMsg instance. Create a ROSBridgeMessage class with specified message type (e.g. std_msgs::String) and call its FromJson method to parse the JSON message. Finally convert the pointer to a FROSBridgeMsg pointer.
cpp
TSharedPtr<FROSBridgeMsg> FROSStringSubScriber::ParseMessage
(TSharedPtr<FJsonObject> JsonObject) const
{
    TSharedPtr<std_msgs::String> StringMessage =
        MakeShareable<std_msgs::String>(new std_msgs::String());        
    StringMessage->FromJson(JsonObject);
    return StaticCastSharedPtr<FROSBridgeMsg>(StringMessage);
}
Callback
Callback is the callback function called when a new message comes and is successfully parsed to a ROSBridgeMsg instance. In this function, we need to first down-cast the FROSBridgeMsg pointer to a pointer of its subclass.

In Unreal Actor
In Unreal Actors we need to add pointer to subscriber to the subscriber list

A note on ROSBridgeHandler
Connections to ROSBridge work via a ROSBridgeHandler object.
There should only be one of these in your project.
If you have multiple actors that need to connect to ROS, a good pattern is to create a custom GameInstance, and store the ROSBridgeHandler object there as a public member.
Your actors can then access the ROSBridgeHandler by calling e.g. this->GetGameInstance().Handler
When the ROS Bridge Handler disconnects to server, it automatically destroys all subscriber instances.
Request Service
A service consists of two parts: Request and Response. Clients send out requests, and then get response from server. Servers process received requests and send out response.
To send service requests in UROSBridge, we need to create a service client class first. This class should extend the FROSBridgeSrvClient and implement the constructor and a callback function. Below is an example of service "AddTwoInts" client.  

Then in ROSActor, we can send service requests using the following function:

Notice: The CallService is not a blocking function, i.e. it will not block the main actor thread to wait for service response but it will call the callback function once it receives the response in following ticks.
Send Response to Service Requests
The plugin can also works as a "server" side who receives ros service requests from and returns response to the clients.
To process service requests in UROSBridge, we need to create a service server class first. This class should extend the FROSBridgeSrvServer and implement the constructor, FromJson, and CallBack function. It is very similar to ROS Bridge Subscriber classes but the only difference is that the return type of CallBack is TSharedPtr<FROSBridgeSrv::SrvResponse> rather than void. Below is an example of service AddTwoInts server.

In Actor, register the server to ROS bridge, then it will process incoming service requests automatically. After disconnection, the server will be automatically destroyed.

Add More Message / Service Types
This plugin already has support for std_msgs, geometry_msgs, std_srvs, etc. but sometimes other types of message / service will be required. We can add new message classes to the plugin or directly to the project source folder.   
Message / Topic
Messages should extend the FROSBridgeMsg class, and implement the following functions:

Constructor & Destructor
void FromJson(TSharedPtr<FJsonObject> JsonObject)
set all the properties from the JsonObject
For numbers, use JsonObject->GetNumberField(FieldName)
For strings, use JsonObject->GetStringField(FieldName)
For other message types or ros time, use ClassType::GetFromJson(JsonObject->GetObjectField(FieldName)) 
For array, first get JsonValue array using TArray<TSharedPtr<FJsonValue>> PointsPtrArray = JsonObject->GetArrayField(TEXT("points")), then for each element Ptr in the array, call Ptr->AsObject(), Ptr->AsNumber() or Ptr->AsString() function to get its value.
It is recommended to always do type checking using Unreal check(...) macro


static CLASS_NAME GetFromJson(TSharedPtr<FJsonObject> JsonObject)
the static version of FromJson()
Create a new message class and use FromJson(JsonObject) to set its properties


virtual FString ToString () const
Create a string with all of the properties of this class for printing.


virtual TSharedPtr<FJsonObject> ToJsonObject() const
Create an FJsonObject and save all of the properties of this message instance to the JsonObject.
For numbers, use JsonObject->SetNumberField(FieldName, Value)
For strings, use JsonObject->SetStringField(FieldName, Value)
For other message types or ros time, use JsonObject->SetObjectField(FieldName, Field.ToJsonObject()) 
For arrays, we first create a JsonValue array using TArray<TSharedPtr<FJsonValue>> PtrArray, then add shared pointer to new created FJsonValueObject / FJsonValueNumber / FJsonValueString to the array, and finally set the field value to this array using Object->SetArrayField(FieldName, PtrArray);



There are several good examples to follow when writing message classes. geometry_msgs/Vector3 is a message class with only built-in types; geometry_msgs/Accel is a message class which includes other messages; geometry_msgs/Polygon is a message class with arrays.
Services
Services consists of two parts, request and response, each of which is a ROS message class. In the plugin,  for each service we define a class extending to the FROSBridgeSrv base class, inside which we define Request and Response classes respectively extending to the SrvRequest and SrvResponse class. Like messages, in each class we need to implement FromJson, ToString, ToJsonObject and static GetFromJson method functions.