- Copyright (C) 2009-2013 Typesafe Inc. <http://www.typesafe.com> 
Testing your application with specs2
Writing tests for your application can be an involved process.  Play provides a default test framework for you, and provides helpers and application stubs to make testing your application as easy as possible.
Overview
The location for tests is in the "test" folder.  There are two sample test files created in the test folder which can be used as templates.
You can run tests from the Play console.

To run all tests, run test.
To run only one test class, run test-only followed by the name of the class i.e. test-only my.namespace.MySpec.
To run only the tests that have failed, run test-quick.
To run tests continually, run a command with a tilde in front, i.e. ~test-quick.
To access test helpers such as FakeApplication in console, run test:console.

Testing in Play is based on SBT, and a full description is available in the testing SBT chapter.
Using specs2
In specs2, tests are organized into specifications, which contain examples which run the system under test through various different code paths.
Specifications extend the Specification trait and are using the should/in format:
@scalatest-helloworldspec
Specifications can be run in either IntelliJ IDEA (using the Scala plugin) or in Eclipse (using the Scala IDE).  Please see the [[IDE page|IDE]] for more details.
NOTE: Due to a bug in the presentation compiler, tests must be defined in a specific format to work with Eclipse:

The package must be exactly the same as the directory path.
The specification must be annotated with @RunWith(classOf[JUnitRunner]).

Here is a valid specification for Eclipse:

Matchers
When you use an example, you must return an example result. Usually, you will see a statement containing a must:
scala
"Hello world" must endWith("world")
The expression that follows the must keyword are known as matchers. Matchers return an example result, typically Success or Failure.  The example will not compile if it does not return a result.
The most useful matchers are the match results.  These are used to check for equality, determine the result of Option and Either, and even check if exceptions are thrown.
There are also optional matchers that allow for XML and JSON matching in tests.
Mockito
Mocks are used to isolate unit tests against external dependencies.  For example, if your class depends on an external DataService class, you can feed appropriate data to your class without instantiating a DataService object.
Mockito is integrated into specs2 as the default mocking library.
To use Mockito, add the following import:
scala
import org.specs2.mock._
You can mock out references to classes like so:
@specs2-mockito-dataservice
@specs2-mockito
Mocking is especially useful for testing the public methods of classes.  Mocking objects and private methods is possible, but considerably harder.
Unit Testing Models
Play does not require models to use a particular database data access layer.  However, if the application uses Anorm or Slick, then frequently the Model will have a reference to database access internally.

For unit testing, this approach can make mocking out the roles method tricky.
A common approach is to keep the models isolated from the database and as much logic as possible, and abstract database access behind a repository layer.
@scalatest-models
@scalatest-repository

and then access them through services:
@scalatest-userservice
In this way, the isAdmin method can be tested by mocking out the UserRepository reference and passing it into the service:
@scalatest-userservicespec
Unit Testing Controllers
Controllers are defined as objects in Play, and so can be trickier to unit test.  In Play this can be alleviated by [[dependency injection|ScalaDependencyInjection]] using getControllerInstance.  Another way to finesse unit testing with a controller is to use a trait with an explicitly typed self reference to the controller:
@scalatest-examplecontroller
and then test the trait:
@scalatest-examplecontrollerspec
Unit Testing EssentialAction
Testing Action or Filter can require to test an an EssentialAction ([[more information about what an EssentialAction is|HttpApi]])
For this, the test Helpers.call can be used like that:
@scalatest-exampleessentialactionspec

Next: [[Writing functional tests with specs2|ScalaFunctionalTestingWithSpecs2]]
