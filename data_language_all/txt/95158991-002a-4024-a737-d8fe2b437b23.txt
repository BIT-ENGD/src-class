% The Manifest Format
The [package] Section
The first section in a Cargo.toml is [package].
toml
[package]
name = "hello_world" # the name of the package
version = "0.1.0"    # the current version, obeying semver
authors = ["you@example.com"]
All three of these fields are mandatory. Cargo bakes in the concept of Semantic
Versioning, so make sure you follow some basic rules:

Before you reach 1.0.0, anything goes.
After 1.0.0, only make breaking changes when you increment the major version.
  In Rust, breaking changes include adding fields to structs or variants to
  enums. Don’t break the build.
After 1.0.0, don’t add any new public API (no new pub anything) in tiny
  versions. Always increment the minor version if you add any new pub structs,
  traits, fields, types, functions, methods or anything else.
Use version numbers with three numeric parts such as 1.0.0 rather than 1.0.

For more on versions, see this
documentation.
The build Field (optional)
This field specifies a file in the repository which is a build script for
building native code. More information can be found in the build script
guide.

The exclude and include Fields (optional)
You can explicitly specify to Cargo that a set of globs should be
ignored or included for the purposes of packaging and rebuilding a package. The
globs specified in the exclude field identify a set of files that are not
included when a package is published as well as ignored for the purposes of
detecting when to rebuild a package, and the globs in include specify files
that are explicitly included.
If a VCS is being used for a package, the exclude field will be seeded with
the VCS’ ignore settings (.gitignore for git for example).


The options are mutually exclusive: setting include will override an
exclude. Note that include must be an exhaustive list of files as otherwise
necessary source files may not be included.
The publish  Field (optional)
The publish field can be used to prevent a package from being published to a
repository by mistake.

Package Metadata
There are a number of optional metadata fields also accepted under the
[package] section:

The crates.io registry will render the description, display
the license, link to the three URLs and categorize by the keywords. These keys
provide useful information to users of the registry and also influence the
search ranking of a crate. It is highly discouraged to omit everything in a
published crate.
The [dependencies] Section
You list dependencies using keys inside of the [dependencies] section. For
example, if you wanted to depend on hammer, color, and geometry:

You can specify the source of a dependency in a few ways:

git = "<git-url>" refers to a git repository with a Cargo.toml inside it
  (not necessarily at the root). The rev, tag, and branch options are also
  recognized to use something other than the master branch.
path = "<relative-path>" refers to another directory with a Cargo.toml
  inside it. The specified path should be relative to the current Cargo.toml.
If path and git are omitted, the dependency will come from crates.io, and
  the version key will be used to indicate the version requirement.

Dependencies from crates.io can also use a shorthand where just the version
requirement is specified:
toml
[dependencies]
hammer = "0.5.0"
color = "> 0.6.0, < 0.8.0"
The syntax of the requirement strings is described in the crates.io
guide.
Platform-specific dependencies take the same format, but are listed under the
target section. Normally Rust-like #[cfg] syntax will be used to define
these sections:

Like with Rust, the syntax here supports the not, any, and all operators
to combine various cfg name/value pairs. Note that the cfg syntax has only
been available since Cargo 0.9.0 (Rust 1.8.0).
In addition to #[cfg] syntax, Cargo also supports listing out the full target
the dependencies would apply to:

If you’re using a custom target specification, quote the full path and file
name:

The [profile.*] Sections
Cargo supports custom configuration of how rustc is invoked through profiles at
the top level. Any manifest may declare a profile, but only the top level
project’s profiles are actually read. All dependencies’ profiles will be
overridden. This is done so the top-level project has control over how its
dependencies are compiled.
There are five currently supported profile names, all of which have the same
configuration available to them. Listed below is the configuration available,
along with the defaults for each profile.

The [features] Section
Cargo supports features to allow expression of:

conditional compilation options (usable through cfg attributes);
optional dependencies, which enhance a package, but are not required; and
clusters of optional dependencies, such as postgres, that would include the
  postgres package, the postgres-macros package, and possibly other packages
  (such as development-time mocking libraries, debugging tools, etc.).

A feature of a package is either an optional dependency, or a set of other
features. The format for specifying features is:

To use the package awesome:
toml
[dependencies.awesome]
version = "1.3.5"
default-features = false # do not include the default features, and optionally
                         # cherry-pick individual features
features = ["secure-password", "civet"]
Rules
The usage of features is subject to a few rules:

Feature names must not conflict with other package names in the manifest. This
  is because they are opted into via features = [...], which only has a single
  namespace.
With the exception of the default feature, all features are opt-in. To opt
  out of the default feature, use default-features = false and cherry-pick
  individual features.
Feature groups are not allowed to cyclically depend on one another.
Dev-dependencies cannot be optional.
Features groups can only reference optional dependencies.
When a feature is selected, Cargo will call rustc with --cfg
  feature="${feature_name}". If a feature group is included, it and all of its
  individual features will be included. This can be tested in code via
  #[cfg(feature = "foo")].

Note that it is explicitly allowed for features to not actually activate any
optional dependencies. This allows packages to internally enable/disable
features without requiring a new dependency.
Usage in End Products
One major use-case for this feature is specifying optional features in
end-products. For example, the Servo project may want to include optional
features that people can enable or disable when they build it.
In that case, Servo will describe features in its Cargo.toml and they can be
enabled using command-line flags:
$ cargo build --release --features "shumway pdf"
Default features could be excluded using --no-default-features.
Usage in Packages
In most cases, the concept of optional dependency in a library is best
expressed as a separate package that the top-level application depends on.
However, high-level packages, like Iron or Piston, may want the ability to
curate a number of packages for easy installation. The current Cargo system
allows them to curate a number of mandatory dependencies into a single package
for easy installation.
In some cases, packages may want to provide additional curation for optional
dependencies:

grouping a number of low-level optional dependencies together into a single
  high-level feature;
specifying packages that are recommended (or suggested) to be included by
  users of the package; and
including a feature (like secure-password in the motivating example) that
  will only work if an optional dependency is available, and would be difficult
  to implement as a separate package (for example, it may be overly difficult to
  design an IO package to be completely decoupled from OpenSSL, with opt-in via
  the inclusion of a separate package).

In almost all cases, it is an antipattern to use these features outside of
high-level packages that are designed for curation. If a feature is optional, it
can almost certainly be expressed as a separate package.
The [dev-dependencies] Section
The format of this section is equivalent to [dependencies]. Dev-dependencies
are not used when compiling a package for building, but are used for compiling
tests and benchmarks.
These dependencies are not propagated to other packages which depend on this
package.
The Project Layout
If your project is an executable, name the main source file src/main.rs. If it
is a library, name the main source file src/lib.rs.
Cargo will also treat any files located in src/bin/*.rs as executables.
Your project can optionally contain folders named examples, tests, and
benches, which Cargo will treat as containing example executable files,
integration tests, and benchmarks respectively.
notrust
▾ src/           # directory containing source files
  lib.rs         # the main entry point for libraries and packages
  main.rs        # the main entry point for projects producing executables
  ▾ bin/         # (optional) directory containing additional executables
    *.rs
▾ examples/      # (optional) examples
  *.rs
▾ tests/         # (optional) integration tests
  *.rs
▾ benches/       # (optional) benchmarks
  *.rs
Examples
Files located under examples are example uses of the functionality provided by
the library. When compiled, they are placed in the target/examples directory.
They must compile as executables (with a main() function) and load in the
library by using extern crate <library-name>. They are compiled when you run
your tests to protect them from bitrotting.
You can run individual examples with the command cargo run --example
<example-name>.
Tests
When you run cargo test, Cargo will:

compile and run your library’s unit tests, which are in the files reachable
  from lib.rs (naturally, any sections marked with #[cfg(test)] will be
  considered at this stage);
compile and run your library’s documentation tests, which are embedded inside
  of documentation blocks;
compile and run your library’s integration tests; and
compile your library’s examples.

Integration Tests
Each file in tests/*.rs is an integration test. When you run cargo test,
Cargo will compile each of these files as a separate crate. The crate can link
to your library by using extern crate <library-name>, like any other code that
depends on it.
Cargo will not automatically compile files inside subdirectories of tests, but
an integration test can import modules from these directories as usual. For
example, if you want several integration tests to share some code, you can put
the shared code in tests/common/mod.rs and then put mod common; in each of
the test files.
Configuring a Target
All of the  [[bin]], [lib], [[bench]], [[test]], and [[example]]
sections support similar configuration for specifying how a target should be
built. The example below uses [lib], but it also applies to all other sections
as well. All values listed are the defaults for that option unless otherwise
specified.

Building Dynamic or Static Libraries
If your project produces a library, you can specify which kind of library to
build by explicitly listing the library in your Cargo.toml:

The available options are dylib, rlib, and staticlib. You should only use
this option in a project. Cargo will always compile packages (dependencies)
based on the requirements of the project that includes them.