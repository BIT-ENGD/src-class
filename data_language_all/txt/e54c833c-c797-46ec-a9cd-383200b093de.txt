[TOC]
Curiosity task - 3D object viewer
We are not doing Pacman. Instead we are doing a Curiousity Task.
We are focusing heavily on Architecture/Framework development for an OpenGL
graphics engine. 
The goal of our engine is to provide a 3D viewer with loading of resource files 
during run-time. The 3D-viewer will support 5 different files which may be 
loaded, edited, re-loaded during run-time by the user:
- Texture files   (e.g. brickwall.jpg)
- Shader files    (e.g. base.glsl)
- Material files  (e.g. brickwall.yml  - custom format)
- Model files     (e.g. cube.yml       - custom format)
- Scene files     (e.g. playground.yml - custom format)
We are focusing on beiing as generic as possible when supporting these files, 
to empower the user. We are trying to make it possible for non-programmers
to enjoy the 3D-viewer, although the text-only input system might scare some
people away.
Our target user is an educator or a student who wants to learn about 3D 
graphics datastructures and systems.
To make our custom model format usable, we want to write an exporter for Blender
for exporting models, i.e. their vertex- and face informaion (position, normal, uv coordinates ...) to our custom format.
We want to model an entire scene graph.
Install Instructions
Windows

Adding the CMake-module for Visual Studio:
Install Visual Studio 2017 15.4 or newer (the CMake module is only available for these versions).
From Visual Studio: go to Tools->Get Tools And Features...
Select the box named Desktop development with C++
Enable the checkbox named Visual C++ Tools for CMake in the righthand column
Press Modify to apply the module


Install python 3(or newer)
Make sure the installation directory is C:\tools\Python36\python.exe


Clone the repository
from gitbash: > cd "./yourdesiredworkdir/"
from gitbash: > git clone http://prod3.imt.hig.no/overkill-studios/imt2531-assignment2.git


In Visual Studio: go to File->Open->CMake..., and select the CMakeLists.txt file located in ./yourdesiredworkdir/imt2531-assignment2/

Controls

Additional/Optional setup

Running the program with different scenes:
    To start the program from a differet scene all you need to do is specify another configuration in the file named launch.vs.json, this can be found in the hidden directory .vs, or by going to CMake->Debug and Launch Settings.
Setting the args of a configuration to reflect a scene will make that scene open upon building & debugging with said configuration.

MacOS
Linux
Since we are using c++17 features, a newer compiler is necessary.
We are also using python3 or above.

Roadmap
Minimum Requirements assignment 2

[x] Textured walls floors
[ ] Menu for pause, resume and exit. (we were excused for this point as it didn't fit the kind of program we made)
[x] Move objects/camera using keyboard or mouse.
[x] Load at least 1 model from a model file. (custom format)
[x] Basic lighting model

Optional requirement assignment 2

[x] Advanced lighting/reflection materials
[x] Change perspective 
[x] Use of multiple advanced mesh.
[x] Write own object loader
[x] Make Camera movable
[x] Multiple scenes

Own requirements Engine

[x] Render a cube. 
[x] Add texture to the cube 
[x] Make the cube spin. 
[x] Add material to the cube. 
[x] Use 2 materials on different parts of the cube. 
[x] Move the cube using mouse input. 
[x] Add floor. 
[x] Texturize the floor. 
[x] Toggle camera spin around the cube. 
[x] Toggle ambient light. Scale ambient light up down. 
[x] Add a directional light. 
[x] Implement Phong lighting model using cube vertex normals. 
[x] Render cube with specular map. 
[ ] Add one of the simple shadow models. 
[x] Swap between 2 different shaders at run-time. 
[x] Swap between 2 different cube materials at run-time. 
[x] Render 2 cubes side by side with different materials. 
[x] Repeat the above with model of the teapot. 

Extra File loader

[x] Load a Shader. (vertex & geometry & fragment) 
[x] Load a Texture. (diffuse & specular) 
[x] Load a Vertexbuffer 
[x] Load a Mesh with indicies to that vertexbuffer. 
[x] Load a Material.  
[x] Load a Transform.  
[x] Load an Entity { Mesh, Material, Transform }  
[x] Render that loaded Entity.  
[x] Update render of loaded Entity on file change 

Extended feature list
1. Rendering of 3D models.
3D models are rendered in a GLFW window. Rendering 3D models in it's simplest form is just pushing each individual vertex down the 3D rendering pipeline of the GPU using shaders. In OpenGL this is achieved by writing -> loading -> compiling -> linking -> buffering -> binding and running the following shader minimum.
```c=
shader vertex
version 150
in vec4 position;
in vec4 color;
out vec4 color_from_vshader;
void main() {
    gl_Position = position;
    color_from_vshader = color;
}
shader fragment
version 150
in vec4 color_from_vshader;
out vec4 out_color;
void main() {
    out_color = color_from_vshader;
}
yaml
vertices: 1560
x   y    z     nx   ny     nz    u   v    r   g   b   a
v:  1.24 0.65 0.10  -0.85 -0.52  0.00  0.0 0.0  255 255 255 150
v:  1.27 0.67 0.10 ......
v:  1.30 0.60 0.10 .......
...
yaml
relations: 24
sun: 0

mercury: 0
mercuryCore: 1
    mercury

venusCam: 0
venus: 1
    venusCam
venusCore: 1
    venus

earthCam: 0
moonMoonCam: 0
moon2: 0
moonCore2: 1
    moon2
moon: 2
    moonCore2
    moonMoonCam
moonCore: 1
    moon

Many more relations....
yml
vertices: 1560
    v:  1.138500  0.598000 -0.100000    0.707 -0.707  0.000    0.000  0.000   255 255 255 255
    v:  1.138500  0.598000  0.100000    0.707 -0.707  0.000    0.000  0.000   255 255 255 255
    v:  1.138500  0.384000 -0.100000    0.707  0.707  0.000    0.000  0.000   255 255 255 255
    v:  1.138500  0.384000  0.100000    0.707  0.707  0.000    0.000  0.000   255 255 255 255
.... 1000's more vertices
meshes: 1
mesh: blendermesh
material: _default   # < -- Awkward to have to go here to edit material here in between 1000's of lines of data.
shader: _default
triangles: 1166
    t: 64 92 65
    t: 92 66 65
    t: 92 0 66
    t: 92 1 0
    t: 92 2 1
    t: 92 3 2
    t: 92 4 3
    t: 92 5 4
.... 1000's more triangles
yml
entities: 1
entity: player1
    model: human
    position: 10 0 0
    rotation: 0 0 -90
    # ...and so on

yml
vertices: 1560
    v:  1.138500  0.598000 -0.100000    0.707 -0.707  0.000    0.000  0.000   255 255 255 255
    v:  1.138500  0.598000  0.100000    0.707 -0.707  0.000    0.000  0.000   255 255 255 255
    v:  1.138500  0.384000 -0.100000    0.707  0.707  0.000    0.000  0.000   255 255 255 255
    v:  1.138500  0.384000  0.100000    0.707  0.707  0.000    0.000  0.000   255 255 255 255
.... 1000's more vertices
triangles: 1166
    t: 64 92 65
    t: 92 66 65
    t: 92 0 66
    t: 92 1 0
    t: 92 2 1
    t: 92 3 2
    t: 92 4 3
    t: 92 5 4
    #.... 1000's more triangles
yml
meshes: 4
mesh: right-arm
shader: basic-color
material: red

mesh: left-arm
shader: basic-color
material: blue

mesh: head
shader: mat-texture
material: _default

mesh: foot
shader: mat-texture
material: brick

yml
entities: 1
entity: player1
    prefab: human
    position: 10 0 0
    rotation: 0 0 -90
    # ...and so on

cpp
    float u, v;
vert.u = 65535U * u;
vert.v = 65535U * v;

cpp
auto changecount = sscanf(valueString.data(), "%f  %f  %f    %f  %f  %f    %f  %f   %c %c %c %c", 
             &vert.x, &vert.y, &vert.z, &nx, &ny, &nz, &u, &v, &vert.r, &vert.g, &vert.b, &vert.a);
```
Here is our complete vertex struct for reference
cpp
struct Vertex
{
    GLfloat  x,y,z;     // 12 bytes
    GLint    n;         // 4 bytes     
    GLushort u,v;       // 4 bytes 
    GLubyte  r,g,b,a;   // 4 byte  
                        // total 24 bytes
};
Byte allignment issues
The reason why our struct is 24 bytes is not by chance. For the VertexArrayObject to operate correctly, it needs data which is byte alligned by the nearest 4 byte. That is at least what we experienced. When we tried to pack uv coordinates from 4 to 2 bytes, we had to have extra padding to make sure our struct still was 24 bytes. 
cpp
struct Vertex
{
    GLfloat  x,y,z;    // 12 bytes
    GLint      n;      // 4 bytes     
    GLushort    uv;    // 2 byte <-- packing uvs yay
    GLubyte  r,g,b,a;  // 4 byte  
    GLushort padding;  // 2 byte <-- wasting space aww
                       // total still 24 bytes
};
Because of this it did not make sense to pack uv coordinates.
6. Animations - still a largely unexplored territory.
The only animations we support now is movement and rotation. We can find this in our scene format
yml
entity: Suzanne
  model: Suzanne
  position: 4 10 1
  rotation: 45 45 45
  scale: 10 10 10
  velocity: 0 0 0 
  angleVelocity: 1 3.4 1.67
We do not know how actual animation data looks like. How it would fit into our system. Would we have to expand our  vertex file format ?
What is even animations as data?
Where does it come from?