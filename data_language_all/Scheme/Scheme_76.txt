(library
  (harlan middle convert-types)
  (export convert-types convert-type)
  (import (rnrs) (except (elegant-weapons helpers) ident?)
          (harlan compile-opts)
    (harlan helpers))
  
;; This pass converts Harlan types into C types.
(define-match convert-types
  ((,[convert-decl -> decl*] ...) decl*))

(define-match convert-decl
  ((include ,h) `(include ,h))
  ((gpu-module ,[convert-kernel -> kernel*] ...)
   `(gpu-module . ,kernel*))
  ((func ,[convert-type -> rtype] ,name
     ((,x* ,[convert-type -> t*]) ...)
     ,[convert-stmt -> stmt])
   `(func ,rtype ,name ,(map list x* t*) ,stmt))
  ((global ,name ,[convert-type -> t] ,[convert-expr -> e])
   `(global ,t ,name ,e))
  ((typedef ,name ,[convert-type -> t])
   `(typedef ,name ,t))
  ((extern ,[convert-type -> t] ,name (,[convert-type -> t*] ...))
   `(extern ,t ,name ,t*)))

(define-match convert-kernel
  ((kernel ,k ((,x* ,[convert-type -> t*]) ...)
     ,[convert-stmt -> stmt*] ...)
   `(kernel ,k ,(map list x* t*) . ,stmt*))
  (,else (convert-decl else)))

(define-match convert-stmt
  ((begin ,[stmt*] ...)
   `(begin . ,stmt*))
  ((let ,x ,[convert-type -> type] ,[convert-expr -> e])
   `(let ,x ,type ,e))
  ((let ,x ,[convert-type -> type])
   `(let ,x ,type))
  ((if ,[convert-expr -> test] ,[conseq])
   `(if ,test ,conseq))
  ((if ,[convert-expr -> test] ,[conseq] ,[alt])
   `(if ,test ,conseq ,alt))
  ((set! ,[convert-expr -> loc] ,[convert-expr -> val])
   `(set! ,loc ,val))
  ((print ,[convert-expr -> e] ...) `(print . ,e))
  ((while ,[convert-expr -> e] ,[stmt])
   `(while ,e ,stmt))
  ((for (,x ,[convert-expr -> start]
            ,[convert-expr -> end]
            ,[convert-expr -> step])
        ,[convert-stmt -> stmt*] ...)
   `(for (,x ,start ,end ,step) . ,stmt*))
  ((kernel
     (((,x* ,[convert-type -> t*])
       (,xs* ,[convert-type -> ts*])) ...)
     (free-vars (,fx* ,[convert-type -> ft*]) ...)
     ,[body])
   `(kernel ,(map (lambda (x t xs ts)
                    `((,x ,t) (,xs ,ts)))
               x* t* xs* ts*)
      (free-vars . ,(map list fx* ft*))
      ,body))
  ((apply-kernel ,k ,[convert-expr -> e*] ...)
   (guard (ident? k))
   `(apply-kernel ,k . ,e*))
  ((do ,[convert-expr -> e])
   `(do ,e))
  ((goto ,name) `(goto ,name))
  ((label ,name) `(label ,name))
  ((return) `(return))
  ((return ,[convert-expr -> expr])
   `(return ,expr)))

(define-match convert-expr
  ((,t ,n) (guard (scalar-type? t)) `(,t ,n))
  ((var ,x) `(var ,x))
  ((c-expr ,x) `(c-expr ,x))
  ((alloc ,[region] ,[expr])
   `(alloc ,region ,expr))
  ((region-ref ,[convert-type -> t] ,[region] ,[ptr])
   `(region-ref ,t ,region ,ptr))
  ((field ,obj ,arg* ...) `(field ,obj . ,arg*))
  ((,op ,[lhs] ,[rhs])
   (guard (or (binop? op) (relop? op)))
   `(,op ,lhs ,rhs))
  ((if ,[test] ,[conseq] ,[alt])
   `(if ,test ,conseq ,alt))
  ((sizeof ,[convert-type -> t]) `(sizeof ,t))
  ((vector-ref ,[v] ,[i]) `(vector-ref ,v ,i))
  ((cast ,[convert-type -> t] ,[e]) `(cast ,t ,e))
  ((deref ,[e]) `(deref ,e))
  ((addressof ,[e]) `(addressof ,e))
  ((assert ,[expr]) `(assert ,expr))
  ((not ,[e]) `(not ,e))
  ((empty-struct) '(empty-struct))
  ((call ,[e] ,[arg*] ...) `(call ,e . ,arg*)))

(define-match convert-type
  (int 'int)
  (bool 'bool_t)
  (char 'char)
  (u64 'uint64_t)
  (float (if (use-doubles) 'double 'float))
  (void 'void)
  (ofstream 'std::ofstream)
  (str '(const-ptr char))
  (region 'region)
  (region_ptr 'region_ptr)
  (cl::kernel 'cl::kernel)
  (cl_mem 'cl_mem)
  ((adt ,[t]) t)
  ((fixed-array ,[t] ,i) `(fixed-array ,t ,i))
  ((cl::buffer ,[t]) `(cl::buffer ,t))
  ((cl::buffer_map ,[t]) `(cl::buffer_map ,t))
  ((ref ,[t]) `(ref ,t))
  ((ptr ,[scalar]) `(ptr ,scalar))
  ((ptr ,space ,[scalar]) `(ptr ,space ,scalar))
  ((vec ,[t]) 'region_ptr)
  ((struct (,x ,[t]) ...) `(struct (,x ,t) ...))
  ((union (,x ,[t]) ...) `(union (,x ,t) ...))
  (((,[t*] ...) -> ,[t])
   `(,t* -> ,t))
  (,x (guard (symbol? x)) x))

;; end library
)
