

\section{Tensor Transformations }\label{tensor-transformations}

Note: Functions taking \lstinline{Tensor} arguments can also take anything
accepted by
\href{../../api_docs/python/framework.md\#convert_to_tensor}{\lstinline{tf.convert_to_tensor}}.

\subsection{Contents}\label{contents}

\subsubsection{\texorpdfstring{\protect\hyperlink{AUTOGENERATED-tensor-transformations}{Tensor
Transformations}}{Tensor Transformations}}\label{tensor-transformations-1}

\begin{itemize}
\tightlist
\item
  \protect\hyperlink{AUTOGENERATED-casting}{Casting}
\item
  \protect\hyperlink{stringux5ftoux5fnumber}{\lstinline{tf.string_to_number(string_tensor, out_type=None, name=None)}}
\item
  \protect\hyperlink{toux5fdouble}{\lstinline{tf.to_double(x, name=\textquotesingle{}ToDouble\textquotesingle{})}}
\item
  \protect\hyperlink{toux5ffloat}{\lstinline{tf.to_float(x, name=\textquotesingle{}ToFloat\textquotesingle{})}}
\item
  \protect\hyperlink{toux5fbfloat16}{\lstinline{tf.to_bfloat16(x, name=\textquotesingle{}ToBFloat16\textquotesingle{})}}
\item
  \protect\hyperlink{toux5fint32}{\lstinline{tf.to_int32(x, name=\textquotesingle{}ToInt32\textquotesingle{})}}
\item
  \protect\hyperlink{toux5fint64}{\lstinline{tf.to_int64(x, name=\textquotesingle{}ToInt64\textquotesingle{})}}
\item
  \protect\hyperlink{cast}{\lstinline{tf.cast(x, dtype, name=None)}}
\item
  \protect\hyperlink{AUTOGENERATED-shapes-and-shaping}{Shapes and
  Shaping}
\item
  \protect\hyperlink{shape}{\lstinline{tf.shape(input, name=None)}}
\item
  \protect\hyperlink{size}{\lstinline{tf.size(input, name=None)}}
\item
  \protect\hyperlink{rank}{\lstinline{tf.rank(input, name=None)}}
\item
  \protect\hyperlink{reshape}{\lstinline{tf.reshape(tensor, shape, name=None)}}
\item
  \protect\hyperlink{squeeze}{\lstinline{tf.squeeze(input, squeeze_dims=None, name=None)}}
\item
  \protect\hyperlink{expandux5fdims}{\lstinline{tf.expand_dims(input, dim, name=None)}}
\item
  \protect\hyperlink{AUTOGENERATED-slicing-and-joining}{Slicing and
  Joining}
\item
  \protect\hyperlink{slice}{\lstinline{tf.slice(input_, begin, size, name=None)}}
\item
  \protect\hyperlink{split}{\lstinline{tf.split(split_dim, num_split, value, name=\textquotesingle{}split\textquotesingle{})}}
\item
  \protect\hyperlink{tile}{\lstinline{tf.tile(input, multiples, name=None)}}
\item
  \protect\hyperlink{pad}{\lstinline{tf.pad(input, paddings, name=None)}}
\item
  \protect\hyperlink{concat}{\lstinline{tf.concat(concat_dim, values, name=\textquotesingle{}concat\textquotesingle{})}}
\item
  \protect\hyperlink{pack}{\lstinline{tf.pack(values, name=\textquotesingle{}pack\textquotesingle{})}}
\item
  \protect\hyperlink{unpack}{\lstinline{tf.unpack(value, num=None, name=\textquotesingle{}unpack\textquotesingle{})}}
\item
  \protect\hyperlink{reverseux5fsequence}{\lstinline{tf.reverse_sequence(input, seq_lengths, seq_dim, name=None)}}
\item
  \protect\hyperlink{reverse}{\lstinline{tf.reverse(tensor, dims, name=None)}}
\item
  \protect\hyperlink{transpose}{\lstinline{tf.transpose(a, perm=None, name=\textquotesingle{}transpose\textquotesingle{})}}
\item
  \protect\hyperlink{gather}{\lstinline{tf.gather(params, indices, name=None)}}
\item
  \protect\hyperlink{dynamicux5fpartition}{\lstinline{tf.dynamic_partition(data, partitions, num_partitions, name=None)}}
\item
  \protect\hyperlink{dynamicux5fstitch}{\lstinline{tf.dynamic_stitch(indices, data, name=None)}}
\end{itemize}

\subsection{Casting }\label{casting}

TensorFlow provides several operations that you can use to cast tensor
data types in your graph.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\lstinline{tf.string_to_number(string_tensor, out_type=None, name=None)}
}{tf.string_to_number(string_tensor, out_type=None, name=None) }}\label{tf.stringux5ftoux5fnumberstringux5ftensor-outux5ftypenone-namenone}

Converts each string in the input Tensor to the specified numeric type.

(Note that int32 overflow results in an error while float overflow
results in a rounded value.)

\subparagraph{Args: }\label{args}

\begin{itemize}
\tightlist
\item \lstinline{string_tensor}: A \lstinline{Tensor} of type \lstinline{string}.
\item \lstinline{out_type}: An optional \lstinline{tf.DType} from: \lstinline{tf.float32, tf.int32}. Defaults to \lstinline{tf.float32}. The numeric type to interpret each string in string_tensor as.
\item \lstinline{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns}

A \lstinline{Tensor} of type \lstinline{out_type}. A Tensor of the same shape
as the input string_tensor.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\lstinline{tf.to_double(x, name=\textquotesingle{}ToDouble\textquotesingle{})}
}{tf.to_double(x, name='ToDouble') }}\label{tf.toux5fdoublex-nametodouble}

Casts a tensor to type \lstinline{float64}.

\subparagraph{Args: }\label{args-1}

\begin{itemize}
\tightlist
\item
  \lstinline{x}: A \lstinline{Tensor} or \lstinline{SparseTensor}.
\item
  \lstinline{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-1}

A \lstinline{Tensor} or \lstinline{SparseTensor} with same shape as \lstinline{x}
with type \lstinline{float64}.

\subparagraph{Raises: }\label{raises}

\begin{itemize}
\tightlist
\item
  \lstinline{TypeError}: If \lstinline{x} cannot be cast to the
  \lstinline{float64}.
\end{itemize}

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\lstinline{tf.to_float(x, name=\textquotesingle{}ToFloat\textquotesingle{})}
}{tf.to_float(x, name='ToFloat') }}\label{tf.toux5ffloatx-nametofloat}

Casts a tensor to type \lstinline{float32}.

\subparagraph{Args: }\label{args-2}

\begin{itemize}
\tightlist
\item
  \lstinline{x}: A \lstinline{Tensor} or \lstinline{SparseTensor}.
\item
  \lstinline{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-2}

A \lstinline{Tensor} or \lstinline{SparseTensor} with same shape as \lstinline{x}
with type \lstinline{float32}.

\subparagraph{Raises: }\label{raises-1}

\begin{itemize}
\tightlist
\item
  \lstinline{TypeError}: If \lstinline{x} cannot be cast to the
  \lstinline{float32}.
\end{itemize}

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\lstinline{tf.to_bfloat16(x, name=\textquotesingle{}ToBFloat16\textquotesingle{})}
}{tf.to_bfloat16(x, name='ToBFloat16') }}\label{tf.toux5fbfloat16x-nametobfloat16}

Casts a tensor to type \lstinline{bfloat16}.

\subparagraph{Args: }\label{args-3}

\begin{itemize}
\tightlist
\item
  \lstinline{x}: A \lstinline{Tensor} or \lstinline{SparseTensor}.
\item
  \lstinline{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-3}

A \lstinline{Tensor} or \lstinline{SparseTensor} with same shape as \lstinline{x}
with type \lstinline{bfloat16}.

\subparagraph{Raises: }\label{raises-2}

\begin{itemize}
\tightlist
\item
  \lstinline{TypeError}: If \lstinline{x} cannot be cast to the
  \lstinline{bfloat16}.
\end{itemize}

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\lstinline{tf.to_int32(x, name=\textquotesingle{}ToInt32\textquotesingle{})}
}{tf.to_int32(x, name='ToInt32') }}\label{tf.toux5fint32x-nametoint32}

Casts a tensor to type \lstinline{int32}.

\subparagraph{Args: }\label{args-4}

\begin{itemize}
\tightlist
\item
  \lstinline{x}: A \lstinline{Tensor} or \lstinline{SparseTensor}.
\item
  \lstinline{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-4}

A \lstinline{Tensor} or \lstinline{SparseTensor} with same shape as \lstinline{x}
with type \lstinline{int32}.

\subparagraph{Raises: }\label{raises-3}

\begin{itemize}
\tightlist
\item
  \lstinline{TypeError}: If \lstinline{x} cannot be cast to the
  \lstinline{int32}.
\end{itemize}

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\lstinline{tf.to_int64(x, name=\textquotesingle{}ToInt64\textquotesingle{})}
}{tf.to_int64(x, name='ToInt64') }}\label{tf.toux5fint64x-nametoint64}

Casts a tensor to type \lstinline{int64}.

\subparagraph{Args: }\label{args-5}

\begin{itemize}
\tightlist
\item
  \lstinline{x}: A \lstinline{Tensor} or \lstinline{SparseTensor}.
\item
  \lstinline{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-5}

A \lstinline{Tensor} or \lstinline{SparseTensor} with same shape as \lstinline{x}
with type \lstinline{int64}.

\subparagraph{Raises: }\label{raises-4}

\begin{itemize}
\tightlist
\item
  \lstinline{TypeError}: If \lstinline{x} cannot be cast to the
  \lstinline{int64}.
\end{itemize}

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\lstinline{tf.cast(x, dtype, name=None)}
}{tf.cast(x, dtype, name=None) }}\label{tf.castx-dtype-namenone}

Casts a tensor to a new type.

The operation casts \lstinline{x} (in case of \lstinline{Tensor}) or
\lstinline{x.values} (in case of \lstinline{SparseTensor}) to \lstinline{dtype}.

For example:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# tensor `a` is [1.8, 2.2], dtype=tf.float}
\NormalTok{tf.cast(a, tf.int32) }\OperatorTok{==>} \NormalTok{[}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{]  }\CommentTok{# dtype=tf.int32}
\end{Highlighting}
\end{Shaded}

\subparagraph{Args: }\label{args-6}

\begin{itemize}
\tightlist
\item
  \lstinline{x}: A \lstinline{Tensor} or \lstinline{SparseTensor}.
\item
  \lstinline{dtype}: The destination type.
\item
  \lstinline{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-6}

A \lstinline{Tensor} or \lstinline{SparseTensor} with same shape as
\lstinline{x}.

\subparagraph{Raises: }\label{raises-5}

\begin{itemize}
\tightlist
\item
  \lstinline{TypeError}: If \lstinline{x} cannot be cast to the
  \lstinline{dtype}.
\end{itemize}

\subsection{Shapes and Shaping }\label{shapes-and-shaping}

TensorFlow provides several operations that you can use to determine the
shape of a tensor and change the shape of a tensor.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\lstinline{tf.shape(input, name=None)}
}{tf.shape(input, name=None) }}\label{tf.shapeinput-namenone}

Returns the shape of a tensor.

This operation returns a 1-D integer tensor representing the shape of
\lstinline{input}.

For example:

\begin{lstlisting}
# 't' is [[[1, 1, 1], [2, 2, 2]], [[3, 3, 3], [4, 4, 4]]]
shape(t) ==> [2, 2, 3]
\end{lstlisting}

\subparagraph{Args: }\label{args-7}

\begin{itemize}
\tightlist
\item
  \lstinline{input}: A \lstinline{Tensor}.
\item
  \lstinline{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-7}

A \lstinline{Tensor} of type \lstinline{int32}.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\lstinline{tf.size(input, name=None)}
}{tf.size(input, name=None) }}\label{tf.sizeinput-namenone}

Returns the size of a tensor.

This operation returns an integer representing the number of elements in
\lstinline{input}.

For example:

\begin{lstlisting}
# 't' is [[[1, 1,, 1], [2, 2, 2]], [[3, 3, 3], [4, 4, 4]]]]
size(t) ==> 12
\end{lstlisting}

\subparagraph{Args: }\label{args-8}

\begin{itemize}
\tightlist
\item
  \lstinline{input}: A \lstinline{Tensor}.
\item
  \lstinline{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-8}

A \lstinline{Tensor} of type \lstinline{int32}.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\lstinline{tf.rank(input, name=None)}
}{tf.rank(input, name=None) }}\label{tf.rankinput-namenone}

Returns the rank of a tensor.

This operation returns an integer representing the rank of
\lstinline{input}.

For example:

\begin{lstlisting}
# 't' is [[[1, 1, 1], [2, 2, 2]], [[3, 3, 3], [4, 4, 4]]]
# shape of tensor 't' is [2, 2, 3]
rank(t) ==> 3
\end{lstlisting}

\textbf{Note}: The rank of a tensor is not the same as the rank of a
matrix. The rank of a tensor is the number of indices required to
uniquely select each element of the tensor. Rank is also known as
``order'', ``degree'', or ``ndims.''

\subparagraph{Args: }\label{args-9}

\begin{itemize}
\tightlist
\item
  \lstinline{input}: A \lstinline{Tensor}.
\item
  \lstinline{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-9}

A \lstinline{Tensor} of type \lstinline{int32}.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\lstinline{tf.reshape(tensor, shape, name=None)}
}{tf.reshape(tensor, shape, name=None) }}\label{tf.reshapetensor-shape-namenone}

Reshapes a tensor.

Given \lstinline{tensor}, this operation returns a tensor that has the same
values as \lstinline{tensor} with shape \lstinline{shape}.

If \lstinline{shape} is the special value \lstinline{{[}-1{]}}, then
\lstinline{tensor} is flattened and the operation outputs a 1-D tensor with
all elements of \lstinline{tensor}.

If \lstinline{shape} is 1-D or higher, then the operation returns a tensor
with shape \lstinline{shape} filled with the values of \lstinline{tensor}. In
this case, the number of elements implied by \lstinline{shape} must be the
same as the number of elements in \lstinline{tensor}.

For example:

\begin{lstlisting}
# tensor 't' is [1, 2, 3, 4, 5, 6, 7, 8, 9]
# tensor 't' has shape [9]
reshape(t, [3, 3]) ==> [[1, 2, 3]
                        [4, 5, 6]
                        [7, 8, 9]]

# tensor 't' is [[[1, 1], [2, 2]]
#                [[3, 3], [4, 4]]]
# tensor 't' has shape [2, 2]
reshape(t, [2, 4]) ==> [[1, 1, 2, 2]
                        [3, 3, 4, 4]]

# tensor 't' is [[[1, 1, 1],
#                 [2, 2, 2]],
#                [[3, 3, 3],
#                 [4, 4, 4]],
#                [[5, 5, 5],
#                 [6, 6, 6]]]
# tensor 't' has shape [3, 2, 3]
# pass '[-1]' to flatten 't'
reshape(t, [-1]) ==> [1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5, 6, 6, 6]
\end{lstlisting}

\subparagraph{Args: }\label{args-10}

\begin{itemize}
\tightlist
\item
  \lstinline{tensor}: A \lstinline{Tensor}.
\item
  \lstinline{shape}: A \lstinline{Tensor} of type \lstinline{int32}. Defines the
  shape of the output tensor.
\item
  \lstinline{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-10}

A \lstinline{Tensor}. Has the same type as \lstinline{tensor}.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\lstinline{tf.squeeze(input, squeeze_dims=None, name=None)}
}{tf.squeeze(input, squeeze_dims=None, name=None) }}\label{tf.squeezeinput-squeezeux5fdimsnone-namenone}

Removes dimensions of size 1 from the shape of a tensor.

Given a tensor \lstinline{input}, this operation returns a tensor of the
same type with all dimensions of size 1 removed. If you don't want to
remove all size 1 dimensions, you can remove specific size 1 dimensions
by specifying \lstinline{squeeze_dims}.

For example:

\begin{lstlisting}
# 't' is a tensor of shape [1, 2, 1, 3, 1, 1]
shape(squeeze(t)) ==> [2, 3]
\end{lstlisting}

Or, to remove specific size 1 dimensions:

\begin{lstlisting}
# 't' is a tensor of shape [1, 2, 1, 3, 1, 1]
shape(squeeze(t, [2, 4])) ==> [1, 2, 3, 1]
\end{lstlisting}

\subparagraph{Args: }\label{args-11}

\begin{itemize}
\tightlist
\item
  \lstinline{input}: A \lstinline{Tensor}. The \lstinline{input} to squeeze.
\item
  \lstinline{squeeze_dims}: An optional list of \lstinline{ints}. Defaults to
  \lstinline{{[}{]}}. If specified, only squeezes the dimensions listed.
  The dimension index starts at 0. It is an error to squeeze a dimension
  that is not 1.
\item
  \lstinline{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-11}

A \lstinline{Tensor}. Has the same type as \lstinline{input}. Contains the
same data as \lstinline{input}, but has one or more dimensions of size 1
removed.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\lstinline{tf.expand_dims(input, dim, name=None)}
}{tf.expand_dims(input, dim, name=None) }}\label{tf.expandux5fdimsinput-dim-namenone}

Inserts a dimension of 1 into a tensor's shape.

Given a tensor \lstinline{input}, this operation inserts a dimension of 1
at the dimension index \lstinline{dim} of \lstinline{input}'s shape. The
dimension index \lstinline{dim} starts at zero; if you specify a negative
number for \lstinline{dim} it is counted backward from the end.

This operation is useful if you want to add a batch dimension to a
single element. For example, if you have a single image of shape
\lstinline{{[}height, width, channels{]}}, you can make it a batch of 1
image with \lstinline{expand_dims(image, 0)}, which will make the shape
\lstinline{{[}1, height, width, channels{]}}.

Other examples:

\begin{lstlisting}
# 't' is a tensor of shape [2]
shape(expand_dims(t, 0)) ==> [1, 2]
shape(expand_dims(t, 1)) ==> [2, 1]
shape(expand_dims(t, -1)) ==> [2, 1]

# 't2' is a tensor of shape [2, 3, 5]
shape(expand_dims(t2, 0)) ==> [1, 2, 3, 5]
shape(expand_dims(t2, 2)) ==> [2, 3, 1, 5]
shape(expand_dims(t2, 3)) ==> [2, 3, 5, 1]
\end{lstlisting}

This operation requires that:

\lstinline{-1-input.dims() \textless{}= dim \textless{}= input.dims()}

This operation is related to \lstinline{squeeze()}, which removes
dimensions of size 1.

\subparagraph{Args: }\label{args-12}

\begin{itemize}
\tightlist
\item
  \lstinline{input}: A \lstinline{Tensor}.
\item
  \lstinline{dim}: A \lstinline{Tensor} of type \lstinline{int32}. 0-D (scalar).
  Specifies the dimension index at which to expand the shape of
  \lstinline{input}.
\item
  \lstinline{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-12}

A \lstinline{Tensor}. Has the same type as \lstinline{input}. Contains the
same data as \lstinline{input}, but its shape has an additional dimension
of size 1 added.

\subsection{Slicing and Joining }\label{slicing-and-joining}

TensorFlow provides several operations to slice or extract parts of a
tensor, or join multiple tensors together.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\lstinline{tf.slice(input_, begin, size, name=None)}
}{tf.slice(input_, begin, size, name=None) }}\label{tf.sliceinputux5f-begin-size-namenone}

Extracts a slice from a tensor.

This operation extracts a slice of size \lstinline{size} from a tensor
\lstinline{input} starting at the location specified by \lstinline{begin}. The
slice \lstinline{size} is represented as a tensor shape, where
\lstinline{size{[}i{]}} is the number of elements of the 'i'th dimension of
\lstinline{input} that you want to slice. The starting location
(\lstinline{begin}) for the slice is represented as an offset in each
dimension of \lstinline{input}. In other words, \lstinline{begin{[}i{]}} is
the offset into the 'i'th dimension of \lstinline{input} that you want to
slice from.

\lstinline{begin} is zero-based; \lstinline{size} is one-based. If
\lstinline{size{[}i{]}} is -1, all remaining elements in dimension i are
included in the slice. In other words, this is equivalent to setting:

\lstinline{size{[}i{]} = input.dim_size(i) - begin{[}i{]}}

This operation requires that:

\lstinline{0 \textless{}= begin{[}i{]} \textless{}= begin{[}i{]} + size{[}i{]} \textless{}= Di  for i in {[}0, n{]}}

For example:

\begin{lstlisting}
# 'input' is [[[1, 1, 1], [2, 2, 2]],
#             [[3, 3, 3], [4, 4, 4]],
#             [[5, 5, 5], [6, 6, 6]]]
tf.slice(input, [1, 0, 0], [1, 1, 3]) ==> [[[3, 3, 3]]]
tf.slice(input, [1, 0, 0], [1, 2, 3]) ==> [[[3, 3, 3],
                                            [4, 4, 4]]]
tf.slice(input, [1, 0, 0], [2, 1, 3]) ==> [[[3, 3, 3]],
                                           [[5, 5, 5]]]
\end{lstlisting}

\subparagraph{Args: }\label{args-13}

\begin{itemize}
\tightlist
\item
  \lstinline{input_}: A \lstinline{Tensor}.
\item
  \lstinline{begin}: An \lstinline{int32} or \lstinline{int64} \lstinline{Tensor}.
\item
  \lstinline{size}: An \lstinline{int32} or \lstinline{int64} \lstinline{Tensor}.
\item
  \lstinline{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-13}

A \lstinline{Tensor} the same type as \lstinline{input}.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\lstinline{tf.split(split_dim, num_split, value, name=\textquotesingle{}split\textquotesingle{})}
}{tf.split(split_dim, num_split, value, name='split') }}\label{tf.splitsplitux5fdim-numux5fsplit-value-namesplit}

Splits a tensor into \lstinline{num_split} tensors along one dimension.

Splits \lstinline{value} along dimension \lstinline{split_dim} into
\lstinline{num_split} smaller tensors. Requires that \lstinline{num_split}
evenly divide \lstinline{value.shape{[}split_dim{]}}.

For example:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# 'value' is a tensor with shape [5, 30]}
\CommentTok{# Split 'value' into 3 tensors along dimension 1}
\NormalTok{split0, split1, split2 }\OperatorTok{=} \NormalTok{tf.split(}\DecValTok{1}\NormalTok{, }\DecValTok{3}\NormalTok{, value)}
\NormalTok{tf.shape(split0) }\OperatorTok{==>} \NormalTok{[}\DecValTok{5}\NormalTok{, }\DecValTok{10}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\subparagraph{Args: }\label{args-14}

\begin{itemize}
\tightlist
\item
  \lstinline{split_dim}: A 0-D \lstinline{int32} \lstinline{Tensor}. The
  dimension along which to split. Must be in the range
  \lstinline{{[}0, rank(value))}.
\item
  \lstinline{num_split}: A 0-D \lstinline{int32} \lstinline{Tensor}. The number
  of ways to split.
\item
  \lstinline{value}: The \lstinline{Tensor} to split.
\item
  \lstinline{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-14}

\lstinline{num_split} \lstinline{Tensor} objects resulting from splitting
\lstinline{value}.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\lstinline{tf.tile(input, multiples, name=None)}
}{tf.tile(input, multiples, name=None) }}\label{tf.tileinput-multiples-namenone}

Constructs a tensor by tiling a given tensor.

This operation creates a new tensor by replicating \lstinline{input}
\lstinline{multiples} times. The output tensor's i'th dimension has
\lstinline{input.dims(i) * multiples{[}i{]}} elements, and the values of
\lstinline{input} are replicated \lstinline{multiples{[}i{]}} times along the
'i'th dimension. For example, tiling \lstinline{{[}a b c d{]}} by
\lstinline{{[}2{]}} produces \lstinline{{[}a b c d a b c d{]}}.

\subparagraph{Args: }\label{args-15}

\begin{itemize}
\tightlist
\item
  \lstinline{input}: A \lstinline{Tensor}. 1-D or higher.
\item
  \lstinline{multiples}: A \lstinline{Tensor} of type \lstinline{int32}. 1-D.
  Length must be the same as the number of dimensions in \lstinline{input}
\item
  \lstinline{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-15}

A \lstinline{Tensor}. Has the same type as \lstinline{input}.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\lstinline{tf.pad(input, paddings, name=None)}
}{tf.pad(input, paddings, name=None) }}\label{tf.padinput-paddings-namenone}

Pads a tensor with zeros.

This operation pads a \lstinline{input} with zeros according to the
\lstinline{paddings} you specify. \lstinline{paddings} is an integer tensor
with shape \lstinline{{[}Dn, 2{]}}, where n is the rank of \lstinline{input}.
For each dimension D of \lstinline{input}, \lstinline{paddings{[}D, 0{]}}
indicates how many zeros to add before the contents of \lstinline{input} in
that dimension, and \lstinline{paddings{[}D, 1{]}} indicates how many
zeros to add after the contents of \lstinline{input} in that dimension.

The padded size of each dimension D of the output is:

\lstinline{paddings(D, 0) + input.dim_size(D) + paddings(D, 1)}

For example:

\begin{lstlisting}
# 't' is [[1, 1], [2, 2]]
# 'paddings' is [[1, 1]], [2, 2]]
# rank of 't' is 2
pad(t, paddings) ==> [[0, 0, 0, 0, 0]
                      [0, 0, 0, 0, 0]
                      [0, 1, 1, 0, 0]
                     [[0, 2, 2, 0, 0]
                      [0, 0, 0, 0, 0]]
\end{lstlisting}

\subparagraph{Args: }\label{args-16}

\begin{itemize}
\tightlist
\item
  \lstinline{input}: A \lstinline{Tensor}.
\item
  \lstinline{paddings}: A \lstinline{Tensor} of type \lstinline{int32}.
\item
  \lstinline{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-16}

A \lstinline{Tensor}. Has the same type as \lstinline{input}.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\lstinline{tf.concat(concat_dim, values, name=\textquotesingle{}concat\textquotesingle{})}
}{tf.concat(concat_dim, values, name='concat') }}\label{tf.concatconcatux5fdim-values-nameconcat}

Concatenates tensors along one dimension.

Concatenates the list of tensors \lstinline{values} along dimension
\lstinline{concat_dim}. If
\lstinline{values{[}i{]}.shape = {[}D0, D1, ... Dconcat_dim(i), ...Dn{]}},
the concatenated result has shape

\begin{lstlisting}
[D0, D1, ... Rconcat_dim, ...Dn]
\end{lstlisting}

where

\begin{lstlisting}
Rconcat_dim = sum(Dconcat_dim(i))
\end{lstlisting}

That is, the data from the input tensors is joined along the
\lstinline{concat_dim} dimension.

The number of dimensions of the input tensors must match, and all
dimensions except \lstinline{concat_dim} must be equal.

For example:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{t1 }\OperatorTok{=} \NormalTok{[[}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{], [}\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{6}\NormalTok{]]}
\NormalTok{t2 }\OperatorTok{=} \NormalTok{[[}\DecValTok{7}\NormalTok{, }\DecValTok{8}\NormalTok{, }\DecValTok{9}\NormalTok{], [}\DecValTok{10}\NormalTok{, }\DecValTok{11}\NormalTok{, }\DecValTok{12}\NormalTok{]]}
\NormalTok{tf.concat(}\DecValTok{0}\NormalTok{, [t1, t2]) }\OperatorTok{==>} \NormalTok{[[}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{], [}\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{6}\NormalTok{], [}\DecValTok{7}\NormalTok{, }\DecValTok{8}\NormalTok{, }\DecValTok{9}\NormalTok{], [}\DecValTok{10}\NormalTok{, }\DecValTok{11}\NormalTok{, }\DecValTok{12}\NormalTok{]]}
\NormalTok{tf.concat(}\DecValTok{1}\NormalTok{, [t1, t2]) }\OperatorTok{==>} \NormalTok{[[}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{7}\NormalTok{, }\DecValTok{8}\NormalTok{, }\DecValTok{9}\NormalTok{], [}\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{6}\NormalTok{, }\DecValTok{10}\NormalTok{, }\DecValTok{11}\NormalTok{, }\DecValTok{12}\NormalTok{]]}

\CommentTok{# tensor t3 with shape [2, 3]}
\CommentTok{# tensor t4 with shape [2, 3]}
\NormalTok{tf.shape(tf.concat(}\DecValTok{0}\NormalTok{, [t3, t4])) }\OperatorTok{==>} \NormalTok{[}\DecValTok{4}\NormalTok{, }\DecValTok{3}\NormalTok{]}
\NormalTok{tf.shape(tf.concat(}\DecValTok{1}\NormalTok{, [t3, t4])) }\OperatorTok{==>} \NormalTok{[}\DecValTok{2}\NormalTok{, }\DecValTok{6}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\subparagraph{Args: }\label{args-17}

\begin{itemize}
\tightlist
\item
  \lstinline{concat_dim}: 0-D \lstinline{int32} \lstinline{Tensor}. Dimension
  along which to concatenate.
\item
  \lstinline{values}: A list of \lstinline{Tensor} objects or a single
  \lstinline{Tensor}.
\item
  \lstinline{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-17}

A \lstinline{Tensor} resulting from concatenation of the input tensors.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\lstinline{tf.pack(values, name=\textquotesingle{}pack\textquotesingle{})}
}{tf.pack(values, name='pack') }}\label{tf.packvalues-namepack}

Packs a list of rank-\lstinline{R} tensors into one rank-\lstinline{(R+1)}
tensor.

Packs tensors in \lstinline{values} into a tensor with rank one higher than
each tensor in \lstinline{values} and shape
\lstinline{{[}len(values){]} + values{[}0{]}.shape}. The output satisfies
\lstinline{output{[}i, ...{]} = values{[}i{]}{[}...{]}}.

This is the opposite of unpack. The numpy equivalent is

\begin{lstlisting}
tf.pack([x, y, z]) = np.asarray([x, y, z])
\end{lstlisting}

\subparagraph{Args: }\label{args-18}

\begin{itemize}
\tightlist
\item
  \lstinline{values}: A list of \lstinline{Tensor} objects with the same shape
  and type.
\item
  \lstinline{name}: A name for this operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-18}

\begin{itemize}
\tightlist
\item
  \lstinline{output}: A packed \lstinline{Tensor} with the same type as
  \lstinline{values}.
\end{itemize}

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\lstinline{tf.unpack(value, num=None, name=\textquotesingle{}unpack\textquotesingle{})}
}{tf.unpack(value, num=None, name='unpack') }}\label{tf.unpackvalue-numnone-nameunpack}

Unpacks the outer dimension of a rank-\lstinline{R} tensor into
rank-\lstinline{(R-1)} tensors.

Unpacks \lstinline{num} tensors from \lstinline{value} along the first
dimension. If \lstinline{num} is not specified (the default), it is
inferred from \lstinline{value}'s shape. If \lstinline{value.shape{[}0{]}} is
not known, \lstinline{ValueError} is raised.

The ith tensor in \lstinline{output} is the slice
\lstinline{value{[}i, ...{]}}. Each tensor in \lstinline{output} has shape
\lstinline{value.shape{[}1:{]}}.

This is the opposite of pack. The numpy equivalent is

\begin{lstlisting}
tf.unpack(x, n) = list(x)
\end{lstlisting}

\subparagraph{Args: }\label{args-19}

\begin{itemize}
\tightlist
\item
  \lstinline{value}: A rank \lstinline{R \textgreater{} 0} \lstinline{Tensor}
  to be unpacked.
\item
  \lstinline{num}: An \lstinline{int}. The first dimension of value.
  Automatically inferred if \lstinline{None} (the default).
\item
  \lstinline{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-19}

The list of \lstinline{Tensor} objects unpacked from \lstinline{value}.

\subparagraph{Raises: }\label{raises-6}

\begin{itemize}
\tightlist
\item
  \lstinline{ValueError}: If \lstinline{num} is unspecified and cannot be
  inferred.
\end{itemize}

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\lstinline{tf.reverse_sequence(input, seq_lengths, seq_dim, name=None)}
}{tf.reverse_sequence(input, seq_lengths, seq_dim, name=None) }}\label{tf.reverseux5fsequenceinput-sequx5flengths-sequx5fdim-namenone}

Reverses variable length slices in dimension \lstinline{seq_dim}.

This op first slices \lstinline{input} along the first dimension, and for
each slice \lstinline{i}, reverses the first \lstinline{seq_lengths{[}i{]}}
elements along the dimension \lstinline{seq_dim}.

The elements of \lstinline{seq_lengths} must obey
\lstinline{seq_lengths{[}i{]} \textless{} input.dims{[}seq_dim{]}}, and
\lstinline{seq_lengths} must be a vector of length \lstinline{input.dims(0)}.

The output slice \lstinline{i} along dimension 0 is then given by input
slice \lstinline{i}, with the first \lstinline{seq_lengths{[}i{]}} slices
along dimension \lstinline{seq_dim} reversed.

For example:

\begin{lstlisting}
# Given this:
seq_dim = 1
input.dims = (4, ...)
seq_lengths = [7, 2, 3, 5]

# then slices of input are reversed on seq_dim, but only up to seq_lengths:
output[0, 0:7, :, ...] = input[0, 7:0:-1, :, ...]
output[1, 0:2, :, ...] = input[1, 2:0:-1, :, ...]
output[2, 0:3, :, ...] = input[2, 3:0:-1, :, ...]
output[3, 0:5, :, ...] = input[3, 5:0:-1, :, ...]

# while entries past seq_lens are copied through:
output[0, 7:, :, ...] = input[0, 7:, :, ...]
output[1, 2:, :, ...] = input[1, 2:, :, ...]
output[2, 3:, :, ...] = input[2, 3:, :, ...]
output[3, 2:, :, ...] = input[3, 2:, :, ...]
\end{lstlisting}

\subparagraph{Args: }\label{args-20}

\begin{itemize}
\tightlist
\item
  \lstinline{input}: A \lstinline{Tensor}. The input to reverse.
\item
  \lstinline{seq_lengths}: A \lstinline{Tensor} of type \lstinline{int64}. 1-D
  with length \lstinline{input.dims(0)} and
  \lstinline{max(seq_lengths) \textless{} input.dims(seq_dim)}
\item
  \lstinline{seq_dim}: An \lstinline{int}. The dimension which is partially
  reversed.
\item
  \lstinline{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-20}

A \lstinline{Tensor}. Has the same type as \lstinline{input}. The partially
reversed input. It has the same shape as \lstinline{input}.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\lstinline{tf.reverse(tensor, dims, name=None)}
}{tf.reverse(tensor, dims, name=None) }}\label{tf.reversetensor-dims-namenone}

Reverses specific dimensions of a tensor.

Given a \lstinline{tensor}, and a \lstinline{bool} tensor \lstinline{dims}
representing the dimensions of \lstinline{tensor}, this operation reverses
each dimension i of \lstinline{tensor} where \lstinline{dims{[}i{]}} is
\lstinline{True}.

\lstinline{tensor} can have up to 8 dimensions. The number of dimensions of
\lstinline{tensor} must equal the number of elements in \lstinline{dims}. In
other words:

\lstinline{rank(tensor) = size(dims)}

For example:

\begin{lstlisting}
# tensor 't' is [[[[ 0,  1,  2,  3],
#                  [ 4,  5,  6,  7],
#                  [ 8,  9, 10, 11]],
#                 [[12, 13, 14, 15],
#                  [16, 17, 18, 19],
#                  [20, 21, 22, 23]]]]
# tensor 't' shape is [1, 2, 3, 4]

# 'dims' is [False, False, False, True]
reverse(t, dims) ==> [[[[ 3,  2,  1,  0],
                        [ 7,  6,  5,  4],
                        [ 11, 10, 9, 8]],
                       [[15, 14, 13, 12],
                        [19, 18, 17, 16],
                        [23, 22, 21, 20]]]]

# 'dims' is [False, True, False, False]
reverse(t, dims) ==> [[[[12, 13, 14, 15],
                        [16, 17, 18, 19],
                        [20, 21, 22, 23]
                       [[ 0,  1,  2,  3],
                        [ 4,  5,  6,  7],
                        [ 8,  9, 10, 11]]]]

# 'dims' is [False, False, True, False]
reverse(t, dims) ==> [[[[8, 9, 10, 11],
                        [4, 5, 6, 7],
                        [0, 1, 2, 3]]
                       [[20, 21, 22, 23],
                        [16, 17, 18, 19],
                        [12, 13, 14, 15]]]]
\end{lstlisting}

\subparagraph{Args: }\label{args-21}

\begin{itemize}
\tightlist
\item
  \lstinline{tensor}: A \lstinline{Tensor}. Must be one of the following
  types: \lstinline{uint8}, \lstinline{int8}, \lstinline{int32}, \lstinline{bool},
  \lstinline{float32}, \lstinline{float64}. Up to 8-D.
\item
  \lstinline{dims}: A \lstinline{Tensor} of type \lstinline{bool}. 1-D. The
  dimensions to reverse.
\item
  \lstinline{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-21}

A \lstinline{Tensor}. Has the same type as \lstinline{tensor}. The same shape
as \lstinline{tensor}.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\lstinline{tf.transpose(a, perm=None, name=\textquotesingle{}transpose\textquotesingle{})}
}{tf.transpose(a, perm=None, name='transpose') }}\label{tf.transposea-permnone-nametranspose}

Transposes \lstinline{a}. Permutes the dimensions according to
\lstinline{perm}.

The returned tensor's dimension i will correspond to the input dimension
\lstinline{perm{[}i{]}}. If \lstinline{perm} is not given, it is set to
(n-1\ldots{}0), where n is the rank of the input tensor. Hence by
default, this operation performs a regular matrix transpose on 2-D input
Tensors.

For example:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# 'x' is [[1 2 3]}
\CommentTok{#         [4 5 6]]}
\NormalTok{tf.transpose(x) }\OperatorTok{==>} \NormalTok{[[}\DecValTok{1} \DecValTok{4}\NormalTok{]}
                     \NormalTok{[}\DecValTok{2} \DecValTok{5}\NormalTok{]}
                     \NormalTok{[}\DecValTok{3} \DecValTok{6}\NormalTok{]]}

\CommentTok{# Equivalently}
\NormalTok{tf.transpose(x perm}\OperatorTok{=}\NormalTok{[}\DecValTok{0}\NormalTok{, }\DecValTok{1}\NormalTok{]) }\OperatorTok{==>} \NormalTok{[[}\DecValTok{1} \DecValTok{4}\NormalTok{]}
                                 \NormalTok{[}\DecValTok{2} \DecValTok{5}\NormalTok{]}
                                 \NormalTok{[}\DecValTok{3} \DecValTok{6}\NormalTok{]]}

\CommentTok{# 'perm' is more useful for n-dimensional tensors, for n > 2}
\CommentTok{# 'x' is   [[[1  2  3]}
\CommentTok{#            [4  5  6]]}
\CommentTok{#           [[7  8  9]}
\CommentTok{#            [10 11 12]]]}
\CommentTok{# Take the transpose of the matrices in dimension-0}
\NormalTok{tf.transpose(b, perm}\OperatorTok{=}\NormalTok{[}\DecValTok{0}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{1}\NormalTok{]) }\OperatorTok{==>} \NormalTok{[[[}\DecValTok{1}  \DecValTok{4}\NormalTok{]}
                                      \NormalTok{[}\DecValTok{2}  \DecValTok{5}\NormalTok{]}
                                      \NormalTok{[}\DecValTok{3}  \DecValTok{6}\NormalTok{]]}

                                     \NormalTok{[[}\DecValTok{7} \DecValTok{10}\NormalTok{]}
                                      \NormalTok{[}\DecValTok{8} \DecValTok{11}\NormalTok{]}
                                      \NormalTok{[}\DecValTok{9} \DecValTok{12}\NormalTok{]]]}
\end{Highlighting}
\end{Shaded}

\subparagraph{Args: }\label{args-22}

\begin{itemize}
\tightlist
\item
  \lstinline{a}: A \lstinline{Tensor}.
\item
  \lstinline{perm}: A permutation of the dimensions of \lstinline{a}.
\item
  \lstinline{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-22}

A transposed \lstinline{Tensor}.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\lstinline{tf.gather(params, indices, name=None)}
}{tf.gather(params, indices, name=None) }}\label{tf.gatherparams-indices-namenone}

Gather slices from \lstinline{params} according to \lstinline{indices}.

\lstinline{indices} must be an integer tensor of any dimension (usually 0-D
or 1-D). Produces an output tensor with shape
\lstinline{indices.shape + params.shape{[}1:{]}} where:

\begin{lstlisting}
# Scalar indices
output[:, ..., :] = params[indices, :, ... :]

# Vector indices
output[i, :, ..., :] = params[indices[i], :, ... :]

# Higher rank indices
output[i, ..., j, :, ... :] = params[indices[i, ..., j], :, ..., :]
\end{lstlisting}

If \lstinline{indices} is a permutation and
\lstinline{len(indices) == params.shape{[}0{]}} then this operation will
permute \lstinline{params} accordingly.

\subparagraph{Args: }\label{args-23}

\begin{itemize}
\tightlist
\item
  \lstinline{params}: A \lstinline{Tensor}.
\item
  \lstinline{indices}: A \lstinline{Tensor}. Must be one of the following
  types: \lstinline{int32}, \lstinline{int64}.
\item
  \lstinline{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-23}

A \lstinline{Tensor}. Has the same type as \lstinline{params}.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\lstinline{tf.dynamic_partition(data, partitions, num_partitions, name=None)}
}{tf.dynamic_partition(data, partitions, num_partitions, name=None) }}\label{tf.dynamicux5fpartitiondata-partitions-numux5fpartitions-namenone}

Partitions \lstinline{data} into \lstinline{num_partitions} tensors using
indices from \lstinline{partitions}.

For each index tuple \lstinline{js} of size \lstinline{partitions.ndim}, the
slice \lstinline{data{[}js, ...{]}} becomes part of
\lstinline{outputs{[}partitions{[}js{]}{]}}. The slices with
\lstinline{partitions{[}js{]} = i} are placed in \lstinline{outputs{[}i{]}}
in lexicographic order of \lstinline{js}, and the first dimension of
\lstinline{outputs{[}i{]}} is the number of entries in \lstinline{partitions}
equal to \lstinline{i}. In detail,

\begin{lstlisting}
outputs[i].shape = [sum(partitions == i)] + data.shape[partitions.ndim:]

outputs[i] = pack([data[js, ...] for js if partitions[js] == i])
\end{lstlisting}

\lstinline{data.shape} must start with \lstinline{partitions.shape}.

For example:

\begin{lstlisting}
# Scalar partitions
partitions = 1
num_partitions = 2
data = [10, 20]
outputs[0] = []  # Empty with shape [0, 2]
outputs[1] = [[10, 20]]

# Vector partitions
partitions = [0, 0, 1, 1, 0]
num_partitions = 2
data = [10, 20, 30, 40, 50]
outputs[0] = [10, 20, 50]
outputs[1] = [30, 40]
\end{lstlisting}

\subparagraph{Args: }\label{args-24}

\begin{itemize}
\tightlist
\item
  \lstinline{data}: A \lstinline{Tensor}.
\item
  \lstinline{partitions}: A \lstinline{Tensor} of type \lstinline{int32}. Any
  shape. Indices in the range \lstinline{{[}0, num_partitions)}.
\item
  \lstinline{num_partitions}: An \lstinline{int} that is
  \lstinline{\textgreater{}= 1}. The number of partitions to output.
\item
  \lstinline{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-24}

A list of \lstinline{num_partitions} \lstinline{Tensor} objects of the same
type as data.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\lstinline{tf.dynamic_stitch(indices, data, name=None)}
}{tf.dynamic_stitch(indices, data, name=None) }}\label{tf.dynamicux5fstitchindices-data-namenone}

Interleave the values from the \lstinline{data} tensors into a single
tensor.

Builds a merged tensor such that

\begin{lstlisting}
merged[indices[m][i, ..., j], ...] = data[m][i, ..., j, ...]
\end{lstlisting}

For example, if each \lstinline{indices{[}m{]}} is scalar or vector, we
have

\begin{lstlisting}
# Scalar indices
merged[indices[m], ...] = data[m][...]

# Vector indices
merged[indices[m][i], ...] = data[m][i, ...]
\end{lstlisting}

Each \lstinline{data{[}i{]}.shape} must start with the corresponding
\lstinline{indices{[}i{]}.shape}, and the rest of
\lstinline{data{[}i{]}.shape} must be constant w.r.t. \lstinline{i}. That is,
we must have
\lstinline{data{[}i{]}.shape = indices{[}i{]}.shape + constant}. In
terms of this \lstinline{constant}, the output shape is

\begin{lstlisting}
merged.shape = [max(indices)] + constant
\end{lstlisting}

Values are merged in order, so if an index appears in both
\lstinline{indices{[}m{]}{[}i{]}} and \lstinline{indices{[}n{]}{[}j{]}} for
\lstinline{(m,i) \textless{} (n,j)} the slice \lstinline{data{[}n{]}{[}j{]}}
will appear in the merged result.

For example:

\begin{lstlisting}
indices[0] = 6
indices[1] = [4, 1]
indices[2] = [[5, 2], [0, 3]]
data[0] = [61, 62]
data[1] = [[41, 42], [11, 12]]
data[2] = [[[51, 52], [21, 22]], [[1, 2], [31, 32]]]
merged = [[1, 2], [11, 12], [21, 22], [31, 32], [41, 42],
          [51, 52], [61, 62]]
\end{lstlisting}

\subparagraph{Args: }\label{args-25}

\begin{itemize}
\tightlist
\item
  \lstinline{indices}: A list of at least 2 \lstinline{Tensor} objects of type
  \lstinline{int32}.
\item
  \lstinline{data}: A list with the same number of \lstinline{Tensor} objects
  as \lstinline{indices} of \lstinline{Tensor} objects of the same type.
\item
  \lstinline{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-25}

A \lstinline{Tensor}. Has the same type as \lstinline{data}.
