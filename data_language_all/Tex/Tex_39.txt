

\section{Sparse Tensors }\label{sparse-tensors}

Note: Functions taking \texttt{Tensor} arguments can also take anything
accepted by
\href{../../api_docs/python/framework.md\#convert_to_tensor}{\texttt{tf.convert\_to\_tensor}}.

\subsection{Contents}\label{contents}

\subsubsection{\texorpdfstring{\protect\hyperlink{AUTOGENERATED-sparse-tensors}{Sparse
Tensors}}{Sparse Tensors}}\label{sparse-tensors-1}

\begin{itemize}
\tightlist
\item
  \protect\hyperlink{AUTOGENERATED-sparse-tensor-representation}{Sparse
  Tensor Representation}
\item
  \protect\hyperlink{SparseTensor}{\texttt{class\ tf.SparseTensor}}
\item
  \protect\hyperlink{SparseTensorValue}{\texttt{class\ tf.SparseTensorValue}}
\item
  \protect\hyperlink{AUTOGENERATED-sparse-to-dense-conversion}{Sparse to
  Dense Conversion}
\item
  \protect\hyperlink{sparseux5ftoux5fdense}{\texttt{tf.sparse\_to\_dense(sparse\_indices,\ output\_shape,\ sparse\_values,\ default\_value,\ name=None)}}
\item
  \protect\hyperlink{sparseux5ftensorux5ftoux5fdense}{\texttt{tf.sparse\_tensor\_to\_dense(sp\_input,\ default\_value,\ name=None)}}
\item
  \protect\hyperlink{sparseux5ftoux5findicator}{\texttt{tf.sparse\_to\_indicator(sp\_input,\ vocab\_size,\ name=None)}}
\item
  \protect\hyperlink{AUTOGENERATED-manipulation}{Manipulation}
\item
  \protect\hyperlink{sparseux5fconcat}{\texttt{tf.sparse\_concat(concat\_dim,\ sp\_inputs,\ name=None)}}
\item
  \protect\hyperlink{sparseux5freorder}{\texttt{tf.sparse\_reorder(sp\_input,\ name=None)}}
\item
  \protect\hyperlink{sparseux5fretain}{\texttt{tf.sparse\_retain(sp\_input,\ to\_retain)}}
\item
  \protect\hyperlink{sparseux5ffillux5femptyux5frows}{\texttt{tf.sparse\_fill\_empty\_rows(sp\_input,\ default\_value,\ name=None)}}
\end{itemize}

\subsection{Sparse Tensor Representation
}\label{sparse-tensor-representation}

Tensorflow supports a \texttt{SparseTensor} representation for data that
is sparse in multiple dimensions. Contrast this representation with
\texttt{IndexedSlices}, which is efficient for representing tensors that
are sparse in their first dimension, and dense along all other
dimensions.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{class\ tf.SparseTensor}
}{class tf.SparseTensor }}\label{class-tf.sparsetensor}

Represents a sparse tensor.

Tensorflow represents a sparse tensor as three separate dense tensors:
\texttt{indices}, \texttt{values}, and \texttt{dense\_shape}. In Python,
the three tensors are collected into a \texttt{SparseTensor} class for
ease of use. If you have separate \texttt{indices}, \texttt{values}, and
\texttt{dense\_shape} tensors, wrap them in a \texttt{SparseTensor}
object before passing to the Ops below.

Concretely, the sparse tensor
\texttt{SparseTensor(values,\ indices,\ dense\_shape)} is

\begin{itemize}
\tightlist
\item
  \texttt{indices}: A 2-D int64 tensor of shape
  \texttt{{[}N,\ ndims{]}}.
\item
  \texttt{values}: A 1-D tensor of any type and shape \texttt{{[}N{]}}.
\item
  \texttt{dense\_shape}: A 1-D int64 tensor of shape
  \texttt{{[}ndims{]}}.
\end{itemize}

where \texttt{N} and \texttt{ndims} are the number of values, and number
of dimensions in the \texttt{SparseTensor} respectively.

The corresponding dense tensor satisfies

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dense.shape }\OperatorTok{=} \NormalTok{dense_shape}
\NormalTok{dense[}\BuiltInTok{tuple}\NormalTok{(indices[i])] }\OperatorTok{=} \NormalTok{values[i]}
\end{Highlighting}
\end{Shaded}

By convention, \texttt{indices} should be sorted in row-major order (or
equivalently lexigraphic order on the tuples \texttt{indices{[}i{]}}).
This is not enforced when \texttt{SparseTensor} objects are constructed,
but most Ops assume correct ordering. If the ordering is wrong, it can
be fixed by calling \texttt{sparse\_reorder} on the misordered
\texttt{SparseTensor}.

Example: The sparse tensor

\begin{Shaded}
\begin{Highlighting}[]
  \NormalTok{SparseTensor(values}\OperatorTok{=}\NormalTok{[}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{], indices}\OperatorTok{=}\NormalTok{[[}\DecValTok{0}\NormalTok{, }\DecValTok{0}\NormalTok{], [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{]], shape}\OperatorTok{=}\NormalTok{[}\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

represents the dense tensor

\begin{Shaded}
\begin{Highlighting}[]
  \NormalTok{[[}\DecValTok{1}\NormalTok{, }\DecValTok{0}\NormalTok{, }\DecValTok{0}\NormalTok{, }\DecValTok{0}\NormalTok{]}
   \NormalTok{[}\DecValTok{0}\NormalTok{, }\DecValTok{0}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{0}\NormalTok{]}
   \NormalTok{[}\DecValTok{0}\NormalTok{, }\DecValTok{0}\NormalTok{, }\DecValTok{0}\NormalTok{, }\DecValTok{0}\NormalTok{]]}
\end{Highlighting}
\end{Shaded}

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\texttt{tf.SparseTensor.\_\_init\_\_(indices,\ values,\ shape)}
}{tf.SparseTensor.\_\_init\_\_(indices, values, shape) }}\label{tf.sparsetensor.ux5fux5finitux5fux5findices-values-shape}

Creates a \texttt{SparseTensor}.

\subparagraph{Args: }\label{args}

\begin{itemize}
\tightlist
\item
  \texttt{indices}: A 2-D int64 tensor of shape
  \texttt{{[}N,\ ndims{]}}.
\item
  \texttt{values}: A 1-D tensor of any type and shape \texttt{{[}N{]}}.
\item
  \texttt{dense\_shape}: A 1-D int64 tensor of shape
  \texttt{{[}ndims{]}}.
\end{itemize}

\subparagraph{Returns: }\label{returns}

A \texttt{SparseTensor}

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\texttt{tf.SparseTensor.indices}
}{tf.SparseTensor.indices }}\label{tf.sparsetensor.indices}

The indices of non-zero values in the represented dense tensor.

\subparagraph{Returns: }\label{returns-1}

A 2-D Tensor of int64 with shape \texttt{{[}N,\ ndims{]}}, where
\texttt{N} is the number of non-zero values in the tensor, and
\texttt{ndims} is the rank.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\texttt{tf.SparseTensor.values}
}{tf.SparseTensor.values }}\label{tf.sparsetensor.values}

The non-zero values in the represented dense tensor.

\subparagraph{Returns: }\label{returns-2}

A 1-D Tensor of any data type.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\texttt{tf.SparseTensor.dtype}
}{tf.SparseTensor.dtype }}\label{tf.sparsetensor.dtype}

The \texttt{DType} of elements in this tensor.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\texttt{tf.SparseTensor.shape}
}{tf.SparseTensor.shape }}\label{tf.sparsetensor.shape}

A 1-D Tensor of int64 representing the shape of the dense tensor.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\texttt{tf.SparseTensor.graph}
}{tf.SparseTensor.graph }}\label{tf.sparsetensor.graph}

The \texttt{Graph} that contains the index, value, and shape tensors.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{class\ tf.SparseTensorValue}
}{class tf.SparseTensorValue }}\label{class-tf.sparsetensorvalue}

SparseTensorValue(indices, values, shape) - - -

\paragraph{\texorpdfstring{\texttt{tf.SparseTensorValue.indices}
}{tf.SparseTensorValue.indices }}\label{tf.sparsetensorvalue.indices}

Alias for field number 0

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\texttt{tf.SparseTensorValue.shape}
}{tf.SparseTensorValue.shape }}\label{tf.sparsetensorvalue.shape}

Alias for field number 2

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\texttt{tf.SparseTensorValue.values}
}{tf.SparseTensorValue.values }}\label{tf.sparsetensorvalue.values}

Alias for field number 1

\subsection{Sparse to Dense Conversion
}\label{sparse-to-dense-conversion}

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.sparse\_to\_dense(sparse\_indices,\ output\_shape,\ sparse\_values,\ default\_value,\ name=None)}
}{tf.sparse\_to\_dense(sparse\_indices, output\_shape, sparse\_values, default\_value, name=None) }}\label{tf.sparseux5ftoux5fdensesparseux5findices-outputux5fshape-sparseux5fvalues-defaultux5fvalue-namenone}

Converts a sparse representation into a dense tensor.

Builds an array \texttt{dense} with shape \texttt{output\_shape} such
that

\begin{verbatim}
# If sparse_indices is scalar
dense[i] = (i == sparse_indices ? sparse_values : default_value)

# If sparse_indices is a vector, then for each i
dense[sparse_indices[i]] = sparse_values[i]

# If sparse_indices is an n by d matrix, then for each i in [0, n)
dense[sparse_indices[i][0], ..., sparse_indices[i][d-1]] = sparse_values[i]
\end{verbatim}

All other values in \texttt{dense} are set to \texttt{default\_value}.
If \texttt{sparse\_values} is a scalar, all sparse indices are set to
this single value.

\subparagraph{Args: }\label{args-1}

\begin{itemize}
\tightlist
\item
  \texttt{sparse\_indices}: A \texttt{Tensor}. Must be one of the
  following types: \texttt{int32}, \texttt{int64}. 0-D, 1-D, or 2-D.
  \texttt{sparse\_indices{[}i{]}} contains the complete index where
  \texttt{sparse\_values{[}i{]}} will be placed.
\item
  \texttt{output\_shape}: A \texttt{Tensor}. Must have the same type as
  \texttt{sparse\_indices}. 1-D. Shape of the dense output tensor.
\item
  \texttt{sparse\_values}: A \texttt{Tensor}. 1-D. Values corresponding
  to each row of \texttt{sparse\_indices}, or a scalar value to be used
  for all sparse indices.
\item
  \texttt{default\_value}: A \texttt{Tensor}. Must have the same type as
  \texttt{sparse\_values}. Scalar value to set for indices not specified
  in \texttt{sparse\_indices}.
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-3}

A \texttt{Tensor}. Has the same type as \texttt{sparse\_values}. Dense
output tensor of shape \texttt{output\_shape}.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.sparse\_tensor\_to\_dense(sp\_input,\ default\_value,\ name=None)}
}{tf.sparse\_tensor\_to\_dense(sp\_input, default\_value, name=None) }}\label{tf.sparseux5ftensorux5ftoux5fdensespux5finput-defaultux5fvalue-namenone}

Converts a \texttt{SparseTensor} into a dense tensor.

This op is a convenience wrapper around \texttt{sparse\_to\_dense} for
\texttt{SparseTensor}s.

For example, if \texttt{sp\_input} has shape \texttt{{[}3,\ 5{]}} and
non-empty string values:

\begin{verbatim}
[0, 1]: a
[0, 3]: b
[2, 0]: c
\end{verbatim}

and \texttt{default\_value} is \texttt{x}, then the output will be a
dense \texttt{{[}3,\ 5{]}} string tensor with values:

\begin{verbatim}
[[x a x b x]
 [x x x x x]
 [c x x x x]]
\end{verbatim}

\subparagraph{Args: }\label{args-2}

\begin{itemize}
\tightlist
\item
  \texttt{sp\_input}: The input \texttt{SparseTensor}.
\item
  \texttt{default\_value}: Scalar value to set for indices not specified
  in \texttt{sp\_input}.
\item
  \texttt{name}: A name prefix for the returned tensors (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-4}

A dense tensor with shape \texttt{sp\_input.shape} and values specified
by the non-empty values in \texttt{sp\_input}. Indices not in
\texttt{sp\_input} are assigned \texttt{default\_value}.

\subparagraph{Raises: }\label{raises}

\begin{itemize}
\tightlist
\item
  \texttt{TypeError}: If \texttt{sp\_input} is not a
  \texttt{SparseTensor}.
\end{itemize}

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.sparse\_to\_indicator(sp\_input,\ vocab\_size,\ name=None)}
}{tf.sparse\_to\_indicator(sp\_input, vocab\_size, name=None) }}\label{tf.sparseux5ftoux5findicatorspux5finput-vocabux5fsize-namenone}

Converts a \texttt{SparseTensor} of ids into a dense bool indicator
tensor.

The last dimension of \texttt{sp\_input} is discarded and replaced with
the values of \texttt{sp\_input}. If
\texttt{sp\_input.shape\ =\ {[}D0,\ D1,\ ...,\ Dn,\ K{]}}, then
\texttt{output.shape\ =\ {[}D0,\ D1,\ ...,\ Dn,\ vocab\_size{]}}, where

\begin{verbatim}
output[d_0, d_1, ..., d_n, sp_input[d_0, d_1, ..., d_n, k]] = True
\end{verbatim}

and False elsewhere in \texttt{output}.

For example, if \texttt{sp\_input.shape\ =\ {[}2,\ 3,\ 4{]}} with
non-empty values:

\begin{verbatim}
[0, 0, 0]: 0
[0, 1, 0]: 10
[1, 0, 3]: 103
[1, 1, 2]: 112
[1, 1, 3]: 113
[1, 2, 1]: 121
\end{verbatim}

and \texttt{vocab\_size\ =\ 200}, then the output will be a
\texttt{{[}2,\ 3,\ 200{]}} dense bool tensor with False everywhere
except at positions

\begin{verbatim}
(0, 0, 0), (0, 1, 10), (1, 0, 103), (1, 1, 112), (1, 1, 113), (1, 2, 121).
\end{verbatim}

This op is useful for converting \texttt{SparseTensor}s into dense
formats for compatibility with ops that expect dense tensors.

The input \texttt{SparseTensor} must be in row-major order.

\subparagraph{Args: }\label{args-3}

\begin{itemize}
\tightlist
\item
  \texttt{sp\_input}: A \texttt{SparseTensor} of type \texttt{int32} or
  \texttt{int64}.
\item
  \texttt{vocab\_size}: The new size of the last dimension, with
  \texttt{all(0\ \textless{}=\ sp\_input.values\ \textless{}\ vocab\_size)}.
\item
  \texttt{name}: A name prefix for the returned tensors (optional)
\end{itemize}

\subparagraph{Returns: }\label{returns-5}

A dense bool indicator tensor representing the indices with specified
value.

\subparagraph{Raises: }\label{raises-1}

\begin{itemize}
\tightlist
\item
  \texttt{TypeError}: If \texttt{sp\_input} is not a
  \texttt{SparseTensor}.
\end{itemize}

\subsection{Manipulation }\label{manipulation}

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.sparse\_concat(concat\_dim,\ sp\_inputs,\ name=None)}
}{tf.sparse\_concat(concat\_dim, sp\_inputs, name=None) }}\label{tf.sparseux5fconcatconcatux5fdim-spux5finputs-namenone}

Concatenates a list of \texttt{SparseTensor} along the specified
dimension.

Concatenation is with respect to the dense versions of each sparse
input. It is assumed that each inputs is a \texttt{SparseTensor} whose
elements are ordered along increasing dimension number.

All inputs' shapes must match, except for the concat dimension. The
\texttt{indices}, \texttt{values}, and \texttt{shapes} lists must have
the same length.

The output shape is identical to the inputs', except along the concat
dimension, where it is the sum of the inputs' sizes along that
dimension.

The output elements will be resorted to preserve the sort order along
increasing dimension number.

This op runs in \texttt{O(M\ log\ M)} time, where \texttt{M} is the
total number of non-empty values across all inputs. This is due to the
need for an internal sort in order to concatenate efficiently across an
arbitrary dimension.

For example, if \texttt{concat\_dim\ =\ 1} and the inputs are

\begin{verbatim}
sp_inputs[0]: shape = [2, 3]
[0, 2]: "a"
[1, 0]: "b"
[1, 1]: "c"

sp_inputs[1]: shape = [2, 4]
[0, 1]: "d"
[0, 2]: "e"
\end{verbatim}

then the output will be

\begin{verbatim}
shape = [2, 7]
[0, 2]: "a"
[0, 4]: "d"
[0, 5]: "e"
[1, 0]: "b"
[1, 1]: "c"
\end{verbatim}

Graphically this is equivalent to doing

\begin{verbatim}
[    a] concat [  d e  ] = [    a   d e  ]
[b c  ]        [       ]   [b c          ]
\end{verbatim}

\subparagraph{Args: }\label{args-4}

\begin{itemize}
\tightlist
\item
  \texttt{concat\_dim}: Dimension to concatenate along.
\item
  \texttt{sp\_inputs}: List of \texttt{SparseTensor} to concatenate.
\item
  \texttt{name}: A name prefix for the returned tensors (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-6}

A \texttt{SparseTensor} with the concatenated output.

\subparagraph{Raises: }\label{raises-2}

\begin{itemize}
\tightlist
\item
  \texttt{TypeError}: If \texttt{sp\_inputs} is not a list of
  \texttt{SparseTensor}.
\end{itemize}

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.sparse\_reorder(sp\_input,\ name=None)}
}{tf.sparse\_reorder(sp\_input, name=None) }}\label{tf.sparseux5freorderspux5finput-namenone}

Reorders a \texttt{SparseTensor} into the canonical, row-major ordering.

Note that by convention, all sparse ops preserve the canonical ordering
along increasing dimension number. The only time ordering can be
violated is during manual manipulation of the indices and values to add
entries.

Reordering does not affect the shape of the \texttt{SparseTensor}.

For example, if sp\_input has shape \texttt{{[}4,\ 5{]}} and
\texttt{indices} / \texttt{values}:

\begin{verbatim}
[0, 3]: b
[0, 1]: a
[3, 1]: d
[2, 0]: c
\end{verbatim}

then the output will be a \texttt{SparseTensor} of shape
\texttt{{[}4,\ 5{]}} and \texttt{indices} / \texttt{values}:

\begin{verbatim}
[0, 1]: a
[0, 3]: b
[2, 0]: c
[3, 1]: d
\end{verbatim}

\subparagraph{Args: }\label{args-5}

\begin{itemize}
\tightlist
\item
  \texttt{sp\_input}: The input \texttt{SparseTensor}.
\item
  \texttt{name}: A name prefix for the returned tensors (optional)
\end{itemize}

\subparagraph{Returns: }\label{returns-7}

A \texttt{SparseTensor} with the same shape and non-empty values, but in
canonical ordering.

\subparagraph{Raises: }\label{raises-3}

\begin{itemize}
\tightlist
\item
  \texttt{TypeError}: If \texttt{sp\_input} is not a
  \texttt{SparseTensor}.
\end{itemize}

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.sparse\_retain(sp\_input,\ to\_retain)}
}{tf.sparse\_retain(sp\_input, to\_retain) }}\label{tf.sparseux5fretainspux5finput-toux5fretain}

Retains specified non-empty values within a \texttt{SparseTensor}.

For example, if \texttt{sp\_input} has shape \texttt{{[}4,\ 5{]}} and 4
non-empty string values:

\begin{verbatim}
[0, 1]: a
[0, 3]: b
[2, 0]: c
[3, 1]: d
\end{verbatim}

and \texttt{to\_retain\ =\ {[}True,\ False,\ False,\ True{]}}, then the
output will be a \texttt{SparseTensor} of shape \texttt{{[}4,\ 5{]}}
with 2 non-empty values:

\begin{verbatim}
[0, 1]: a
[3, 1]: d
\end{verbatim}

\subparagraph{Args: }\label{args-6}

\begin{itemize}
\tightlist
\item
  \texttt{sp\_input}: The input \texttt{SparseTensor} with \texttt{N}
  non-empty elements.
\item
  \texttt{to\_retain}: A bool vector of length \texttt{N} with
  \texttt{M} true values.
\end{itemize}

\subparagraph{Returns: }\label{returns-8}

A \texttt{SparseTensor} with the same shape as the input and \texttt{M}
non-empty elements corresponding to the true positions in
\texttt{to\_retain}.

\subparagraph{Raises: }\label{raises-4}

\begin{itemize}
\tightlist
\item
  \texttt{TypeError}: If \texttt{sp\_input} is not a
  \texttt{SparseTensor}.
\end{itemize}

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.sparse\_fill\_empty\_rows(sp\_input,\ default\_value,\ name=None)}
}{tf.sparse\_fill\_empty\_rows(sp\_input, default\_value, name=None) }}\label{tf.sparseux5ffillux5femptyux5frowsspux5finput-defaultux5fvalue-namenone}

Fills empty rows in the input 2-D \texttt{SparseTensor} with a default
value.

This op adds entries with the specified \texttt{default\_value} at index
\texttt{{[}row,\ 0{]}} for any row in the input that does not already
have a value.

For example, suppose \texttt{sp\_input} has shape \texttt{{[}5,\ 6{]}}
and non-empty values:

\begin{verbatim}
[0, 1]: a
[0, 3]: b
[2, 0]: c
[3, 1]: d
\end{verbatim}

Rows 1 and 4 are empty, so the output will be of shape
\texttt{{[}5,\ 6{]}} with values:

\begin{verbatim}
[0, 1]: a
[0, 3]: b
[1, 0]: default_value
[2, 0]: c
[3, 1]: d
[4, 0]: default_value
\end{verbatim}

Note that the input may have empty columns at the end, with no effect on
this op.

The output \texttt{SparseTensor} will be in row-major order and will
have the same shape as the input.

This op also returns an indicator vector such that

\begin{verbatim}
empty_row_indicator[i] = True iff row i was an empty row.
\end{verbatim}

\subparagraph{Args: }\label{args-7}

\begin{itemize}
\tightlist
\item
  \texttt{sp\_input}: A \texttt{SparseTensor} with shape
  \texttt{{[}N,\ M{]}}.
\item
  \texttt{default\_value}: The value to fill for empty rows, with the
  same type as \texttt{sp\_input.}
\item
  \texttt{name}: A name prefix for the returned tensors (optional)
\end{itemize}

\subparagraph{Returns: }\label{returns-9}

\begin{itemize}
\tightlist
\item
  \texttt{sp\_ordered\_output}: A \texttt{SparseTensor} with shape
  \texttt{{[}N,\ M{]}}, and with all empty rows filled in with
  \texttt{default\_value}.
\item
  \texttt{empty\_row\_indicator}: A bool vector of length \texttt{N}
  indicating whether each input row was empty.
\end{itemize}

\subparagraph{Raises: }\label{raises-5}

\begin{itemize}
\tightlist
\item
  \texttt{TypeError}: If \texttt{sp\_input} is not a
  \texttt{SparseTensor}.
\end{itemize}

