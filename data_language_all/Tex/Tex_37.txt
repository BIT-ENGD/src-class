

\section{Control Flow }\label{control-flow}

Note: Functions taking \texttt{Tensor} arguments can also take anything
accepted by
\href{../../api_docs/python/framework.md\#convert_to_tensor}{\texttt{tf.convert\_to\_tensor}}.

\subsection{Contents}\label{contents}

\subsubsection{\texorpdfstring{\protect\hyperlink{AUTOGENERATED-control-flow}{Control
Flow}}{Control Flow}}\label{control-flow-1}

\begin{itemize}
\tightlist
\item
  \protect\hyperlink{AUTOGENERATED-control-flow-operations}{Control Flow
  Operations}
\item
  \protect\hyperlink{identity}{\texttt{tf.identity(input,\ name=None)}}
\item
  \protect\hyperlink{tuple}{\texttt{tf.tuple(tensors,\ name=None,\ control\_inputs=None)}}
\item
  \protect\hyperlink{group}{\texttt{tf.group(*inputs,\ **kwargs)}}
\item
  \protect\hyperlink{noux5fop}{\texttt{tf.no\_op(name=None)}}
\item
  \protect\hyperlink{countux5fupux5fto}{\texttt{tf.count\_up\_to(ref,\ limit,\ name=None)}}
\item
  \protect\hyperlink{AUTOGENERATED-logical-operators}{Logical Operators}
\item
  \protect\hyperlink{logicalux5fand}{\texttt{tf.logical\_and(x,\ y,\ name=None)}}
\item
  \protect\hyperlink{logicalux5fnot}{\texttt{tf.logical\_not(x,\ name=None)}}
\item
  \protect\hyperlink{logicalux5for}{\texttt{tf.logical\_or(x,\ y,\ name=None)}}
\item
  \protect\hyperlink{logicalux5fxor}{\texttt{tf.logical\_xor(x,\ y,\ name=\textquotesingle{}LogicalXor\textquotesingle{})}}
\item
  \protect\hyperlink{AUTOGENERATED-comparison-operators}{Comparison
  Operators}
\item
  \protect\hyperlink{equal}{\texttt{tf.equal(x,\ y,\ name=None)}}
\item
  \protect\hyperlink{notux5fequal}{\texttt{tf.not\_equal(x,\ y,\ name=None)}}
\item
  \protect\hyperlink{less}{\texttt{tf.less(x,\ y,\ name=None)}}
\item
  \protect\hyperlink{lessux5fequal}{\texttt{tf.less\_equal(x,\ y,\ name=None)}}
\item
  \protect\hyperlink{greater}{\texttt{tf.greater(x,\ y,\ name=None)}}
\item
  \protect\hyperlink{greaterux5fequal}{\texttt{tf.greater\_equal(x,\ y,\ name=None)}}
\item
  \protect\hyperlink{select}{\texttt{tf.select(condition,\ t,\ e,\ name=None)}}
\item
  \protect\hyperlink{where}{\texttt{tf.where(input,\ name=None)}}
\item
  \protect\hyperlink{AUTOGENERATED-debugging-operations}{Debugging
  Operations}
\item
  \protect\hyperlink{isux5ffinite}{\texttt{tf.is\_finite(x,\ name=None)}}
\item
  \protect\hyperlink{isux5finf}{\texttt{tf.is\_inf(x,\ name=None)}}
\item
  \protect\hyperlink{isux5fnan}{\texttt{tf.is\_nan(x,\ name=None)}}
\item
  \protect\hyperlink{verifyux5ftensorux5fallux5ffinite}{\texttt{tf.verify\_tensor\_all\_finite(t,\ msg,\ name=None)}}
\item
  \protect\hyperlink{checkux5fnumerics}{\texttt{tf.check\_numerics(tensor,\ message,\ name=None)}}
\item
  \protect\hyperlink{addux5fcheckux5fnumericsux5fops}{\texttt{tf.add\_check\_numerics\_ops()}}
\item
  \protect\hyperlink{Assert}{\texttt{tf.Assert(condition,\ data,\ summarize=None,\ name=None)}}
\item
  \protect\hyperlink{Print}{\texttt{tf.Print(input\_,\ data,\ message=None,\ first\_n=None,\ summarize=None,\ name=None)}}
\end{itemize}

\subsection{Control Flow Operations }\label{control-flow-operations}

TensorFlow provides several operations and classes that you can use to
control the execution of operations and add conditional dependencies to
your graph.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.identity(input,\ name=None)}
}{tf.identity(input, name=None) }}\label{tf.identityinput-namenone}

Return a tensor with the same shape and contents as the input tensor or
value.

\subparagraph{Args: }\label{args}

\begin{itemize}
\tightlist
\item
  \texttt{input}: A \texttt{Tensor}.
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns}

A \texttt{Tensor}. Has the same type as \texttt{input}.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.tuple(tensors,\ name=None,\ control\_inputs=None)}
}{tf.tuple(tensors, name=None, control\_inputs=None) }}\label{tf.tupletensors-namenone-controlux5finputsnone}

Group tensors together.

This creates a tuple of tensors with the same values as the
\texttt{tensors} argument, except that the value of each tensor is only
returned after the values of all tensors have been computed.

\texttt{control\_inputs} contains additional ops that have to finish
before this op finishes, but whose outputs are not returned.

This can be used as a ``join'' mechanism for parallel computations: all
the argument tensors can be computed in parallel, but the values of any
tensor returned by \texttt{tuple} are only available after all the
parallel computations are done.

See also \texttt{group} and \texttt{with\_dependencies}.

\subparagraph{Args: }\label{args-1}

\begin{itemize}
\tightlist
\item
  \texttt{tensors}: A list of \texttt{Tensor}s or
  \texttt{IndexedSlices}, some entries can be \texttt{None}.
\item
  \texttt{name}: (optional) A name to use as a \texttt{name\_scope} for
  the operation.
\item
  \texttt{control\_inputs}: List of additional ops to finish before
  returning.
\end{itemize}

\subparagraph{Returns: }\label{returns-1}

Same as \texttt{tensors}.

\subparagraph{Raises: }\label{raises}

\begin{itemize}
\tightlist
\item
  \texttt{ValueError}: If \texttt{tensors} does not contain any
  \texttt{Tensor} or \texttt{IndexedSlices}.
\end{itemize}

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.group(*inputs,\ **kwargs)}
}{tf.group(*inputs, **kwargs) }}\label{tf.groupinputs-kwargs}

Create an op that groups multiple operations.

When this op finishes, all ops in \texttt{input} have finished. This op
has no output.

See also \texttt{tuple} and \texttt{with\_dependencies}.

\subparagraph{Args: }\label{args-2}

\begin{itemize}
\tightlist
\item
  \texttt{*inputs}: One or more tensors to group.
\item
  \texttt{**kwargs}: Optional parameters to pass when constructing the
  NodeDef.
\item
  \texttt{name}: A name for this operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-2}

An Operation that executes all its inputs.

\subparagraph{Raises: }\label{raises-1}

\begin{itemize}
\tightlist
\item
  \texttt{ValueError}: If an unknown keyword argument is provided, or if
  there are no inputs.
\end{itemize}

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.no\_op(name=None)}
}{tf.no\_op(name=None) }}\label{tf.noux5fopnamenone}

Does nothing. Only useful as a placeholder for control edges.

\subparagraph{Args: }\label{args-3}

\begin{itemize}
\tightlist
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-3}

The created Operation.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.count\_up\_to(ref,\ limit,\ name=None)}
}{tf.count\_up\_to(ref, limit, name=None) }}\label{tf.countux5fupux5ftoref-limit-namenone}

Increments `ref' until it reaches `limit'.

This operation outputs ``ref'' after the update is done. This makes it
easier to chain operations that need to use the updated value.

\subparagraph{Args: }\label{args-4}

\begin{itemize}
\tightlist
\item
  \texttt{ref}: A mutable \texttt{Tensor}. Must be one of the following
  types: \texttt{int32}, \texttt{int64}. Should be from a scalar
  \texttt{Variable} node.
\item
  \texttt{limit}: An \texttt{int}. If incrementing ref would bring it
  above limit, instead generates an `OutOfRange' error.
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-4}

A \texttt{Tensor}. Has the same type as \texttt{ref}. A copy of the
input before increment. If nothing else modifies the input, the values
produced will all be distinct.

\subsection{Logical Operators }\label{logical-operators}

TensorFlow provides several operations that you can use to add logical
operators to your graph.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.logical\_and(x,\ y,\ name=None)}
}{tf.logical\_and(x, y, name=None) }}\label{tf.logicalux5fandx-y-namenone}

Returns the truth value of x AND y element-wise.

\subparagraph{Args: }\label{args-5}

\begin{itemize}
\tightlist
\item
  \texttt{x}: A \texttt{Tensor} of type \texttt{bool}.
\item
  \texttt{y}: A \texttt{Tensor} of type \texttt{bool}.
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-5}

A \texttt{Tensor} of type \texttt{bool}.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.logical\_not(x,\ name=None)}
}{tf.logical\_not(x, name=None) }}\label{tf.logicalux5fnotx-namenone}

Returns the truth value of NOT x element-wise.

\subparagraph{Args: }\label{args-6}

\begin{itemize}
\tightlist
\item
  \texttt{x}: A \texttt{Tensor} of type \texttt{bool}.
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-6}

A \texttt{Tensor} of type \texttt{bool}.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.logical\_or(x,\ y,\ name=None)}
}{tf.logical\_or(x, y, name=None) }}\label{tf.logicalux5forx-y-namenone}

Returns the truth value of x OR y element-wise.

\subparagraph{Args: }\label{args-7}

\begin{itemize}
\tightlist
\item
  \texttt{x}: A \texttt{Tensor} of type \texttt{bool}.
\item
  \texttt{y}: A \texttt{Tensor} of type \texttt{bool}.
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-7}

A \texttt{Tensor} of type \texttt{bool}.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.logical\_xor(x,\ y,\ name=\textquotesingle{}LogicalXor\textquotesingle{})}
}{tf.logical\_xor(x, y, name='LogicalXor') }}\label{tf.logicalux5fxorx-y-namelogicalxor}

x \^{} y = (x \textbar{} y) \& \textasciitilde{}(x \& y).

\subsection{Comparison Operators }\label{comparison-operators}

TensorFlow provides several operations that you can use to add
comparison operators to your graph.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.equal(x,\ y,\ name=None)}
}{tf.equal(x, y, name=None) }}\label{tf.equalx-y-namenone}

Returns the truth value of (x == y) element-wise.

\subparagraph{Args: }\label{args-8}

\begin{itemize}
\tightlist
\item
  \texttt{x}: A \texttt{Tensor}. Must be one of the following types:
  \texttt{float32}, \texttt{float64}, \texttt{int32}, \texttt{int64},
  \texttt{complex64}, \texttt{quint8}, \texttt{qint8}, \texttt{qint32}.
\item
  \texttt{y}: A \texttt{Tensor}. Must have the same type as \texttt{x}.
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-8}

A \texttt{Tensor} of type \texttt{bool}.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.not\_equal(x,\ y,\ name=None)}
}{tf.not\_equal(x, y, name=None) }}\label{tf.notux5fequalx-y-namenone}

Returns the truth value of (x != y) element-wise.

\subparagraph{Args: }\label{args-9}

\begin{itemize}
\tightlist
\item
  \texttt{x}: A \texttt{Tensor}. Must be one of the following types:
  \texttt{float32}, \texttt{float64}, \texttt{int32}, \texttt{int64},
  \texttt{complex64}, \texttt{quint8}, \texttt{qint8}, \texttt{qint32}.
\item
  \texttt{y}: A \texttt{Tensor}. Must have the same type as \texttt{x}.
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-9}

A \texttt{Tensor} of type \texttt{bool}.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.less(x,\ y,\ name=None)}
}{tf.less(x, y, name=None) }}\label{tf.lessx-y-namenone}

Returns the truth value of (x \textless{} y) element-wise.

\subparagraph{Args: }\label{args-10}

\begin{itemize}
\tightlist
\item
  \texttt{x}: A \texttt{Tensor}. Must be one of the following types:
  \texttt{float32}, \texttt{float64}, \texttt{int32}, \texttt{int64}.
\item
  \texttt{y}: A \texttt{Tensor}. Must have the same type as \texttt{x}.
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-10}

A \texttt{Tensor} of type \texttt{bool}.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.less\_equal(x,\ y,\ name=None)}
}{tf.less\_equal(x, y, name=None) }}\label{tf.lessux5fequalx-y-namenone}

Returns the truth value of (x \textless{}= y) element-wise.

\subparagraph{Args: }\label{args-11}

\begin{itemize}
\tightlist
\item
  \texttt{x}: A \texttt{Tensor}. Must be one of the following types:
  \texttt{float32}, \texttt{float64}, \texttt{int32}, \texttt{int64}.
\item
  \texttt{y}: A \texttt{Tensor}. Must have the same type as \texttt{x}.
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-11}

A \texttt{Tensor} of type \texttt{bool}.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.greater(x,\ y,\ name=None)}
}{tf.greater(x, y, name=None) }}\label{tf.greaterx-y-namenone}

Returns the truth value of (x \textgreater{} y) element-wise.

\subparagraph{Args: }\label{args-12}

\begin{itemize}
\tightlist
\item
  \texttt{x}: A \texttt{Tensor}. Must be one of the following types:
  \texttt{float32}, \texttt{float64}, \texttt{int32}, \texttt{int64}.
\item
  \texttt{y}: A \texttt{Tensor}. Must have the same type as \texttt{x}.
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-12}

A \texttt{Tensor} of type \texttt{bool}.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.greater\_equal(x,\ y,\ name=None)}
}{tf.greater\_equal(x, y, name=None) }}\label{tf.greaterux5fequalx-y-namenone}

Returns the truth value of (x \textgreater{}= y) element-wise.

\subparagraph{Args: }\label{args-13}

\begin{itemize}
\tightlist
\item
  \texttt{x}: A \texttt{Tensor}. Must be one of the following types:
  \texttt{float32}, \texttt{float64}, \texttt{int32}, \texttt{int64}.
\item
  \texttt{y}: A \texttt{Tensor}. Must have the same type as \texttt{x}.
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-13}

A \texttt{Tensor} of type \texttt{bool}.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.select(condition,\ t,\ e,\ name=None)}
}{tf.select(condition, t, e, name=None) }}\label{tf.selectcondition-t-e-namenone}

Selects elements from \texttt{t} or \texttt{e}, depending on
\texttt{condition}.

The \texttt{condition}, \texttt{t}, and \texttt{e} tensors must all have
the same shape, and the output will also have that shape. The
\texttt{condition} tensor acts as an element-wise mask that chooses,
based on the value at each element, whether the corresponding element in
the output should be taken from \texttt{t} (if true) or \texttt{e} (if
false). For example:

For example:

\begin{verbatim}
# 'condition' tensor is [[True, False]
#                        [True, False]]
# 't' is [[1, 1],
#         [1, 1]]
# 'e' is [[2, 2],
#         [2, 2]]
select(condition, t, e) ==> [[1, 2],
                             [1, 2]]
\end{verbatim}

\subparagraph{Args: }\label{args-14}

\begin{itemize}
\tightlist
\item
  \texttt{condition}: A \texttt{Tensor} of type \texttt{bool}.
\item
  \texttt{t}: A \texttt{Tensor} with the same shape as
  \texttt{condition}.
\item
  \texttt{e}: A \texttt{Tensor} with the same type and shape as
  \texttt{t}.
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-14}

A \texttt{Tensor} with the same type and shape as \texttt{t} and
\texttt{e}.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.where(input,\ name=None)}
}{tf.where(input, name=None) }}\label{tf.whereinput-namenone}

Returns locations of true values in a boolean tensor.

This operation returns the coordinates of true elements in
\texttt{input}. The coordinates are returned in a 2-D tensor where the
first dimension (rows) represents the number of true elements, and the
second dimension (columns) represents the coordinates of the true
elements. Keep in mind, the shape of the output tensor can vary
depending on how many true values there are in \texttt{input}. Indices
are output in row-major order.

For example:

\begin{verbatim}
# 'input' tensor is [[True, False]
#                    [True, False]]
# 'input' has two true values, so output has two coordinates.
# 'input' has rank of 2, so coordinates have two indices.
where(input) ==> [[0, 0],
                  [1, 0]]

# `input` tensor is [[[True, False]
#                     [True, False]]
#                    [[False, True]
#                     [False, True]]
#                    [[False, False]
#                     [False, True]]]
# 'input' has 5 true values, so output has 5 coordinates.
# 'input' has rank of 3, so coordinates have three indices.
where(input) ==> [[0, 0, 0],
                  [0, 1, 0],
                  [1, 0, 1],
                  [1, 1, 1],
                  [2, 1, 1]]
\end{verbatim}

\subparagraph{Args: }\label{args-15}

\begin{itemize}
\tightlist
\item
  \texttt{input}: A \texttt{Tensor} of type \texttt{bool}.
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-15}

A \texttt{Tensor} of type \texttt{int64}.

\subsection{Debugging Operations }\label{debugging-operations}

TensorFlow provides several operations that you can use to validate
values and debug your graph.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.is\_finite(x,\ name=None)}
}{tf.is\_finite(x, name=None) }}\label{tf.isux5ffinitex-namenone}

Returns which elements of x are finite.

\subparagraph{Args: }\label{args-16}

\begin{itemize}
\tightlist
\item
  \texttt{x}: A \texttt{Tensor}. Must be one of the following types:
  \texttt{float32}, \texttt{float64}.
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-16}

A \texttt{Tensor} of type \texttt{bool}.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.is\_inf(x,\ name=None)}
}{tf.is\_inf(x, name=None) }}\label{tf.isux5finfx-namenone}

Returns which elements of x are Inf.

\subparagraph{Args: }\label{args-17}

\begin{itemize}
\tightlist
\item
  \texttt{x}: A \texttt{Tensor}. Must be one of the following types:
  \texttt{float32}, \texttt{float64}.
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-17}

A \texttt{Tensor} of type \texttt{bool}.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.is\_nan(x,\ name=None)}
}{tf.is\_nan(x, name=None) }}\label{tf.isux5fnanx-namenone}

Returns which elements of x are NaN.

\subparagraph{Args: }\label{args-18}

\begin{itemize}
\tightlist
\item
  \texttt{x}: A \texttt{Tensor}. Must be one of the following types:
  \texttt{float32}, \texttt{float64}.
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-18}

A \texttt{Tensor} of type \texttt{bool}.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.verify\_tensor\_all\_finite(t,\ msg,\ name=None)}
}{tf.verify\_tensor\_all\_finite(t, msg, name=None) }}\label{tf.verifyux5ftensorux5fallux5ffinitet-msg-namenone}

Assert that the tensor does not contain any NaN's or Inf's.

\subparagraph{Args: }\label{args-19}

\begin{itemize}
\tightlist
\item
  \texttt{t}: Tensor to check.
\item
  \texttt{msg}: Message to log on failure.
\item
  \texttt{name}: A name for this operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-19}

Same tensor as \texttt{t}.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.check\_numerics(tensor,\ message,\ name=None)}
}{tf.check\_numerics(tensor, message, name=None) }}\label{tf.checkux5fnumericstensor-message-namenone}

Checks a tensor for NaN and Inf values.

When run, reports an \texttt{InvalidArgument} error if \texttt{tensor}
has any values that are not a number (NaN) or infinity (Inf). Otherwise,
passes \texttt{tensor} as-is.

\subparagraph{Args: }\label{args-20}

\begin{itemize}
\tightlist
\item
  \texttt{tensor}: A \texttt{Tensor}. Must be one of the following
  types: \texttt{float32}, \texttt{float64}.
\item
  \texttt{message}: A \texttt{string}. Prefix of the error message.
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-20}

A \texttt{Tensor}. Has the same type as \texttt{tensor}.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.add\_check\_numerics\_ops()}
}{tf.add\_check\_numerics\_ops() }}\label{tf.addux5fcheckux5fnumericsux5fops}

Connect a check\_numerics to every floating point tensor.

\texttt{check\_numerics} operations themselves are added for each
\texttt{float} or \texttt{double} tensor in the graph. For all ops in
the graph, the \texttt{check\_numerics} op for all of its
(\texttt{float} or \texttt{double}) inputs is guaranteed to run before
the \texttt{check\_numerics} op on any of its outputs.

\subparagraph{Returns: }\label{returns-21}

A \texttt{group} op depending on all \texttt{check\_numerics} ops added.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.Assert(condition,\ data,\ summarize=None,\ name=None)}
}{tf.Assert(condition, data, summarize=None, name=None) }}\label{tf.assertcondition-data-summarizenone-namenone}

Asserts that the given condition is true.

If \texttt{condition} evaluates to false, print the list of tensors in
\texttt{data}. \texttt{summarize} determines how many entries of the
tensors to print.

\subparagraph{Args: }\label{args-21}

\begin{itemize}
\tightlist
\item
  \texttt{condition}: The condition to evaluate.
\item
  \texttt{data}: The tensors to print out when condition is false.
\item
  \texttt{summarize}: Print this many entries of each tensor.
\item
  \texttt{name}: A name for this operation (optional).
\end{itemize}

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.Print(input\_,\ data,\ message=None,\ first\_n=None,\ summarize=None,\ name=None)}
}{tf.Print(input\_, data, message=None, first\_n=None, summarize=None, name=None) }}\label{tf.printinputux5f-data-messagenone-firstux5fnnone-summarizenone-namenone}

Prints a list of tensors.

This is an identity op with the side effect of printing \texttt{data}
when evaluating.

\subparagraph{Args: }\label{args-22}

\begin{itemize}
\tightlist
\item
  \texttt{input\_}: A tensor passed through this op.
\item
  \texttt{data}: A list of tensors to print out when op is evaluated.
\item
  \texttt{message}: A string, prefix of the error message.
\item
  \texttt{first\_n}: Only log \texttt{first\_n} number of times.
  Negative numbers log always; this is the default.
\item
  \texttt{summarize}: Only print this many entries of each tensor.
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-22}

Same tensor as \texttt{input\_}.

