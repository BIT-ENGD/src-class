


\section{Images }\label{images}

Note: Functions taking \texttt{Tensor} arguments can also take anything
accepted by
\href{../../api_docs/python/framework.md\#convert_to_tensor}{\texttt{tf.convert\_to\_tensor}}.

\subsection{Contents}\label{contents}

\subsubsection{\texorpdfstring{\protect\hyperlink{AUTOGENERATED-images}{Images}}{Images}}\label{images-1}

\begin{itemize}
\tightlist
\item
  \protect\hyperlink{AUTOGENERATED-encoding-and-decoding}{Encoding and
  Decoding}
\item
  \protect\hyperlink{decodeux5fjpeg}{\texttt{tf.image.decode\_jpeg(contents,\ channels=None,\ ratio=None,\ fancy\_upscaling=None,\ try\_recover\_truncated=None,\ acceptable\_fraction=None,\ name=None)}}
\item
  \protect\hyperlink{encodeux5fjpeg}{\texttt{tf.image.encode\_jpeg(image,\ format=None,\ quality=None,\ progressive=None,\ optimize\_size=None,\ chroma\_downsampling=None,\ density\_unit=None,\ x\_density=None,\ y\_density=None,\ xmp\_metadata=None,\ name=None)}}
\item
  \protect\hyperlink{decodeux5fpng}{\texttt{tf.image.decode\_png(contents,\ channels=None,\ name=None)}}
\item
  \protect\hyperlink{encodeux5fpng}{\texttt{tf.image.encode\_png(image,\ compression=None,\ name=None)}}
\item
  \protect\hyperlink{AUTOGENERATED-resizing}{Resizing}
\item
  \protect\hyperlink{resizeux5fimages}{\texttt{tf.image.resize\_images(images,\ new\_height,\ new\_width,\ method=0)}}
\item
  \protect\hyperlink{resizeux5farea}{\texttt{tf.image.resize\_area(images,\ size,\ name=None)}}
\item
  \protect\hyperlink{resizeux5fbicubic}{\texttt{tf.image.resize\_bicubic(images,\ size,\ name=None)}}
\item
  \protect\hyperlink{resizeux5fbilinear}{\texttt{tf.image.resize\_bilinear(images,\ size,\ name=None)}}
\item
  \protect\hyperlink{resizeux5fnearestux5fneighbor}{\texttt{tf.image.resize\_nearest\_neighbor(images,\ size,\ name=None)}}
\item
  \protect\hyperlink{AUTOGENERATED-cropping}{Cropping}
\item
  \protect\hyperlink{resizeux5fimageux5fwithux5fcropux5forux5fpad}{\texttt{tf.image.resize\_image\_with\_crop\_or\_pad(image,\ target\_height,\ target\_width)}}
\item
  \protect\hyperlink{padux5ftoux5fboundingux5fbox}{\texttt{tf.image.pad\_to\_bounding\_box(image,\ offset\_height,\ offset\_width,\ target\_height,\ target\_width)}}
\item
  \protect\hyperlink{cropux5ftoux5fboundingux5fbox}{\texttt{tf.image.crop\_to\_bounding\_box(image,\ offset\_height,\ offset\_width,\ target\_height,\ target\_width)}}
\item
  \protect\hyperlink{randomux5fcrop}{\texttt{tf.image.random\_crop(image,\ size,\ seed=None,\ name=None)}}
\item
  \protect\hyperlink{extractux5fglimpse}{\texttt{tf.image.extract\_glimpse(input,\ size,\ offsets,\ centered=None,\ normalized=None,\ uniform\_noise=None,\ name=None)}}
\item
  \protect\hyperlink{AUTOGENERATED-flipping-and-transposing}{Flipping
  and Transposing}
\item
  \protect\hyperlink{flipux5fupux5fdown}{\texttt{tf.image.flip\_up\_down(image)}}
\item
  \protect\hyperlink{randomux5fflipux5fupux5fdown}{\texttt{tf.image.random\_flip\_up\_down(image,\ seed=None)}}
\item
  \protect\hyperlink{flipux5fleftux5fright}{\texttt{tf.image.flip\_left\_right(image)}}
\item
  \protect\hyperlink{randomux5fflipux5fleftux5fright}{\texttt{tf.image.random\_flip\_left\_right(image,\ seed=None)}}
\item
  \protect\hyperlink{transposeux5fimage}{\texttt{tf.image.transpose\_image(image)}}
\item
  \protect\hyperlink{AUTOGENERATED-image-adjustments}{Image Adjustments}
\item
  \protect\hyperlink{adjustux5fbrightness}{\texttt{tf.image.adjust\_brightness(image,\ delta,\ min\_value=None,\ max\_value=None)}}
\item
  \protect\hyperlink{randomux5fbrightness}{\texttt{tf.image.random\_brightness(image,\ max\_delta,\ seed=None)}}
\item
  \protect\hyperlink{adjustux5fcontrast}{\texttt{tf.image.adjust\_contrast(images,\ contrast\_factor,\ min\_value=None,\ max\_value=None)}}
\item
  \protect\hyperlink{randomux5fcontrast}{\texttt{tf.image.random\_contrast(image,\ lower,\ upper,\ seed=None)}}
\item
  \protect\hyperlink{perux5fimageux5fwhitening}{\texttt{tf.image.per\_image\_whitening(image)}}
\end{itemize}

\subsection{Encoding and Decoding }\label{encoding-and-decoding}

TensorFlow provides Ops to decode and encode JPEG and PNG formats.
Encoded images are represented by scalar string Tensors, decoded images
by 3-D uint8 tensors of shape \texttt{{[}height,\ width,\ channels{]}}.

The encode and decode Ops apply to one image at a time. Their input and
output are all of variable size. If you need fixed size images, pass the
output of the decode Ops to one of the cropping and resizing Ops.

Note: The PNG encode and decode Ops support RGBA, but the conversions
Ops presently only support RGB, HSV, and GrayScale.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.image.decode\_jpeg(contents,\ channels=None,\ ratio=None,\ fancy\_upscaling=None,\ try\_recover\_truncated=None,\ acceptable\_fraction=None,\ name=None)}
}{tf.image.decode\_jpeg(contents, channels=None, ratio=None, fancy\_upscaling=None, try\_recover\_truncated=None, acceptable\_fraction=None, name=None) }}\label{tf.image.decodeux5fjpegcontents-channelsnone-rationone-fancyux5fupscalingnone-tryux5frecoverux5ftruncatednone-acceptableux5ffractionnone-namenone}

Decode a JPEG-encoded image to a uint8 tensor.

The attr \texttt{channels} indicates the desired number of color
channels for the decoded image.

Accepted values are:

\begin{itemize}
\tightlist
\item
  0: Use the number of channels in the JPEG-encoded image.
\item
  1: output a grayscale image.
\item
  3: output an RGB image.
\end{itemize}

If needed, the JPEG-encoded image is transformed to match the requested
number of color channels.

The attr \texttt{ratio} allows downscaling the image by an integer
factor during decoding. Allowed values are: 1, 2, 4, and 8. This is much
faster than downscaling the image later.

\subparagraph{Args: }\label{args}

\begin{itemize}
\tightlist
\item
  \texttt{contents}: A \texttt{Tensor} of type \texttt{string}. 0-D. The
  JPEG-encoded image.
\item
  \texttt{channels}: An optional \texttt{int}. Defaults to \texttt{0}.
  Number of color channels for the decoded image.
\item
  \texttt{ratio}: An optional \texttt{int}. Defaults to \texttt{1}.
  Downscaling ratio.
\item
  \texttt{fancy\_upscaling}: An optional \texttt{bool}. Defaults to
  \texttt{True}. If true use a slower but nicer upscaling of the chroma
  planes (yuv420/422 only).
\item
  \texttt{try\_recover\_truncated}: An optional \texttt{bool}. Defaults
  to \texttt{False}. If true try to recover an image from truncated
  input.
\item
  \texttt{acceptable\_fraction}: An optional \texttt{float}. Defaults to
  \texttt{1}. The minimum required fraction of lines before a truncated
  input is accepted.
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns}

A \texttt{Tensor} of type \texttt{uint8}. 3-D with shape
\texttt{{[}height,\ width,\ channels{]}}..

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.image.encode\_jpeg(image,\ format=None,\ quality=None,\ progressive=None,\ optimize\_size=None,\ chroma\_downsampling=None,\ density\_unit=None,\ x\_density=None,\ y\_density=None,\ xmp\_metadata=None,\ name=None)}
}{tf.image.encode\_jpeg(image, format=None, quality=None, progressive=None, optimize\_size=None, chroma\_downsampling=None, density\_unit=None, x\_density=None, y\_density=None, xmp\_metadata=None, name=None) }}\label{tf.image.encodeux5fjpegimage-formatnone-qualitynone-progressivenone-optimizeux5fsizenone-chromaux5fdownsamplingnone-densityux5funitnone-xux5fdensitynone-yux5fdensitynone-xmpux5fmetadatanone-namenone}

JPEG-encode an image.

\texttt{image} is a 3-D uint8 Tensor of shape
\texttt{{[}height,\ width,\ channels{]}}.

The attr \texttt{format} can be used to override the color format of the
encoded output. Values can be:

\begin{itemize}
\tightlist
\item
  \texttt{\textquotesingle{}\textquotesingle{}}: Use a default format
  based on the number of channels in the image.
\item
  \texttt{grayscale}: Output a grayscale JPEG image. The
  \texttt{channels} dimension of \texttt{image} must be 1.
\item
  \texttt{rgb}: Output an RGB JPEG image. The \texttt{channels}
  dimension of \texttt{image} must be 3.
\end{itemize}

If \texttt{format} is not specified or is the empty string, a default
format is picked in function of the number of channels in
\texttt{image}:

\begin{itemize}
\tightlist
\item
  1: Output a grayscale image.
\item
  3: Output an RGB image.
\end{itemize}

\subparagraph{Args: }\label{args-1}

\begin{itemize}
\tightlist
\item
  \texttt{image}: A \texttt{Tensor} of type \texttt{uint8}. 3-D with
  shape \texttt{{[}height,\ width,\ channels{]}}.
\item
  \texttt{format}: An optional \texttt{string} from:
  \texttt{"",\ "grayscale",\ "rgb"}. Defaults to \texttt{""}. Per pixel
  image format.
\item
  \texttt{quality}: An optional \texttt{int}. Defaults to \texttt{95}.
  Quality of the compression from 0 to 100 (higher is better and
  slower).
\item
  \texttt{progressive}: An optional \texttt{bool}. Defaults to
  \texttt{False}. If True, create a JPEG that loads progressively
  (coarse to fine).
\item
  \texttt{optimize\_size}: An optional \texttt{bool}. Defaults to
  \texttt{False}. If True, spend CPU/RAM to reduce size with no quality
  change.
\item
  \texttt{chroma\_downsampling}: An optional \texttt{bool}. Defaults to
  \texttt{True}. See http://en.wikipedia.org/wiki/Chroma\_subsampling.
\item
  \texttt{density\_unit}: An optional \texttt{string} from:
  \texttt{"in",\ "cm"}. Defaults to \texttt{"in"}. Unit used to specify
  \texttt{x\_density} and \texttt{y\_density}: pixels per inch
  (\texttt{\textquotesingle{}in\textquotesingle{}}) or centimeter
  (\texttt{\textquotesingle{}cm\textquotesingle{}}).
\item
  \texttt{x\_density}: An optional \texttt{int}. Defaults to
  \texttt{300}. Horizontal pixels per density unit.
\item
  \texttt{y\_density}: An optional \texttt{int}. Defaults to
  \texttt{300}. Vertical pixels per density unit.
\item
  \texttt{xmp\_metadata}: An optional \texttt{string}. Defaults to
  \texttt{""}. If not empty, embed this XMP metadata in the image
  header.
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-1}

A \texttt{Tensor} of type \texttt{string}. 0-D. JPEG-encoded image.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.image.decode\_png(contents,\ channels=None,\ name=None)}
}{tf.image.decode\_png(contents, channels=None, name=None) }}\label{tf.image.decodeux5fpngcontents-channelsnone-namenone}

Decode a PNG-encoded image to a uint8 tensor.

The attr \texttt{channels} indicates the desired number of color
channels for the decoded image.

Accepted values are:

\begin{itemize}
\tightlist
\item
  0: Use the number of channels in the PNG-encoded image.
\item
  1: output a grayscale image.
\item
  3: output an RGB image.
\item
  4: output an RGBA image.
\end{itemize}

If needed, the PNG-encoded image is transformed to match the requested
number of color channels.

\subparagraph{Args: }\label{args-2}

\begin{itemize}
\tightlist
\item
  \texttt{contents}: A \texttt{Tensor} of type \texttt{string}. 0-D. The
  PNG-encoded image.
\item
  \texttt{channels}: An optional \texttt{int}. Defaults to \texttt{0}.
  Number of color channels for the decoded image.
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-2}

A \texttt{Tensor} of type \texttt{uint8}. 3-D with shape
\texttt{{[}height,\ width,\ channels{]}}.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.image.encode\_png(image,\ compression=None,\ name=None)}
}{tf.image.encode\_png(image, compression=None, name=None) }}\label{tf.image.encodeux5fpngimage-compressionnone-namenone}

PNG-encode an image.

\texttt{image} is a 3-D uint8 Tensor of shape
\texttt{{[}height,\ width,\ channels{]}} where \texttt{channels} is:

\begin{itemize}
\tightlist
\item
  1: for grayscale.
\item
  3: for RGB.
\item
  4: for RGBA.
\end{itemize}

The ZLIB compression level, \texttt{compression}, can be -1 for the
PNG-encoder default or a value from 0 to 9. 9 is the highest compression
level, generating the smallest output, but is slower.

\subparagraph{Args: }\label{args-3}

\begin{itemize}
\tightlist
\item
  \texttt{image}: A \texttt{Tensor} of type \texttt{uint8}. 3-D with
  shape \texttt{{[}height,\ width,\ channels{]}}.
\item
  \texttt{compression}: An optional \texttt{int}. Defaults to
  \texttt{-1}. Compression level.
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-3}

A \texttt{Tensor} of type \texttt{string}. 0-D. PNG-encoded image.

\subsection{Resizing }\label{resizing}

The resizing Ops accept input images as tensors of several types. They
always output resized images as float32 tensors.

The convenience function
\protect\hyperlink{resizeux5fimages}{resize\_images()} supports both 4-D
and 3-D tensors as input and output. 4-D tensors are for batches of
images, 3-D tensors for individual images.

Other resizing Ops only support 3-D individual images as input:
\protect\hyperlink{resizeux5farea}{resize\_area},
\protect\hyperlink{resizeux5fbicubic}{resize\_bicubic},
\protect\hyperlink{resizeux5fbilinear}{resize\_bilinear},
\protect\hyperlink{resizeux5fnearestux5fneighbor}{resize\_nearest\_neighbor}.

Example:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Decode a JPG image and resize it to 299 by 299.}
\NormalTok{image }\OperatorTok{=} \NormalTok{tf.image.decode_jpeg(...)}
\NormalTok{resized_image }\OperatorTok{=} \NormalTok{tf.image.resize_bilinear(image, [}\DecValTok{299}\NormalTok{, }\DecValTok{299}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

Maybe refer to the Queue examples that show how to add images to a Queue
after resizing them to a fixed size, and how to dequeue batches of
resized images from the Queue.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.image.resize\_images(images,\ new\_height,\ new\_width,\ method=0)}
}{tf.image.resize\_images(images, new\_height, new\_width, method=0) }}\label{tf.image.resizeux5fimagesimages-newux5fheight-newux5fwidth-method0}

Resize \texttt{images} to \texttt{new\_width}, \texttt{new\_height}
using the specified \texttt{method}.

Resized images will be distorted if their original aspect ratio is not
the same as \texttt{new\_width}, \texttt{new\_height}. To avoid
distortions see
\protect\hyperlink{resizeux5fimageux5fwithux5fcropux5forux5fpad}{resize\_image\_with\_crop\_or\_pad}.

\texttt{method} can be one of:

\begin{itemize}
\tightlist
\item
  ResizeMethod.BILINEAR: {[}Bilinear interpolation.{]}
  (https://en.wikipedia.org/wiki/Bilinear\_interpolation)
\item
  ResizeMethod.NEAREST\_NEIGHBOR: {[}Nearest neighbor interpolation.{]}
  (https://en.wikipedia.org/wiki/Nearest-neighbor\_interpolation)
\item
  ResizeMethod.BICUBIC: {[}Bicubic interpolation.{]}
  (https://en.wikipedia.org/wiki/Bicubic\_interpolation)
\item
  ResizeMethod.AREA: Area interpolation.
\end{itemize}

\subparagraph{Args: }\label{args-4}

\begin{itemize}
\tightlist
\item
  \texttt{images}: 4-D Tensor of shape
  \texttt{{[}batch,\ height,\ width,\ channels{]}} or 3-D Tensor of
  shape \texttt{{[}height,\ width,\ channels{]}}.
\item
  \texttt{new\_height}: integer.
\item
  \texttt{new\_width}: integer.
\item
  \texttt{method}: ResizeMethod. Defaults to
  \texttt{ResizeMethod.BILINEAR}.
\end{itemize}

\subparagraph{Raises: }\label{raises}

\begin{itemize}
\tightlist
\item
  \texttt{ValueError}: if the shape of \texttt{images} is incompatible
  with the shape arguments to this function
\item
  \texttt{ValueError}: if an unsupported resize method is specified.
\end{itemize}

\subparagraph{Returns: }\label{returns-4}

If \texttt{images} was 4-D, a 4-D float Tensor of shape
\texttt{{[}batch,\ new\_height,\ new\_width,\ channels{]}}. If
\texttt{images} was 3-D, a 3-D float Tensor of shape
\texttt{{[}new\_height,\ new\_width,\ channels{]}}.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.image.resize\_area(images,\ size,\ name=None)}
}{tf.image.resize\_area(images, size, name=None) }}\label{tf.image.resizeux5fareaimages-size-namenone}

Resize \texttt{images} to \texttt{size} using area interpolation.

Input images can be of different types but output images are always
float.

\subparagraph{Args: }\label{args-5}

\begin{itemize}
\tightlist
\item
  \texttt{images}: A \texttt{Tensor}. Must be one of the following
  types: \texttt{uint8}, \texttt{int8}, \texttt{int32},
  \texttt{float32}, \texttt{float64}. 4-D with shape
  \texttt{{[}batch,\ height,\ width,\ channels{]}}.
\item
  \texttt{size}: A 1-D int32 Tensor of 2 elements:
  \texttt{new\_height,\ new\_width}. The new size for the images.
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-5}

A \texttt{Tensor} of type \texttt{float32}. 4-D with shape
\texttt{{[}batch,\ new\_height,\ new\_width,\ channels{]}}.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.image.resize\_bicubic(images,\ size,\ name=None)}
}{tf.image.resize\_bicubic(images, size, name=None) }}\label{tf.image.resizeux5fbicubicimages-size-namenone}

Resize \texttt{images} to \texttt{size} using bicubic interpolation.

Input images can be of different types but output images are always
float.

\subparagraph{Args: }\label{args-6}

\begin{itemize}
\tightlist
\item
  \texttt{images}: A \texttt{Tensor}. Must be one of the following
  types: \texttt{uint8}, \texttt{int8}, \texttt{int32},
  \texttt{float32}, \texttt{float64}. 4-D with shape
  \texttt{{[}batch,\ height,\ width,\ channels{]}}.
\item
  \texttt{size}: A 1-D int32 Tensor of 2 elements:
  \texttt{new\_height,\ new\_width}. The new size for the images.
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-6}

A \texttt{Tensor} of type \texttt{float32}. 4-D with shape
\texttt{{[}batch,\ new\_height,\ new\_width,\ channels{]}}.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.image.resize\_bilinear(images,\ size,\ name=None)}
}{tf.image.resize\_bilinear(images, size, name=None) }}\label{tf.image.resizeux5fbilinearimages-size-namenone}

Resize \texttt{images} to \texttt{size} using bilinear interpolation.

Input images can be of different types but output images are always
float.

\subparagraph{Args: }\label{args-7}

\begin{itemize}
\tightlist
\item
  \texttt{images}: A \texttt{Tensor}. Must be one of the following
  types: \texttt{uint8}, \texttt{int8}, \texttt{int32},
  \texttt{float32}, \texttt{float64}. 4-D with shape
  \texttt{{[}batch,\ height,\ width,\ channels{]}}.
\item
  \texttt{size}: A 1-D int32 Tensor of 2 elements:
  \texttt{new\_height,\ new\_width}. The new size for the images.
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-7}

A \texttt{Tensor} of type \texttt{float32}. 4-D with shape
\texttt{{[}batch,\ new\_height,\ new\_width,\ channels{]}}.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.image.resize\_nearest\_neighbor(images,\ size,\ name=None)}
}{tf.image.resize\_nearest\_neighbor(images, size, name=None) }}\label{tf.image.resizeux5fnearestux5fneighborimages-size-namenone}

Resize \texttt{images} to \texttt{size} using nearest neighbor
interpolation.

Input images can be of different types but output images are always
float.

\subparagraph{Args: }\label{args-8}

\begin{itemize}
\tightlist
\item
  \texttt{images}: A \texttt{Tensor}. Must be one of the following
  types: \texttt{uint8}, \texttt{int8}, \texttt{int32},
  \texttt{float32}, \texttt{float64}. 4-D with shape
  \texttt{{[}batch,\ height,\ width,\ channels{]}}.
\item
  \texttt{size}: A 1-D int32 Tensor of 2 elements:
  \texttt{new\_height,\ new\_width}. The new size for the images.
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-8}

A \texttt{Tensor}. Has the same type as \texttt{images}. 4-D with shape
\texttt{{[}batch,\ new\_height,\ new\_width,\ channels{]}}.

\subsection{Cropping }\label{cropping}

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.image.resize\_image\_with\_crop\_or\_pad(image,\ target\_height,\ target\_width)}
}{tf.image.resize\_image\_with\_crop\_or\_pad(image, target\_height, target\_width) }}\label{tf.image.resizeux5fimageux5fwithux5fcropux5forux5fpadimage-targetux5fheight-targetux5fwidth}

Crops and/or pads an image to a target width and height.

Resizes an image to a target width and height by either centrally
cropping the image or padding it evenly with zeros.

If \texttt{width} or \texttt{height} is greater than the specified
\texttt{target\_width} or \texttt{target\_height} respectively, this op
centrally crops along that dimension. If \texttt{width} or
\texttt{height} is smaller than the specified \texttt{target\_width} or
\texttt{target\_height} respectively, this op centrally pads with 0
along that dimension.

\subparagraph{Args: }\label{args-9}

\begin{itemize}
\tightlist
\item
  \texttt{image}: 3-D tensor of shape {[}height, width, channels{]}
\item
  \texttt{target\_height}: Target height.
\item
  \texttt{target\_width}: Target width.
\end{itemize}

\subparagraph{Raises: }\label{raises-1}

\begin{itemize}
\tightlist
\item
  \texttt{ValueError}: if \texttt{target\_height} or
  \texttt{target\_width} are zero or negative.
\end{itemize}

\subparagraph{Returns: }\label{returns-9}

Cropped and/or padded image of shape
\texttt{{[}target\_height,\ target\_width,\ channels{]}}

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.image.pad\_to\_bounding\_box(image,\ offset\_height,\ offset\_width,\ target\_height,\ target\_width)}
}{tf.image.pad\_to\_bounding\_box(image, offset\_height, offset\_width, target\_height, target\_width) }}\label{tf.image.padux5ftoux5fboundingux5fboximage-offsetux5fheight-offsetux5fwidth-targetux5fheight-targetux5fwidth}

Pad \texttt{image} with zeros to the specified \texttt{height} and
\texttt{width}.

Adds \texttt{offset\_height} rows of zeros on top,
\texttt{offset\_width} columns of zeros on the left, and then pads the
image on the bottom and right with zeros until it has dimensions
\texttt{target\_height}, \texttt{target\_width}.

This op does nothing if \texttt{offset\_*} is zero and the image already
has size \texttt{target\_height} by \texttt{target\_width}.

\subparagraph{Args: }\label{args-10}

\begin{itemize}
\tightlist
\item
  \texttt{image}: 3-D tensor with shape
  \texttt{{[}height,\ width,\ channels{]}}
\item
  \texttt{offset\_height}: Number of rows of zeros to add on top.
\item
  \texttt{offset\_width}: Number of columns of zeros to add on the left.
\item
  \texttt{target\_height}: Height of output image.
\item
  \texttt{target\_width}: Width of output image.
\end{itemize}

\subparagraph{Returns: }\label{returns-10}

3-D tensor of shape
\texttt{{[}target\_height,\ target\_width,\ channels{]}}

\subparagraph{Raises: }\label{raises-2}

\begin{itemize}
\tightlist
\item
  \texttt{ValueError}: If the shape of \texttt{image} is incompatible
  with the \texttt{offset\_*} or \texttt{target\_*} arguments
\end{itemize}

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.image.crop\_to\_bounding\_box(image,\ offset\_height,\ offset\_width,\ target\_height,\ target\_width)}
}{tf.image.crop\_to\_bounding\_box(image, offset\_height, offset\_width, target\_height, target\_width) }}\label{tf.image.cropux5ftoux5fboundingux5fboximage-offsetux5fheight-offsetux5fwidth-targetux5fheight-targetux5fwidth}

Crops an image to a specified bounding box.

This op cuts a rectangular part out of \texttt{image}. The top-left
corner of the returned image is at
\texttt{offset\_height,\ offset\_width} in \texttt{image}, and its
lower-right corner is at `offset\_height + target\_height, offset\_width
+ target\_width'.

\subparagraph{Args: }\label{args-11}

\begin{itemize}
\tightlist
\item
  \texttt{image}: 3-D tensor with shape
  \texttt{{[}height,\ width,\ channels{]}}
\item
  \texttt{offset\_height}: Vertical coordinate of the top-left corner of
  the result in the input.
\item
  \texttt{offset\_width}: Horizontal coordinate of the top-left corner
  of the result in the input.
\item
  \texttt{target\_height}: Height of the result.
\item
  \texttt{target\_width}: Width of the result.
\end{itemize}

\subparagraph{Returns: }\label{returns-11}

3-D tensor of image with shape
\texttt{{[}target\_height,\ target\_width,\ channels{]}}

\subparagraph{Raises: }\label{raises-3}

\begin{itemize}
\tightlist
\item
  \texttt{ValueError}: If the shape of \texttt{image} is incompatible
  with the \texttt{offset\_*} or \texttt{target\_*} arguments
\end{itemize}

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.image.random\_crop(image,\ size,\ seed=None,\ name=None)}
}{tf.image.random\_crop(image, size, seed=None, name=None) }}\label{tf.image.randomux5fcropimage-size-seednone-namenone}

Randomly crops \texttt{image} to size
\texttt{{[}target\_height,\ target\_width{]}}.

The offset of the output within \texttt{image} is uniformly random.
\texttt{image} always fully contains the result.

\subparagraph{Args: }\label{args-12}

\begin{itemize}
\tightlist
\item
  \texttt{image}: 3-D tensor of shape
  \texttt{{[}height,\ width,\ channels{]}}
\item
  \texttt{size}: 1-D tensor with two elements, specifying target
  \texttt{{[}height,\ width{]}}
\item
  \texttt{seed}: A Python integer. Used to create a random seed. See
  \href{../../api_docs/python/constant_op.md\#set_random_seed}{\texttt{set\_random\_seed}}
  for behavior.
\item
  \texttt{name}: A name for this operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-12}

A cropped 3-D tensor of shape
\texttt{{[}target\_height,\ target\_width,\ channels{]}}.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.image.extract\_glimpse(input,\ size,\ offsets,\ centered=None,\ normalized=None,\ uniform\_noise=None,\ name=None)}
}{tf.image.extract\_glimpse(input, size, offsets, centered=None, normalized=None, uniform\_noise=None, name=None) }}\label{tf.image.extractux5fglimpseinput-size-offsets-centerednone-normalizednone-uniformux5fnoisenone-namenone}

Extracts a glimpse from the input tensor.

Returns a set of windows called glimpses extracted at location
\texttt{offsets} from the input tensor. If the windows only partially
overlaps the inputs, the non overlapping areas will be filled with
random noise.

The result is a 4-D tensor of shape
\texttt{{[}batch\_size,\ glimpse\_height,\ glimpse\_width,\ channels{]}}.
The channels and batch dimensions are the same as that of the input
tensor. The height and width of the output windows are specified in the
\texttt{size} parameter.

The argument \texttt{normalized} and \texttt{centered} controls how the
windows are built: * If the coordinates are normalized but not centered,
0.0 and 1.0 correspond to the minimum and maximum of each height and
width dimension. * If the coordinates are both normalized and centered,
they range from -1.0 to 1.0. The coordinates (-1.0, -1.0) correspond to
the upper left corner, the lower right corner is located at (1.0, 1.0)
and the center is at (0, 0). * If the coordinates are not normalized
they are interpreted as numbers of pixels.

\subparagraph{Args: }\label{args-13}

\begin{itemize}
\tightlist
\item
  \texttt{input}: A \texttt{Tensor} of type \texttt{float32}. A 4-D
  float tensor of shape
  \texttt{{[}batch\_size,\ height,\ width,\ channels{]}}.
\item
  \texttt{size}: A \texttt{Tensor} of type \texttt{int32}. A 1-D tensor
  of 2 elements containing the size of the glimpses to extract. The
  glimpse height must be specified first, following by the glimpse
  width.
\item
  \texttt{offsets}: A \texttt{Tensor} of type \texttt{float32}. A 2-D
  integer tensor of shape \texttt{{[}batch\_size,\ 2{]}} containing the
  x, y locations of the center of each window.
\item
  \texttt{centered}: An optional \texttt{bool}. Defaults to
  \texttt{True}. indicates if the offset coordinates are centered
  relative to the image, in which case the (0, 0) offset is relative to
  the center of the input images. If false, the (0,0) offset corresponds
  to the upper left corner of the input images.
\item
  \texttt{normalized}: An optional \texttt{bool}. Defaults to
  \texttt{True}. indicates if the offset coordinates are normalized.
\item
  \texttt{uniform\_noise}: An optional \texttt{bool}. Defaults to
  \texttt{True}. indicates if the noise should be generated using a
  uniform distribution or a gaussian distribution.
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-13}

A \texttt{Tensor} of type \texttt{float32}. A tensor representing the
glimpses
\texttt{{[}batch\_size,\ glimpse\_height,\ \ \ glimpse\_width,\ channels{]}}.

\subsection{Flipping and Transposing }\label{flipping-and-transposing}

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.image.flip\_up\_down(image)}
}{tf.image.flip\_up\_down(image) }}\label{tf.image.flipux5fupux5fdownimage}

Flip an image horizontally (upside down).

Outputs the contents of \texttt{image} flipped along the first
dimension, which is \texttt{height}.

See also \texttt{reverse()}.

\subparagraph{Args: }\label{args-14}

\begin{itemize}
\tightlist
\item
  \texttt{image}: A 3-D tensor of shape
  \texttt{{[}height,\ width,\ channels{]}.}
\end{itemize}

\subparagraph{Returns: }\label{returns-14}

A 3-D tensor of the same type and shape as \texttt{image}.

\subparagraph{Raises: }\label{raises-4}

\begin{itemize}
\tightlist
\item
  \texttt{ValueError}: if the shape of \texttt{image} not supported.
\end{itemize}

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.image.random\_flip\_up\_down(image,\ seed=None)}
}{tf.image.random\_flip\_up\_down(image, seed=None) }}\label{tf.image.randomux5fflipux5fupux5fdownimage-seednone}

Randomly flips an image vertically (upside down).

With a 1 in 2 chance, outputs the contents of \texttt{image} flipped
along the first dimension, which is \texttt{height}. Otherwise output
the image as-is.

\subparagraph{Args: }\label{args-15}

\begin{itemize}
\tightlist
\item
  \texttt{image}: A 3-D tensor of shape
  \texttt{{[}height,\ width,\ channels{]}.}
\item
  \texttt{seed}: A Python integer. Used to create a random seed. See
  \href{../../api_docs/python/constant_op.md\#set_random_seed}{\texttt{set\_random\_seed}}
  for behavior.
\end{itemize}

\subparagraph{Returns: }\label{returns-15}

A 3-D tensor of the same type and shape as \texttt{image}.

\subparagraph{Raises: }\label{raises-5}

\begin{itemize}
\tightlist
\item
  \texttt{ValueError}: if the shape of \texttt{image} not supported.
\end{itemize}

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.image.flip\_left\_right(image)}
}{tf.image.flip\_left\_right(image) }}\label{tf.image.flipux5fleftux5frightimage}

Flip an image horizontally (left to right).

Outputs the contents of \texttt{image} flipped along the second
dimension, which is \texttt{width}.

See also \texttt{reverse()}.

\subparagraph{Args: }\label{args-16}

\begin{itemize}
\tightlist
\item
  \texttt{image}: A 3-D tensor of shape
  \texttt{{[}height,\ width,\ channels{]}.}
\end{itemize}

\subparagraph{Returns: }\label{returns-16}

A 3-D tensor of the same type and shape as \texttt{image}.

\subparagraph{Raises: }\label{raises-6}

\begin{itemize}
\tightlist
\item
  \texttt{ValueError}: if the shape of \texttt{image} not supported.
\end{itemize}

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.image.random\_flip\_left\_right(image,\ seed=None)}
}{tf.image.random\_flip\_left\_right(image, seed=None) }}\label{tf.image.randomux5fflipux5fleftux5frightimage-seednone}

Randomly flip an image horizontally (left to right).

With a 1 in 2 chance, outputs the contents of \texttt{image} flipped
along the second dimension, which is \texttt{width}. Otherwise output
the image as-is.

\subparagraph{Args: }\label{args-17}

\begin{itemize}
\tightlist
\item
  \texttt{image}: A 3-D tensor of shape
  \texttt{{[}height,\ width,\ channels{]}.}
\item
  \texttt{seed}: A Python integer. Used to create a random seed. See
  \href{../../api_docs/python/constant_op.md\#set_random_seed}{\texttt{set\_random\_seed}}
  for behavior.
\end{itemize}

\subparagraph{Returns: }\label{returns-17}

A 3-D tensor of the same type and shape as \texttt{image}.

\subparagraph{Raises: }\label{raises-7}

\begin{itemize}
\tightlist
\item
  \texttt{ValueError}: if the shape of \texttt{image} not supported.
\end{itemize}

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.image.transpose\_image(image)}
}{tf.image.transpose\_image(image) }}\label{tf.image.transposeux5fimageimage}

Transpose an image by swapping the first and second dimension.

See also \texttt{transpose()}.

\subparagraph{Args: }\label{args-18}

\begin{itemize}
\tightlist
\item
  \texttt{image}: 3-D tensor of shape
  \texttt{{[}height,\ width,\ channels{]}}
\end{itemize}

\subparagraph{Returns: }\label{returns-18}

A 3-D tensor of shape \texttt{{[}width,\ height,\ channels{]}}

\subparagraph{Raises: }\label{raises-8}

\begin{itemize}
\tightlist
\item
  \texttt{ValueError}: if the shape of \texttt{image} not supported.
\end{itemize}

\subsection{Image Adjustments }\label{image-adjustments}

TensorFlow provides functions to adjust images in various ways:
brightness, contrast, hue, and saturation. Each adjustment can be done
with predefined parameters or with random parameters picked from
predefined intervals. Random adjustments are often useful to expand a
training set and reduce overfitting.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.image.adjust\_brightness(image,\ delta,\ min\_value=None,\ max\_value=None)}
}{tf.image.adjust\_brightness(image, delta, min\_value=None, max\_value=None) }}\label{tf.image.adjustux5fbrightnessimage-delta-minux5fvaluenone-maxux5fvaluenone}

Adjust the brightness of RGB or Grayscale images.

The value \texttt{delta} is added to all components of the tensor
\texttt{image}. \texttt{image} and \texttt{delta} are cast to
\texttt{float} before adding, and the resulting values are clamped to
\texttt{{[}min\_value,\ max\_value{]}}. Finally, the result is cast back
to \texttt{images.dtype}.

If \texttt{min\_value} or \texttt{max\_value} are not given, they are
set to the minimum and maximum allowed values for \texttt{image.dtype}
respectively.

\subparagraph{Args: }\label{args-19}

\begin{itemize}
\tightlist
\item
  \texttt{image}: A tensor.
\item
  \texttt{delta}: A scalar. Amount to add to the pixel values.
\item
  \texttt{min\_value}: Minimum value for output.
\item
  \texttt{max\_value}: Maximum value for output.
\end{itemize}

\subparagraph{Returns: }\label{returns-19}

A tensor of the same shape and type as \texttt{image}.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.image.random\_brightness(image,\ max\_delta,\ seed=None)}
}{tf.image.random\_brightness(image, max\_delta, seed=None) }}\label{tf.image.randomux5fbrightnessimage-maxux5fdelta-seednone}

Adjust the brightness of images by a random factor.

Equivalent to \texttt{adjust\_brightness()} using a \texttt{delta}
randomly picked in the interval \texttt{{[}-max\_delta,\ max\_delta)}.

Note that \texttt{delta} is picked as a float. Because for integer type
images, the brightness adjusted result is rounded before casting,
integer images may have modifications in the range
\texttt{{[}-max\_delta,max\_delta{]}}.

\subparagraph{Args: }\label{args-20}

\begin{itemize}
\tightlist
\item
  \texttt{image}: 3-D tensor of shape
  \texttt{{[}height,\ width,\ channels{]}}.
\item
  \texttt{max\_delta}: float, must be non-negative.
\item
  \texttt{seed}: A Python integer. Used to create a random seed. See
  \href{../../api_docs/python/constant_op.md\#set_random_seed}{\texttt{set\_random\_seed}}
  for behavior.
\end{itemize}

\subparagraph{Returns: }\label{returns-20}

3-D tensor of images of shape \texttt{{[}height,\ width,\ channels{]}}

\subparagraph{Raises: }\label{raises-9}

\begin{itemize}
\tightlist
\item
  \texttt{ValueError}: if max\_delta is negative.
\end{itemize}

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.image.adjust\_contrast(images,\ contrast\_factor,\ min\_value=None,\ max\_value=None)}
}{tf.image.adjust\_contrast(images, contrast\_factor, min\_value=None, max\_value=None) }}\label{tf.image.adjustux5fcontrastimages-contrastux5ffactor-minux5fvaluenone-maxux5fvaluenone}

Adjust contrast of RGB or grayscale images.

\texttt{images} is a tensor of at least 3 dimensions. The last 3
dimensions are interpreted as \texttt{{[}height,\ width,\ channels{]}}.
The other dimensions only represent a collection of images, such as
\texttt{{[}batch,\ height,\ width,\ channels{]}.}

Contrast is adjusted independently for each channel of each image.

For each channel, this Op first computes the mean of the image pixels in
the channel and then adjusts each component \texttt{x} of each pixel to
\texttt{(x\ -\ mean)\ *\ contrast\_factor\ +\ mean}.

The adjusted values are then clipped to fit in the
\texttt{{[}min\_value,\ max\_value{]}} interval. If \texttt{min\_value}
or \texttt{max\_value} is not given, it is replaced with the minimum and
maximum values for the data type of \texttt{images} respectively.

The contrast-adjusted image is always computed as \texttt{float}, and it
is cast back to its original type after clipping.

\subparagraph{Args: }\label{args-21}

\begin{itemize}
\tightlist
\item
  \texttt{images}: Images to adjust. At least 3-D.
\item
  \texttt{contrast\_factor}: A float multiplier for adjusting contrast.
\item
  \texttt{min\_value}: Minimum value for clipping the adjusted pixels.
\item
  \texttt{max\_value}: Maximum value for clipping the adjusted pixels.
\end{itemize}

\subparagraph{Returns: }\label{returns-21}

The constrast-adjusted image or images.

\subparagraph{Raises: }\label{raises-10}

\begin{itemize}
\tightlist
\item
  \texttt{ValueError}: if the arguments are invalid.
\end{itemize}

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.image.random\_contrast(image,\ lower,\ upper,\ seed=None)}
}{tf.image.random\_contrast(image, lower, upper, seed=None) }}\label{tf.image.randomux5fcontrastimage-lower-upper-seednone}

Adjust the contrase of an image by a random factor.

Equivalent to \texttt{adjust\_constrast()} but uses a
\texttt{contrast\_factor} randomly picked in the interval
\texttt{{[}lower,\ upper{]}}.

\subparagraph{Args: }\label{args-22}

\begin{itemize}
\tightlist
\item
  \texttt{image}: 3-D tensor of shape
  \texttt{{[}height,\ width,\ channels{]}}.
\item
  \texttt{lower}: float. Lower bound for the random contrast factor.
\item
  \texttt{upper}: float. Upper bound for the random contrast factor.
\item
  \texttt{seed}: A Python integer. Used to create a random seed. See
  \href{../../api_docs/python/constant_op.md\#set_random_seed}{\texttt{set\_random\_seed}}
  for behavior.
\end{itemize}

\subparagraph{Returns: }\label{returns-22}

3-D tensor of shape \texttt{{[}height,\ width,\ channels{]}}.

\subparagraph{Raises: }\label{raises-11}

\begin{itemize}
\tightlist
\item
  \texttt{ValueError}: if \texttt{upper\ \textless{}=\ lower} or if
  \texttt{lower\ \textless{}\ 0}.
\end{itemize}

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.image.per\_image\_whitening(image)}
}{tf.image.per\_image\_whitening(image) }}\label{tf.image.perux5fimageux5fwhiteningimage}

Linearly scales \texttt{image} to have zero mean and unit norm.

This op computes \texttt{(x\ -\ mean)\ /\ adjusted\_stddev}, where
\texttt{mean} is the average of all values in image, and
\texttt{adjusted\_stddev\ =\ max(stddev,\ 1.0/srqt(image.NumElements()))}.

\texttt{stddev} is the standard deviation of all values in
\texttt{image}. It is capped away from zero to protect against division
by 0 when handling uniform images.

Note that this implementation is limited: * It only whitens based on the
statistics of an individual image. * It does not take into account the
covariance structure.

\subparagraph{Args: }\label{args-23}

\begin{itemize}
\tightlist
\item
  \texttt{image}: 3-D tensor of shape
  \texttt{{[}height,\ width,\ channels{]}}.
\end{itemize}

\subparagraph{Returns: }\label{returns-23}

The whitened image with same shape as \texttt{image}.

\subparagraph{Raises: }\label{raises-12}

\begin{itemize}
\tightlist
\item
  \texttt{ValueError}: if the shape of `image' is incompatible with this
  function.
\end{itemize}


