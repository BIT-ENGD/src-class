

\begin{document}

\section{Neural Network }\label{neural-network}

Note: Functions taking \texttt{Tensor} arguments can also take anything
accepted by
\href{../../api_docs/python/framework.md\#convert_to_tensor}{\texttt{tf.convert\_to\_tensor}}.

\subsection{Contents}\label{contents}

\subsubsection{\texorpdfstring{\protect\hyperlink{AUTOGENERATED-neural-network}{Neural
Network}}{Neural Network}}\label{neural-network-1}

\begin{itemize}
\tightlist
\item
  \protect\hyperlink{AUTOGENERATED-activation-functions}{Activation
  Functions}
\item
  \protect\hyperlink{relu}{\texttt{tf.nn.relu(features,\ name=None)}}
\item
  \protect\hyperlink{relu6}{\texttt{tf.nn.relu6(features,\ name=None)}}
\item
  \protect\hyperlink{softplus}{\texttt{tf.nn.softplus(features,\ name=None)}}
\item
  \protect\hyperlink{dropout}{\texttt{tf.nn.dropout(x,\ keep\_prob,\ noise\_shape=None,\ seed=None,\ name=None)}}
\item
  \protect\hyperlink{biasux5fadd}{\texttt{tf.nn.bias\_add(value,\ bias,\ name=None)}}
\item
  \protect\hyperlink{sigmoid}{\texttt{tf.sigmoid(x,\ name=None)}}
\item
  \protect\hyperlink{tanh}{\texttt{tf.tanh(x,\ name=None)}}
\item
  \protect\hyperlink{AUTOGENERATED-convolution}{Convolution}
\item
  \protect\hyperlink{conv2d}{\texttt{tf.nn.conv2d(input,\ filter,\ strides,\ padding,\ use\_cudnn\_on\_gpu=None,\ name=None)}}
\item
  \protect\hyperlink{depthwiseux5fconv2d}{\texttt{tf.nn.depthwise\_conv2d(input,\ filter,\ strides,\ padding,\ name=None)}}
\item
  \protect\hyperlink{separableux5fconv2d}{\texttt{tf.nn.separable\_conv2d(input,\ depthwise\_filter,\ pointwise\_filter,\ strides,\ padding,\ name=None)}}
\item
  \protect\hyperlink{AUTOGENERATED-pooling}{Pooling}
\item
  \protect\hyperlink{avgux5fpool}{\texttt{tf.nn.avg\_pool(value,\ ksize,\ strides,\ padding,\ name=None)}}
\item
  \protect\hyperlink{maxux5fpool}{\texttt{tf.nn.max\_pool(value,\ ksize,\ strides,\ padding,\ name=None)}}
\item
  \protect\hyperlink{maxux5fpoolux5fwithux5fargmax}{\texttt{tf.nn.max\_pool\_with\_argmax(input,\ ksize,\ strides,\ padding,\ Targmax=None,\ name=None)}}
\item
  \protect\hyperlink{AUTOGENERATED-normalization}{Normalization}
\item
  \protect\hyperlink{l2ux5fnormalize}{\texttt{tf.nn.l2\_normalize(x,\ dim,\ epsilon=1e-12,\ name=None)}}
\item
  \protect\hyperlink{localux5fresponseux5fnormalization}{\texttt{tf.nn.local\_response\_normalization(input,\ depth\_radius=None,\ bias=None,\ alpha=None,\ beta=None,\ name=None)}}
\item
  \protect\hyperlink{moments}{\texttt{tf.nn.moments(x,\ axes,\ name=None)}}
\item
  \protect\hyperlink{AUTOGENERATED-losses}{Losses}
\item
  \protect\hyperlink{l2ux5floss}{\texttt{tf.nn.l2\_loss(t,\ name=None)}}
\item
  \protect\hyperlink{AUTOGENERATED-classification}{Classification}
\item
  \protect\hyperlink{sigmoidux5fcrossux5fentropyux5fwithux5flogits}{\texttt{tf.nn.sigmoid\_cross\_entropy\_with\_logits(logits,\ targets,\ name=None)}}
\item
  \protect\hyperlink{softmax}{\texttt{tf.nn.softmax(logits,\ name=None)}}
\item
  \protect\hyperlink{softmaxux5fcrossux5fentropyux5fwithux5flogits}{\texttt{tf.nn.softmax\_cross\_entropy\_with\_logits(logits,\ labels,\ name=None)}}
\item
  \protect\hyperlink{AUTOGENERATED-embeddings}{Embeddings}
\item
  \protect\hyperlink{embeddingux5flookup}{\texttt{tf.nn.embedding\_lookup(params,\ ids,\ name=None)}}
\item
  \protect\hyperlink{AUTOGENERATED-evaluation}{Evaluation}
\item
  \protect\hyperlink{topux5fk}{\texttt{tf.nn.top\_k(input,\ k,\ name=None)}}
\item
  \protect\hyperlink{inux5ftopux5fk}{\texttt{tf.nn.in\_top\_k(predictions,\ targets,\ k,\ name=None)}}
\item
  \protect\hyperlink{AUTOGENERATED-candidate-sampling}{Candidate
  Sampling}
\item
  \protect\hyperlink{AUTOGENERATED-sampled-loss-functions}{Sampled Loss
  Functions}
\item
  \protect\hyperlink{nceux5floss}{\texttt{tf.nn.nce\_loss(weights,\ biases,\ inputs,\ labels,\ num\_sampled,\ num\_classes,\ num\_true=1,\ sampled\_values=None,\ remove\_accidental\_hits=False,\ name=\textquotesingle{}nce\_loss\textquotesingle{})}}
\item
  \protect\hyperlink{sampledux5fsoftmaxux5floss}{\texttt{tf.nn.sampled\_softmax\_loss(weights,\ biases,\ inputs,\ labels,\ num\_sampled,\ num\_classes,\ num\_true=1,\ sampled\_values=None,\ remove\_accidental\_hits=True,\ name=\textquotesingle{}sampled\_softmax\_loss\textquotesingle{})}}
\item
  \protect\hyperlink{AUTOGENERATED-candidate-samplers}{Candidate
  Samplers}
\item
  \protect\hyperlink{uniformux5fcandidateux5fsampler}{\texttt{tf.nn.uniform\_candidate\_sampler(true\_classes,\ num\_true,\ num\_sampled,\ unique,\ range\_max,\ seed=None,\ name=None)}}
\item
  \protect\hyperlink{logux5funiformux5fcandidateux5fsampler}{\texttt{tf.nn.log\_uniform\_candidate\_sampler(true\_classes,\ num\_true,\ num\_sampled,\ unique,\ range\_max,\ seed=None,\ name=None)}}
\item
  \protect\hyperlink{learnedux5funigramux5fcandidateux5fsampler}{\texttt{tf.nn.learned\_unigram\_candidate\_sampler(true\_classes,\ num\_true,\ num\_sampled,\ unique,\ range\_max,\ seed=None,\ name=None)}}
\item
  \protect\hyperlink{fixedux5funigramux5fcandidateux5fsampler}{\texttt{tf.nn.fixed\_unigram\_candidate\_sampler(true\_classes,\ num\_true,\ num\_sampled,\ unique,\ range\_max,\ vocab\_file=\textquotesingle{}\textquotesingle{},\ distortion=0.0,\ num\_reserved\_ids=0,\ num\_shards=1,\ shard=0,\ unigrams={[}{]},\ seed=None,\ name=None)}}
\item
  \protect\hyperlink{AUTOGENERATED-miscellaneous-candidate-sampling-utilities}{Miscellaneous
  candidate sampling utilities}
\item
  \protect\hyperlink{computeux5faccidentalux5fhits}{\texttt{tf.nn.compute\_accidental\_hits(true\_classes,\ sampled\_candidates,\ num\_true,\ seed=None,\ name=None)}}
\end{itemize}

\subsection{Activation Functions }\label{activation-functions}

The activation ops provide different types of nonlinearities for use in
neural networks. These include smooth nonlinearities (\texttt{sigmoid},
\texttt{tanh}, and \texttt{softplus}), continuous but not everywhere
differentiable functions (\texttt{relu}, \texttt{relu6}, and
\texttt{relu\_x}), and random regularization (\texttt{dropout}).

All activation ops apply componentwise, and produce a tensor of the same
shape as the input tensor.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.nn.relu(features,\ name=None)}
}{tf.nn.relu(features, name=None) }}\label{tf.nn.relufeatures-namenone}

Computes rectified linear: \texttt{max(features,\ 0)}.

\subparagraph{Args: }\label{args}

\begin{itemize}
\tightlist
\item
  \texttt{features}: A \texttt{Tensor}. Must be one of the following
  types: \texttt{float32}, \texttt{float64}, \texttt{int32},
  \texttt{int64}, \texttt{uint8}, \texttt{int16}, \texttt{int8}.
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns}

A \texttt{Tensor}. Has the same type as \texttt{features}.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.nn.relu6(features,\ name=None)}
}{tf.nn.relu6(features, name=None) }}\label{tf.nn.relu6features-namenone}

Computes Rectified Linear 6: \texttt{min(max(features,\ 0),\ 6)}.

\subparagraph{Args: }\label{args-1}

\begin{itemize}
\tightlist
\item
  \texttt{features}: A \texttt{Tensor} with type \texttt{float},
  \texttt{double}, \texttt{int32}, \texttt{int64}, \texttt{uint8},
  \texttt{int16}, or \texttt{int8}.
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-1}

A \texttt{Tensor} with the same type as \texttt{features}.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.nn.softplus(features,\ name=None)}
}{tf.nn.softplus(features, name=None) }}\label{tf.nn.softplusfeatures-namenone}

Computes softplus: \texttt{log(exp(features)\ +\ 1)}.

\subparagraph{Args: }\label{args-2}

\begin{itemize}
\tightlist
\item
  \texttt{features}: A \texttt{Tensor}. Must be one of the following
  types: \texttt{float32}, \texttt{float64}, \texttt{int32},
  \texttt{int64}, \texttt{uint8}, \texttt{int16}, \texttt{int8}.
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-2}

A \texttt{Tensor}. Has the same type as \texttt{features}.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.nn.dropout(x,\ keep\_prob,\ noise\_shape=None,\ seed=None,\ name=None)}
}{tf.nn.dropout(x, keep\_prob, noise\_shape=None, seed=None, name=None) }}\label{tf.nn.dropoutx-keepux5fprob-noiseux5fshapenone-seednone-namenone}

Computes dropout.

With probability \texttt{keep\_prob}, outputs the input element scaled
up by \texttt{1\ /\ keep\_prob}, otherwise outputs \texttt{0}. The
scaling is so that the expected sum is unchanged.

By default, each element is kept or dropped independently. If
\texttt{noise\_shape} is specified, it must be
\href{http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html}{broadcastable}
to the shape of \texttt{x}, and only dimensions with
\texttt{noise\_shape{[}i{]}\ ==\ shape(x){[}i{]}} will make independent
decisions. For example, if \texttt{shape(x)\ =\ {[}k,\ l,\ m,\ n{]}} and
\texttt{noise\_shape\ =\ {[}k,\ 1,\ 1,\ n{]}}, each batch and channel
component will be kept independently and each row and column will be
kept or not kept together.

\subparagraph{Args: }\label{args-3}

\begin{itemize}
\tightlist
\item
  \texttt{x}: A tensor.
\item
  \texttt{keep\_prob}: A Python float. The probability that each element
  is kept.
\item
  \texttt{noise\_shape}: A 1-D \texttt{Tensor} of type \texttt{int32},
  representing the shape for randomly generated keep/drop flags.
\item
  \texttt{seed}: A Python integer. Used to create random seeds. See
  \href{../../api_docs/python/constant_op.md\#set_random_seed}{\texttt{set\_random\_seed}}
  for behavior.
\item
  \texttt{name}: A name for this operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-3}

A Tensor of the same shape of \texttt{x}.

\subparagraph{Raises: }\label{raises}

\begin{itemize}
\tightlist
\item
  \texttt{ValueError}: If \texttt{keep\_prob} is not in
  \texttt{(0,\ 1{]}}.
\end{itemize}

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.nn.bias\_add(value,\ bias,\ name=None)}
}{tf.nn.bias\_add(value, bias, name=None) }}\label{tf.nn.biasux5faddvalue-bias-namenone}

Adds \texttt{bias} to \texttt{value}.

This is (mostly) a special case of \texttt{tf.add} where \texttt{bias}
is restricted to 1-D. Broadcasting is supported, so \texttt{value} may
have any number of dimensions. Unlike \texttt{tf.add}, the type of
\texttt{bias} is allowed to differ from \texttt{value} in the case where
both types are quantized.

\subparagraph{Args: }\label{args-4}

\begin{itemize}
\tightlist
\item
  \texttt{value}: A \texttt{Tensor} with type \texttt{float},
  \texttt{double}, \texttt{int64}, \texttt{int32}, \texttt{uint8},
  \texttt{int16}, \texttt{int8}, or \texttt{complex64}.
\item
  \texttt{bias}: A 1-D \texttt{Tensor} with size matching the last
  dimension of \texttt{value}. Must be the same type as \texttt{value}
  unless \texttt{value} is a quantized type, in which case a different
  quantized type may be used.
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-4}

A \texttt{Tensor} with the same type as \texttt{value}.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.sigmoid(x,\ name=None)}
}{tf.sigmoid(x, name=None) }}\label{tf.sigmoidx-namenone}

Computes sigmoid of \texttt{x} element-wise.

Specifically, \texttt{y\ =\ 1\ /\ (1\ +\ exp(-x))}.

\subparagraph{Args: }\label{args-5}

\begin{itemize}
\tightlist
\item
  \texttt{x}: A Tensor with type \texttt{float}, \texttt{double},
  \texttt{int32}, \texttt{complex64}, \texttt{int64}, or
  \texttt{qint32}.
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-5}

A Tensor with the same type as \texttt{x} if
\texttt{x.dtype\ !=\ qint32} otherwise the return type is
\texttt{quint8}.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.tanh(x,\ name=None)}
}{tf.tanh(x, name=None) }}\label{tf.tanhx-namenone}

Computes hyperbolic tangent of \texttt{x} element-wise.

\subparagraph{Args: }\label{args-6}

\begin{itemize}
\tightlist
\item
  \texttt{x}: A Tensor with type \texttt{float}, \texttt{double},
  \texttt{int32}, \texttt{complex64}, \texttt{int64}, or
  \texttt{qint32}.
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-6}

A Tensor with the same type as \texttt{x} if
\texttt{x.dtype\ !=\ qint32} otherwise the return type is
\texttt{quint8}.

\subsection{Convolution }\label{convolution}

The convolution ops sweep a 2-D filter over a batch of images, applying
the filter to each window of each image of the appropriate size. The
different ops trade off between generic vs.~specific filters:

\begin{itemize}
\tightlist
\item
  \texttt{conv2d}: Arbitrary filters that can mix channels together.
\item
  \texttt{depthwise\_conv2d}: Filters that operate on each channel
  independently.
\item
  \texttt{separable\_conv2d}: A depthwise spatial filter followed by a
  pointwise filter.
\end{itemize}

Note that although these ops are called ``convolution'', they are
strictly speaking ``cross-correlation'' since the filter is combined
with an input window without reversing the filter. For details, see
\href{https://en.wikipedia.org/wiki/Cross-correlation\#Properties}{the
properties of cross-correlation}.

The filter is applied to image patches of the same size as the filter
and strided according to the \texttt{strides} argument.
\texttt{strides\ =\ {[}1,\ 1,\ 1,\ 1{]}} applies the filter to a patch
at every offset, \texttt{strides\ =\ {[}1,\ 2,\ 2,\ 1{]}} applies the
filter to every other image patch in each dimension, etc.

Ignoring channels for the moment, the spatial semantics of the
convolution ops are as follows. If the 4-D \texttt{input} has shape
\texttt{{[}batch,\ in\_height,\ in\_width,\ ...{]}} and the 4-D
\texttt{filter} has shape
\texttt{{[}filter\_height,\ filter\_width,\ ...{]}}, then

\begin{verbatim}
shape(output) = [batch,
                 (in_height - filter_height + 1) / strides[1],
                 (in_width - filter_width + 1) / strides[2],
                 ...]

output[b, i, j, :] =
    sum_{di, dj} input[b, strides[1] * i + di, strides[2] * j + dj, ...] *
                 filter[di, dj, ...]
\end{verbatim}

Since \texttt{input} is 4-D, each \texttt{input{[}b,\ i,\ j,\ :{]}} is a
vector. For \texttt{conv2d}, these vectors are multiplied by the
\texttt{filter{[}di,\ dj,\ :,\ :{]}} matrices to produce new vectors.
For \texttt{depthwise\_conv\_2d}, each scalar component
\texttt{input{[}b,\ i,\ j,\ k{]}} is multiplied by a vector
\texttt{filter{[}di,\ dj,\ k{]}}, and all the vectors are concatenated.

In the formula for \texttt{shape(output)}, the rounding direction
depends on padding:

\begin{itemize}
\tightlist
\item
  \texttt{padding\ =\ \textquotesingle{}SAME\textquotesingle{}}: Round
  down (only full size windows are considered).
\item
  \texttt{padding\ =\ \textquotesingle{}VALID\textquotesingle{}}: Round
  up (partial windows are included).
\end{itemize}

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.nn.conv2d(input,\ filter,\ strides,\ padding,\ use\_cudnn\_on\_gpu=None,\ name=None)}
}{tf.nn.conv2d(input, filter, strides, padding, use\_cudnn\_on\_gpu=None, name=None) }}\label{tf.nn.conv2dinput-filter-strides-padding-useux5fcudnnux5fonux5fgpunone-namenone}

Computes a 2-D convolution given 4-D \texttt{input} and \texttt{filter}
tensors.

Given an input tensor of shape
\texttt{{[}batch,\ in\_height,\ in\_width,\ in\_channels{]}} and a
filter / kernel tensor of shape
\texttt{{[}filter\_height,\ filter\_width,\ in\_channels,\ out\_channels{]}},
this op performs the following:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Flattens the filter to a 2-D matrix with shape
  \texttt{{[}filter\_height\ *\ filter\_width\ *\ in\_channels,\ output\_channels{]}}.
\item
  Extracts image patches from the the input tensor to form a
  \emph{virtual} tensor of shape
  \texttt{{[}batch,\ out\_height,\ out\_width,\ \ \ \ filter\_height\ *\ filter\_width\ *\ in\_channels{]}}.
\item
  For each patch, right-multiplies the filter matrix and the image patch
  vector.
\end{enumerate}

In detail,

\begin{verbatim}
output[b, i, j, k] =
    sum_{di, dj, q} input[b, strides[1] * i + di, strides[2] * j + dj, q] *
                    filter[di, dj, q, k]
\end{verbatim}

Must have \texttt{strides{[}0{]}\ =\ strides{[}3{]}\ =\ 1}. For the most
common case of the same horizontal and vertices strides,
\texttt{strides\ =\ {[}1,\ stride,\ stride,\ 1{]}}.

\subparagraph{Args: }\label{args-7}

\begin{itemize}
\tightlist
\item
  \texttt{input}: A \texttt{Tensor}. Must be one of the following types:
  \texttt{float32}, \texttt{float64}.
\item
  \texttt{filter}: A \texttt{Tensor}. Must have the same type as
  \texttt{input}.
\item
  \texttt{strides}: A list of \texttt{ints}. 1-D of length 4. The stride
  of the sliding window for each dimension of \texttt{input}.
\item
  \texttt{padding}: A \texttt{string} from: \texttt{"SAME",\ "VALID"}.
  The type of padding algorithm to use.
\item
  \texttt{use\_cudnn\_on\_gpu}: An optional \texttt{bool}. Defaults to
  \texttt{True}.
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-7}

A \texttt{Tensor}. Has the same type as \texttt{input}.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.nn.depthwise\_conv2d(input,\ filter,\ strides,\ padding,\ name=None)}
}{tf.nn.depthwise\_conv2d(input, filter, strides, padding, name=None) }}\label{tf.nn.depthwiseux5fconv2dinput-filter-strides-padding-namenone}

Depthwise 2-D convolution.

Given an input tensor of shape
\texttt{{[}batch,\ in\_height,\ in\_width,\ in\_channels{]}} and a
filter tensor of shape
\texttt{{[}filter\_height,\ filter\_width,\ in\_channels,\ channel\_multiplier{]}}
containing \texttt{in\_channels} convolutional filters of depth 1,
\texttt{depthwise\_conv2d} applies a different filter to each input
channel (expanding from 1 channel to \texttt{channel\_multiplier}
channels for each), then concatenates the results together. The output
has \texttt{in\_channels\ *\ channel\_multiplier} channels.

In detail,

\begin{verbatim}
output[b, i, j, k * channel_multiplier + q] =
    sum_{di, dj} input[b, strides[1] * i + di, strides[2] * j + dj, k] *
                 filter[di, dj, k, q]
\end{verbatim}

Must have \texttt{strides{[}0{]}\ =\ strides{[}3{]}\ =\ 1}. For the most
common case of the same horizontal and vertical strides,
\texttt{strides\ =\ {[}1,\ stride,\ stride,\ 1{]}}.

\subparagraph{Args: }\label{args-8}

\begin{itemize}
\tightlist
\item
  \texttt{input}: 4-D with shape
  \texttt{{[}batch,\ in\_height,\ in\_width,\ in\_channels{]}}.
\item
  \texttt{filter}: 4-D with shape
  \texttt{{[}filter\_height,\ filter\_width,\ in\_channels,\ channel\_multiplier{]}}.
\item
  \texttt{strides}: 1-D of size 4. The stride of the sliding window for
  each dimension of \texttt{input}.
\item
  \texttt{padding}: A string, either
  \texttt{\textquotesingle{}VALID\textquotesingle{}} or
  \texttt{\textquotesingle{}SAME\textquotesingle{}}. The padding
  algorithm.
\item
  \texttt{name}: A name for this operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-8}

A 4-D \texttt{Tensor} of shape
\texttt{{[}batch,\ out\_height,\ out\_width,\ in\_channels\ *\ channel\_multiplier{]}.}

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.nn.separable\_conv2d(input,\ depthwise\_filter,\ pointwise\_filter,\ strides,\ padding,\ name=None)}
}{tf.nn.separable\_conv2d(input, depthwise\_filter, pointwise\_filter, strides, padding, name=None) }}\label{tf.nn.separableux5fconv2dinput-depthwiseux5ffilter-pointwiseux5ffilter-strides-padding-namenone}

2-D convolution with separable filters.

Performs a depthwise convolution that acts separately on channels
followed by a pointwise convolution that mixes channels. Note that this
is separability between dimensions \texttt{{[}1,\ 2{]}} and \texttt{3},
not spatial separability between dimensions \texttt{1} and \texttt{2}.

In detail,

\begin{verbatim}
output[b, i, j, k] = sum_{di, dj, q, r]
    input[b, strides[1] * i + di, strides[2] * j + dj, q] *
    depthwise_filter[di, dj, q, r] *
    pointwise_filter[0, 0, q * channel_multiplier + r, k]
\end{verbatim}

\texttt{strides} controls the strides for the depthwise convolution
only, since the pointwise convolution has implicit strides of
\texttt{{[}1,\ 1,\ 1,\ 1{]}}. Must have
\texttt{strides{[}0{]}\ =\ strides{[}3{]}\ =\ 1}. For the most common
case of the same horizontal and vertical strides,
\texttt{strides\ =\ {[}1,\ stride,\ stride,\ 1{]}}.

\subparagraph{Args: }\label{args-9}

\begin{itemize}
\tightlist
\item
  \texttt{input}: 4-D \texttt{Tensor} with shape
  \texttt{{[}batch,\ in\_height,\ in\_width,\ in\_channels{]}}.
\item
  \texttt{depthwise\_filter}: 4-D \texttt{Tensor} with shape
  \texttt{{[}filter\_height,\ filter\_width,\ in\_channels,\ channel\_multiplier{]}}.
  Contains \texttt{in\_channels} convolutional filters of depth 1.
\item
  \texttt{pointwise\_filter}: 4-D \texttt{Tensor} with shape
  \texttt{{[}1,\ 1,\ channel\_multiplier\ *\ in\_channels,\ out\_channels{]}}.
  Pointwise filter to mix channels after \texttt{depthwise\_filter} has
  convolved spatially.
\item
  \texttt{strides}: 1-D of size 4. The strides for the depthwise
  convolution for each dimension of \texttt{input}.
\item
  \texttt{padding}: A string, either
  \texttt{\textquotesingle{}VALID\textquotesingle{}} or
  \texttt{\textquotesingle{}SAME\textquotesingle{}}. The padding
  algorithm.
\item
  \texttt{name}: A name for this operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-9}

A 4-D \texttt{Tensor} of shape
\texttt{{[}batch,\ out\_height,\ out\_width,\ out\_channels{]}}.

\subsection{Pooling }\label{pooling}

The pooling ops sweep a rectangular window over the input tensor,
computing a reduction operation for each window (average, max, or max
with argmax). Each pooling op uses rectangular windows of size
\texttt{ksize} separated by offset \texttt{strides}. For example, if
\texttt{strides} is all ones every window is used, if \texttt{strides}
is all twos every other window is used in each dimension, etc.

In detail, the output is

\begin{verbatim}
output[i] = reduce(value[strides * i:strides * i + ksize])
\end{verbatim}

for each tuple of indices \texttt{i}. The output shape is

\begin{verbatim}
shape(output) = (shape(value) - ksize + 1) / strides
\end{verbatim}

where the rounding direction depends on padding:

\begin{itemize}
\tightlist
\item
  \texttt{padding\ =\ \textquotesingle{}SAME\textquotesingle{}}: Round
  down (only full size windows are considered).
\item
  \texttt{padding\ =\ \textquotesingle{}VALID\textquotesingle{}}: Round
  up (partial windows are included).
\end{itemize}

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.nn.avg\_pool(value,\ ksize,\ strides,\ padding,\ name=None)}
}{tf.nn.avg\_pool(value, ksize, strides, padding, name=None) }}\label{tf.nn.avgux5fpoolvalue-ksize-strides-padding-namenone}

Performs the average pooling on the input.

Each entry in \texttt{output} is the mean of the corresponding size
\texttt{ksize} window in \texttt{value}.

\subparagraph{Args: }\label{args-10}

\begin{itemize}
\tightlist
\item
  \texttt{value}: A 4-D \texttt{Tensor} of shape
  \texttt{{[}batch,\ height,\ width,\ channels{]}} and type
  \texttt{float32}, \texttt{float64}, \texttt{qint8}, \texttt{quint8},
  or \texttt{qint32}.
\item
  \texttt{ksize}: A list of ints that has length \textgreater{}= 4. The
  size of the window for each dimension of the input tensor.
\item
  \texttt{strides}: A list of ints that has length \textgreater{}= 4.
  The stride of the sliding window for each dimension of the input
  tensor.
\item
  \texttt{padding}: A string, either
  \texttt{\textquotesingle{}VALID\textquotesingle{}} or
  \texttt{\textquotesingle{}SAME\textquotesingle{}}. The padding
  algorithm.
\item
  \texttt{name}: Optional name for the operation.
\end{itemize}

\subparagraph{Returns: }\label{returns-10}

A \texttt{Tensor} with the same type as \texttt{value}. The average
pooled output tensor.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.nn.max\_pool(value,\ ksize,\ strides,\ padding,\ name=None)}
}{tf.nn.max\_pool(value, ksize, strides, padding, name=None) }}\label{tf.nn.maxux5fpoolvalue-ksize-strides-padding-namenone}

Performs the max pooling on the input.

\subparagraph{Args: }\label{args-11}

\begin{itemize}
\tightlist
\item
  \texttt{value}: A 4-D \texttt{Tensor} with shape
  \texttt{{[}batch,\ height,\ width,\ channels{]}} and type
  \texttt{float32}, \texttt{float64}, \texttt{qint8}, \texttt{quint8},
  \texttt{qint32}.
\item
  \texttt{ksize}: A list of ints that has length \textgreater{}= 4. The
  size of the window for each dimension of the input tensor.
\item
  \texttt{strides}: A list of ints that has length \textgreater{}= 4.
  The stride of the sliding window for each dimension of the input
  tensor.
\item
  \texttt{padding}: A string, either
  \texttt{\textquotesingle{}VALID\textquotesingle{}} or
  \texttt{\textquotesingle{}SAME\textquotesingle{}}. The padding
  algorithm.
\item
  \texttt{name}: Optional name for the operation.
\end{itemize}

\subparagraph{Returns: }\label{returns-11}

A \texttt{Tensor} with the same type as \texttt{value}. The max pooled
output tensor.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.nn.max\_pool\_with\_argmax(input,\ ksize,\ strides,\ padding,\ Targmax=None,\ name=None)}
}{tf.nn.max\_pool\_with\_argmax(input, ksize, strides, padding, Targmax=None, name=None) }}\label{tf.nn.maxux5fpoolux5fwithux5fargmaxinput-ksize-strides-padding-targmaxnone-namenone}

Performs max pooling on the input and outputs both max values and
indices.

The indices in \texttt{argmax} are flattened, so that a maximum value at
position \texttt{{[}b,\ y,\ x,\ c{]}} becomes flattened index
\texttt{((b\ *\ height\ +\ y)\ *\ width\ +\ x)\ *\ channels\ +\ c}.

\subparagraph{Args: }\label{args-12}

\begin{itemize}
\tightlist
\item
  \texttt{input}: A \texttt{Tensor} of type \texttt{float32}. 4-D with
  shape \texttt{{[}batch,\ height,\ width,\ channels{]}}. Input to pool
  over.
\item
  \texttt{ksize}: A list of \texttt{ints} that has length
  \texttt{\textgreater{}=\ 4}. The size of the window for each dimension
  of the input tensor.
\item
  \texttt{strides}: A list of \texttt{ints} that has length
  \texttt{\textgreater{}=\ 4}. The stride of the sliding window for each
  dimension of the input tensor.
\item
  \texttt{padding}: A \texttt{string} from: \texttt{"SAME",\ "VALID"}.
  The type of padding algorithm to use.
\item
  \texttt{Targmax}: An optional \texttt{tf.DType} from:
  \texttt{tf.int32,\ tf.int64}. Defaults to \texttt{tf.int64}.
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-12}

A tuple of \texttt{Tensor} objects (output, argmax).

\begin{itemize}
\tightlist
\item
  \texttt{output}: A \texttt{Tensor} of type \texttt{float32}. The max
  pooled output tensor.
\item
  \texttt{argmax}: A \texttt{Tensor} of type \texttt{Targmax}. 4-D. The
  flattened indices of the max values chosen for each output.
\end{itemize}

\subsection{Normalization }\label{normalization}

Normalization is useful to prevent neurons from saturating when inputs
may have varying scale, and to aid generalization.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.nn.l2\_normalize(x,\ dim,\ epsilon=1e-12,\ name=None)}
}{tf.nn.l2\_normalize(x, dim, epsilon=1e-12, name=None) }}\label{tf.nn.l2ux5fnormalizex-dim-epsilon1e-12-namenone}

Normalizes along dimension \texttt{dim} using an L2 norm.

For a 1-D tensor with \texttt{dim\ =\ 0}, computes

\begin{verbatim}
output = x / sqrt(max(sum(x**2), epsilon))
\end{verbatim}

For \texttt{x} with more dimensions, independently normalizes each 1-D
slice along dimension \texttt{dim}.

\subparagraph{Args: }\label{args-13}

\begin{itemize}
\tightlist
\item
  \texttt{x}: A \texttt{Tensor}.
\item
  \texttt{dim}: Dimension along which to normalize.
\item
  \texttt{epsilon}: A lower bound value for the norm. Will use
  \texttt{sqrt(epsilon)} as the divisor if
  \texttt{norm\ \textless{}\ sqrt(epsilon)}.
\item
  \texttt{name}: A name for this operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-13}

A \texttt{Tensor} with the same shape as \texttt{x}.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.nn.local\_response\_normalization(input,\ depth\_radius=None,\ bias=None,\ alpha=None,\ beta=None,\ name=None)}
}{tf.nn.local\_response\_normalization(input, depth\_radius=None, bias=None, alpha=None, beta=None, name=None) }}\label{tf.nn.localux5fresponseux5fnormalizationinput-depthux5fradiusnone-biasnone-alphanone-betanone-namenone}

Local Response Normalization.

The 4-D \texttt{input} tensor is treated as a 3-D array of 1-D vectors
(along the last dimension), and each vector is normalized independently.
Within a given vector, each component is divided by the weighted,
squared sum of inputs within \texttt{depth\_radius}. In detail,

\begin{verbatim}
sqr_sum[a, b, c, d] =
    sum(input[a, b, c, d - depth_radius : d + depth_radius + 1] ** 2)
output = input / (bias + alpha * sqr_sum ** beta)
\end{verbatim}

For details, see {[}Krizhevsky et al., ImageNet classification with deep
convolutional neural networks (NIPS 2012){]}
(http://papers.nips.cc/paper/4824-imagenet-classification-with-deep-convolutional-neural-networks).

\subparagraph{Args: }\label{args-14}

\begin{itemize}
\tightlist
\item
  \texttt{input}: A \texttt{Tensor} of type \texttt{float32}. 4-D.
\item
  \texttt{depth\_radius}: An optional \texttt{int}. Defaults to
  \texttt{5}. 0-D. Half-width of the 1-D normalization window.
\item
  \texttt{bias}: An optional \texttt{float}. Defaults to \texttt{1}. An
  offset (usually positive to avoid dividing by 0).
\item
  \texttt{alpha}: An optional \texttt{float}. Defaults to \texttt{1}. A
  scale factor, usually positive.
\item
  \texttt{beta}: An optional \texttt{float}. Defaults to \texttt{0.5}.
  An exponent.
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-14}

A \texttt{Tensor} of type \texttt{float32}.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.nn.moments(x,\ axes,\ name=None)}
}{tf.nn.moments(x, axes, name=None) }}\label{tf.nn.momentsx-axes-namenone}

Calculate the mean and variance of \texttt{x}.

The mean and variance are calculated by aggregating the contents of
\texttt{x} across \texttt{axes}. If \texttt{x} is 1-D and
\texttt{axes\ =\ {[}0{]}} this is just the mean and variance of a
vector.

For so-called ``global normalization'' needed for convolutional filters
pass \texttt{axes={[}0,\ 1,\ 2{]}} (batch, height, width). For batch
normalization pass \texttt{axes={[}0{]}} (batch).

\subparagraph{Args: }\label{args-15}

\begin{itemize}
\tightlist
\item
  \texttt{x}: A \texttt{Tensor}.
\item
  \texttt{axes}: array of ints. Axes along which to compute mean and
  variance.
\item
  \texttt{name}: Name used to scope the operations that compute the
  moments.
\end{itemize}

\subparagraph{Returns: }\label{returns-15}

Two \texttt{Tensors}: \texttt{mean} and \texttt{variance}.

\subsection{Losses }\label{losses}

The loss ops measure error between two tensors, or between a tensor and
zero. These can be used for measuring accuracy of a network in a
regression task or for regularization purposes (weight decay).

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.nn.l2\_loss(t,\ name=None)}
}{tf.nn.l2\_loss(t, name=None) }}\label{tf.nn.l2ux5flosst-namenone}

L2 Loss.

Computes half the L2 norm of a tensor without the \texttt{sqrt}:

\begin{verbatim}
output = sum(t ** 2) / 2
\end{verbatim}

\subparagraph{Args: }\label{args-16}

\begin{itemize}
\tightlist
\item
  \texttt{t}: A \texttt{Tensor}. Must be one of the following types:
  \texttt{float32}, \texttt{float64}, \texttt{int64}, \texttt{int32},
  \texttt{uint8}, \texttt{int16}, \texttt{int8}, \texttt{complex64},
  \texttt{qint8}, \texttt{quint8}, \texttt{qint32}. Typically 2-D, but
  may have any dimensions.
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-16}

A \texttt{Tensor}. Has the same type as \texttt{t}. 0-D.

\subsection{Classification }\label{classification}

TensorFlow provides several operations that help you perform
classification.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.nn.sigmoid\_cross\_entropy\_with\_logits(logits,\ targets,\ name=None)}
}{tf.nn.sigmoid\_cross\_entropy\_with\_logits(logits, targets, name=None) }}\label{tf.nn.sigmoidux5fcrossux5fentropyux5fwithux5flogitslogits-targets-namenone}

Computes sigmoid cross entropy given \texttt{logits}.

Measures the probability error in discrete classification tasks in which
each class is independent and not mutually exclusive. For instance, one
could perform multilabel classification where a picture can contain both
an elephant and a dog at the same time.

For brevity, let \texttt{x\ =\ logits}, \texttt{z\ =\ targets}. The
logistic loss is

\begin{verbatim}
x - x * z + log(1 + exp(-x))
\end{verbatim}

To ensure stability and avoid overflow, the implementation uses

\begin{verbatim}
max(x, 0) - x * z + log(1 + exp(-abs(x)))
\end{verbatim}

\texttt{logits} and \texttt{targets} must have the same type and shape.

\subparagraph{Args: }\label{args-17}

\begin{itemize}
\tightlist
\item
  \texttt{logits}: A \texttt{Tensor} of type \texttt{float32} or
  \texttt{float64}.
\item
  \texttt{targets}: A \texttt{Tensor} of the same type and shape as
  \texttt{logits}.
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-17}

A \texttt{Tensor} of the same shape as \texttt{logits} with the
componentwise logistic losses.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.nn.softmax(logits,\ name=None)}
}{tf.nn.softmax(logits, name=None) }}\label{tf.nn.softmaxlogits-namenone}

Computes softmax activations.

For each batch \texttt{i} and class \texttt{j} we have

\begin{verbatim}
softmax[i, j] = exp(logits[i, j]) / sum(exp(logits[i]))
\end{verbatim}

\subparagraph{Args: }\label{args-18}

\begin{itemize}
\tightlist
\item
  \texttt{logits}: A \texttt{Tensor}. Must be one of the following
  types: \texttt{float32}, \texttt{float64}. 2-D with shape
  \texttt{{[}batch\_size,\ num\_classes{]}}.
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-18}

A \texttt{Tensor}. Has the same type as \texttt{logits}. Same shape as
\texttt{logits}.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.nn.softmax\_cross\_entropy\_with\_logits(logits,\ labels,\ name=None)}
}{tf.nn.softmax\_cross\_entropy\_with\_logits(logits, labels, name=None) }}\label{tf.nn.softmaxux5fcrossux5fentropyux5fwithux5flogitslogits-labels-namenone}

Computes softmax cross entropy between \texttt{logits} and
\texttt{labels}.

Measures the probability error in discrete classification tasks in which
the classes are mutually exclusive (each entry is in exactly one class).
For example, each CIFAR-10 image is labeled with one and only one label:
an image can be a dog or a truck, but not both.

\textbf{WARNING:} This op expects unscaled logits, since it performs a
\texttt{softmax} on \texttt{logits} internally for efficiency. Do not
call this op with the output of \texttt{softmax}, as it will produce
incorrect results.

\texttt{logits} and \texttt{labels} must have the same shape
\texttt{{[}batch\_size,\ num\_classes{]}} and the same dtype (either
\texttt{float32} or \texttt{float64}).

\subparagraph{Args: }\label{args-19}

\begin{itemize}
\tightlist
\item
  \texttt{logits}: Unscaled log probabilities.
\item
  \texttt{labels}: Each row \texttt{labels{[}i{]}} must be a valid
  probability distribution.
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-19}

A 1-D \texttt{Tensor} of length \texttt{batch\_size} of the same type as
\texttt{logits} with the softmax cross entropy loss.

\subsection{Embeddings }\label{embeddings}

TensorFlow provides library support for looking up values in embedding
tensors.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.nn.embedding\_lookup(params,\ ids,\ name=None)}
}{tf.nn.embedding\_lookup(params, ids, name=None) }}\label{tf.nn.embeddingux5flookupparams-ids-namenone}

Looks up \texttt{ids} in a list of embedding tensors.

This function is used to perform parallel lookups on the list of tensors
in \texttt{params}. It is a generalization of
\href{../../api_docs/python/array_ops.md\#gather}{\texttt{tf.gather()}},
where \texttt{params} is interpreted as a partition of a larger
embedding tensor.

If \texttt{len(params)\ \textgreater{}\ 1}, each element \texttt{id} of
\texttt{ids} is partitioned between the elements of \texttt{params} by
computing \texttt{p\ =\ id\ \%\ len(params)}, and is then used to look
up the slice \texttt{params{[}p{]}{[}id\ //\ len(params),\ ...{]}}.

The results of the lookup are then concatenated into a dense tensor. The
returned tensor has shape \texttt{shape(ids)\ +\ shape(params){[}1:{]}}.

\subparagraph{Args: }\label{args-20}

\begin{itemize}
\tightlist
\item
  \texttt{params}: A list of tensors with the same shape and type.
\item
  \texttt{ids}: A \texttt{Tensor} with type \texttt{int32} containing
  the ids to be looked up in \texttt{params}.
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-20}

A \texttt{Tensor} with the same type as the tensors in \texttt{params}.

\subparagraph{Raises: }\label{raises-1}

\begin{itemize}
\tightlist
\item
  \texttt{ValueError}: If \texttt{params} is empty.
\end{itemize}

\subsection{Evaluation }\label{evaluation}

The evaluation ops are useful for measuring the performance of a
network. Since they are nondifferentiable, they are typically used at
evaluation time.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.nn.top\_k(input,\ k,\ name=None)}
}{tf.nn.top\_k(input, k, name=None) }}\label{tf.nn.topux5fkinput-k-namenone}

Returns the values and indices of the k largest elements for each row.

\textbackslash{}(values\_\{i, j\}\textbackslash{}) represents the j-th
largest element in \textbackslash{}(input\_i\textbackslash{}).

\textbackslash{}(indices\_\{i, j\}\textbackslash{}) gives the column
index of the corresponding element, such that
\textbackslash{}(input\_\{i, indices\_\{i, j\}\} = values\_\{i,
j\}\textbackslash{}). If two elements are equal, the lower-index element
appears first.

\subparagraph{Args: }\label{args-21}

\begin{itemize}
\tightlist
\item
  \texttt{input}: A \texttt{Tensor}. Must be one of the following types:
  \texttt{float32}, \texttt{float64}, \texttt{int32}, \texttt{int64},
  \texttt{uint8}, \texttt{int16}, \texttt{int8}. A batch\_size x classes
  tensor
\item
  \texttt{k}: An \texttt{int} that is \texttt{\textgreater{}=\ 1}.
  Number of top elements to look for within each row
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-21}

A tuple of \texttt{Tensor} objects (values, indices).

\begin{itemize}
\tightlist
\item
  \texttt{values}: A \texttt{Tensor}. Has the same type as
  \texttt{input}. A batch\_size x k tensor with the k largest elements
  for each row, sorted in descending order
\item
  \texttt{indices}: A \texttt{Tensor} of type \texttt{int32}. A
  batch\_size x k tensor with the index of each value within each row
\end{itemize}

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.nn.in\_top\_k(predictions,\ targets,\ k,\ name=None)}
}{tf.nn.in\_top\_k(predictions, targets, k, name=None) }}\label{tf.nn.inux5ftopux5fkpredictions-targets-k-namenone}

Says whether the targets are in the top K predictions.

This outputs a batch\_size bool array, an entry out{[}i{]} is true if
the prediction for the target class is among the top k predictions among
all predictions for example i. Note that the behavior of InTopK differs
from the TopK op in its handling of ties; if multiple classes have the
same prediction value and straddle the top-k boundary, all of those
classes are considered to be in the top k.

More formally, let

\textbackslash{}(predictions\_i\textbackslash{}) be the predictions for
all classes for example i, \textbackslash{}(targets\_i\textbackslash{})
be the target class for example i,
\textbackslash{}(out\_i\textbackslash{}) be the output for example i,

\[out_i = predictions_{i, targets_i} \in TopKIncludingTies(predictions_i)\]

\subparagraph{Args: }\label{args-22}

\begin{itemize}
\tightlist
\item
  \texttt{predictions}: A \texttt{Tensor} of type \texttt{float32}. A
  batch\_size x classes tensor
\item
  \texttt{targets}: A \texttt{Tensor} of type \texttt{int32}. A
  batch\_size vector of class ids
\item
  \texttt{k}: An \texttt{int}. Number of top elements to look at for
  computing precision
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-22}

A \texttt{Tensor} of type \texttt{bool}. Computed Precision at k as a
bool Tensor

\subsection{Candidate Sampling }\label{candidate-sampling}

Do you want to train a multiclass or multilabel model with thousands or
millions of output classes (for example, a language model with a large
vocabulary)? Training with a full Softmax is slow in this case, since
all of the classes are evaluated for every training example. Candidate
Sampling training algorithms can speed up your step times by only
considering a small randomly-chosen subset of contrastive classes
(called candidates) for each batch of training examples.

See our {[}Candidate Sampling Algorithms Reference{]}
(../../extras/candidate\_sampling.pdf)

\subsubsection{Sampled Loss Functions }\label{sampled-loss-functions}

TensorFlow provides the following sampled loss functions for faster
training.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.nn.nce\_loss(weights,\ biases,\ inputs,\ labels,\ num\_sampled,\ num\_classes,\ num\_true=1,\ sampled\_values=None,\ remove\_accidental\_hits=False,\ name=\textquotesingle{}nce\_loss\textquotesingle{})}
}{tf.nn.nce\_loss(weights, biases, inputs, labels, num\_sampled, num\_classes, num\_true=1, sampled\_values=None, remove\_accidental\_hits=False, name='nce\_loss') }}\label{tf.nn.nceux5flossweights-biases-inputs-labels-numux5fsampled-numux5fclasses-numux5ftrue1-sampledux5fvaluesnone-removeux5faccidentalux5fhitsfalse-namenceux5floss}

Computes and returns the noise-contrastive estimation training loss.

See {[}Noise-contrastive estimation: A new estimation principle for
unnormalized statistical models{]}
(http://www.jmlr.org/proceedings/papers/v9/gutmann10a/gutmann10a.pdf).
Also see our {[}Candidate Sampling Algorithms Reference{]}
(http://www.tensorflow.org/extras/candidate\_sampling.pdf)

Note: In the case where num\_true \textgreater{} 1, we assign to each
target class the target probability 1 / num\_true so that the target
probabilities sum to 1 per-example.

Note: It would be useful to allow a variable number of target classes
per example. We hope to provide this functionality in a future release.
For now, if you have a variable number of target classes, you can pad
them out to a constant number by either repeating them or by padding
with an otherwise unused class.

\subparagraph{Args: }\label{args-23}

\begin{itemize}
\tightlist
\item
  \texttt{weights}: A \texttt{Tensor} of shape {[}num\_classes, dim{]}.
  The class embeddings.
\item
  \texttt{biases}: A \texttt{Tensor} of shape {[}num\_classes{]}. The
  class biases.
\item
  \texttt{inputs}: A \texttt{Tensor} of shape {[}batch\_size, dim{]}.
  The forward activations of the input network.
\item
  \texttt{labels}: A \texttt{Tensor} of type \texttt{int64} and shape
  \texttt{{[}batch\_size,\ num\_true{]}}. The target classes.
\item
  \texttt{num\_sampled}: An \texttt{int}. The number of classes to
  randomly sample per batch.
\item
  \texttt{num\_classes}: An \texttt{int}. The number of possible
  classes.
\item
  \texttt{num\_true}: An \texttt{int}. The number of target classes per
  training example.
\item
  \texttt{sampled\_values}: a tuple of
  \texttt{(sampled\_candidates,\ true\_expected\_count,\ \ \ sampled\_expected\_count)}
  returned by a *\_candidate\_sampler function. (if None, we default to
  LogUniformCandidateSampler)
\item
  \texttt{remove\_accidental\_hits}: A \texttt{bool}. Whether to remove
  ``accidental hits'' where a sampled class equals one of the target
  classes. If set to \texttt{True}, this is a ``Sampled Logistic'' loss
  instead of NCE, and we are learning to generate log-odds instead of
  log probabilities. See our {[}Candidate Sampling Algorithms
  Reference{]}
  (http://www.tensorflow.org/extras/candidate\_sampling.pdf). Default is
  False.
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-23}

A batch\_size 1-D tensor of per-example NCE losses.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.nn.sampled\_softmax\_loss(weights,\ biases,\ inputs,\ labels,\ num\_sampled,\ num\_classes,\ num\_true=1,\ sampled\_values=None,\ remove\_accidental\_hits=True,\ name=\textquotesingle{}sampled\_softmax\_loss\textquotesingle{})}
}{tf.nn.sampled\_softmax\_loss(weights, biases, inputs, labels, num\_sampled, num\_classes, num\_true=1, sampled\_values=None, remove\_accidental\_hits=True, name='sampled\_softmax\_loss') }}\label{tf.nn.sampledux5fsoftmaxux5flossweights-biases-inputs-labels-numux5fsampled-numux5fclasses-numux5ftrue1-sampledux5fvaluesnone-removeux5faccidentalux5fhitstrue-namesampledux5fsoftmaxux5floss}

Computes and returns the sampled softmax training loss.

This is a faster way to train a softmax classifier over a huge number of
classes.

This operation is for training only. It is generally an underestimate of
the full softmax loss.

At inference time, you can compute full softmax probabilities with the
expression
\texttt{tf.nn.softmax(tf.matmul(inputs,\ weights)\ +\ biases)}.

See our {[}Candidate Sampling Algorithms Reference{]}
(http://www.tensorflow.org/extras/candidate\_sampling.pdf)

Also see Section 3 of http://arxiv.org/abs/1412.2007 for the math.

\subparagraph{Args: }\label{args-24}

\begin{itemize}
\tightlist
\item
  \texttt{weights}: A \texttt{Tensor} of shape {[}num\_classes, dim{]}.
  The class embeddings.
\item
  \texttt{biases}: A \texttt{Tensor} of shape {[}num\_classes{]}. The
  class biases.
\item
  \texttt{inputs}: A \texttt{Tensor} of shape {[}batch\_size, dim{]}.
  The forward activations of the input network.
\item
  \texttt{labels}: A \texttt{Tensor} of type \texttt{int64} and shape
  \texttt{{[}batch\_size,\ num\_true{]}}. The target classes. Note that
  this format differs from the \texttt{labels} argument of
  \texttt{nn.softmax\_cross\_entropy\_with\_logits}.
\item
  \texttt{num\_sampled}: An \texttt{int}. The number of classes to
  randomly sample per batch.
\item
  \texttt{num\_classes}: An \texttt{int}. The number of possible
  classes.
\item
  \texttt{num\_true}: An \texttt{int}. The number of target classes per
  training example.
\item
  \texttt{sampled\_values}: a tuple of
  \texttt{(sampled\_candidates,\ true\_expected\_count,\ \ \ sampled\_expected\_count)}
  returned by a *\_candidate\_sampler function. (if None, we default to
  LogUniformCandidateSampler)
\item
  \texttt{remove\_accidental\_hits}: A \texttt{bool}. whether to remove
  ``accidental hits'' where a sampled class equals one of the target
  classes. Default is True.
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-24}

A batch\_size 1-D tensor of per-example sampled softmax losses.

\subsubsection{Candidate Samplers }\label{candidate-samplers}

TensorFlow provides the following samplers for randomly sampling
candidate classes when using one of the sampled loss functions above.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.nn.uniform\_candidate\_sampler(true\_classes,\ num\_true,\ num\_sampled,\ unique,\ range\_max,\ seed=None,\ name=None)}
}{tf.nn.uniform\_candidate\_sampler(true\_classes, num\_true, num\_sampled, unique, range\_max, seed=None, name=None) }}\label{tf.nn.uniformux5fcandidateux5fsamplertrueux5fclasses-numux5ftrue-numux5fsampled-unique-rangeux5fmax-seednone-namenone}

Samples a set of classes using a uniform base distribution.

This operation randomly samples a tensor of sampled classes
(\texttt{sampled\_candidates}) from the range of integers
\texttt{{[}0,\ range\_max{]}}.

The elements of \texttt{sampled\_candidates} are drawn without
replacement (if \texttt{unique=True}) or with replacement (if
\texttt{unique=False}) from the base distribution.

The base distribution for this operation is the uniform distribution
over the range of integers \texttt{{[}0,\ range\_max{]}}.

In addition, this operation returns tensors
\texttt{true\_expected\_count} and \texttt{sampled\_expected\_count}
representing the number of times each of the target classes
(\texttt{true\_classes}) and the sampled classes
(\texttt{sampled\_candidates}) is expected to occur in an average tensor
of sampled classes. These values correspond to \texttt{Q(y\textbar{}x)}
defined in
\href{http://www.tensorflow.org/extras/candidate_sampling.pdf}{this
document}. If \texttt{unique=True}, then these are post-rejection
probabilities and we compute them approximately.

\subparagraph{Args: }\label{args-25}

\begin{itemize}
\tightlist
\item
  \texttt{true\_classes}: A \texttt{Tensor} of type \texttt{int64} and
  shape \texttt{{[}batch\_size,\ num\_true{]}}. The target classes.
\item
  \texttt{num\_true}: An \texttt{int}. The number of target classes per
  training example.
\item
  \texttt{num\_sampled}: An \texttt{int}. The number of classes to
  randomly sample per batch.
\item
  \texttt{unique}: A \texttt{bool}. Determines whether all sampled
  classes in a batch are unique.
\item
  \texttt{range\_max}: An \texttt{int}. The number of possible classes.
\item
  \texttt{seed}: An \texttt{int}. An operation-specific seed. Default is
  0.
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-25}

\begin{itemize}
\tightlist
\item
  \texttt{sampled\_candidates}: A tensor of type \texttt{int64} and
  shape \texttt{{[}num\_sampled{]}}. The sampled classes.
\item
  \texttt{true\_expected\_count}: A tensor of type \texttt{float}. Same
  shape as \texttt{true\_classes}. The expected counts under the
  sampling distribution of each of \texttt{true\_classes}.
\item
  \texttt{sampled\_expected\_count}: A tensor of type \texttt{float}.
  Same shape as \texttt{sampled\_candidates}. The expected counts under
  the sampling distribution of each of \texttt{sampled\_candidates}.
\end{itemize}

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.nn.log\_uniform\_candidate\_sampler(true\_classes,\ num\_true,\ num\_sampled,\ unique,\ range\_max,\ seed=None,\ name=None)}
}{tf.nn.log\_uniform\_candidate\_sampler(true\_classes, num\_true, num\_sampled, unique, range\_max, seed=None, name=None) }}\label{tf.nn.logux5funiformux5fcandidateux5fsamplertrueux5fclasses-numux5ftrue-numux5fsampled-unique-rangeux5fmax-seednone-namenone}

Samples a set of classes using a log-uniform (Zipfian) base
distribution.

This operation randomly samples a tensor of sampled classes
(\texttt{sampled\_candidates}) from the range of integers
\texttt{{[}0,\ range\_max{]}}.

The elements of \texttt{sampled\_candidates} are drawn without
replacement (if \texttt{unique=True}) or with replacement (if
\texttt{unique=False}) from the base distribution.

The base distribution for this operation is an approximately log-uniform
or Zipfian distribution:

\texttt{P(class)\ =\ (log(class\ +\ 2)\ -\ log(class\ +\ 1))\ /\ log(range\_max\ +\ 1)}

This sampler is useful when the target classes approximately follow such
a distribution - for example, if the classes represent words in a
lexicon sorted in decreasing order of frequency. If your classes are not
ordered by decreasing frequency, do not use this op.

In addition, this operation returns tensors
\texttt{true\_expected\_count} and \texttt{sampled\_expected\_count}
representing the number of times each of the target classes
(\texttt{true\_classes}) and the sampled classes
(\texttt{sampled\_candidates}) is expected to occur in an average tensor
of sampled classes. These values correspond to \texttt{Q(y\textbar{}x)}
defined in
\href{http://www.tensorflow.org/extras/candidate_sampling.pdf}{this
document}. If \texttt{unique=True}, then these are post-rejection
probabilities and we compute them approximately.

\subparagraph{Args: }\label{args-26}

\begin{itemize}
\tightlist
\item
  \texttt{true\_classes}: A \texttt{Tensor} of type \texttt{int64} and
  shape \texttt{{[}batch\_size,\ num\_true{]}}. The target classes.
\item
  \texttt{num\_true}: An \texttt{int}. The number of target classes per
  training example.
\item
  \texttt{num\_sampled}: An \texttt{int}. The number of classes to
  randomly sample per batch.
\item
  \texttt{unique}: A \texttt{bool}. Determines whether all sampled
  classes in a batch are unique.
\item
  \texttt{range\_max}: An \texttt{int}. The number of possible classes.
\item
  \texttt{seed}: An \texttt{int}. An operation-specific seed. Default is
  0.
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-26}

\begin{itemize}
\tightlist
\item
  \texttt{sampled\_candidates}: A tensor of type \texttt{int64} and
  shape \texttt{{[}num\_sampled{]}}. The sampled classes.
\item
  \texttt{true\_expected\_count}: A tensor of type \texttt{float}. Same
  shape as \texttt{true\_classes}. The expected counts under the
  sampling distribution of each of \texttt{true\_classes}.
\item
  \texttt{sampled\_expected\_count}: A tensor of type \texttt{float}.
  Same shape as \texttt{sampled\_candidates}. The expected counts under
  the sampling distribution of each of \texttt{sampled\_candidates}.
\end{itemize}

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.nn.learned\_unigram\_candidate\_sampler(true\_classes,\ num\_true,\ num\_sampled,\ unique,\ range\_max,\ seed=None,\ name=None)}
}{tf.nn.learned\_unigram\_candidate\_sampler(true\_classes, num\_true, num\_sampled, unique, range\_max, seed=None, name=None) }}\label{tf.nn.learnedux5funigramux5fcandidateux5fsamplertrueux5fclasses-numux5ftrue-numux5fsampled-unique-rangeux5fmax-seednone-namenone}

Samples a set of classes from a distribution learned during training.

This operation randomly samples a tensor of sampled classes
(\texttt{sampled\_candidates}) from the range of integers
\texttt{{[}0,\ range\_max{]}}.

The elements of \texttt{sampled\_candidates} are drawn without
replacement (if \texttt{unique=True}) or with replacement (if
\texttt{unique=False}) from the base distribution.

The base distribution for this operation is constructed on the fly
during training. It is a unigram distribution over the target classes
seen so far during training. Every integer in
\texttt{{[}0,\ range\_max{]}} begins with a weight of 1, and is
incremented by 1 each time it is seen as a target class. The base
distribution is not saved to checkpoints, so it is reset when the model
is reloaded.

In addition, this operation returns tensors
\texttt{true\_expected\_count} and \texttt{sampled\_expected\_count}
representing the number of times each of the target classes
(\texttt{true\_classes}) and the sampled classes
(\texttt{sampled\_candidates}) is expected to occur in an average tensor
of sampled classes. These values correspond to \texttt{Q(y\textbar{}x)}
defined in
\href{http://www.tensorflow.org/extras/candidate_sampling.pdf}{this
document}. If \texttt{unique=True}, then these are post-rejection
probabilities and we compute them approximately.

\subparagraph{Args: }\label{args-27}

\begin{itemize}
\tightlist
\item
  \texttt{true\_classes}: A \texttt{Tensor} of type \texttt{int64} and
  shape \texttt{{[}batch\_size,\ num\_true{]}}. The target classes.
\item
  \texttt{num\_true}: An \texttt{int}. The number of target classes per
  training example.
\item
  \texttt{num\_sampled}: An \texttt{int}. The number of classes to
  randomly sample per batch.
\item
  \texttt{unique}: A \texttt{bool}. Determines whether all sampled
  classes in a batch are unique.
\item
  \texttt{range\_max}: An \texttt{int}. The number of possible classes.
\item
  \texttt{seed}: An \texttt{int}. An operation-specific seed. Default is
  0.
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-27}

\begin{itemize}
\tightlist
\item
  \texttt{sampled\_candidates}: A tensor of type \texttt{int64} and
  shape \texttt{{[}num\_sampled{]}}. The sampled classes.
\item
  \texttt{true\_expected\_count}: A tensor of type \texttt{float}. Same
  shape as \texttt{true\_classes}. The expected counts under the
  sampling distribution of each of \texttt{true\_classes}.
\item
  \texttt{sampled\_expected\_count}: A tensor of type \texttt{float}.
  Same shape as \texttt{sampled\_candidates}. The expected counts under
  the sampling distribution of each of \texttt{sampled\_candidates}.
\end{itemize}

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.nn.fixed\_unigram\_candidate\_sampler(true\_classes,\ num\_true,\ num\_sampled,\ unique,\ range\_max,\ vocab\_file=\textquotesingle{}\textquotesingle{},\ distortion=0.0,\ num\_reserved\_ids=0,\ num\_shards=1,\ shard=0,\ unigrams={[}{]},\ seed=None,\ name=None)}
}{tf.nn.fixed\_unigram\_candidate\_sampler(true\_classes, num\_true, num\_sampled, unique, range\_max, vocab\_file='', distortion=0.0, num\_reserved\_ids=0, num\_shards=1, shard=0, unigrams={[}{]}, seed=None, name=None) }}\label{tf.nn.fixedux5funigramux5fcandidateux5fsamplertrueux5fclasses-numux5ftrue-numux5fsampled-unique-rangeux5fmax-vocabux5ffile-distortion0.0-numux5freservedux5fids0-numux5fshards1-shard0-unigrams-seednone-namenone}

Samples a set of classes using the provided (fixed) base distribution.

This operation randomly samples a tensor of sampled classes
(\texttt{sampled\_candidates}) from the range of integers
\texttt{{[}0,\ range\_max{]}}.

The elements of \texttt{sampled\_candidates} are drawn without
replacement (if \texttt{unique=True}) or with replacement (if
\texttt{unique=False}) from the base distribution.

The base distribution is read from a file or passed in as an in-memory
array. There is also an option to skew the distribution by applying a
distortion power to the weights.

In addition, this operation returns tensors
\texttt{true\_expected\_count} and \texttt{sampled\_expected\_count}
representing the number of times each of the target classes
(\texttt{true\_classes}) and the sampled classes
(\texttt{sampled\_candidates}) is expected to occur in an average tensor
of sampled classes. These values correspond to \texttt{Q(y\textbar{}x)}
defined in
\href{http://www.tensorflow.org/extras/candidate_sampling.pdf}{this
document}. If \texttt{unique=True}, then these are post-rejection
probabilities and we compute them approximately.

\subparagraph{Args: }\label{args-28}

\begin{itemize}
\tightlist
\item
  \texttt{true\_classes}: A \texttt{Tensor} of type \texttt{int64} and
  shape \texttt{{[}batch\_size,\ num\_true{]}}. The target classes.
\item
  \texttt{num\_true}: An \texttt{int}. The number of target classes per
  training example.
\item
  \texttt{num\_sampled}: An \texttt{int}. The number of classes to
  randomly sample per batch.
\item
  \texttt{unique}: A \texttt{bool}. Determines whether all sampled
  classes in a batch are unique.
\item
  \texttt{range\_max}: An \texttt{int}. The number of possible classes.
\item
  \texttt{vocab\_file}: Each valid line in this file (which should have
  a CSV-like format) corresponds to a valid word ID. IDs are in
  sequential order, starting from num\_reserved\_ids. The last entry in
  each line is expected to be a value corresponding to the count or
  relative probability. Exactly one of \texttt{vocab\_file} and
  \texttt{unigrams} needs to be passed to this operation.
\item
  \texttt{distortion}: The distortion is used to skew the unigram
  probability distribution. Each weight is first raised to the
  distortion's power before adding to the internal unigram distribution.
  As a result, \texttt{distortion\ =\ 1.0} gives regular unigram
  sampling (as defined by the vocab file), and
  \texttt{distortion\ =\ 0.0} gives a uniform distribution.
\item
  \texttt{num\_reserved\_ids}: Optionally some reserved IDs can be added
  in the range \texttt{{[}0,\ num\_reserved\_ids{]}} by the users. One
  use case is that a special unknown word token is used as ID 0. These
  IDs will have a sampling probability of 0.
\item
  \texttt{num\_shards}: A sampler can be used to sample from a subset of
  the original range in order to speed up the whole computation through
  parallelism. This parameter (together with \texttt{shard}) indicates
  the number of partitions that are being used in the overall
  computation.
\item
  \texttt{shard}: A sampler can be used to sample from a subset of the
  original range in order to speed up the whole computation through
  parallelism. This parameter (together with \texttt{num\_shards})
  indicates the particular partition number of the operation, when
  partitioning is being used.
\item
  \texttt{unigrams}: A list of unigram counts or probabilities, one per
  ID in sequential order. Exactly one of \texttt{vocab\_file} and
  \texttt{unigrams} should be passed to this operation.
\item
  \texttt{seed}: An \texttt{int}. An operation-specific seed. Default is
  0.
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-28}

\begin{itemize}
\tightlist
\item
  \texttt{sampled\_candidates}: A tensor of type \texttt{int64} and
  shape \texttt{{[}num\_sampled{]}}. The sampled classes.
\item
  \texttt{true\_expected\_count}: A tensor of type \texttt{float}. Same
  shape as \texttt{true\_classes}. The expected counts under the
  sampling distribution of each of \texttt{true\_classes}.
\item
  \texttt{sampled\_expected\_count}: A tensor of type \texttt{float}.
  Same shape as \texttt{sampled\_candidates}. The expected counts under
  the sampling distribution of each of \texttt{sampled\_candidates}.
\end{itemize}

\subsubsection{Miscellaneous candidate sampling utilities
}\label{miscellaneous-candidate-sampling-utilities}

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\texttt{tf.nn.compute\_accidental\_hits(true\_classes,\ sampled\_candidates,\ num\_true,\ seed=None,\ name=None)}
}{tf.nn.compute\_accidental\_hits(true\_classes, sampled\_candidates, num\_true, seed=None, name=None) }}\label{tf.nn.computeux5faccidentalux5fhitstrueux5fclasses-sampledux5fcandidates-numux5ftrue-seednone-namenone}

Compute the ids of positions in sampled\_candidates matching
true\_classes.

In Candidate Sampling, this operation facilitates virtually removing
sampled classes which happen to match target classes. This is done in
Sampled Softmax and Sampled Logistic.

See our
\href{http://www.tensorflow.org/extras/candidate_sampling.pdf}{Candidate
Sampling Algorithms Reference}.

We presuppose that the \texttt{sampled\_candidates} are unique.

We call it an `accidental hit' when one of the target classes matches
one of the sampled classes. This operation reports accidental hits as
triples \texttt{(index,\ id,\ weight)}, where \texttt{index} represents
the row number in \texttt{true\_classes}, \texttt{id} represents the
position in \texttt{sampled\_candidates}, and weight is
\texttt{-FLOAT\_MAX}.

The result of this op should be passed through a
\texttt{sparse\_to\_dense} operation, then added to the logits of the
sampled classes. This removes the contradictory effect of accidentally
sampling the true target classes as noise classes for the same example.

\subparagraph{Args: }\label{args-29}

\begin{itemize}
\tightlist
\item
  \texttt{true\_classes}: A \texttt{Tensor} of type \texttt{int64} and
  shape \texttt{{[}batch\_size,\ num\_true{]}}. The target classes.
\item
  \texttt{sampled\_candidates}: A tensor of type \texttt{int64} and
  shape \texttt{{[}num\_sampled{]}}. The sampled\_candidates output of
  CandidateSampler.
\item
  \texttt{num\_true}: An \texttt{int}. The number of target classes per
  training example.
\item
  \texttt{seed}: An \texttt{int}. An operation-specific seed. Default is
  0.
\item
  \texttt{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-29}

\begin{itemize}
\tightlist
\item
  \texttt{indices}: A \texttt{Tensor} of type \texttt{int32} and shape
  \texttt{{[}num\_accidental\_hits{]}}. Values indicate rows in
  \texttt{true\_classes}.
\item
  \texttt{ids}: A \texttt{Tensor} of type \texttt{int64} and shape
  \texttt{{[}num\_accidental\_hits{]}}. Values indicate positions in
  \texttt{sampled\_candidates}.
\item
  \texttt{weights}: A \texttt{Tensor} of type \texttt{float} and shape
  \texttt{{[}num\_accidental\_hits{]}}. Each value is
  \texttt{-FLOAT\_MAX}.
\end{itemize}


