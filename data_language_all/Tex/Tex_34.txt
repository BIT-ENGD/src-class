

\section{Variables }\label{variables}

Note: Functions taking \lstinline{Tensor} arguments can also take anything
accepted by
\href{../../api_docs/python/framework.md\#convert_to_tensor}{\lstinline{tf.convert\_to\_tensor}}.

\subsection{Contents}\label{contents}

\subsubsection{\texorpdfstring{\protect\hyperlink{AUTOGENERATED-variables}{Variables}}{Variables}}\label{variables-1}

\begin{itemize}
\tightlist
\item
  \protect\hyperlink{AUTOGENERATED-variables}{Variables}
\item
  \protect\hyperlink{Variable}{\lstinline{class\ tf.Variable}}
\item
  \protect\hyperlink{AUTOGENERATED-variable-helper-functions}{Variable
  helper functions}
\item
  \protect\hyperlink{allux5fvariables}{\lstinline{tf.all\_variables()}}
\item
  \protect\hyperlink{trainableux5fvariables}{\lstinline{tf.trainable\_variables()}}
\item
  \protect\hyperlink{initializeux5fallux5fvariables}{\lstinline{tf.initialize\_all\_variables()}}
\item
  \protect\hyperlink{initializeux5fvariables}{\lstinline{tf.initialize\_variables(var\_list,\ name=\textquotesingle{}init\textquotesingle{})}}
\item
  \protect\hyperlink{assertux5fvariablesux5finitialized}{\lstinline{tf.assert\_variables\_initialized(var\_list=None)}}
\item
  \protect\hyperlink{AUTOGENERATED-saving-and-restoring-variables}{Saving
  and Restoring Variables}
\item
  \protect\hyperlink{Saver}{\lstinline{class\ tf.train.Saver}}
\item
  \protect\hyperlink{latestux5fcheckpoint}{\lstinline{tf.train.latest\_checkpoint(checkpoint\_dir,\ latest\_filename=None)}}
\item
  \protect\hyperlink{getux5fcheckpointux5fstate}{\lstinline{tf.train.get\_checkpoint\_state(checkpoint\_dir,\ latest\_filename=None)}}
\item
  \protect\hyperlink{updateux5fcheckpointux5fstate}{\lstinline{tf.train.update\_checkpoint\_state(save\_dir,\ model\_checkpoint\_path,\ all\_model\_checkpoint\_paths=None,\ latest\_filename=None)}}
\item
  \protect\hyperlink{AUTOGENERATED-sharing-variables}{Sharing Variables}
\item
  \protect\hyperlink{getux5fvariable}{\lstinline{tf.get\_variable(name,\ shape=None,\ dtype=tf.float32,\ initializer=None,\ trainable=True,\ collections=None)}}
\item
  \protect\hyperlink{getux5fvariableux5fscope}{\lstinline{tf.get\_variable\_scope()}}
\item
  \protect\hyperlink{variableux5fscope}{\lstinline{tf.variable\_scope(name\_or\_scope,\ reuse=None,\ initializer=None)}}
\item
  \protect\hyperlink{constantux5finitializer}{\lstinline{tf.constant\_initializer(value=0.0)}}
\item
  \protect\hyperlink{randomux5fnormalux5finitializer}{\lstinline{tf.random\_normal\_initializer(mean=0.0,\ stddev=1.0,\ seed=None)}}
\item
  \protect\hyperlink{truncatedux5fnormalux5finitializer}{\lstinline{tf.truncated\_normal\_initializer(mean=0.0,\ stddev=1.0,\ seed=None)}}
\item
  \protect\hyperlink{randomux5funiformux5finitializer}{\lstinline{tf.random\_uniform\_initializer(minval=0.0,\ maxval=1.0,\ seed=None)}}
\item
  \protect\hyperlink{uniformux5funitux5fscalingux5finitializer}{\lstinline{tf.uniform\_unit\_scaling\_initializer(factor=1.0,\ seed=None)}}
\item
  \protect\hyperlink{zerosux5finitializer}{\lstinline{tf.zeros\_initializer(shape,\ dtype=tf.float32)}}
\item
  \protect\hyperlink{AUTOGENERATED-sparse-variable-updates}{Sparse
  Variable Updates}
\item
  \protect\hyperlink{scatterux5fupdate}{\lstinline{tf.scatter\_update(ref,\ indices,\ updates,\ use\_locking=None,\ name=None)}}
\item
  \protect\hyperlink{scatterux5fadd}{\lstinline{tf.scatter\_add(ref,\ indices,\ updates,\ use\_locking=None,\ name=None)}}
\item
  \protect\hyperlink{scatterux5fsub}{\lstinline{tf.scatter\_sub(ref,\ indices,\ updates,\ use\_locking=None,\ name=None)}}
\item
  \protect\hyperlink{sparseux5fmask}{\lstinline{tf.sparse\_mask(a,\ mask\_indices,\ name=None)}}
\item
  \protect\hyperlink{IndexedSlices}{\lstinline{class\ tf.IndexedSlices}}
\end{itemize}

\subsection{Variables }\label{variables-2}

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\lstinline{class\ tf.Variable}
}{class tf.Variable }}\label{class-tf.variable}

See the \href{../../how_tos/variables/index.md}{Variables How To} for a
high level overview.

A variable maintains state in the graph across calls to \lstinline{run()}.
You add a variable to the graph by constructing an instance of the class
\lstinline{Variable}.

The \lstinline{Variable()} constructor requires an initial value for the
variable, which can be a \lstinline{Tensor} of any type and shape. The
initial value defines the type and shape of the variable. After
construction, the type and shape of the variable are fixed. The value
can be changed using one of the assign methods.

If you want to change the shape of a variable later you have to use an
\lstinline{assign} Op with \lstinline{validate\_shape=False}.

Just like any \lstinline{Tensor}, variables created with
\lstinline{Variable()} can be used as inputs for other Ops in the graph.
Additionally, all the operators overloaded for the \lstinline{Tensor} class
are carried over to variables, so you can also add nodes to the graph by
just doing arithmetic on variables.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import} \NormalTok{tensorflow }\ImportTok{as} \NormalTok{tf}

\CommentTok{# Create a variable.}
\NormalTok{w }\OperatorTok{=} \NormalTok{tf.Variable(}\OperatorTok{<}\NormalTok{initial}\OperatorTok{-}\NormalTok{value}\OperatorTok{>}\NormalTok{, name}\OperatorTok{=<}\NormalTok{optional}\OperatorTok{-}\NormalTok{name}\OperatorTok{>}\NormalTok{)}

\CommentTok{# Use the variable in the graph like any Tensor.}
\NormalTok{y }\OperatorTok{=} \NormalTok{tf.matmul(w, ...another variable }\OperatorTok{or} \NormalTok{tensor...)}

\CommentTok{# The overloaded operators are available too.}
\NormalTok{z }\OperatorTok{=} \NormalTok{tf.sigmoid(w }\OperatorTok{+} \NormalTok{b)}

\CommentTok{# Assign a new value to the variable with `assign()` or a related method.}
\NormalTok{w.assign(w }\OperatorTok{+} \FloatTok{1.0}\NormalTok{)}
\NormalTok{w.assign_add(}\FloatTok{1.0}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

When you launch the graph, variables have to be explicitly initialized
before you can run Ops that use their value. You can initialize a
variable by running its \emph{initializer op}, restoring the variable
from a save file, or simply running an \lstinline{assign} Op that assigns a
value to the variable. In fact, the variable \emph{initializer op} is
just an \lstinline{assign} Op that assigns the variable's initial value to
the variable itself.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Launch the graph in a session.}
\ControlFlowTok{with} \NormalTok{tf.Session() }\ImportTok{as} \NormalTok{sess:}
    \CommentTok{# Run the variable initializer.}
    \NormalTok{sess.run(w.initializer)}
    \CommentTok{# ...you now can run ops that use the value of 'w'...}
\end{Highlighting}
\end{Shaded}

The most common initialization pattern is to use the convenience
function \lstinline{initialize_all_variables()} to add an Op to the graph
that initializes all the variables. You then run that Op after launching
the graph.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Add an Op to initialize all variables.}
\NormalTok{init_op }\OperatorTok{=} \NormalTok{tf.initialize_all_variables()}

\CommentTok{# Launch the graph in a session.}
\ControlFlowTok{with} \NormalTok{tf.Session() }\ImportTok{as} \NormalTok{sess:}
    \CommentTok{# Run the Op that initializes all variables.}
    \NormalTok{sess.run(init_op)}
    \CommentTok{# ...you can now run any Op that uses variable values...}
\end{Highlighting}
\end{Shaded}

If you need to create a variable with an initial value dependent on
another variable, use the other variable's
\lstinline{initialized_value()}. This ensures that variables are
initialized in the right order.

All variables are automatically collected in the graph where they are
created. By default, the constructor adds the new variable to the graph
collection \lstinline{GraphKeys.VARIABLES}. The convenience function
\lstinline{all_variables()} returns the contents of that collection.

When building a machine learning model it is often convenient to
distinguish betwen variables holding the trainable model parameters and
other variables such as a \lstinline{global step} variable used to count
training steps. To make this easier, the variable constructor supports a
\lstinline{trainable=\textless{}bool\textgreater{}} parameter. If
\lstinline{True}, the new variable is also added to the graph collection
\lstinline{GraphKeys.TRAINABLE_VARIABLES}. The convenience function
\lstinline{trainable_variables()} returns the contents of this collection.
The various \lstinline{Optimizer} classes use this collection as the
default list of variables to optimize.

Creating a variable.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\lstinline{tf.Variable.__init__(initial_value, trainable=True, collections=None, validate_shape=True, name=None)}
}{tf.Variable.__init__(initial_value, trainable=True, collections=None, validate_shape=True, name=None) }}\label{tf.variable.ux5fux5finitux5fux5finitialux5fvalue-trainabletrue-collectionsnone-validateux5fshapetrue-namenone}

Creates a new variable with value \lstinline{initial_value}.

The new variable is added to the graph collections listed in
\lstinline{collections}, which defaults to
\lstinline{{[}GraphKeys.VARIABLES{]}}.

If \lstinline{trainable} is \lstinline{True} the variable is also added to the
graph collection \lstinline{GraphKeys.TRAINABLE_VARIABLES}.

This constructor creates both a \lstinline{variable} Op and an
\lstinline{assign} Op to set the variable to its initial value.

\subparagraph{Args: }\label{args}

\begin{itemize}
\tightlist
\item
  \lstinline{initial_value}: A \lstinline{Tensor}, or Python object
  convertible to a \lstinline{Tensor}. The initial value for the Variable.
  Must have a shape specified unless \lstinline{validate_shape} is set to
  False.
\item
  \lstinline{trainable}: If \lstinline{True}, the default, also adds the
  variable to the graph collection
  \lstinline{GraphKeys.TRAINABLE_VARIABLES}. This collection is used as
  the default list of variables to use by the \lstinline{Optimizer}
  classes.
\item
  \lstinline{collections}: List of graph collections keys. The new variable
  is added to these collections. Defaults to
  \lstinline{{[}GraphKeys.VARIABLES{]}}.
\item
  \lstinline{validate_shape}: If \lstinline{False}, allows the variable to be
  initialized with a value of unknown shape. If \lstinline{True}, the
  default, the shape of \lstinline{initial_value} must be known.
\item
  \lstinline{name}: Optional name for the variable. Defaults to
  \lstinline{\textquotesingle{}Variable\textquotesingle{}} and gets
  uniquified automatically.
\end{itemize}

\subparagraph{Returns: }\label{returns}

A Variable.

\subparagraph{Raises: }\label{raises}

\begin{itemize}
\tightlist
\item
  \lstinline{ValueError}: If the initial value does not have a shape and
  \lstinline{validate_shape} is \lstinline{True}.
\end{itemize}

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\lstinline{tf.Variable.initialized_value()}
}{tf.Variable.initialized_value() }}\label{tf.variable.initializedux5fvalue}

Returns the value of the initialized variable.

You should use this instead of the variable itself to initialize another
variable with a value that depends on the value of this variable.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Initialize 'v' with a random tensor.}
\NormalTok{v }\OperatorTok{=} \NormalTok{tf.Variable(tf.truncated_normal([}\DecValTok{10}\NormalTok{, }\DecValTok{40}\NormalTok{]))}
\CommentTok{# Use `initialized_value` to guarantee that `v` has been}
\CommentTok{# initialized before its value is used to initialize `w`.}
\CommentTok{# The random values are picked only once.}
\NormalTok{w }\OperatorTok{=} \NormalTok{tf.Variable(v.initialized_value() }\OperatorTok{*} \FloatTok{2.0}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\subparagraph{Returns: }\label{returns-1}

A \lstinline{Tensor} holding the value of this variable after its
initializer has run.

Changing a variable value.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\lstinline{tf.Variable.assign(value, use_locking=False)}
}{tf.Variable.assign(value, use_locking=False) }}\label{tf.variable.assignvalue-useux5flockingfalse}

Assigns a new value to the variable.

This is essentially a shortcut for \lstinline{assign(self,\ value)}.

\subparagraph{Args: }\label{args-1}

\begin{itemize}
\tightlist
\item
  \lstinline{value}: A \lstinline{Tensor}. The new value for this variable.
\item
  \lstinline{use\_locking}: If \lstinline{True}, use locking during the
  assignment.
\end{itemize}

\subparagraph{Returns: }\label{returns-2}

A \lstinline{Tensor} that will hold the new value of this variable after
the assignment has completed.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\lstinline{tf.Variable.assign\_add(delta,\ use\_locking=False)}
}{tf.Variable.assign\_add(delta, use\_locking=False) }}\label{tf.variable.assignux5fadddelta-useux5flockingfalse}

Adds a value to this variable.

This is essentially a shortcut for \lstinline{assign\_add(self,\ delta)}.

\subparagraph{Args: }\label{args-2}

\begin{itemize}
\tightlist
\item
  \lstinline{delta}: A \lstinline{Tensor}. The value to add to this variable.
\item
  \lstinline{use\_locking}: If \lstinline{True}, use locking during the
  operation.
\end{itemize}

\subparagraph{Returns: }\label{returns-3}

A \lstinline{Tensor} that will hold the new value of this variable after
the addition has completed.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\lstinline{tf.Variable.assign\_sub(delta,\ use\_locking=False)}
}{tf.Variable.assign\_sub(delta, use\_locking=False) }}\label{tf.variable.assignux5fsubdelta-useux5flockingfalse}

Subtracts a value from this variable.

This is essentially a shortcut for \lstinline{assign\_sub(self,\ delta)}.

\subparagraph{Args: }\label{args-3}

\begin{itemize}
\tightlist
\item
  \lstinline{delta}: A \lstinline{Tensor}. The value to subtract from this
  variable.
\item
  \lstinline{use\_locking}: If \lstinline{True}, use locking during the
  operation.
\end{itemize}

\subparagraph{Returns: }\label{returns-4}

A \lstinline{Tensor} that will hold the new value of this variable after
the subtraction has completed.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\lstinline{tf.Variable.scatter\_sub(sparse\_delta,\ use\_locking=False)}
}{tf.Variable.scatter\_sub(sparse\_delta, use\_locking=False) }}\label{tf.variable.scatterux5fsubsparseux5fdelta-useux5flockingfalse}

Subtracts \lstinline{IndexedSlices} from this variable.

This is essentially a shortcut for
\lstinline{scatter\_sub(self,\ sparse\_delta.indices,\ sparse\_delta.values)}.

\subparagraph{Args: }\label{args-4}

\begin{itemize}
\tightlist
\item
  \lstinline{sparse\_delta}: \lstinline{IndexedSlices} to be subtracted from
  this variable.
\item
  \lstinline{use\_locking}: If \lstinline{True}, use locking during the
  operation.
\end{itemize}

\subparagraph{Returns: }\label{returns-5}

A \lstinline{Tensor} that will hold the new value of this variable after
the scattered subtraction has completed.

\subparagraph{Raises: }\label{raises-1}

\begin{itemize}
\tightlist
\item
  \lstinline{ValueError}: if \lstinline{sparse\_delta} is not an
  \lstinline{IndexedSlices}.
\end{itemize}

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\lstinline{tf.Variable.count\_up\_to(limit)}
}{tf.Variable.count\_up\_to(limit) }}\label{tf.variable.countux5fupux5ftolimit}

Increments this variable until it reaches \lstinline{limit}.

When that Op is run it tries to increment the variable by \lstinline{1}. If
incrementing the variable would bring it above \lstinline{limit} then the
Op raises the exception \lstinline{OutOfRangeError}.

If no error is raised, the Op outputs the value of the variable before
the increment.

This is essentially a shortcut for \lstinline{count\_up\_to(self,\ limit)}.

\subparagraph{Args: }\label{args-5}

\begin{itemize}
\tightlist
\item
  \lstinline{limit}: value at which incrementing the variable raises an
  error.
\end{itemize}

\subparagraph{Returns: }\label{returns-6}

A \lstinline{Tensor} that will hold the variable value before the
increment. If no other Op modifies this variable, the values produced
will all be distinct.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\lstinline{tf.Variable.eval(session=None)}
}{tf.Variable.eval(session=None) }}\label{tf.variable.evalsessionnone}

In a session, computes and returns the value of this variable.

This is not a graph construction method, it does not add ops to the
graph.

This convenience method requires a session where the graph containing
this variable has been launched. If no session is passed, the default
session is used. See the
\href{../../api_docs/python/client.md\#Session}{Session class} for more
information on launching a graph and on sessions.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{v }\OperatorTok{=} \NormalTok{tf.Variable([}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{])}
\NormalTok{init }\OperatorTok{=} \NormalTok{tf.initialize_all_variables()}

\ControlFlowTok{with} \NormalTok{tf.Session() }\ImportTok{as} \NormalTok{sess:}
    \NormalTok{sess.run(init)}
    \CommentTok{# Usage passing the session explicitly.}
    \BuiltInTok{print} \NormalTok{v.}\BuiltInTok{eval}\NormalTok{(sess)}
    \CommentTok{# Usage with the default session.  The 'with' block}
    \CommentTok{# above makes 'sess' the default session.}
    \BuiltInTok{print} \NormalTok{v.}\BuiltInTok{eval}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\subparagraph{Args: }\label{args-6}

\begin{itemize}
\tightlist
\item
  \lstinline{session}: The session to use to evaluate this variable. If
  none, the default session is used.
\end{itemize}

\subparagraph{Returns: }\label{returns-7}

A numpy \lstinline{ndarray} with a copy of the value of this variable.

Properties.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\lstinline{tf.Variable.name}
}{tf.Variable.name }}\label{tf.variable.name}

The name of this variable.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\lstinline{tf.Variable.dtype}
}{tf.Variable.dtype }}\label{tf.variable.dtype}

The \lstinline{DType} of this variable.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\lstinline{tf.Variable.get\_shape()}
}{tf.Variable.get\_shape() }}\label{tf.variable.getux5fshape}

The \lstinline{TensorShape} of this variable.

\subparagraph{Returns: }\label{returns-8}

A \lstinline{TensorShape}.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\lstinline{tf.Variable.device}
}{tf.Variable.device }}\label{tf.variable.device}

The device of this variable.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\lstinline{tf.Variable.initializer}
}{tf.Variable.initializer }}\label{tf.variable.initializer}

The initializer operation for this variable.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\lstinline{tf.Variable.graph}
}{tf.Variable.graph }}\label{tf.variable.graph}

The \lstinline{Graph} of this variable.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\lstinline{tf.Variable.op}
}{tf.Variable.op }}\label{tf.variable.op}

The \lstinline{Operation} of this variable.

\subsection{Variable helper functions }\label{variable-helper-functions}

TensorFlow provides a set of functions to help manage the set of
variables collected in the graph.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\lstinline{tf.all\_variables()}
}{tf.all\_variables() }}\label{tf.allux5fvariables}

Returns all variables collected in the graph.

The \lstinline{Variable()} constructor automatically adds new variables to
the graph collection \lstinline{GraphKeys.VARIABLES}. This convenience
function returns the contents of that collection.

\subparagraph{Returns: }\label{returns-9}

A list of \lstinline{Variable} objects.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\lstinline{tf.trainable\_variables()}
}{tf.trainable\_variables() }}\label{tf.trainableux5fvariables}

Returns all variables created with \lstinline{trainable=True}.

When passed \lstinline{trainable=True}, the \lstinline{Variable()} constructor
automatically adds new variables to the graph collection
\lstinline{GraphKeys.TRAINABLE\_VARIABLES}. This convenience function
returns the contents of that collection.

\subparagraph{Returns: }\label{returns-10}

A list of Variable objects.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\lstinline{tf.initialize\_all\_variables()}
}{tf.initialize\_all\_variables() }}\label{tf.initializeux5fallux5fvariables}

Returns an Op that initializes all variables.

This is just a shortcut for
\lstinline{initialize\_variables(all\_variables())}

\subparagraph{Returns: }\label{returns-11}

An Op that initializes all variables in the graph.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\lstinline{tf.initialize\_variables(var\_list,\ name=\textquotesingle{}init\textquotesingle{})}
}{tf.initialize\_variables(var\_list, name='init') }}\label{tf.initializeux5fvariablesvarux5flist-nameinit}

Returns an Op that initializes a list of variables.

After you launch the graph in a session, you can run the returned Op to
initialize all the variables in \lstinline{var\_list}. This Op runs all the
initializers of the variables in \lstinline{var\_list} in parallel.

Calling \lstinline{initialize\_variables()} is equivalent to passing the
list of initializers to \lstinline{Group()}.

If \lstinline{var\_list} is empty, however, the function still returns an
Op that can be run. That Op just has no effect.

\subparagraph{Args: }\label{args-7}

\begin{itemize}
\tightlist
\item
  \lstinline{var\_list}: List of \lstinline{Variable} objects to initialize.
\item
  \lstinline{name}: Optional name for the returned operation.
\end{itemize}

\subparagraph{Returns: }\label{returns-12}

An Op that run the initializers of all the specified variables.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\lstinline{tf.assert\_variables\_initialized(var\_list=None)}
}{tf.assert\_variables\_initialized(var\_list=None) }}\label{tf.assertux5fvariablesux5finitializedvarux5flistnone}

Returns an Op to check if variables are initialized.

When run, the returned Op will raise the exception
\lstinline{FailedPreconditionError} if any of the variables has not yet
been initialized.

Note: This function is implemented by trying to fetch the values of the
variables. If one of the variables is not initialized a message may be
logged by the C++ runtime. This is expected.

\subparagraph{Args: }\label{args-8}

\begin{itemize}
\tightlist
\item
  \lstinline{var\_list}: List of \lstinline{Variable} objects to check.
  Defaults to the value of \lstinline{all\_variables().}
\end{itemize}

\subparagraph{Returns: }\label{returns-13}

An Op, or None if there are no variables.

\subsection{Saving and Restoring Variables
}\label{saving-and-restoring-variables}

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\lstinline{class\ tf.train.Saver}
}{class tf.train.Saver }}\label{class-tf.train.saver}

Saves and restores variables.

See \href{../../how_tos/variables/index.md}{Variables} for an overview
of variables, saving and restoring.

The \lstinline{Saver} class adds ops to save and restore variables to and
from \emph{checkpoints}. It also provides convenience methods to run
these ops.

Checkpoints are binary files in a proprietary format which map variable
names to tensor values. The best way to examine the contents of a
checkpoint is to load it using a \lstinline{Saver}.

Savers can automatically number checkpoint filenames with a provided
counter. This lets you keep multiple checkpoints at different steps
while training a model. For example you can number the checkpoint
filenames with the training step number. To avoid filling up disks,
savers manage checkpoint files automatically. For example, they can keep
only the N most recent files, or one checkpoint for every N hours of
training.

You number checkpoint filenames by passing a value to the optional
\lstinline{global\_step} argument to \lstinline{save()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{saver.save(sess, }\StringTok{'my-model'}\NormalTok{, global_step}\OperatorTok{=}\DecValTok{0}\NormalTok{) }\OperatorTok{==>} \NormalTok{filename: }\StringTok{'my-model-0'}
\NormalTok{...}
\NormalTok{saver.save(sess, }\StringTok{'my-model'}\NormalTok{, global_step}\OperatorTok{=}\DecValTok{1000}\NormalTok{) }\OperatorTok{==>} \NormalTok{filename: }\StringTok{'my-model-1000'}
\end{Highlighting}
\end{Shaded}

Additionally, optional arguments to the \lstinline{Saver()} constructor let
you control the proliferation of checkpoint files on disk:

\begin{itemize}
\item
  \lstinline{max\_to\_keep} indicates the maximum number of recent
  checkpoint files to keep. As new files are created, older files are
  deleted. If None or 0, all checkpoint files are kept. Defaults to 5
  (that is, the 5 most recent checkpoint files are kept.)
\item
  \lstinline{keep\_checkpoint\_every\_n\_hours}: In addition to keeping the
  most recent \lstinline{max\_to\_keep} checkpoint files, you might want to
  keep one checkpoint file for every N hours of training. This can be
  useful if you want to later analyze how a model progressed during a
  long training session. For example, passing
  \lstinline{keep\_checkpoint\_every\_n\_hours=2} ensures that you keep one
  checkpoint file for every 2 hours of training. The default value of
  10,000 hours effectively disables the feature.
\end{itemize}

Note that you still have to call the \lstinline{save()} method to save the
model. Passing these arguments to the constructor will not save
variables automatically for you.

A training program that saves regularly looks like:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{...}
\CommentTok{# Create a saver.}
\NormalTok{saver }\OperatorTok{=} \NormalTok{tf.train.Saver(...variables...)}
\CommentTok{# Launch the graph and train, saving the model every 1,000 steps.}
\NormalTok{sess }\OperatorTok{=} \NormalTok{tf.Session()}
\ControlFlowTok{for} \NormalTok{step }\OperatorTok{in} \BuiltInTok{xrange}\NormalTok{(}\DecValTok{1000000}\NormalTok{):}
    \NormalTok{sess.run(..training_op..)}
    \ControlFlowTok{if} \NormalTok{step }\OperatorTok{%} \DecValTok{1000} \OperatorTok{==} \DecValTok{0}\NormalTok{:}
        \CommentTok{# Append the step number to the checkpoint name:}
        \NormalTok{saver.save(sess, }\StringTok{'my-model'}\NormalTok{, global_step}\OperatorTok{=}\NormalTok{step)}
\end{Highlighting}
\end{Shaded}

In addition to checkpoint files, savers keep a protocol buffer on disk
with the list of recent checkpoints. This is used to manage numbered
checkpoint files and by \lstinline{latest\_checkpoint()}, which makes it
easy to discover the path to the most recent checkpoint. That protocol
buffer is stored in a file named `checkpoint' next to the checkpoint
files.

If you create several savers, you can specify a different filename for
the protocol buffer file in the call to \lstinline{save()}.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\lstinline{tf.train.Saver.\_\_init\_\_(var\_list=None,\ reshape=False,\ sharded=False,\ max\_to\_keep=5,\ keep\_checkpoint\_every\_n\_hours=10000.0,\ name=None,\ restore\_sequentially=False,\ saver\_def=None,\ builder=None)}
}{tf.train.Saver.\_\_init\_\_(var\_list=None, reshape=False, sharded=False, max\_to\_keep=5, keep\_checkpoint\_every\_n\_hours=10000.0, name=None, restore\_sequentially=False, saver\_def=None, builder=None) }}\label{tf.train.saver.ux5fux5finitux5fux5fvarux5flistnone-reshapefalse-shardedfalse-maxux5ftoux5fkeep5-keepux5fcheckpointux5feveryux5fnux5fhours10000.0-namenone-restoreux5fsequentiallyfalse-saverux5fdefnone-buildernone}

Creates a \lstinline{Saver}.

The constructor adds ops to save and restore variables.

\lstinline{var\_list} specifies the variables that will be saved and
restored. It can be passed as a \lstinline{dict} or a list:

\begin{itemize}
\tightlist
\item
  A \lstinline{dict} of names to variables: The keys are the names that
  will be used to save or restore the variables in the checkpoint files.
\item
  A list of variables: The variables will be keyed with their op name in
  the checkpoint files.
\end{itemize}

For example:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{v1 }\OperatorTok{=} \NormalTok{tf.Variable(..., name}\OperatorTok{=}\StringTok{'v1'}\NormalTok{)}
\NormalTok{v2 }\OperatorTok{=} \NormalTok{tf.Variable(..., name}\OperatorTok{=}\StringTok{'v2'}\NormalTok{)}

\CommentTok{# Pass the variables as a dict:}
\NormalTok{saver }\OperatorTok{=} \NormalTok{tf.train.Saver(\{}\StringTok{'v1'}\NormalTok{: v1, }\StringTok{'v2'}\NormalTok{: v2\})}

\CommentTok{# Or pass them as a list.}
\NormalTok{saver }\OperatorTok{=} \NormalTok{tf.train.Saver([v1, v2])}
\CommentTok{# Passing a list is equivalent to passing a dict with the variable op names}
\CommentTok{# as keys:}
\NormalTok{saver }\OperatorTok{=} \NormalTok{tf.train.Saver(\{v.op.name: v }\ControlFlowTok{for} \NormalTok{v }\OperatorTok{in} \NormalTok{[v1, v2]\})}
\end{Highlighting}
\end{Shaded}

The optional \lstinline{reshape} argument, if True, allows restoring a
variable from a save file where the variable had a different shape, but
the same number of elements and type. This is useful if you have
reshaped a variable and want to reload it from an older checkpoint.

The optional \lstinline{sharded} argument, if True, instructs the saver to
shard checkpoints per device.

\subparagraph{Args: }\label{args-9}

\begin{itemize}
\tightlist
\item
  \lstinline{var\_list}: A list of Variables or a dictionary mapping names
  to Variables. If None, defaults to the list of all variables.
\item
  \lstinline{reshape}: If True, allows restoring parameters from a
  checkpoint where the variables have a different shape.
\item
  \lstinline{sharded}: If True, shard the checkpoints, one per device.
\item
  \lstinline{max\_to\_keep}: maximum number of recent checkpoints to keep.
  Defaults to 10,000 hours.
\item
  \lstinline{keep\_checkpoint\_every\_n\_hours}: How often to keep
  checkpoints. Defaults to 10,000 hours.
\item
  \lstinline{name}: string. Optional name to use as a prefix when adding
  operations.
\item
  \lstinline{restore\_sequentially}: A Bool, which if true, causes restore
  of different variables to happen sequentially within each device. This
  can lower memory usage when restoring very large models.
\item
  \lstinline{saver\_def}: Optional SaverDef proto to use instead of running
  the builder. This is only useful for specialty code that wants to
  recreate a Saver object for a previously built Graph that had a Saver.
  The saver\_def proto should be the one returned by the
  as\_saver\_def() call of the Saver that was created for that Graph.
\item
  \lstinline{builder}: Optional SaverBuilder to use if a saver\_def was not
  provided. Defaults to BaseSaverBuilder().
\end{itemize}

\subparagraph{Raises: }\label{raises-2}

\begin{itemize}
\tightlist
\item
  \lstinline{TypeError}: If \lstinline{var\_list} is invalid.
\item
  \lstinline{ValueError}: If any of the keys or values in
  \lstinline{var\_list} is not unique.
\end{itemize}

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\lstinline{tf.train.Saver.save(sess,\ save\_path,\ global\_step=None,\ latest\_filename=None)}
}{tf.train.Saver.save(sess, save\_path, global\_step=None, latest\_filename=None) }}\label{tf.train.saver.savesess-saveux5fpath-globalux5fstepnone-latestux5ffilenamenone}

Saves variables.

This method runs the ops added by the constructor for saving variables.
It requires a session in which the graph was launched. The variables to
save must also have been initialized.

The method returns the path of the newly created checkpoint file. This
path can be passed directly to a call to \lstinline{restore()}.

\subparagraph{Args: }\label{args-10}

\begin{itemize}
\tightlist
\item
  \lstinline{sess}: A Session to use to save the variables.
\item
  \lstinline{save\_path}: string. Path to the checkpoint filename. If the
  saver is \lstinline{sharded}, this is the prefix of the sharded
  checkpoint filename.
\item
  \lstinline{global\_step}: If provided the global step number is appended
  to \lstinline{save\_path} to create the checkpoint filename. The optional
  argument can be a Tensor, a Tensor name or an integer.
\item
  \lstinline{latest\_filename}: Optional name for the protocol buffer file
  that will contains the list of most recent checkpoint filenames. That
  file, kept in the same directory as the checkpoint files, is
  automatically managed by the saver to keep track of recent
  checkpoints. Defaults to `checkpoint'.
\end{itemize}

\subparagraph{Returns: }\label{returns-14}

A string: path at which the variables were saved. If the saver is
sharded, this string ends with: `-?????-of-nnnnn' where `nnnnn' is the
number of shards created.

\subparagraph{Raises: }\label{raises-3}

\begin{itemize}
\tightlist
\item
  \lstinline{TypeError}: If \lstinline{sess} is not a Session.
\end{itemize}

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\lstinline{tf.train.Saver.restore(sess,\ save\_path)}
}{tf.train.Saver.restore(sess, save\_path) }}\label{tf.train.saver.restoresess-saveux5fpath}

Restores previously saved variables.

This method runs the ops added by the constructor for restoring
variables. It requires a session in which the graph was launched. The
variables to restore do not have to have been initialized, as restoring
is itself a way to initialize variables.

The \lstinline{save\_path} argument is typically a value previously
returned from a \lstinline{save()} call, or a call to
\lstinline{latest\_checkpoint()}.

\subparagraph{Args: }\label{args-11}

\begin{itemize}
\tightlist
\item
  \lstinline{sess}: A Session to use to restore the parameters.
\item
  \lstinline{save\_path}: Path where parameters were previously saved.
\end{itemize}

Other utility methods.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\lstinline{tf.train.Saver.last\_checkpoints}
}{tf.train.Saver.last\_checkpoints }}\label{tf.train.saver.lastux5fcheckpoints}

List of not-yet-deleted checkpoint filenames.

You can pass any of the returned values to \lstinline{restore()}.

\subparagraph{Returns: }\label{returns-15}

A list of checkpoint filenames, sorted from oldest to newest.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\lstinline{tf.train.Saver.set\_last\_checkpoints(last\_checkpoints)}
}{tf.train.Saver.set\_last\_checkpoints(last\_checkpoints) }}\label{tf.train.saver.setux5flastux5fcheckpointslastux5fcheckpoints}

Sets the list of not-yet-deleted checkpoint filenames.

\subparagraph{Args: }\label{args-12}

\begin{itemize}
\tightlist
\item
  \lstinline{last\_checkpoints}: a list of checkpoint filenames.
\end{itemize}

\subparagraph{Raises: }\label{raises-4}

\begin{itemize}
\tightlist
\item
  \lstinline{AssertionError}: if the list of checkpoint filenames has
  already been set.
\end{itemize}

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\lstinline{tf.train.Saver.as\_saver\_def()}
}{tf.train.Saver.as\_saver\_def() }}\label{tf.train.saver.asux5fsaverux5fdef}

Generates a \lstinline{SaverDef} representation of this saver.

\subparagraph{Returns: }\label{returns-16}

A \lstinline{SaverDef} proto.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\lstinline{tf.train.latest\_checkpoint(checkpoint\_dir,\ latest\_filename=None)}
}{tf.train.latest\_checkpoint(checkpoint\_dir, latest\_filename=None) }}\label{tf.train.latestux5fcheckpointcheckpointux5fdir-latestux5ffilenamenone}

Finds the filename of latest saved checkpoint file.

\subparagraph{Args: }\label{args-13}

\begin{itemize}
\tightlist
\item
  \lstinline{checkpoint\_dir}: Directory where the variables were saved.
\item
  \lstinline{latest\_filename}: Optional name for the protocol buffer file
  that contains the list of most recent checkpoint filenames. See the
  corresponding argument to \lstinline{Saver.save()}.
\end{itemize}

\subparagraph{Returns: }\label{returns-17}

The full path to the latest checkpoint or None if no checkpoint was
found.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\lstinline{tf.train.get\_checkpoint\_state(checkpoint\_dir,\ latest\_filename=None)}
}{tf.train.get\_checkpoint\_state(checkpoint\_dir, latest\_filename=None) }}\label{tf.train.getux5fcheckpointux5fstatecheckpointux5fdir-latestux5ffilenamenone}

Returns CheckpointState proto from the ``checkpoint'' file.

If the ``checkpoint'' file contains a valid CheckpointState proto,
returns it.

\subparagraph{Args: }\label{args-14}

\begin{itemize}
\tightlist
\item
  \lstinline{checkpoint\_dir}: The directory of checkpoints.
\item
  \lstinline{latest\_filename}: Optional name of the checkpoint file.
  Default to `checkpoint'.
\end{itemize}

\subparagraph{Returns: }\label{returns-18}

A CheckpointState if the state was available, None otherwise.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\lstinline{tf.train.update\_checkpoint\_state(save\_dir,\ model\_checkpoint\_path,\ all\_model\_checkpoint\_paths=None,\ latest\_filename=None)}
}{tf.train.update\_checkpoint\_state(save\_dir, model\_checkpoint\_path, all\_model\_checkpoint\_paths=None, latest\_filename=None) }}\label{tf.train.updateux5fcheckpointux5fstatesaveux5fdir-modelux5fcheckpointux5fpath-allux5fmodelux5fcheckpointux5fpathsnone-latestux5ffilenamenone}

Updates the content of the `checkpoint' file.

This updates the checkpoint file containing a CheckpointState proto.

\subparagraph{Args: }\label{args-15}

\begin{itemize}
\tightlist
\item
  \lstinline{save\_dir}: Directory where the model was saved.
\item
  \lstinline{model\_checkpoint\_path}: The checkpoint file.
\item
  \lstinline{all\_model\_checkpoint\_paths}: list of strings. Paths to all
  not-yet-deleted checkpoints, sorted from oldest to newest. If this is
  a non-empty list, the last element must be equal to
  model\_checkpoint\_path. These paths are also saved in the
  CheckpointState proto.
\item
  \lstinline{latest\_filename}: Optional name of the checkpoint file.
  Default to `checkpoint'.
\end{itemize}

\subparagraph{Raises: }\label{raises-5}

\begin{itemize}
\tightlist
\item
  \lstinline{RuntimeError}: If the save paths conflict.
\end{itemize}

\subsection{Sharing Variables }\label{sharing-variables}

TensorFlow provides several classes and operations that you can use to
create variables contingent on certain conditions.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\lstinline{tf.get\_variable(name,\ shape=None,\ dtype=tf.float32,\ initializer=None,\ trainable=True,\ collections=None)}
}{tf.get\_variable(name, shape=None, dtype=tf.float32, initializer=None, trainable=True, collections=None) }}\label{tf.getux5fvariablename-shapenone-dtypetf.float32-initializernone-trainabletrue-collectionsnone}

Gets an existing variable with these parameters or create a new one.

This function prefixes the name with the current variable scope and
performs reuse checks. See the
\href{../../how_tos/variable_scope/index.md}{Variable Scope How To} for
an extensive description of how reusing works. Here is a basic example:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{with} \NormalTok{tf.variable_scope(}\StringTok{"foo"}\NormalTok{):}
    \NormalTok{v }\OperatorTok{=} \NormalTok{get_variable(}\StringTok{"v"}\NormalTok{, [}\DecValTok{1}\NormalTok{])  }\CommentTok{# v.name == "foo/v:0"}
    \NormalTok{w }\OperatorTok{=} \NormalTok{get_variable(}\StringTok{"w"}\NormalTok{, [}\DecValTok{1}\NormalTok{])  }\CommentTok{# w.name == "foo/w:0"}
\ControlFlowTok{with} \NormalTok{tf.variable_scope(}\StringTok{"foo"}\NormalTok{, reuse}\OperatorTok{=}\VariableTok{True}\NormalTok{)}
    \NormalTok{v1 }\OperatorTok{=} \NormalTok{get_variable(}\StringTok{"v"}\NormalTok{)  }\CommentTok{# The same as v above.}
\end{Highlighting}
\end{Shaded}

If initializer is \lstinline{None} (the default), the default initializer
passed in the constructor is used. If that one is \lstinline{None} too, a
\lstinline{UniformUnitScalingInitializer} will be used.

\subparagraph{Args: }\label{args-16}

\begin{itemize}
\tightlist
\item
  \lstinline{name}: the name of the new or existing variable.
\item
  \lstinline{shape}: shape of the new or existing variable.
\item
  \lstinline{dtype}: type of the new or existing variable (defaults to
  \lstinline{DT\_FLOAT}).
\item
  \lstinline{initializer}: initializer for the variable if one is created.
\item
  \lstinline{trainable}: If \lstinline{True} also add the variable to the
  graph collection \lstinline{GraphKeys.TRAINABLE\_VARIABLES} (see
  variables.Variable).
\item
  \lstinline{collections}: List of graph collections keys to add the
  Variable to. Defaults to \lstinline{{[}GraphKeys.VARIABLES{]}} (see
  variables.Variable).
\end{itemize}

\subparagraph{Returns: }\label{returns-19}

The created or existing variable.

\subparagraph{Raises: }\label{raises-6}

\begin{itemize}
\tightlist
\item
  \lstinline{ValueError}: when creating a new variable and shape is not
  declared, or when violating reuse during variable creation. Reuse is
  set inside \lstinline{variable\_scope}.
\end{itemize}

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\lstinline{tf.get\_variable\_scope()}
}{tf.get\_variable\_scope() }}\label{tf.getux5fvariableux5fscope}

Returns the current variable scope.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\lstinline{tf.variable\_scope(name\_or\_scope,\ reuse=None,\ initializer=None)}
}{tf.variable\_scope(name\_or\_scope, reuse=None, initializer=None) }}\label{tf.variableux5fscopenameux5forux5fscope-reusenone-initializernone}

Returns a context for variable scope.

Variable scope allows to create new variables and to share already
created ones while providing checks to not create or share by accident.
For details, see the
\href{../../how_tos/variable_scope/index.md}{Variable Scope How To},
here we present only a few basic examples.

Simple example of how to create a new variable:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{with} \NormalTok{tf.variable_scope(}\StringTok{"foo"}\NormalTok{):}
    \ControlFlowTok{with} \NormalTok{tf.variable_scope(}\StringTok{"bar"}\NormalTok{):}
        \NormalTok{v }\OperatorTok{=} \NormalTok{tf.get_variable(}\StringTok{"v"}\NormalTok{, [}\DecValTok{1}\NormalTok{])}
        \ControlFlowTok{assert} \NormalTok{v.name }\OperatorTok{==} \StringTok{"foo/bar/v:0"}
\end{Highlighting}
\end{Shaded}

Basic example of sharing a variable:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{with} \NormalTok{tf.variable_scope(}\StringTok{"foo"}\NormalTok{):}
    \NormalTok{v }\OperatorTok{=} \NormalTok{get_variable(}\StringTok{"v"}\NormalTok{, [}\DecValTok{1}\NormalTok{])}
\ControlFlowTok{with} \NormalTok{tf.variable_scope(}\StringTok{"foo"}\NormalTok{, reuse}\OperatorTok{=}\VariableTok{True}\NormalTok{):}
    \NormalTok{v1 }\OperatorTok{=} \NormalTok{tf.get_variable(}\StringTok{"v"}\NormalTok{, [}\DecValTok{1}\NormalTok{])}
\ControlFlowTok{assert} \NormalTok{v1 }\OperatorTok{==} \NormalTok{v}
\end{Highlighting}
\end{Shaded}

Sharing a variable by capturing a scope and setting reuse:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{with} \NormalTok{tf.variable_scope(}\StringTok{"foo"}\NormalTok{) }\ImportTok{as} \NormalTok{scope.}
    \NormalTok{v }\OperatorTok{=} \NormalTok{get_variable(}\StringTok{"v"}\NormalTok{, [}\DecValTok{1}\NormalTok{])}
    \NormalTok{scope.reuse_variables()}
    \NormalTok{v1 }\OperatorTok{=} \NormalTok{tf.get_variable(}\StringTok{"v"}\NormalTok{, [}\DecValTok{1}\NormalTok{])}
\ControlFlowTok{assert} \NormalTok{v1 }\OperatorTok{==} \NormalTok{v}
\end{Highlighting}
\end{Shaded}

To prevent accidental sharing of variables, we raise an exception when
getting an existing variable in a non-reusing scope.

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{with} \NormalTok{tf.variable_scope(}\StringTok{"foo"}\NormalTok{) }\ImportTok{as} \NormalTok{scope.}
    \NormalTok{v }\OperatorTok{=} \NormalTok{get_variable(}\StringTok{"v"}\NormalTok{, [}\DecValTok{1}\NormalTok{])}
    \NormalTok{v1 }\OperatorTok{=} \NormalTok{tf.get_variable(}\StringTok{"v"}\NormalTok{, [}\DecValTok{1}\NormalTok{])}
    \CommentTok{#  Raises ValueError("... v already exists ...").}
\end{Highlighting}
\end{Shaded}

Similarly, we raise an exception when trying to get a variable that does
not exist in reuse mode.

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{with} \NormalTok{tf.variable_scope(}\StringTok{"foo"}\NormalTok{, reuse}\OperatorTok{=}\VariableTok{True}\NormalTok{):}
    \NormalTok{v }\OperatorTok{=} \NormalTok{get_variable(}\StringTok{"v"}\NormalTok{, [}\DecValTok{1}\NormalTok{])}
    \CommentTok{#  Raises ValueError("... v does not exists ...").}
\end{Highlighting}
\end{Shaded}

Note that the \lstinline{reuse} flag is inherited: if we open a reusing
scope, then all its sub-scopes become reusing as well.

\subparagraph{Args: }\label{args-17}

\begin{itemize}
\tightlist
\item
  \lstinline{name\_or\_scope}: \lstinline{string} or \lstinline{VariableScope}:
  the scope to open.
\item
  \lstinline{reuse}: \lstinline{True} or \lstinline{None}; if \lstinline{True}, we
  go into reuse mode for this scope as well as all sub-scopes; if
  \lstinline{None}, we just inherit the parent scope reuse.
\item
  \lstinline{initializer}: default initializer for variables within this
  scope.
\end{itemize}

\subparagraph{Yields: }\label{yields}

A scope that can be to captured and reused.

\subparagraph{Raises: }\label{raises-7}

\begin{itemize}
\tightlist
\item
  \lstinline{ValueError}: when trying to reuse within a create scope, or
  create within a reuse scope, or if reuse is not \lstinline{None} or
  \lstinline{True}.
\item
  \lstinline{TypeError}: when the types of some arguments are not
  appropriate.
\end{itemize}

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\lstinline{tf.constant\_initializer(value=0.0)}
}{tf.constant\_initializer(value=0.0) }}\label{tf.constantux5finitializervalue0.0}

Returns an initializer that generates Tensors with a single value.

\subparagraph{Args: }\label{args-18}

\begin{itemize}
\tightlist
\item
  \lstinline{value}: A Python scalar. All elements of the initialized
  variable will be set to this value.
\end{itemize}

\subparagraph{Returns: }\label{returns-20}

An initializer that generates Tensors with a single value.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\lstinline{tf.random\_normal\_initializer(mean=0.0,\ stddev=1.0,\ seed=None)}
}{tf.random\_normal\_initializer(mean=0.0, stddev=1.0, seed=None) }}\label{tf.randomux5fnormalux5finitializermean0.0-stddev1.0-seednone}

Returns an initializer that generates Tensors with a normal
distribution.

\subparagraph{Args: }\label{args-19}

\begin{itemize}
\tightlist
\item
  \lstinline{mean}: a python scalar or a scalar tensor. Mean of the random
  values to generate.
\item
  \lstinline{stddev}: a python scalar or a scalar tensor. Standard
  deviation of the random values to generate.
\item
  \lstinline{seed}: A Python integer. Used to create random seeds. See
  \href{../../api_docs/python/constant_op.md\#set_random_seed}{\lstinline{set\_random\_seed}}
  for behavior.
\end{itemize}

\subparagraph{Returns: }\label{returns-21}

An initializer that generates Tensors with a normal distribution.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\lstinline{tf.truncated\_normal\_initializer(mean=0.0,\ stddev=1.0,\ seed=None)}
}{tf.truncated\_normal\_initializer(mean=0.0, stddev=1.0, seed=None) }}\label{tf.truncatedux5fnormalux5finitializermean0.0-stddev1.0-seednone}

Returns an initializer that generates a truncated normal distribution.

These values are similar to values from a random\_normal\_initializer
except that values more than two standard deviations from the mean are
discarded and re-drawn. This is the recommended initializer for neural
network weights and filters.

\subparagraph{Args: }\label{args-20}

\begin{itemize}
\tightlist
\item
  \lstinline{mean}: a python scalar or a scalar tensor. Mean of the random
  values to generate.
\item
  \lstinline{stddev}: a python scalar or a scalar tensor. Standard
  deviation of the random values to generate.
\item
  \lstinline{seed}: A Python integer. Used to create random seeds. See
  \href{../../api_docs/python/constant_op.md\#set_random_seed}{\lstinline{set\_random\_seed}}
  for behavior.
\end{itemize}

\subparagraph{Returns: }\label{returns-22}

An initializer that generates Tensors with a truncated normal
distribution.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\lstinline{tf.random\_uniform\_initializer(minval=0.0,\ maxval=1.0,\ seed=None)}
}{tf.random\_uniform\_initializer(minval=0.0, maxval=1.0, seed=None) }}\label{tf.randomux5funiformux5finitializerminval0.0-maxval1.0-seednone}

Returns an initializer that generates Tensors with a uniform
distribution.

\subparagraph{Args: }\label{args-21}

\begin{itemize}
\tightlist
\item
  \lstinline{minval}: a python scalar or a scalar tensor. lower bound of
  the range of random values to generate.
\item
  \lstinline{maxval}: a python scalar or a scalar tensor. upper bound of
  the range of random values to generate.
\item
  \lstinline{seed}: A Python integer. Used to create random seeds. See
  \href{../../api_docs/python/constant_op.md\#set_random_seed}{\lstinline{set\_random\_seed}}
  for behavior.
\end{itemize}

\subparagraph{Returns: }\label{returns-23}

An initializer that generates Tensors with a uniform distribution.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\lstinline{tf.uniform\_unit\_scaling\_initializer(factor=1.0,\ seed=None)}
}{tf.uniform\_unit\_scaling\_initializer(factor=1.0, seed=None) }}\label{tf.uniformux5funitux5fscalingux5finitializerfactor1.0-seednone}

Returns an initializer that generates tensors without scaling variance.

When initializing a deep network, it is in principle advantageous to
keep the scale of the input variance constant, so it does not explode or
diminish by reaching the final layer. If the input is \lstinline{x} and the
operation \lstinline{x\ *\ W}, and we want to initialize \lstinline{W}
uniformly at random, we need to pick \lstinline{W} from

\begin{verbatim}
[-sqrt(3) / sqrt(dim), sqrt(3) / sqrt(dim)]
\end{verbatim}

to keep the scale intact, where \lstinline{dim\ =\ W.shape{[}0{]}} (the
size of the input). A similar calculation for convolutional networks
gives an analogous result with \lstinline{dim} equal to the product of the
first 3 dimensions. When nonlinearities are present, we need to multiply
this by a constant \lstinline{factor}. See
\url{https://arxiv.org/pdf/1412.6558v3.pdf} for deeper motivation,
experiments and the calculation of constants. In section 2.3 there, the
constants were numerically computed: for a linear layer it's 1.0, relu:
\textasciitilde{}1.43, tanh: \textasciitilde{}1.15.

\subparagraph{Args: }\label{args-22}

\begin{itemize}
\tightlist
\item
  \lstinline{factor}: Float. A multiplicative factor by which the values
  will be scaled.
\item
  \lstinline{seed}: A Python integer. Used to create random seeds. See
  \href{../../api_docs/python/constant_op.md\#set_random_seed}{\lstinline{set\_random\_seed}}
  for behavior.
\end{itemize}

\subparagraph{Returns: }\label{returns-24}

An initializer that generates tensors with unit variance.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\lstinline{tf.zeros\_initializer(shape,\ dtype=tf.float32)}
}{tf.zeros\_initializer(shape, dtype=tf.float32) }}\label{tf.zerosux5finitializershape-dtypetf.float32}

An adaptor for zeros() to match the Initializer spec.

\subsection{Sparse Variable Updates }\label{sparse-variable-updates}

The sparse update ops modify a subset of the entries in a dense
\lstinline{Variable}, either overwriting the entries or adding /
subtracting a delta. These are useful for training embedding models and
similar lookup-based networks, since only a small subset of embedding
vectors change in any given step.

Since a sparse update of a large tensor may be generated automatically
during gradient computation (as in the gradient of
\href{../../api_docs/python/array_ops.md\#gather}{\lstinline{tf.gather}}),
an \protect\hyperlink{IndexedSlices}{\lstinline{IndexedSlices}} class is
provided that encapsulates a set of sparse indices and values.
\lstinline{IndexedSlices} objects are detected and handled automatically by
the optimizers in most cases.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\lstinline{tf.scatter\_update(ref,\ indices,\ updates,\ use\_locking=None,\ name=None)}
}{tf.scatter\_update(ref, indices, updates, use\_locking=None, name=None) }}\label{tf.scatterux5fupdateref-indices-updates-useux5flockingnone-namenone}

Applies sparse updates to a variable reference.

This operation computes

\begin{verbatim}
# Scalar indices
ref[indices, ...] = updates[...]

# Vector indices (for each i)
ref[indices[i], ...] = updates[i, ...]

# High rank indices (for each i, ..., j)
ref[indices[i, ..., j], ...] = updates[i, ..., j, ...]
\end{verbatim}

This operation outputs \lstinline{ref} after the update is done. This makes
it easier to chain operations that need to use the reset value.

If \lstinline{indices} contains duplicate entries, lexicographically later
entries override earlier entries.

Requires \lstinline{updates.shape\ =\ indices.shape\ +\ ref.shape{[}1:{]}}.

\subparagraph{Args: }\label{args-23}

\begin{itemize}
\tightlist
\item
  \lstinline{ref}: A mutable \lstinline{Tensor}. Should be from a
  \lstinline{Variable} node.
\item
  \lstinline{indices}: A \lstinline{Tensor}. Must be one of the following
  types: \lstinline{int32}, \lstinline{int64}. A tensor of indices into the
  first dimension of \lstinline{ref}.
\item
  \lstinline{updates}: A \lstinline{Tensor}. Must have the same type as
  \lstinline{ref}. A tensor of updated values to store in \lstinline{ref}.
\item
  \lstinline{use\_locking}: An optional \lstinline{bool}. Defaults to
  \lstinline{True}. If True, the assignment will be protected by a lock;
  otherwise the behavior is undefined, but may exhibit less contention.
\item
  \lstinline{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-25}

Same as \lstinline{ref}. Returned as a convenience for operations that want
to use the updated values after the update is done.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\lstinline{tf.scatter\_add(ref,\ indices,\ updates,\ use\_locking=None,\ name=None)}
}{tf.scatter\_add(ref, indices, updates, use\_locking=None, name=None) }}\label{tf.scatterux5faddref-indices-updates-useux5flockingnone-namenone}

Adds sparse updates to a variable reference.

This operation computes

\begin{verbatim}
# Scalar indices
ref[indices, ...] += updates[...]

# Vector indices (for each i)
ref[indices[i], ...] += updates[i, ...]

# High rank indices (for each i, ..., j)
ref[indices[i, ..., j], ...] += updates[i, ..., j, ...]
\end{verbatim}

This operation outputs \lstinline{ref} after the update is done. This makes
it easier to chain operations that need to use the reset value.

Duplicate entries are handled correctly: if multiple \lstinline{indices}
reference the same location, their contributions add.

Requires \lstinline{updates.shape\ =\ indices.shape\ +\ ref.shape{[}1:{]}}.

\subparagraph{Args: }\label{args-24}

\begin{itemize}
\tightlist
\item
  \lstinline{ref}: A mutable \lstinline{Tensor}. Must be one of the following
  types: \lstinline{float32}, \lstinline{float64}, \lstinline{int64},
  \lstinline{int32}, \lstinline{uint8}, \lstinline{int16}, \lstinline{int8},
  \lstinline{complex64}, \lstinline{qint8}, \lstinline{quint8}, \lstinline{qint32}.
  Should be from a \lstinline{Variable} node.
\item
  \lstinline{indices}: A \lstinline{Tensor}. Must be one of the following
  types: \lstinline{int32}, \lstinline{int64}. A tensor of indices into the
  first dimension of \lstinline{ref}.
\item
  \lstinline{updates}: A \lstinline{Tensor}. Must have the same type as
  \lstinline{ref}. A tensor of updated values to add to \lstinline{ref}.
\item
  \lstinline{use\_locking}: An optional \lstinline{bool}. Defaults to
  \lstinline{False}. If True, the addition will be protected by a lock;
  otherwise the behavior is undefined, but may exhibit less contention.
\item
  \lstinline{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-26}

Same as \lstinline{ref}. Returned as a convenience for operations that want
to use the updated values after the update is done.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\lstinline{tf.scatter\_sub(ref,\ indices,\ updates,\ use\_locking=None,\ name=None)}
}{tf.scatter\_sub(ref, indices, updates, use\_locking=None, name=None) }}\label{tf.scatterux5fsubref-indices-updates-useux5flockingnone-namenone}

Subtracts sparse updates to a variable reference.

\begin{verbatim}
# Scalar indices
ref[indices, ...] -= updates[...]

# Vector indices (for each i)
ref[indices[i], ...] -= updates[i, ...]

# High rank indices (for each i, ..., j)
ref[indices[i, ..., j], ...] -= updates[i, ..., j, ...]
\end{verbatim}

This operation outputs \lstinline{ref} after the update is done. This makes
it easier to chain operations that need to use the reset value.

Duplicate entries are handled correctly: if multiple \lstinline{indices}
reference the same location, their (negated) contributions add.

Requires \lstinline{updates.shape\ =\ indices.shape\ +\ ref.shape{[}1:{]}}.

\subparagraph{Args: }\label{args-25}

\begin{itemize}
\tightlist
\item
  \lstinline{ref}: A mutable \lstinline{Tensor}. Must be one of the following
  types: \lstinline{float32}, \lstinline{float64}, \lstinline{int64},
  \lstinline{int32}, \lstinline{uint8}, \lstinline{int16}, \lstinline{int8},
  \lstinline{complex64}, \lstinline{qint8}, \lstinline{quint8}, \lstinline{qint32}.
  Should be from a \lstinline{Variable} node.
\item
  \lstinline{indices}: A \lstinline{Tensor}. Must be one of the following
  types: \lstinline{int32}, \lstinline{int64}. A tensor of indices into the
  first dimension of \lstinline{ref}.
\item
  \lstinline{updates}: A \lstinline{Tensor}. Must have the same type as
  \lstinline{ref}. A tensor of updated values to subtract from
  \lstinline{ref}.
\item
  \lstinline{use\_locking}: An optional \lstinline{bool}. Defaults to
  \lstinline{False}. If True, the subtraction will be protected by a lock;
  otherwise the behavior is undefined, but may exhibit less contention.
\item
  \lstinline{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-27}

Same as \lstinline{ref}. Returned as a convenience for operations that want
to use the updated values after the update is done.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\lstinline{tf.sparse\_mask(a,\ mask\_indices,\ name=None)}
}{tf.sparse\_mask(a, mask\_indices, name=None) }}\label{tf.sparseux5fmaska-maskux5findices-namenone}

Masks elements of \lstinline{IndexedSlices}.

Given an \lstinline{IndexedSlices} instance \lstinline{a}, returns another
\lstinline{IndexedSlices} that contains a subset of the slices of
\lstinline{a}. Only the slices at indices specified in
\lstinline{mask\_indices} are returned.

This is useful when you need to extract a subset of slices in an
\lstinline{IndexedSlices} object.

For example:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# `a` contains slices at indices [12, 26, 37, 45] from a large tensor}
\CommentTok{# with shape [1000, 10]}
\NormalTok{a.indices }\OperatorTok{=>} \NormalTok{[}\DecValTok{12}\NormalTok{, }\DecValTok{26}\NormalTok{, }\DecValTok{37}\NormalTok{, }\DecValTok{45}\NormalTok{]}
\NormalTok{tf.shape(a.values) }\OperatorTok{=>} \NormalTok{[}\DecValTok{4}\NormalTok{, }\DecValTok{10}\NormalTok{]}

\CommentTok{# `b` will be the subset of `a` slices at its second and third indices, so}
\CommentTok{# we want to mask of its first and last indices (which are at absolute}
\CommentTok{# indices 12, 45)}
\NormalTok{b }\OperatorTok{=} \NormalTok{tf.sparse_mask(a, [}\DecValTok{12}\NormalTok{, }\DecValTok{45}\NormalTok{])}

\NormalTok{b.indices }\OperatorTok{=>} \NormalTok{[}\DecValTok{26}\NormalTok{, }\DecValTok{37}\NormalTok{]}
\NormalTok{tf.shape(b.values) }\OperatorTok{=>} \NormalTok{[}\DecValTok{2}\NormalTok{, }\DecValTok{10}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\subparagraph{Args: }\label{args-26}

\begin{itemize}
\tightlist
\item
  \lstinline{a}: An \lstinline{IndexedSlices} instance.
\item
  \lstinline{mask\_indices}: Indices of elements to mask.
\item
  \lstinline{name}: A name for the operation (optional).
\end{itemize}

\subparagraph{Returns: }\label{returns-28}

The masked \lstinline{IndexedSlices} instance.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsubsection{\texorpdfstring{\lstinline{class\ tf.IndexedSlices}
}{class tf.IndexedSlices }}\label{class-tf.indexedslices}

A sparse representation of a set of tensor slices at given indices.

This class is a simple wrapper for a pair of \lstinline{Tensor} objects:

\begin{itemize}
\tightlist
\item
  \lstinline{values}: A \lstinline{Tensor} of any dtype with shape
  \lstinline{{[}D0,\ D1,\ ...,\ Dn{]}}.
\item
  \lstinline{indices}: A 1-D integer \lstinline{Tensor} with shape
  \lstinline{{[}D0{]}}.
\end{itemize}

An \lstinline{IndexedSlices} is typically used to represent a subset of a
larger tensor \lstinline{dense} of shape
\lstinline{{[}LARGE0,\ D1,\ ..\ ,\ DN{]}} where
\lstinline{LARGE0\ \textgreater{}\textgreater{}\ D0}. The values in
\lstinline{indices} are the indices in the first dimension of the slices
that have been extracted from the larger tensor.

The dense tensor \lstinline{dense} represented by an \lstinline{IndexedSlices}
\lstinline{slices} has

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dense[slices.indices[i], :, :, :, ...] }\OperatorTok{=} \NormalTok{slices.values[i, :, :, :, ...]}
\end{Highlighting}
\end{Shaded}

The \lstinline{IndexedSlices} class is used principally in the definition
of gradients for operations that have sparse gradients (e.g.
\href{../../api_docs/python/array_ops.md\#gather}{\lstinline{tf.gather}}).

Contrast this representation with
\href{../../api_docs/python/sparse_ops.md\#SparseTensor}{\lstinline{SparseTensor}},
which uses multi-dimensional indices and scalar values.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\lstinline{tf.IndexedSlices.\_\_init\_\_(values,\ indices,\ dense\_shape=None)}
}{tf.IndexedSlices.\_\_init\_\_(values, indices, dense\_shape=None) }}\label{tf.indexedslices.ux5fux5finitux5fux5fvalues-indices-denseux5fshapenone}

Creates an \lstinline{IndexedSlices}.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\lstinline{tf.IndexedSlices.values}
}{tf.IndexedSlices.values }}\label{tf.indexedslices.values}

A \lstinline{Tensor} containing the values of the slices.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\lstinline{tf.IndexedSlices.indices}
}{tf.IndexedSlices.indices }}\label{tf.indexedslices.indices}

A 1-D \lstinline{Tensor} containing the indices of the slices.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\lstinline{tf.IndexedSlices.dense\_shape}
}{tf.IndexedSlices.dense\_shape }}\label{tf.indexedslices.denseux5fshape}

A 1-D \lstinline{Tensor} containing the shape of the corresponding dense
tensor.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\lstinline{tf.IndexedSlices.name}
}{tf.IndexedSlices.name }}\label{tf.indexedslices.name}

The name of this \lstinline{IndexedSlices}.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\lstinline{tf.IndexedSlices.dtype}
}{tf.IndexedSlices.dtype }}\label{tf.indexedslices.dtype}

The \lstinline{DType} of elements in this tensor.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\lstinline{tf.IndexedSlices.device}
}{tf.IndexedSlices.device }}\label{tf.indexedslices.device}

The name of the device on which \lstinline{values} will be produced, or
\lstinline{None}.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\paragraph{\texorpdfstring{\lstinline{tf.IndexedSlices.op}
}{tf.IndexedSlices.op }}\label{tf.indexedslices.op}

The \lstinline{Operation} that produces \lstinline{values} as an output.

