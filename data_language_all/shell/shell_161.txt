#!/usr/bin/env bash

tmp=$(git_extra_mktemp)
above=0
# if the output won't be printed to tty, disable the color
test -t 1 && to_tty=true
color=

#
# print usage message
#
usage() {
  echo 1>&2 "usage: git effort [--above <value>] [<path>...] [-- [<log options>...]]"
}

#
# get dates for the given <commit>
#
dates() {
  eval "git log $args_to_git_log --pretty='format: %ad' --date=short -- \"$1\""
}

# tput, being quiet about unknown capabilities
tputq() {
  tput "$@" 2>/dev/null
  return 0
}

#
# hide cursor
#

hide_cursor() {
  tputq civis
}

#
# show cursor, and remove temporary file
#

show_cursor_and_cleanup() {
  tputq cnorm
  tputq sgr0
  rm "$tmp" > /dev/null 2>&1
  exit 0
}

#
# get active days for the given <commit>
#

active_days() {
  echo "$1" | sort -r | uniq | wc -l
}

#
# set 'color' based on the given <num>
#

color_for() {
  if [ "$to_tty" = true ]; then
    if   [ $1 -gt 200 ]; then color="$(tputq setaf 1)$(tputq bold)"
    elif [ $1 -gt 150 ]; then color="$(tputq setaf 1)"  # red
    elif [ $1 -gt 125 ]; then color="$(tputq setaf 2)$(tputq bold)"
    elif [ $1 -gt 100 ]; then color="$(tputq setaf 2)"  # green
    elif [ $1 -gt 75 ]; then color="$(tputq setaf 5)$(tputq bold)"
    elif [ $1 -gt 50 ]; then color="$(tputq setaf 5)"  # purplish
    elif [ $1 -gt 25 ]; then color="$(tputq setaf 3)$(tputq bold)"
    elif [ $1 -gt 10 ]; then color="$(tputq setaf 3)"  # yellow
    else color="$(tputq sgr0)" # default color
    fi
  else
    color=""
  fi
}

#
# compute the effort of the given <path ...>
#

effort() {
    path=$1
    local commit_dates
    local color reset_color commits len dot f_dot i msg active
    reset_color=""
    test "$to_tty" = true && reset_color="$(tputq sgr0)"
    commit_dates=`dates "$path"`
    [ $? -gt 0 ] && exit 255

    # Ensure it's not just an empty line
    if [ -z "`head -c 1 <<<$(echo $commit_dates)`" ]
    then
      exit 0
    fi

    commits=`wc -l <<<"$(echo "$commit_dates")"`
    color='90'

    # ignore <= --above
    test $commits -le $above && exit 0

    # commits
    color_for $(( $commits - $above ))
    len=${#path}
    dot="."
    f_dot="$path"
    i=0 ; while test $i -lt $(( $columns - $len )) ; do
      f_dot=$f_dot$dot
      i=$(($i+1))
    done

    msg=$(printf "  ${color}%s %-10d" "$f_dot" $commits)

    # active days
    active=`active_days "$commit_dates"`
    color_for $(( $active - $above ))
    msg="$msg $(printf "${color} %d${reset_color}\n" $active)"
    echo "$msg"
}

#
# print heading
#

heading() {
  echo
  printf "  %-${columns}s %-10s %s\n" 'path' 'commits' 'active days'
  echo
}

#
# output sorted results
#

sort_effort() {
  clear
  echo " "
  heading
  < $tmp sort -rn -k 2
}

declare -a paths=()
while [ "${#}" -ge 1 ] ; do

  case "$1" in
    --above)
      shift
      above=$1
      ;;
    --)
      shift
      args_to_git_log=$(printf " %q" "${@:1}")
      break
      ;;
    --*)
      usage
      echo 1>&2 "error: unknown argument $1"
      echo 1>&2 "error: if that argument was meant for git-log,"
      echo 1>&2 "error: please put it after two dashes ( -- )."
      exit 1
      ;;
    *)
      paths+=( "$1" )
      ;;
  esac

  shift
done

# Exit if above-value is not an int
if [ -z "${above##*[!0-9]*}" ] ; then
  echo "error: argument to --above was not an integer" 1>&2
  exit 1
fi

# remove empty quotes that appear when there are no arguments
args_to_git_log="${args_to_git_log#\ \'\'}"
export args_to_git_log

# set column width to match longest filename
columns=$(( $(git ls-files | awk '{ print length }' | sort -rn | head -1 ) + 5 ))
export columns

# [path ...]

if test "${#paths}" -eq 0; then
  save_ifs=$IFS
  IFS=`echo -en "\n\b"`
  paths=(`git ls-files`)
  IFS=$save_ifs
  unset save_ifs
fi

# hide cursor

hide_cursor
trap show_cursor_and_cleanup INT

# export functions so subshells can call them
export -f effort
export -f color_for
export -f active_days
export -f dates
export -f tputq
export to_tty
export above
export log_args


bash_params=
# If bash exits successfully with --import-functions,
# then we need to pass it (FreeBSD probably)
bash --import-functions -c ":" 1>/dev/null 2>&1
if [ $? -eq 0 ] ; then
  bash_params="--import-functions"
fi

heading
# send paths to effort
printf "%s\0" "${paths[@]}" | xargs -0 -n 1 -P 4 -I % bash $bash_params -c "effort \"%\"" | tee $tmp

# if more than one path, sort and print
test "$(wc -l $tmp | awk '{print $1}')" -gt 1 && sort_effort
echo

show_cursor_and_cleanup
#!/usr/bin/env bash
invers=$(tput rev)
reset=$(tput sgr0)
txtbld=$(tput bold)             
bldred=${txtbld}$(tput setaf 1) 

# default option settings
guardedmode=false
singlemode=false
allwsmode=false

#
# print usage message
#
usage() {
  echo 1>&2 "usage: git bulk [-g] ([-a]|[-w <ws-name>]) <git command>"
  echo 1>&2 "       git bulk --addworkspace <ws-name> <ws-root-directory>"
  echo 1>&2 "       git bulk --removeworkspace <ws-name>"
  echo 1>&2 "       git bulk --addcurrent <ws-name>"
  echo 1>&2 "       git bulk --purge"
  echo 1>&2 "       git bulk --listall"
}

# add another workspace to global git config
function addworkspace { git config --global bulkworkspaces."$wsname" "$wsdir"; }

# add current directory
function addcurrent { git config --global bulkworkspaces."$wsname" "$PWD"; }

# remove workspace from global git config
function removeworkspace { checkWSName && git config --global --unset bulkworkspaces."$wsname"; }

# remove workspace from global git config
function purge { git config --global --remove-section bulkworkspaces; }

# list all current workspace locations defined
function listall { git config --global --get-regexp bulkworkspaces; }

# guarded execution of a git command in one specific repository
function guardedExecution () {
  if $guardedmode; then
    echo -n "${invers}git $gitcommand${reset} -> execute here (y/n)? "
    read -n 1 -r </dev/tty; echo
    if [[ $REPLY =~ ^[Yy]$ ]]; then atomicExecution; fi
  else
     atomicExecution
  fi
}

# atomic git command execution with log
function atomicExecution () {
  echo "${bldred}->${reset} executing ${invers}git $gitcommand${reset}" && git $gitcommand
}

# check if the passed command is known as a core git command
function checkGitCommand () {
  if git help -a | grep -o -q "\b${corecommand}\b"; then
    echo "Core command \"$corecommand\" accepted."
  else
    if git config --get-regexp alias | grep -o -q "\.${corecommand} "; then
      echo "Alias ${corecommand} accepted."
    else
      usage && echo "error: unknown GIT command: $corecommand" && exit 1
    fi
  fi
}

# check if workspace name is registered
function checkWSName () {
  while read workspace; do
    parseWsName "$workspace"
    if [[ $rwsname == "$wsname" ]]; then return; fi
  done <<< "$(echo "$(listall)")"
  # when here the ws name was not found
  usage && echo "error: unknown workspace name: $wsname" && exit 1 
}

# parse out wsname from workspacespec
function parseWsName () {
  local wsspec="$1"
  rwsdir=${wsspec#* }
  rwsname=${wsspec#*.} && rwsname=${rwsname%% *}
}

# detects the wsname of the current directory
function wsnameToCurrent () {
  while read workspace; do
    if [ -z "$workspace" ]; then continue; fi
    parseWsName "$workspace"
    if echo "$PWD" | grep -o -q "$rwsdir"; then wsname="$rwsname" && return; fi
  done <<< "$(echo "$(listall)")"
  # when here then not in workspace dir
  echo "error: you are not in a workspace directory. your registered workspaces are:" && \
    wslist="$(echo "$(listall)")" && echo "${wslist:-'<no workspaces defined yet>'}" && exit 1
}

# helper to check number of arguments
function allowedargcount () {
  ( test "$paramcount" -ne "$1" ) && ( usage && echo 1>&2 "error: wrong number of arguments" && exit 1 ) 
}

# execute the bulk operation
function executBulkOp () {
  checkGitCommand
  if ! $allwsmode && ! $singlemode; then wsnameToCurrent; fi # by default git bulk works within the 'current' workspace
  listall | while read workspacespec; do
    parseWsName "$workspacespec"
    if [[ -n $wsname ]] && [[ $rwsname != "$wsname" ]]; then continue; fi
    eval cd "\"$rwsdir\""
    local actual=$(pwd)
    echo "Executing bulk operation in workspace ${invers}$actual${reset}"
    eval find . -name ".git" | while read line; do
      local gitrepodir=${line::${#line}-5} # cut the .git part of find results to have the root git directory of that repository
      eval cd "\"$gitrepodir\"" # into git repo location
      local curdir=$(pwd)
      local leadingpath=${curdir#${actual}}
      echo "Current repository: ${leadingpath%/*}/${bldred}${curdir##*/}${reset}"
      guardedExecution
      eval cd "\"$rwsdir\"" # back to origin location of last find command
    done 
  done 
}

paramcount="${#}"

# if no arguments show usage
if [[ $paramcount -le 0 ]]; then usage; fi

# parse command parameters
while [ "${#}" -ge 1 ] ; do
  case "$1" in
    --listall|--purge)
      butilcommand="${1:2}" && break ;;
    --removeworkspace|--addcurrent|--addworkspace)
      butilcommand="${1:2}" && wsname="$2" && wsdir="$3" && break ;;
    -a) 
      allwsmode=true ;;
    -g) 
      guardedmode=true ;;
    -w) 
      singlemode=true && shift && wsname="$1" && checkWSName ;;
    -*) 
      usage && echo 1>&2 "error: unknown argument $1" && exit 1 ;;
    --*) 
      usage && echo 1>&2 "error: unknown argument $1" && exit 1 ;;
    *) # git core commands
      butilcommand="executBulkOp" && corecommand="$1" && gitcommand="$@" && break ;;
  esac && shift
done

# check option compatibility
if $allwsmode && $singlemode; then echo 1>&2 "error: options -w and -a are incompatible" && exit 1; fi

# if single mode check the supplied workspace name
if $singlemode; then echo "Selected single workspace mode in workspace: $wsname" && checkWSName; fi 

# check right number of arguments
case $butilcommand in
  listall|purge) allowedargcount 1;;
  addcurrent|removeworkspace) allowedargcount 2;;
  addworkspace) allowedargcount 3;;
esac

$butilcommand # run user command
#!/usr/bin/env bash
invers=$(tput rev)
reset=$(tput sgr0)
txtbld=$(tput bold)             
bldred=${txtbld}$(tput setaf 1) 

# default option settings
guardedmode=false
singlemode=false
allwsmode=false

#
# print usage message
#
usage() {
  echo 1>&2 "usage: git bulk [-g] ([-a]|[-w <ws-name>]) <git command>"
  echo 1>&2 "       git bulk --addworkspace <ws-name> <ws-root-directory>"
  echo 1>&2 "       git bulk --removeworkspace <ws-name>"
  echo 1>&2 "       git bulk --addcurrent <ws-name>"
  echo 1>&2 "       git bulk --purge"
  echo 1>&2 "       git bulk --listall"
}

# add another workspace to global git config
function addworkspace { git config --global bulkworkspaces."$wsname" "$wsdir"; }

# add current directory
function addcurrent { git config --global bulkworkspaces."$wsname" "$PWD"; }

# remove workspace from global git config
function removeworkspace { checkWSName && git config --global --unset bulkworkspaces."$wsname"; }

# remove workspace from global git config
function purge { git config --global --remove-section bulkworkspaces; }

# list all current workspace locations defined
function listall { git config --global --get-regexp bulkworkspaces; }

# guarded execution of a git command in one specific repository
function guardedExecution () {
  if $guardedmode; then
    echo -n "${invers}git $gitcommand${reset} -> execute here (y/n)? "
    read -n 1 -r </dev/tty; echo
    if [[ $REPLY =~ ^[Yy]$ ]]; then atomicExecution; fi
  else
     atomicExecution
  fi
}

# atomic git command execution with log
function atomicExecution () {
  echo "${bldred}->${reset} executing ${invers}git $gitcommand${reset}" && git $gitcommand
}

# check if the passed command is known as a core git command
function checkGitCommand () {
  if git help -a | grep -o -q "\b${corecommand}\b"; then
    echo "Core command \"$corecommand\" accepted."
  else
    if git config --get-regexp alias | grep -o -q "\.${corecommand} "; then
      echo "Alias ${corecommand} accepted."
    else
      usage && echo "error: unknown GIT command: $corecommand" && exit 1
    fi
  fi
}

# check if workspace name is registered
function checkWSName () {
  while read workspace; do
    parseWsName "$workspace"
    if [[ $rwsname == "$wsname" ]]; then return; fi
  done <<< "$(echo "$(listall)")"
  # when here the ws name was not found
  usage && echo "error: unknown workspace name: $wsname" && exit 1 
}

# parse out wsname from workspacespec
function parseWsName () {
  local wsspec="$1"
  rwsdir=${wsspec#* }
  rwsname=${wsspec#*.} && rwsname=${rwsname%% *}
}

# detects the wsname of the current directory
function wsnameToCurrent () {
  while read workspace; do
    if [ -z "$workspace" ]; then continue; fi
    parseWsName "$workspace"
    if echo "$PWD" | grep -o -q "$rwsdir"; then wsname="$rwsname" && return; fi
  done <<< "$(echo "$(listall)")"
  # when here then not in workspace dir
  echo "error: you are not in a workspace directory. your registered workspaces are:" && \
    wslist="$(echo "$(listall)")" && echo "${wslist:-'<no workspaces defined yet>'}" && exit 1
}

# helper to check number of arguments
function allowedargcount () {
  ( test "$paramcount" -ne "$1" ) && ( usage && echo 1>&2 "error: wrong number of arguments" && exit 1 ) 
}

# execute the bulk operation
function executBulkOp () {
  checkGitCommand
  if ! $allwsmode && ! $singlemode; then wsnameToCurrent; fi # by default git bulk works within the 'current' workspace
  listall | while read workspacespec; do
    parseWsName "$workspacespec"
    if [[ -n $wsname ]] && [[ $rwsname != "$wsname" ]]; then continue; fi
    eval cd "\"$rwsdir\""
    local actual=$(pwd)
    echo "Executing bulk operation in workspace ${invers}$actual${reset}"
    eval find . -name ".git" | while read line; do
      local gitrepodir=${line::${#line}-5} # cut the .git part of find results to have the root git directory of that repository
      eval cd "\"$gitrepodir\"" # into git repo location
      local curdir=$(pwd)
      local leadingpath=${curdir#${actual}}
      echo "Current repository: ${leadingpath%/*}/${bldred}${curdir##*/}${reset}"
      guardedExecution
      eval cd "\"$rwsdir\"" # back to origin location of last find command
    done 
  done 
}

paramcount="${#}"

# if no arguments show usage
if [[ $paramcount -le 0 ]]; then usage; fi

# parse command parameters
while [ "${#}" -ge 1 ] ; do
  case "$1" in
    --listall|--purge)
      butilcommand="${1:2}" && break ;;
    --removeworkspace|--addcurrent|--addworkspace)
      butilcommand="${1:2}" && wsname="$2" && wsdir="$3" && break ;;
    -a) 
      allwsmode=true ;;
    -g) 
      guardedmode=true ;;
    -w) 
      singlemode=true && shift && wsname="$1" && checkWSName ;;
    -*) 
      usage && echo 1>&2 "error: unknown argument $1" && exit 1 ;;
    --*) 
      usage && echo 1>&2 "error: unknown argument $1" && exit 1 ;;
    *) # git core commands
      butilcommand="executBulkOp" && corecommand="$1" && gitcommand="$@" && break ;;
  esac && shift
done

# check option compatibility
if $allwsmode && $singlemode; then echo 1>&2 "error: options -w and -a are incompatible" && exit 1; fi

# if single mode check the supplied workspace name
if $singlemode; then echo "Selected single workspace mode in workspace: $wsname" && checkWSName; fi 

# check right number of arguments
case $butilcommand in
  listall|purge) allowedargcount 1;;
  addcurrent|removeworkspace) allowedargcount 2;;
  addworkspace) allowedargcount 3;;
esac

$butilcommand # run user command
