cite 'about-alias'
about-alias 'vagrant aliases'

# Aliases
alias vhl='vagrant hosts list'
alias vscp='vagrant scp'
alias vsl='vagrant snapshot list'
alias vst='vagrant snapshot take'
alias vup="vagrant up"
alias vupl="vagrant up 2>&1 | tee vagrant.log"
alias vh="vagrant halt"
alias vs="vagrant suspend"
alias vr="vagrant resume"
alias vrl="vagrant reload"
alias vssh="vagrant ssh"
alias vst="vagrant status"
alias vp="vagrant provision"
alias vdstr="vagrant destroy"
# requires vagrant-list plugin
alias vl="vagrant list"
# requires vagrant-hostmanager plugin
alias vhst="vagrant hostmanager"
#
# Provides for an easier use of SSH by setting up ssh-agent.
#
# Authors:
#   Sorin Ionescu <sorin.ionescu@gmail.com>
#

# Return if requirements are not found.
if (( ! $+commands[ssh-agent] )); then
  return 1
fi

# Set the path to the SSH directory.
_ssh_dir="$HOME/.ssh"

# Set the path to the environment file if not set by another module.
_ssh_agent_env="${_ssh_agent_env:-${TMPDIR:-/tmp}/ssh-agent.env.$UID}"

# Set the path to the persistent authentication socket.
_ssh_agent_sock="${TMPDIR:-/tmp}/ssh-agent.sock.$UID"

# Start ssh-agent if not started.
if [[ ! -S "$SSH_AUTH_SOCK" ]]; then
  # Export environment variables.
  source "$_ssh_agent_env" 2> /dev/null

  # Start ssh-agent if not started.
  if ! ps -U "$LOGNAME" -o pid,ucomm | grep -q -- "${SSH_AGENT_PID:--1} ssh-agent"; then
    eval "$(ssh-agent | sed '/^echo /d' | tee "$_ssh_agent_env")"
  fi
fi

# Create a persistent SSH authentication socket.
if [[ -S "$SSH_AUTH_SOCK" && "$SSH_AUTH_SOCK" != "$_ssh_agent_sock" ]]; then
  ln -sf "$SSH_AUTH_SOCK" "$_ssh_agent_sock"
  export SSH_AUTH_SOCK="$_ssh_agent_sock"
fi

# Load identities.
if ssh-add -l 2>&1 | grep -q 'The agent has no identities'; then
  zstyle -a ':prezto:module:ssh:load' identities '_ssh_identities'
  # ssh-add has strange requirements for running SSH_ASKPASS, so we duplicate
  # them here. Essentially, if the other requirements are met, we redirect stdin
  # from /dev/null in order to meet the final requirement.
  #
  # From ssh-add(1):
  # If ssh-add needs a passphrase, it will read the passphrase from the current
  # terminal if it was run from a terminal. If ssh-add does not have a terminal
  # associated with it but DISPLAY and SSH_ASKPASS are set, it will execute the
  # program specified by SSH_ASKPASS and open an X11 window to read the
  # passphrase.
  if [[ -n "$DISPLAY" && -x "$SSH_ASKPASS" ]]; then
    ssh-add ${_ssh_identities:+$_ssh_dir/${^_ssh_identities[@]}} < /dev/null 2> /dev/null
  else
    ssh-add ${_ssh_identities:+$_ssh_dir/${^_ssh_identities[@]}} 2> /dev/null
  fi
fi

# Clean up.
unset _ssh_{dir,identities} _ssh_agent_{env,sock}
# This is a simple script to assist in manually installing Microsoft.NETCore.App 1.0.1
# and is primarily meant to help Linux users encountering https://github.com/dotnet/cli/issues/3681
# Complete installers are expected to be available with a mid-September release rendering This
# script unneccessary.

echo ===========================================
read -p "Download and install 1.0.1 now? (y/n) " answer

if [ "$answer" == "y" ] || [ "$answer" == "Y" ]; then
    
    tmp_dir=~/tmp-update
    download="https://download.microsoft.com/download/B/0/0/B00543E8-54D9-4D4A-826B-84348956AA75/"

    rid=$(dotnet --info | grep "RID" | cut -d ":" -f2)
    rid="${rid##*( )}"
    istmpclean=0

    case $rid in
        *osx*)
            netcoreapp_dir="/usr/local/share/dotnet/shared/Microsoft.NETCore.App/"
        ;;
        *ubuntu*)
            netcoreapp_dir="/usr/share/dotnet/shared/Microsoft.NETCore.App/"
        ;;
        *)
            netcoreapp_dir="/opt/dotnet/shared/Microsoft.NETCore.App/"
        ;;
    esac #set netcoreapp location

    if [ -d $netcoreapp_dir"/1.0.1/" ]; then
        isinstalled=1
        echo
        echo "Looks like 1.0.1 is already installed." 
        echo "ls -al " $netcoreapp_dir
        echo 

        ls -al $netcoreapp_dir
        
        echo
        echo "Exiting install."
        echo ===========================================
	else # 1.0.1 installed

        echo
        echo "dotnet identifies your machine as:" $rid
        echo

        case $rid in
            *osx.10*)
                archive="dotnet-osx-x64.1.0.1.tar.gz"
            ;;
            *ubuntu.14*)
                archive="dotnet-ubuntu-x64.1.0.1.tar.gz"
            ;;
            *ubuntu.16*)
                archive="dotnet-ubuntu.16.04-x64.1.0.1.tar.gz"
            ;;
            *debian*)
                archive="dotnet-debian-x64.1.0.1.tar.gz"
            ;;
            *centos*)
                archive="dotnet-centos-x64.1.0.1.tar.gz"
            ;;
            *rhel*)
                archive="dotnet-rhel-x64.1.0.1.tar.gz"
            ;;
            *opensus.13*)
                archive="dotnet-opensus.13.2-x64.1.0.1.tar.gz"
            ;;
            *fedora.23*)
                archive="dotnet-fedora.23-x64.1.0.1.tar.gz"
            ;;
        esac #rid

        # Check to see if tmp-update has been left behind. If so, clean up first. 
        if [ -d $tmp_dir ]; then
            #tmp_dir left behind from previous attempt
            echo
            echo "Directory "$tmp_dir" already exists and needs to be cleaned before proceding."
            echo
            read -p "Clean up temporary files and locations used by this script (y/n)?" answer

            if [ "$answer" == "y" ] || [ "$answer" == "Y" ]; then
                cd ~
                sudo rm -r tmp-update/ 
                istmpclean=1 #tmp_dir removed
                echo $tmp_dir "removed."
                echo
            else
                istmpclean=0 #tmp_dir not removed
                echo "Cancelling temporary files and location clean up and exiting install."
                echo ========================================================================
                echo
            fi # clean tmp_dir
        else
            istmpclean=1 #tmp_dir not found
        fi # exists tmp_dir
        
        if [ $istmpclean == 1 ]; then
            # create ~/tmp-update and cd
            mkdir $tmp_dir && cd $tmp_dir

            # Get Microsoft.NETCore.App archive chosen above 
            echo "Downloading:" $archive
            curl -SL -O -# $download$archive

            echo
            echo "Extracting" $archive

            # Extract /shared
            tar -xvz -f $archive "./shared/Microsoft.NETCore.App/1.0.1/"

            # Move 1.0.1
            echo
            echo "Moving 1.0.1 to" $netcoreapp_dir
            sudo mv shared/Microsoft.NETCore.App/1.0.1 $netcoreapp_dir

            echo
            echo "Install complete. If it was successful you should see a 1.0.1 directory in the listing below."
            echo
            echo "ls -al " $netcoreapp_dir

            ls -al $netcoreapp_dir

            echo
            read -p "Clean up temporary files and locations created by this script (y/n)?" answer

            if [ "$answer" == "y" ] || [ "$answer" == "Y" ]; then
                cd ~
                sudo rm -r tmp-update/ 
                echo $tmp_dir "removed."
                echo
            else
                echo
                echo "Cancelling temporary files and location clean up and exiting install."
                echo ========================================================================
                echo
            fi #tmp file cleanup after successful install
        else
            echo "tmp_dir needs to be cleaned up before attempting to install."
        fi # tmpclean check
    fi # 1.0.1 installed
else #top level install decision
    echo
	echo "Exiting install."
    echo ===========================================
    echo
fi #top level install decision