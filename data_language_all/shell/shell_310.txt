# This is a simple script to assist in manually installing Microsoft.NETCore.App 1.0.1
# and is primarily meant to help Linux users encountering https://github.com/dotnet/cli/issues/3681
# Complete installers are expected to be available with a mid-September release rendering This
# script unneccessary.

echo ===========================================
read -p "Download and install 1.0.1 now? (y/n) " answer

if [ "$answer" == "y" ] || [ "$answer" == "Y" ]; then
    
    tmp_dir=~/tmp-update
    download="https://download.microsoft.com/download/B/0/0/B00543E8-54D9-4D4A-826B-84348956AA75/"

    rid=$(dotnet --info | grep "RID" | cut -d ":" -f2)
    rid="${rid##*( )}"
    istmpclean=0

    case $rid in
        *osx*)
            netcoreapp_dir="/usr/local/share/dotnet/shared/Microsoft.NETCore.App/"
        ;;
        *ubuntu*)
            netcoreapp_dir="/usr/share/dotnet/shared/Microsoft.NETCore.App/"
        ;;
        *)
            netcoreapp_dir="/opt/dotnet/shared/Microsoft.NETCore.App/"
        ;;
    esac #set netcoreapp location

    if [ -d $netcoreapp_dir"/1.0.1/" ]; then
        isinstalled=1
        echo
        echo "Looks like 1.0.1 is already installed." 
        echo "ls -al " $netcoreapp_dir
        echo 

        ls -al $netcoreapp_dir
        
        echo
        echo "Exiting install."
        echo ===========================================
	else # 1.0.1 installed

        echo
        echo "dotnet identifies your machine as:" $rid
        echo

        case $rid in
            *osx.10*)
                archive="dotnet-osx-x64.1.0.1.tar.gz"
            ;;
            *ubuntu.14*)
                archive="dotnet-ubuntu-x64.1.0.1.tar.gz"
            ;;
            *ubuntu.16*)
                archive="dotnet-ubuntu.16.04-x64.1.0.1.tar.gz"
            ;;
            *debian*)
                archive="dotnet-debian-x64.1.0.1.tar.gz"
            ;;
            *centos*)
                archive="dotnet-centos-x64.1.0.1.tar.gz"
            ;;
            *rhel*)
                archive="dotnet-rhel-x64.1.0.1.tar.gz"
            ;;
            *opensus.13*)
                archive="dotnet-opensus.13.2-x64.1.0.1.tar.gz"
            ;;
            *fedora.23*)
                archive="dotnet-fedora.23-x64.1.0.1.tar.gz"
            ;;
        esac #rid

        # Check to see if tmp-update has been left behind. If so, clean up first. 
        if [ -d $tmp_dir ]; then
            #tmp_dir left behind from previous attempt
            echo
            echo "Directory "$tmp_dir" already exists and needs to be cleaned before proceding."
            echo
            read -p "Clean up temporary files and locations used by this script (y/n)?" answer

            if [ "$answer" == "y" ] || [ "$answer" == "Y" ]; then
                cd ~
                sudo rm -r tmp-update/ 
                istmpclean=1 #tmp_dir removed
                echo $tmp_dir "removed."
                echo
            else
                istmpclean=0 #tmp_dir not removed
                echo "Cancelling temporary files and location clean up and exiting install."
                echo ========================================================================
                echo
            fi # clean tmp_dir
        else
            istmpclean=1 #tmp_dir not found
        fi # exists tmp_dir
        
        if [ $istmpclean == 1 ]; then
            # create ~/tmp-update and cd
            mkdir $tmp_dir && cd $tmp_dir

            # Get Microsoft.NETCore.App archive chosen above 
            echo "Downloading:" $archive
            curl -SL -O -# $download$archive

            echo
            echo "Extracting" $archive

            # Extract /shared
            tar -xvz -f $archive "./shared/Microsoft.NETCore.App/1.0.1/"

            # Move 1.0.1
            echo
            echo "Moving 1.0.1 to" $netcoreapp_dir
            sudo mv shared/Microsoft.NETCore.App/1.0.1 $netcoreapp_dir

            echo
            echo "Install complete. If it was successful you should see a 1.0.1 directory in the listing below."
            echo
            echo "ls -al " $netcoreapp_dir

            ls -al $netcoreapp_dir

            echo
            read -p "Clean up temporary files and locations created by this script (y/n)?" answer

            if [ "$answer" == "y" ] || [ "$answer" == "Y" ]; then
                cd ~
                sudo rm -r tmp-update/ 
                echo $tmp_dir "removed."
                echo
            else
                echo
                echo "Cancelling temporary files and location clean up and exiting install."
                echo ========================================================================
                echo
            fi #tmp file cleanup after successful install
        else
            echo "tmp_dir needs to be cleaned up before attempting to install."
        fi # tmpclean check
    fi # 1.0.1 installed
else #top level install decision
    echo
	echo "Exiting install."
    echo ===========================================
    echo
fi #top level install decision#
# Initializes Prezto.
#
# Authors:
#   Sorin Ionescu <sorin.ionescu@gmail.com>
#

#
# Version Check
#

# Check for the minimum supported version.
min_zsh_version='4.3.11'
if ! autoload -Uz is-at-least || ! is-at-least "$min_zsh_version"; then
  printf "prezto: old shell detected, minimum required: %s\n" "$min_zsh_version" >&2
  return 1
fi
unset min_zsh_version

# zprezto convenience updater
# The function is surrounded by ( ) instead of { } so it starts in a subshell
# and won't affect the environment of the calling shell
function zprezto-update {
  (
    function cannot-fast-forward {
      local STATUS="$1"
      [[ -n "${STATUS}" ]] && printf "%s\n" "${STATUS}"
      printf "Unable to fast-forward the changes. You can fix this by "
      printf "running\ncd '%s' and then\n'git pull' " "${ZPREZTODIR}"
      printf "to manually pull and possibly merge in changes\n"
    }
    cd -q -- "${ZPREZTODIR}" || return 7
    local orig_branch="$(git symbolic-ref HEAD 2> /dev/null | cut -d '/' -f 3)"
    if [[ "$orig_branch" == "master" ]]; then
      git fetch || return "$?"
      local UPSTREAM=$(git rev-parse '@{u}')
      local LOCAL=$(git rev-parse HEAD)
      local REMOTE=$(git rev-parse "$UPSTREAM")
      local BASE=$(git merge-base HEAD "$UPSTREAM")
      if [[ $LOCAL == $REMOTE ]]; then
        printf "There are no updates.\n"
        return 0
      elif [[ $LOCAL == $BASE ]]; then
        printf "There is an update available. Trying to pull.\n\n"
        if git pull --ff-only; then
          printf "Syncing submodules\n"
          git submodule update --recursive
          return $?
        else
          cannot-fast-forward
          return 1
        fi
      elif [[ $REMOTE == $BASE ]]; then
        cannot-fast-forward "Commits in master that aren't in upstream."
        return 1
      else
        cannot-fast-forward "Upstream and local have diverged."
        return 1
      fi
    else
      printf "zprezto install at '%s' is not on the master branch " "${ZPREZTODIR}"
      printf "(you're on '%s')\nUnable to automatically update.\n" "${orig_branch}"
      return 1
    fi
    return 1
  )
}
#
# Module Loader
#

# Loads Prezto modules.
function pmodload {
  local -a pmodules
  local -a pmodule_dirs
  local -a locations
  local pmodule
  local pmodule_location
  local pfunction_glob='^([_.]*|prompt_*_setup|README*|*~)(-.N:t)'

  # Load in any additional directories and warn if they don't exist
  zstyle -a ':prezto:load' pmodule-dirs 'user_pmodule_dirs'
  for user_dir in "$user_pmodule_dirs[@]"; do
    if [[ ! -d "$user_dir" ]]; then
      echo "$0: Missing user module dir: $user_dir"
    fi
  done

  pmodule_dirs=("$ZPREZTODIR/modules" "$ZPREZTODIR/contrib" "$user_pmodule_dirs[@]")

  # $argv is overridden in the anonymous function.
  pmodules=("$argv[@]")

  # Load Prezto modules.
  for pmodule in "$pmodules[@]"; do
    if zstyle -t ":prezto:module:$pmodule" loaded 'yes' 'no'; then
      continue
    else
      locations=(${pmodule_dirs:+${^pmodule_dirs}/$pmodule(-/FN)})
      if (( ${#locations} > 1 )); then
        print "$0: conflicting module locations: $locations"
        continue
      elif (( ${#locations} < 1 )); then
        print "$0: no such module: $pmodule"
        continue
      fi

      # Grab the full path to this module
      pmodule_location=${locations[1]}

      # Add functions to $fpath.
      fpath=(${pmodule_location}/functions(/FN) $fpath)

      function {
        local pfunction

        # Extended globbing is needed for listing autoloadable function directories.
        setopt LOCAL_OPTIONS EXTENDED_GLOB

        # Load Prezto functions.
        for pfunction in ${pmodule_location}/functions/$~pfunction_glob; do
          autoload -Uz "$pfunction"
        done
      }

      if [[ -s "${pmodule_location}/init.zsh" ]]; then
        source "${pmodule_location}/init.zsh"
      elif [[ -s "${pmodule_location}/${pmodule}.plugin.zsh" ]]; then
        source "${pmodule_location}/${pmodule}.plugin.zsh"
      fi

      if (( $? == 0 )); then
        zstyle ":prezto:module:$pmodule" loaded 'yes'
      else
        # Remove the $fpath entry.
        fpath[(r)${pmodule_location}/functions]=()

        function {
          local pfunction

          # Extended globbing is needed for listing autoloadable function
          # directories.
          setopt LOCAL_OPTIONS EXTENDED_GLOB

          # Unload Prezto functions.
          for pfunction in ${pmodule_location}/functions/$~pfunction_glob; do
            unfunction "$pfunction"
          done
        }

        zstyle ":prezto:module:$pmodule" loaded 'no'
      fi
    fi
  done
}

#
# Prezto Initialization
#

# This finds the directory prezto is installed to so plugin managers don't need
# to rely on dirty hacks to force prezto into a directory. Additionally, it
# needs to be done here because inside the pmodload function ${0:h} evaluates to
# the current directory of the shell rather than the prezto dir.
ZPREZTODIR=${0:h}

# Source the Prezto configuration file.
if [[ -s "${ZDOTDIR:-$HOME}/.zpreztorc" ]]; then
  source "${ZDOTDIR:-$HOME}/.zpreztorc"
fi

# Disable color and theme in dumb terminals.
if [[ "$TERM" == 'dumb' ]]; then
  zstyle ':prezto:*:*' color 'no'
  zstyle ':prezto:module:prompt' theme 'off'
fi

# Load Zsh modules.
zstyle -a ':prezto:load' zmodule 'zmodules'
for zmodule ("$zmodules[@]") zmodload "zsh/${(z)zmodule}"
unset zmodule{s,}

# Autoload Zsh functions.
zstyle -a ':prezto:load' zfunction 'zfunctions'
for zfunction ("$zfunctions[@]") autoload -Uz "$zfunction"
unset zfunction{s,}

# Load Prezto modules.
zstyle -a ':prezto:load' pmodule 'pmodules'
pmodload "$pmodules[@]"
unset pmodules
#
# Initializes Prezto.
#
# Authors:
#   Sorin Ionescu <sorin.ionescu@gmail.com>
#

#
# Version Check
#

# Check for the minimum supported version.
min_zsh_version='4.3.11'
if ! autoload -Uz is-at-least || ! is-at-least "$min_zsh_version"; then
  printf "prezto: old shell detected, minimum required: %s\n" "$min_zsh_version" >&2
  return 1
fi
unset min_zsh_version

# zprezto convenience updater
# The function is surrounded by ( ) instead of { } so it starts in a subshell
# and won't affect the environment of the calling shell
function zprezto-update {
  (
    function cannot-fast-forward {
      local STATUS="$1"
      [[ -n "${STATUS}" ]] && printf "%s\n" "${STATUS}"
      printf "Unable to fast-forward the changes. You can fix this by "
      printf "running\ncd '%s' and then\n'git pull' " "${ZPREZTODIR}"
      printf "to manually pull and possibly merge in changes\n"
    }
    cd -q -- "${ZPREZTODIR}" || return 7
    local orig_branch="$(git symbolic-ref HEAD 2> /dev/null | cut -d '/' -f 3)"
    if [[ "$orig_branch" == "master" ]]; then
      git fetch || return "$?"
      local UPSTREAM=$(git rev-parse '@{u}')
      local LOCAL=$(git rev-parse HEAD)
      local REMOTE=$(git rev-parse "$UPSTREAM")
      local BASE=$(git merge-base HEAD "$UPSTREAM")
      if [[ $LOCAL == $REMOTE ]]; then
        printf "There are no updates.\n"
        return 0
      elif [[ $LOCAL == $BASE ]]; then
        printf "There is an update available. Trying to pull.\n\n"
        if git pull --ff-only; then
          printf "Syncing submodules\n"
          git submodule update --recursive
          return $?
        else
          cannot-fast-forward
          return 1
        fi
      elif [[ $REMOTE == $BASE ]]; then
        cannot-fast-forward "Commits in master that aren't in upstream."
        return 1
      else
        cannot-fast-forward "Upstream and local have diverged."
        return 1
      fi
    else
      printf "zprezto install at '%s' is not on the master branch " "${ZPREZTODIR}"
      printf "(you're on '%s')\nUnable to automatically update.\n" "${orig_branch}"
      return 1
    fi
    return 1
  )
}
#
# Module Loader
#

# Loads Prezto modules.
function pmodload {
  local -a pmodules
  local -a pmodule_dirs
  local -a locations
  local pmodule
  local pmodule_location
  local pfunction_glob='^([_.]*|prompt_*_setup|README*|*~)(-.N:t)'

  # Load in any additional directories and warn if they don't exist
  zstyle -a ':prezto:load' pmodule-dirs 'user_pmodule_dirs'
  for user_dir in "$user_pmodule_dirs[@]"; do
    if [[ ! -d "$user_dir" ]]; then
      echo "$0: Missing user module dir: $user_dir"
    fi
  done

  pmodule_dirs=("$ZPREZTODIR/modules" "$ZPREZTODIR/contrib" "$user_pmodule_dirs[@]")

  # $argv is overridden in the anonymous function.
  pmodules=("$argv[@]")

  # Load Prezto modules.
  for pmodule in "$pmodules[@]"; do
    if zstyle -t ":prezto:module:$pmodule" loaded 'yes' 'no'; then
      continue
    else
      locations=(${pmodule_dirs:+${^pmodule_dirs}/$pmodule(-/FN)})
      if (( ${#locations} > 1 )); then
        print "$0: conflicting module locations: $locations"
        continue
      elif (( ${#locations} < 1 )); then
        print "$0: no such module: $pmodule"
        continue
      fi

      # Grab the full path to this module
      pmodule_location=${locations[1]}

      # Add functions to $fpath.
      fpath=(${pmodule_location}/functions(/FN) $fpath)

      function {
        local pfunction

        # Extended globbing is needed for listing autoloadable function directories.
        setopt LOCAL_OPTIONS EXTENDED_GLOB

        # Load Prezto functions.
        for pfunction in ${pmodule_location}/functions/$~pfunction_glob; do
          autoload -Uz "$pfunction"
        done
      }

      if [[ -s "${pmodule_location}/init.zsh" ]]; then
        source "${pmodule_location}/init.zsh"
      elif [[ -s "${pmodule_location}/${pmodule}.plugin.zsh" ]]; then
        source "${pmodule_location}/${pmodule}.plugin.zsh"
      fi

      if (( $? == 0 )); then
        zstyle ":prezto:module:$pmodule" loaded 'yes'
      else
        # Remove the $fpath entry.
        fpath[(r)${pmodule_location}/functions]=()

        function {
          local pfunction

          # Extended globbing is needed for listing autoloadable function
          # directories.
          setopt LOCAL_OPTIONS EXTENDED_GLOB

          # Unload Prezto functions.
          for pfunction in ${pmodule_location}/functions/$~pfunction_glob; do
            unfunction "$pfunction"
          done
        }

        zstyle ":prezto:module:$pmodule" loaded 'no'
      fi
    fi
  done
}

#
# Prezto Initialization
#

# This finds the directory prezto is installed to so plugin managers don't need
# to rely on dirty hacks to force prezto into a directory. Additionally, it
# needs to be done here because inside the pmodload function ${0:h} evaluates to
# the current directory of the shell rather than the prezto dir.
ZPREZTODIR=${0:h}

# Source the Prezto configuration file.
if [[ -s "${ZDOTDIR:-$HOME}/.zpreztorc" ]]; then
  source "${ZDOTDIR:-$HOME}/.zpreztorc"
fi

# Disable color and theme in dumb terminals.
if [[ "$TERM" == 'dumb' ]]; then
  zstyle ':prezto:*:*' color 'no'
  zstyle ':prezto:module:prompt' theme 'off'
fi

# Load Zsh modules.
zstyle -a ':prezto:load' zmodule 'zmodules'
for zmodule ("$zmodules[@]") zmodload "zsh/${(z)zmodule}"
unset zmodule{s,}

# Autoload Zsh functions.
zstyle -a ':prezto:load' zfunction 'zfunctions'
for zfunction ("$zfunctions[@]") autoload -Uz "$zfunction"
unset zfunction{s,}

# Load Prezto modules.
zstyle -a ':prezto:load' pmodule 'pmodules'
pmodload "$pmodules[@]"
unset pmodules
