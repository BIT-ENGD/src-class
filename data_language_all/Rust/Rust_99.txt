/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

use filemanager_thread::FileManager;
use hyper::header::{Charset, ContentLength, ContentType, Headers};
use hyper::header::{ContentDisposition, DispositionParam, DispositionType};
use ipc_channel::ipc;
use mime::{Attr, Mime};
use net_traits::NetworkError;
use net_traits::blob_url_store::parse_blob_url;
use net_traits::filemanager_thread::ReadFileProgress;
use servo_url::ServoUrl;

// TODO: Check on GET
// https://w3c.github.io/FileAPI/#requestResponseModel

/// https://fetch.spec.whatwg.org/#concept-basic-fetch (partial)
// TODO: make async.
pub fn load_blob_sync
            (url: ServoUrl,
             filemanager: FileManager)
             -> Result<(Headers, Vec<u8>), NetworkError> {
    let (id, origin) = match parse_blob_url(&url) {
        Ok((id, origin)) => (id, origin),
        Err(()) => {
            let e = format!("Invalid blob URL format {:?}", url);
            return Err(NetworkError::Internal(e));
        }
    };

    let (sender, receiver) = ipc::channel().unwrap();
    let check_url_validity = true;
    filemanager.read_file(sender, id, check_url_validity, origin);

    let blob_buf = match receiver.recv().unwrap() {
        Ok(ReadFileProgress::Meta(blob_buf)) => blob_buf,
        Ok(_) => {
            return Err(NetworkError::Internal("Invalid filemanager reply".to_string()));
        }
        Err(e) => {
            return Err(NetworkError::Internal(format!("{:?}", e)));
        }
    };

    let content_type: Mime = blob_buf.type_string.parse().unwrap_or(mime!(Text / Plain));
    let charset = content_type.get_param(Attr::Charset);

    let mut headers = Headers::new();

    if let Some(name) = blob_buf.filename {
        let charset = charset.and_then(|c| c.as_str().parse().ok());
        headers.set(ContentDisposition {
            disposition: DispositionType::Inline,
            parameters: vec![
                DispositionParam::Filename(charset.unwrap_or(Charset::Us_Ascii),
                                           None, name.as_bytes().to_vec())
            ]
        });
    }

    // Basic fetch, Step 4.
    headers.set(ContentLength(blob_buf.size as u64));
    // Basic fetch, Step 5.
    headers.set(ContentType(content_type.clone()));

    let mut bytes = blob_buf.bytes;
    loop {
        match receiver.recv().unwrap() {
            Ok(ReadFileProgress::Partial(ref mut new_bytes)) => {
                bytes.append(new_bytes);
            }
            Ok(ReadFileProgress::EOF) => {
                return Ok((headers, bytes));
            }
            Ok(_) => {
                return Err(NetworkError::Internal("Invalid filemanager reply".to_string()));
            }
            Err(e) => {
                return Err(NetworkError::Internal(format!("{:?}", e)));
            }
        }
    }
}
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

use base64;
use hyper::mime::{Attr, Mime, SubLevel, TopLevel, Value};
use servo_url::ServoUrl;
use url::Position;
use url::percent_encoding::percent_decode;

pub enum DecodeError {
    InvalidDataUri,
    NonBase64DataUri,
}

pub type DecodeData = (Mime, Vec<u8>);

pub fn decode(url: &ServoUrl) -> Result<DecodeData, DecodeError> {
    assert_eq!(url.scheme(), "data");
    // Split out content type and data.
    let parts: Vec<&str> = url[Position::BeforePath..Position::AfterQuery].splitn(2, ',').collect();
    if parts.len() != 2 {
        return Err(DecodeError::InvalidDataUri);
    }

    // ";base64" must come at the end of the content type, per RFC 2397.
    // rust-http will fail to parse it because there's no =value part.
    let mut ct_str = parts[0];
    let is_base64 = ct_str.ends_with(";base64");
    if is_base64 {
        ct_str = &ct_str[..ct_str.len() - ";base64".len()];
    }
    let ct_str = if ct_str.starts_with(";charset=") {
        format!("text/plain{}", ct_str)
    } else {
        ct_str.to_owned()
    };

    let content_type = ct_str.parse().unwrap_or_else(|_| {
        Mime(TopLevel::Text, SubLevel::Plain,
             vec![(Attr::Charset, Value::Ext("US-ASCII".to_owned()))])
    });

    let mut bytes = percent_decode(parts[1].as_bytes()).collect::<Vec<_>>();
    if is_base64 {
        // FIXME(#2909): Itâ€™s unclear what to do with non-alphabet characters,
        // but Acid 3 apparently depends on spaces being ignored.
        bytes = bytes.into_iter().filter(|&b| b != b' ').collect::<Vec<u8>>();
        match base64::decode(&bytes) {
            Err(..) => return Err(DecodeError::NonBase64DataUri),
            Ok(data) => bytes = data,
        }
    }
    Ok((content_type, bytes))
}
