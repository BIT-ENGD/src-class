use futures::task::{self, Task};
use futures::{Async, Future, Poll, Stream};
use serde_json;
use std::boxed::Box;
use std::cell::RefCell;
use std::collections::{HashMap, HashSet};
use std::marker::Unsize;
use std::ops::CoerceUnsized;
use std::rc::{Rc, Weak};
use BackgroundExecutor;

pub type ViewId = usize;

pub trait View: Stream<Item = (), Error = ()> {
    fn component_name(&self) -> &'static str;
    fn will_mount(&mut self, &mut Window, WeakViewHandle<Self>)
    where
        Self: Sized,
    {
    }
    fn render(&self) -> serde_json::Value;
    fn dispatch_action(&mut self, serde_json::Value, &mut Window) {}
}

pub struct Window(Rc<RefCell<Inner>>);

#[derive(Clone)]
pub struct WeakWindowHandle(Weak<RefCell<Inner>>);

pub struct WindowUpdateStream {
    counter: usize,
    polled_once: bool,
    inner: Weak<RefCell<Inner>>,
}

pub struct Inner {
    background: Option<BackgroundExecutor>,
    root_view: Option<ViewHandle>,
    next_view_id: ViewId,
    views: HashMap<ViewId, Rc<RefCell<View<Item = (), Error = ()>>>>,
    inserted: HashSet<ViewId>,
    removed: HashSet<ViewId>,
    focused: Option<ViewId>,
    height: f64,
    update_stream_counter: usize,
    update_stream_task: Option<Task>,
}

pub struct ViewHandle {
    pub view_id: ViewId,
    inner: Weak<RefCell<Inner>>,
}

pub struct WeakViewHandle<T: ?Sized>(Weak<RefCell<T>>);

#[derive(Serialize, Debug)]
pub struct WindowUpdate {
    updated: Vec<ViewUpdate>,
    removed: Vec<ViewId>,
    focused: Option<ViewId>,
}

#[derive(Serialize, Debug)]
pub struct ViewUpdate {
    component_name: &'static str,
    view_id: ViewId,
    props: serde_json::Value,
}

impl Window {
    pub fn new(background: Option<BackgroundExecutor>, height: f64) -> Self {
        Window(Rc::new(RefCell::new(Inner {
            background,
            root_view: None,
            next_view_id: 0,
            views: HashMap::new(),
            inserted: HashSet::new(),
            removed: HashSet::new(),
            focused: None,
            height: height,
            update_stream_counter: 0,
            update_stream_task: None,
        })))
    }

    pub fn dispatch_action(&mut self, view_id: ViewId, action: serde_json::Value) {
        let view = self.0.borrow().get_view(view_id);
        view.map(|view| view.borrow_mut().dispatch_action(action, self));
    }

    pub fn updates(&mut self) -> WindowUpdateStream {
        let mut inner = self.0.borrow_mut();
        inner.update_stream_counter += 1;
        WindowUpdateStream {
            counter: inner.update_stream_counter,
            polled_once: false,
            inner: Rc::downgrade(&self.0),
        }
    }

    pub fn set_height(&mut self, height: f64) {
        self.0.borrow_mut().height = height;
    }

    pub fn set_root_view(&mut self, root_view: ViewHandle) {
        self.0.borrow_mut().root_view = Some(root_view);
    }

    pub fn height(&self) -> f64 {
        self.0.borrow().height
    }

    pub fn add_view<T: 'static + View>(&mut self, view: T) -> ViewHandle {
        let view_id = {
            let mut inner = self.0.borrow_mut();
            inner.next_view_id += 1;
            inner.next_view_id - 1
        };

        let view_rc = Rc::new(RefCell::new(view));
        let weak_view = Rc::downgrade(&view_rc);
        view_rc
            .borrow_mut()
            .will_mount(self, WeakViewHandle(weak_view));

        let mut inner = self.0.borrow_mut();
        inner.views.insert(view_id, view_rc);
        inner.inserted.insert(view_id);
        inner.notify();
        ViewHandle {
            view_id,
            inner: Rc::downgrade(&self.0),
        }
    }

    pub fn spawn<F: Future<Item = (), Error = ()> + Send + 'static>(&self, future: F) {
        self.0
            .borrow()
            .background
            .as_ref()
            .map(|background| background.execute(Box::new(future)));
    }

    pub fn handle(&self) -> WeakWindowHandle {
        WeakWindowHandle(Rc::downgrade(&self.0))
    }
}

impl WeakWindowHandle {
    pub fn map<F, T>(&self, f: F) -> Option<T>
    where
        F: FnOnce(&mut Window) -> T,
    {
        self.0.upgrade().map(|inner| {
            let mut window = Window(inner);
            f(&mut window)
        })
    }
}

impl Stream for WindowUpdateStream {
    type Item = WindowUpdate;
    type Error = ();

    fn poll(&mut self) -> Poll<Option<Self::Item>, Self::Error> {
        let inner_ref = match self.inner.upgrade() {
            None => return Ok(Async::Ready(None)),
            Some(inner) => inner,
        };

        let mut window_update;
        {
            let mut inner = inner_ref.borrow_mut();

            if self.counter < inner.update_stream_counter {
                return Ok(Async::Ready(None));
            }

            if self.polled_once {
                window_update = WindowUpdate {
                    updated: Vec::new(),
                    removed: inner.removed.iter().cloned().collect(),
                    focused: inner.focused.take(),
                };

                for id in inner.inserted.iter() {
                    if !inner.removed.contains(&id) {
                        let view = inner.get_view(*id).unwrap();
                        let view = view.borrow();
                        window_update.updated.push(ViewUpdate {
                            view_id: *id,
                            component_name: view.component_name(),
                            props: view.render(),
                        });
                    }
                }

                for (id, ref view) in inner.views.iter() {
                    let result = view.borrow_mut().poll();
                    if !inner.inserted.contains(&id) {
                        if let Ok(Async::Ready(Some(()))) = result {
                            let view = view.borrow();
                            window_update.updated.push(ViewUpdate {
                                view_id: *id,
                                component_name: view.component_name(),
                                props: view.render(),
                            });
                        }
                    }
                }
            } else {
                window_update = WindowUpdate {
                    updated: Vec::new(),
                    removed: Vec::new(),
                    focused: inner.focused.take(),
                };

                for (id, ref view) in inner.views.iter() {
                    let mut view = view.borrow_mut();
                    let _ = view.poll();
                    window_update.updated.push(ViewUpdate {
                        view_id: *id,
                        component_name: view.component_name(),
                        props: view.render(),
                    });
                }

                self.polled_once = true;
            }
        }

        let mut inner = inner_ref.borrow_mut();
        inner.inserted.clear();
        inner.removed.clear();

        if window_update.removed.is_empty() && window_update.updated.is_empty() {
            inner.update_stream_task = Some(task::current());
            Ok(Async::NotReady)
        } else {
            Ok(Async::Ready(Some(window_update)))
        }
    }
}

impl Inner {
    fn notify(&mut self) {
        self.update_stream_task.take().map(|task| task.notify());
    }

    fn get_view(&self, id: ViewId) -> Option<Rc<RefCell<View<Item = (), Error = ()>>>> {
        self.views.get(&id).map(|view| view.clone())
    }
}

impl ViewHandle {
    pub fn focus(&self) -> Result<(), ()> {
        let inner = self.inner.upgrade().ok_or(())?;
        let mut inner = inner.borrow_mut();
        inner.focused = Some(self.view_id);
        inner.notify();
        Ok(())
    }
}

impl Drop for ViewHandle {
    fn drop(&mut self) {
        // Store the removed view here to prevent it from being dropped until after the borrow of
        // inner is dropped, since the removed view may itself hold other view handles which will
        // call drop reentrantly.
        let mut _removed_view = None;

        let inner = self.inner.upgrade();
        if let Some(inner) = inner {
            let mut inner = inner.borrow_mut();
            _removed_view = inner.views.remove(&self.view_id);
            inner.removed.insert(self.view_id);
            inner.notify();
        }
    }
}

impl<T: ?Sized> WeakViewHandle<T> {
    pub fn map<F, R>(&self, f: F) -> Option<R>
    where
        F: FnOnce(&mut T) -> R,
    {
        self.0.upgrade().map(|view| f(&mut *view.borrow_mut()))
    }
}

impl<T: ?Sized> Clone for WeakViewHandle<T> {
    fn clone(&self) -> Self {
        WeakViewHandle(self.0.clone())
    }
}

impl<T, U> CoerceUnsized<WeakViewHandle<U>> for WeakViewHandle<T>
where
    T: Unsize<U> + ?Sized,
    U: ?Sized,
{
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_view_handle_drop() {
        // Dropping the window should not cause a panic
        let mut window = Window::new(None, 100.0);
        window.add_view(TestView::new(true));
    }

    struct TestView {
        add_child: bool,
        handle: Option<ViewHandle>,
        updates: NotifyCell<()>,
    }

    use notify_cell::NotifyCell;

    impl TestView {
        fn new(add_child: bool) -> Self {
            TestView {
                add_child,
                handle: None,
                updates: NotifyCell::new(()),
            }
        }
    }

    impl View for TestView {
        fn component_name(&self) -> &'static str {
            "TestView"
        }

        fn render(&self) -> serde_json::Value {
            json!({})
        }

        fn will_mount(&mut self, window: &mut Window, _view_handle: WeakViewHandle<Self>) {
            if self.add_child {
                self.handle = Some(window.add_view(TestView::new(false)));
            }
        }
    }

    impl Stream for TestView {
        type Item = ();
        type Error = ();

        fn poll(&mut self) -> Poll<Option<Self::Item>, Self::Error> {
            self.updates.poll()
        }
    }
}
use buffer::{self, Buffer, BufferId};
use buffer_view::{BufferView, BufferViewDelegate};
use cross_platform;
use file_finder::{FileFinderView, FileFinderViewDelegate};
use futures::{Future, Poll, Stream};
use never::Never;
use notify_cell::NotifyCell;
use notify_cell::NotifyCellObserver;
use project::{
    self, LocalProject, PathSearch, PathSearchStatus, Project, ProjectService, RemoteProject,
    TreeId,
};
use rpc::{self, client, server};
use serde_json;
use std::cell::{Ref, RefCell, RefMut};
use std::ops::Range;
use std::rc::Rc;
use window::{View, ViewHandle, WeakViewHandle, WeakWindowHandle, Window};
use ForegroundExecutor;
use IntoShared;
use UserId;

pub trait Workspace {
    fn user_id(&self) -> UserId;
    fn project(&self) -> Ref<Project>;
    fn project_mut(&self) -> RefMut<Project>;
}

pub struct LocalWorkspace {
    next_user_id: UserId,
    user_id: UserId,
    project: Rc<RefCell<LocalProject>>,
}

pub struct RemoteWorkspace {
    user_id: UserId,
    project: Rc<RefCell<RemoteProject>>,
}

pub struct WorkspaceService {
    workspace: Rc<RefCell<LocalWorkspace>>,
}

#[derive(Serialize, Deserialize)]
pub struct ServiceState {
    user_id: UserId,
    project: rpc::ServiceId,
}

pub struct WorkspaceView {
    foreground: ForegroundExecutor,
    workspace: Rc<RefCell<Workspace>>,
    active_buffer_view: Option<WeakViewHandle<BufferView>>,
    center_pane: Option<ViewHandle>,
    modal: Option<ViewHandle>,
    left_panel: Option<ViewHandle>,
    updates: NotifyCell<()>,
    self_handle: Option<WeakViewHandle<WorkspaceView>>,
    window_handle: Option<WeakWindowHandle>,
}

#[derive(Clone, Serialize, Deserialize)]
pub struct Anchor {
    buffer_id: BufferId,
    range: Range<buffer::Anchor>,
}

#[derive(Deserialize)]
#[serde(tag = "type")]
enum WorkspaceViewAction {
    ToggleFileFinder,
    SaveActiveBuffer,
}

impl LocalWorkspace {
    pub fn new(project: LocalProject) -> Self {
        Self {
            user_id: 0,
            next_user_id: 1,
            project: project.into_shared(),
        }
    }
}

impl Workspace for LocalWorkspace {
    fn user_id(&self) -> UserId {
        self.user_id
    }

    fn project(&self) -> Ref<Project> {
        self.project.borrow()
    }

    fn project_mut(&self) -> RefMut<Project> {
        self.project.borrow_mut()
    }
}

impl RemoteWorkspace {
    pub fn new(
        foreground: ForegroundExecutor,
        service: client::Service<WorkspaceService>,
    ) -> Result<Self, rpc::Error> {
        let state = service.state()?;
        let project = RemoteProject::new(foreground.clone(), service.take_service(state.project)?)?;
        Ok(Self {
            user_id: state.user_id,
            project: project.into_shared(),
        })
    }
}

impl Workspace for RemoteWorkspace {
    fn user_id(&self) -> UserId {
        self.user_id
    }

    fn project(&self) -> Ref<Project> {
        self.project.borrow()
    }

    fn project_mut(&self) -> RefMut<Project> {
        self.project.borrow_mut()
    }
}

impl WorkspaceService {
    pub fn new(workspace: Rc<RefCell<LocalWorkspace>>) -> Self {
        Self { workspace }
    }
}

impl server::Service for WorkspaceService {
    type State = ServiceState;
    type Update = Never;
    type Request = Never;
    type Response = Never;

    fn init(&mut self, connection: &server::Connection) -> ServiceState {
        let mut workspace = self.workspace.borrow_mut();
        let user_id = workspace.next_user_id;
        workspace.next_user_id += 1;
        ServiceState {
            user_id,
            project: connection
                .add_service(ProjectService::new(workspace.project.clone()))
                .service_id(),
        }
    }
}

impl WorkspaceView {
    pub fn new(foreground: ForegroundExecutor, workspace: Rc<RefCell<Workspace>>) -> Self {
        WorkspaceView {
            workspace,
            foreground,
            active_buffer_view: None,
            center_pane: None,
            modal: None,
            left_panel: None,
            updates: NotifyCell::new(()),
            self_handle: None,
            window_handle: None,
        }
    }

    fn toggle_file_finder(&mut self, window: &mut Window) {
        if self.modal.is_some() {
            self.modal = None;
        } else {
            let delegate = self.self_handle.as_ref().cloned().unwrap();
            let view = window.add_view(FileFinderView::new(delegate));
            view.focus().unwrap();
            self.modal = Some(view);
        }
        self.updates.set(());
    }

    fn open_buffer<T>(&self, buffer: T)
    where
        T: 'static + Future<Item = Rc<RefCell<Buffer>>, Error = project::Error>,
    {
        if let Some(window_handle) = self.window_handle.clone() {
            let user_id = self.workspace.borrow().user_id();
            let view_handle = self.self_handle.clone();
            self.foreground
                .execute(Box::new(buffer.then(move |result| {
                    window_handle.map(|window| match result {
                        Ok(buffer) => {
                            if let Some(view_handle) = view_handle {
                                let mut buffer_view =
                                    BufferView::new(buffer, user_id, Some(view_handle.clone()));
                                buffer_view.set_line_height(20.0);
                                let buffer_view = window.add_view(buffer_view);
                                buffer_view.focus().unwrap();
                                view_handle.map(|view| {
                                    view.center_pane = Some(buffer_view);
                                    view.modal = None;
                                    view.updates.set(());
                                });
                            }
                        }
                        Err(error) => {
                            eprintln!("Error opening buffer {:?}", error);
                            unimplemented!("Error handling for open_buffer: {:?}", error);
                        }
                    });
                    Ok(())
                })))
                .unwrap();
        }
    }

    fn save_active_buffer(&self) {
        if let Some(ref active_buffer_view) = self.active_buffer_view {
            active_buffer_view.map(|buffer_view| {
                self.foreground
                    .execute(Box::new(buffer_view.save().then(|result| {
                        if let Err(error) = result {
                            eprintln!("Error saving buffer {:?}", error);
                            unimplemented!("Error handling for save_buffer: {:?}", error);
                        } else {
                            Ok(())
                        }
                    })))
                    .unwrap();
            });
        }
    }
}

impl View for WorkspaceView {
    fn component_name(&self) -> &'static str {
        "Workspace"
    }

    fn render(&self) -> serde_json::Value {
        json!({
            "center_pane": self.center_pane.as_ref().map(|view_handle| view_handle.view_id),
            "modal": self.modal.as_ref().map(|view_handle| view_handle.view_id),
            "left_panel": self.left_panel.as_ref().map(|view_handle| view_handle.view_id)
        })
    }

    fn will_mount(&mut self, window: &mut Window, view_handle: WeakViewHandle<Self>) {
        self.self_handle = Some(view_handle.clone());
        self.window_handle = Some(window.handle());
    }

    fn dispatch_action(&mut self, action: serde_json::Value, window: &mut Window) {
        match serde_json::from_value(action) {
            Ok(WorkspaceViewAction::ToggleFileFinder) => self.toggle_file_finder(window),
            Ok(WorkspaceViewAction::SaveActiveBuffer) => self.save_active_buffer(),
            Err(error) => eprintln!("Unrecognized action {}", error),
        }
    }
}

impl BufferViewDelegate for WorkspaceView {
    fn set_active_buffer_view(&mut self, handle: WeakViewHandle<BufferView>) {
        self.active_buffer_view = Some(handle);
    }
}

impl FileFinderViewDelegate for WorkspaceView {
    fn search_paths(
        &self,
        needle: &str,
        max_results: usize,
        include_ignored: bool,
    ) -> (PathSearch, NotifyCellObserver<PathSearchStatus>) {
        let workspace = self.workspace.borrow();
        let project = workspace.project();
        project.search_paths(needle, max_results, include_ignored)
    }

    fn did_close(&mut self) {
        self.modal = None;
        self.updates.set(());
    }

    fn did_confirm(&mut self, tree_id: TreeId, path: &cross_platform::Path, _: &mut Window) {
        let workspace = self.workspace.borrow();
        self.open_buffer(workspace.project().open_path(tree_id, path));
    }
}

impl Stream for WorkspaceView {
    type Item = ();
    type Error = ();

    fn poll(&mut self) -> Poll<Option<Self::Item>, Self::Error> {
        self.updates.poll()
    }
}
