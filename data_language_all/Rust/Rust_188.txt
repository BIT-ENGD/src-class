pub mod client;
mod messages;
pub mod server;

pub use self::messages::{Response, ServiceId};
use std::error;
use std::fmt;

#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize)]
pub enum Error {
    ConnectionDropped,
    IoError(String),
    ServiceDropped,
    ServiceNotFound,
    ServiceTaken,
    UpdatesTaken,
}

impl fmt::Display for Error {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        match *self {
            Error::IoError(ref description) => {
                write!(fmt, "{}: {}", error::Error::description(self), description)
            }
            _ => write!(fmt, "{}", error::Error::description(self)),
        }
    }
}

impl error::Error for Error {
    fn description(&self) -> &str {
        match *self {
            Error::ConnectionDropped => "connection dropped",
            Error::IoError(_) => "io error",
            Error::ServiceDropped => "service dropped",
            Error::ServiceNotFound => "service not found",
            Error::ServiceTaken => "service taken",
            Error::UpdatesTaken => "updates taken",
        }
    }
}

#[cfg(test)]
pub(crate) mod tests {
    use super::*;
    use futures::{future, unsync, Async, Future, Sink, Stream};
    use never::Never;
    use notify_cell::{NotifyCell, NotifyCellObserver};
    use std::rc::Rc;
    use stream_ext::StreamExt;
    use tokio_core::reactor;

    #[test]
    fn test_connection() {
        let mut reactor = reactor::Core::new().unwrap();
        let model = Rc::new(TestModel::new(42));
        let client_1 = connect(&mut reactor, TestService::new(model.clone()));
        assert_eq!(client_1.state(), Ok(42));

        model.increment_by(2);
        let client_2 = connect(&mut reactor, TestService::new(model.clone()));
        assert_eq!(client_2.state(), Ok(44));

        model.increment_by(4);
        let mut client_1_updates = client_1.updates().unwrap();
        assert_eq!(client_1_updates.wait_next(&mut reactor), Some(44));
        assert_eq!(client_1_updates.wait_next(&mut reactor), Some(48));
        let mut client_2_updates = client_2.updates().unwrap();
        assert_eq!(client_2_updates.wait_next(&mut reactor), Some(48));

        let request_future = client_2.request(TestRequest::Increment(3));
        let response = reactor.run(request_future).unwrap();
        assert_eq!(response, TestServiceResponse::Ack);
        assert_eq!(client_1_updates.wait_next(&mut reactor), Some(51));
        assert_eq!(client_2_updates.wait_next(&mut reactor), Some(51));
    }

    #[test]
    fn test_create_and_drop_service() {
        let mut reactor = reactor::Core::new().unwrap();
        let mut root_model = TestModel::new(42);
        let child_model = Rc::new(TestModel::new(12));
        root_model.child_model = Some(child_model.clone());
        let root_model = Rc::new(root_model);
        let client = connect(&mut reactor, TestService::new(root_model.clone()));
        assert_eq!(Rc::strong_count(&child_model), 2);

        let request_future = client.request(TestRequest::CreateService);
        let response = reactor.run(request_future).unwrap();
        assert_eq!(response, TestServiceResponse::ServiceCreated(1));
        let child_client = client.take_service::<TestService>(1).unwrap();
        let mut child_updates = child_client.updates().unwrap();
        assert_eq!(child_client.state(), Ok(12));
        assert!(client.take_service::<TestService>(1).is_err());
        assert_eq!(Rc::strong_count(&child_model), 3);

        let request_future = client.request(TestRequest::DropService);
        let response = reactor.run(request_future).unwrap();
        assert_eq!(response, TestServiceResponse::Ack);
        assert!(child_client.state().is_ok());
        assert!(
            reactor
                .run(child_client.request(TestRequest::Increment(5)))
                .is_ok()
        );
        assert_eq!(Rc::strong_count(&child_model), 3);

        drop(child_client);
        assert_eq!(child_updates.poll(), Ok(Async::Ready(Some(17))));
        assert_eq!(Rc::strong_count(&child_model), 3);

        drop(child_updates);
        reactor.turn(None); // Send drop message
        reactor.turn(None); // Receive drop message

        assert!(client.take_service::<TestService>(1).is_err());
        assert_eq!(Rc::strong_count(&child_model), 2);
    }

    #[test]
    fn test_creating_service_in_async_response() {
        let mut reactor = reactor::Core::new().unwrap();
        let service = TestService::new(Rc::new(TestModel::new(42)));
        // Throttle connection to ensure both the response *and* the new service are sent together.
        let client = connect_throttled(&mut reactor, service, Some(100));
        let request_future = client.request(TestRequest::CreateServiceAsync);
        let response = reactor.run(request_future).unwrap();
        match response {
            TestServiceResponse::ServiceCreated(id) => {
                client
                    .take_service::<TestService>(id)
                    .expect("Service to exist by the time we receive a response");
            }
            _ => panic!(),
        }
    }

    #[test]
    fn test_add_service_on_init_or_update() {
        struct NoopService {
            init_called: bool,
            services_to_add_on_init: usize,
            services_to_add_on_update: usize,
            child_services: Vec<server::ServiceHandle>,
        }

        impl NoopService {
            fn new(services_to_add_on_init: usize, services_to_add_on_update: usize) -> Self {
                Self {
                    init_called: false,
                    services_to_add_on_init,
                    services_to_add_on_update,
                    child_services: Vec::new(),
                }
            }
        }

        impl server::Service for NoopService {
            type State = ();
            type Update = ();
            type Request = ();
            type Response = ();

            fn init(&mut self, connection: &server::Connection) -> Self::State {
                self.init_called = true;
                while self.services_to_add_on_init != 0 {
                    self.child_services
                        .push(connection.add_service(NoopService::new(0, 0)));
                    self.services_to_add_on_init -= 1;
                }
                ()
            }

            fn poll_update(
                &mut self,
                connection: &server::Connection,
            ) -> Async<Option<Self::Update>> {
                assert!(self.init_called);
                while self.services_to_add_on_update != 0 {
                    self.child_services
                        .push(connection.add_service(NoopService::new(0, 0)));
                    self.services_to_add_on_update -= 1;
                }
                Async::NotReady
            }
        }

        let mut reactor = reactor::Core::new().unwrap();
        let client = connect(&mut reactor, NoopService::new(1, 2));
        assert!(client.take_service::<NoopService>(1).is_ok());
        assert!(client.take_service::<NoopService>(2).is_ok());
        assert!(client.take_service::<NoopService>(3).is_ok());
        assert!(client.take_service::<NoopService>(4).is_err());
    }

    #[test]
    fn test_drop_client_updates() {
        let mut reactor = reactor::Core::new().unwrap();
        let model = Rc::new(TestModel::new(42));
        let root_client = connect(&mut reactor, TestService::new(model.clone()));

        let updates = root_client.updates();
        drop(updates);

        model.increment_by(3);
        reactor.turn(None);
    }

    #[test]
    fn test_interrupting_connection_to_client() {
        let (client_to_server_tx, client_to_server_rx) = unsync::mpsc::unbounded();
        let client_to_server_rx = client_to_server_rx.map_err(|_| unreachable!());
        let model = Rc::new(TestModel::new(42));
        let mut server = server::Connection::new(client_to_server_rx, TestService::new(model));
        drop(client_to_server_tx);
        assert_eq!(server.poll(), Ok(Async::Ready(None)));
    }

    #[test]
    fn test_interrupting_connection_to_server_during_handshake() {
        let mut reactor = reactor::Core::new().unwrap();
        let (server_to_client_tx, server_to_client_rx) = unsync::mpsc::unbounded();
        let server_to_client_rx = server_to_client_rx.map_err(|_| unreachable!());
        drop(server_to_client_tx);
        let client_future = client::Connection::new::<_, TestService>(server_to_client_rx);
        assert!(reactor.run(client_future).is_err());
    }

    #[test]
    fn test_interrupting_connection_to_server_after_handshake() {
        let mut reactor = reactor::Core::new().unwrap();

        let (server_to_client_tx, server_to_client_rx) = unsync::mpsc::unbounded();
        let server_to_client_rx = server_to_client_rx.map_err(|_| unreachable!());
        let (_client_to_server_tx, client_to_server_rx) = unsync::mpsc::unbounded();
        let client_to_server_rx = client_to_server_rx.map_err(|_| unreachable!());

        let model = Rc::new(TestModel::new(42));
        let server = server::Connection::new(client_to_server_rx, TestService::new(model));
        reactor.handle().spawn(
            server_to_client_tx
                .send_all(server.map_err(|_| unreachable!()))
                .then(|_| Ok(())),
        );

        let client_future = client::Connection::new::<_, TestService>(server_to_client_rx);
        let (mut client, _) = reactor.run(client_future).unwrap();

        drop(reactor);
        assert_eq!(client.poll(), Ok(Async::Ready(None)));
    }

    pub fn connect<S: 'static + server::Service>(
        reactor: &mut reactor::Core,
        service: S,
    ) -> client::Service<S> {
        connect_throttled(reactor, service, None)
    }

    fn connect_throttled<S: 'static + server::Service>(
        reactor: &mut reactor::Core,
        service: S,
        delay: Option<u64>,
    ) -> client::Service<S> {
        let (server_to_client_tx, server_to_client_rx) = unsync::mpsc::unbounded();
        let server_to_client_rx = server_to_client_rx.map_err(|_| unreachable!());
        let (client_to_server_tx, client_to_server_rx) = unsync::mpsc::unbounded();
        let client_to_server_rx = client_to_server_rx.map_err(|_| unreachable!());

        let server = if let Some(delay) = delay {
            server::Connection::new(client_to_server_rx.throttle(delay), service)
        } else {
            server::Connection::new(client_to_server_rx, service)
        };
        reactor.handle().spawn(
            server_to_client_tx
                .send_all(server.map_err(|_| unreachable!()))
                .then(|_| Ok(())),
        );

        let client_future = if let Some(delay) = delay {
            client::Connection::new(server_to_client_rx.throttle(delay))
        } else {
            client::Connection::new(server_to_client_rx)
        };
        let (client, service_client) = reactor.run(client_future).unwrap();
        reactor.handle().spawn(
            client_to_server_tx
                .send_all(client.map_err(|_| unreachable!()))
                .then(|_| Ok(())),
        );

        service_client
    }

    #[derive(Clone)]
    struct TestModel {
        cell: NotifyCell<usize>,
        child_model: Option<Rc<TestModel>>,
    }

    struct TestService {
        model: Rc<TestModel>,
        observer: NotifyCellObserver<usize>,
        child_service: Option<server::ServiceHandle>,
    }

    #[derive(Serialize, Deserialize)]
    enum TestRequest {
        Increment(usize),
        CreateService,
        DropService,
        CreateServiceAsync,
    }

    #[derive(Debug, PartialEq, Serialize, Deserialize)]
    enum TestServiceResponse {
        Ack,
        ServiceCreated(ServiceId),
    }

    impl TestService {
        fn new(model: Rc<TestModel>) -> Self {
            let observer = model.cell.observe();
            TestService {
                model,
                observer,
                child_service: None,
            }
        }
    }

    impl server::Service for TestService {
        type State = usize;
        type Update = usize;
        type Request = TestRequest;
        type Response = TestServiceResponse;

        fn init(&mut self, _: &server::Connection) -> Self::State {
            self.model.cell.get()
        }

        fn poll_update(&mut self, _: &server::Connection) -> Async<Option<Self::Update>> {
            self.observer.poll().unwrap()
        }

        fn request(
            &mut self,
            request: Self::Request,
            connection: &server::Connection,
        ) -> Option<Box<Future<Item = Self::Response, Error = Never>>> {
            match request {
                TestRequest::Increment(count) => {
                    self.model.increment_by(count);
                    Some(Box::new(future::ok(TestServiceResponse::Ack)))
                }
                TestRequest::CreateService => {
                    let handle = connection.add_service(TestService::new(
                        self.model.child_model.as_ref().unwrap().clone(),
                    ));
                    let service_id = handle.service_id();
                    self.child_service = Some(handle);
                    Some(Box::new(future::ok(TestServiceResponse::ServiceCreated(
                        service_id,
                    ))))
                }
                TestRequest::DropService => {
                    self.child_service.take();
                    Some(Box::new(future::ok(TestServiceResponse::Ack)))
                }
                TestRequest::CreateServiceAsync => {
                    use futures;
                    use std::thread;

                    let (tx, rx) = futures::sync::oneshot::channel();

                    thread::spawn(|| {
                        tx.send(()).unwrap();
                    });

                    let connection = connection.clone();
                    Some(Box::new(rx.map_err(|_| unreachable!()).and_then(
                        move |_| {
                            let service_handle = connection
                                .add_service(TestService::new(Rc::new(TestModel::new(0))));
                            Ok(TestServiceResponse::ServiceCreated(
                                service_handle.service_id(),
                            ))
                        },
                    )))
                }
            }
        }
    }

    impl TestModel {
        fn new(count: usize) -> Self {
            TestModel {
                cell: NotifyCell::new(count),
                child_model: None,
            }
        }

        fn increment_by(&self, delta: usize) {
            self.cell.set(self.cell.get() + delta);
        }
    }
}
use super::messages::{MessageToClient, MessageToServer, RequestId, Response, ServiceId};
use super::Error;
use bincode::{deserialize, serialize};
use bytes::Bytes;
use futures::stream::FuturesUnordered;
use futures::task::{self, Task};
use futures::{future, Async, Future, Poll, Stream};
use never::Never;
use serde::{Deserialize, Serialize};
use std::cell::RefCell;
use std::collections::{HashMap, HashSet};
use std::io;
use std::mem;
use std::rc::{Rc, Weak};

pub trait Service {
    type State: 'static + Serialize + for<'a> Deserialize<'a>;
    type Update: 'static + Serialize + for<'a> Deserialize<'a>;
    type Request: 'static + Serialize + for<'a> Deserialize<'a>;
    type Response: 'static + Serialize + for<'a> Deserialize<'a>;

    fn init(&mut self, connection: &Connection) -> Self::State;

    fn poll_update(&mut self, _connection: &Connection) -> Async<Option<Self::Update>> {
        Async::NotReady
    }

    fn request(
        &mut self,
        _request: Self::Request,
        _connection: &Connection,
    ) -> Option<Box<Future<Item = Self::Response, Error = Never>>> {
        None
    }
}

trait RawBytesService {
    fn init(&mut self, connection: &mut Connection) -> Bytes;
    fn poll_update(&mut self, connection: &mut Connection) -> Async<Option<Bytes>>;
    fn request(
        &mut self,
        request: Bytes,
        connection: &mut Connection,
    ) -> Option<Box<Future<Item = Bytes, Error = Never>>>;
}

#[derive(Clone)]
pub struct Connection(Rc<RefCell<ConnectionState>>);

struct ConnectionState {
    next_service_id: ServiceId,
    services: HashMap<ServiceId, Rc<RefCell<RawBytesService>>>,
    client_service_handles: HashMap<ServiceId, ServiceHandle>,
    inserted: HashSet<ServiceId>,
    removed: HashSet<ServiceId>,
    incoming: Box<Stream<Item = Bytes, Error = io::Error>>,
    pending_responses:
        Rc<RefCell<FuturesUnordered<Box<Future<Item = ResponseEnvelope, Error = Never>>>>>,
    pending_task: Option<Task>,
}

struct ServiceRegistration {
    pub service_id: ServiceId,
    connection: Weak<RefCell<ConnectionState>>,
}

#[derive(Clone)]
pub struct ServiceHandle(Rc<ServiceRegistration>);

struct ResponseEnvelope {
    service_id: ServiceId,
    request_id: RequestId,
    response: Response,
}

impl Connection {
    pub fn new<S, T>(incoming: S, root_service: T) -> Self
    where
        S: 'static + Stream<Item = Bytes, Error = io::Error>,
        T: 'static + Service,
    {
        let connection = Connection(Rc::new(RefCell::new(ConnectionState {
            next_service_id: 0,
            services: HashMap::new(),
            client_service_handles: HashMap::new(),
            inserted: HashSet::new(),
            removed: HashSet::new(),
            incoming: Box::new(incoming),
            pending_responses: Rc::new(RefCell::new(FuturesUnordered::new())),
            pending_task: None,
        })));
        connection.add_service(root_service);
        connection
    }

    pub fn add_service<T: 'static + Service>(&self, service: T) -> ServiceHandle {
        let mut state = self.0.borrow_mut();

        let service_id = state.next_service_id;
        state.next_service_id += 1;
        let service = Rc::new(RefCell::new(service));
        state.services.insert(service_id, service);
        state.inserted.insert(service_id);

        let handle = ServiceHandle(Rc::new(ServiceRegistration {
            connection: Rc::downgrade(&self.0),
            service_id,
        }));

        state
            .client_service_handles
            .insert(service_id, handle.clone());

        handle
    }

    fn poll_incoming(&mut self) -> Result<bool, io::Error> {
        loop {
            let poll = self.0.borrow_mut().incoming.poll();
            match poll {
                Ok(Async::Ready(Some(request))) => match deserialize(&request).unwrap() {
                    MessageToServer::Request {
                        request_id,
                        service_id,
                        payload,
                    } => {
                        let pending_responses = self.0.borrow().pending_responses.clone();

                        if let Some(service) = self.take_service(service_id) {
                            if let Some(response) = service.borrow_mut().request(payload, self) {
                                pending_responses.borrow_mut().push(Box::new(response.map(
                                    move |response| ResponseEnvelope {
                                        request_id,
                                        service_id,
                                        response: Ok(response),
                                    },
                                )));
                            }
                        } else {
                            pending_responses.borrow_mut().push(Box::new(future::ok(
                                ResponseEnvelope {
                                    request_id,
                                    service_id,
                                    response: Err(Error::ServiceNotFound),
                                },
                            )));
                        }
                    }
                    MessageToServer::DroppedService(service_id) => {
                        let service_handle = {
                            let mut state = self.0.borrow_mut();
                            state.client_service_handles.remove(&service_id)
                        };

                        if service_handle.is_none() {
                            eprintln!("Dropping unknown service with id {}", service_id);
                        }
                    }
                },
                Ok(Async::Ready(None)) => return Ok(false),
                Ok(Async::NotReady) => return Ok(true),
                Err(error) => {
                    eprintln!("Error polling incoming connection: {}", error);
                    return Err(error);
                }
            }
        }
    }

    fn poll_outgoing(&mut self) -> Poll<Option<Bytes>, ()> {
        let pending_responses = self.0.borrow_mut().pending_responses.clone();
        let mut responses = HashMap::new();
        loop {
            match pending_responses.borrow_mut().poll() {
                Ok(Async::Ready(Some(envelope))) => {
                    responses
                        .entry(envelope.service_id)
                        .or_insert(Vec::new())
                        .push((envelope.request_id, envelope.response));
                }
                Ok(Async::Ready(None)) | Ok(Async::NotReady) => break,
                Err(_) => unreachable!(),
            }
        }

        let existing_service_ids = {
            let state = self.0.borrow();
            state
                .services
                .keys()
                .cloned()
                .filter(|id| !state.inserted.contains(id))
                .collect::<Vec<ServiceId>>()
        };

        let mut updates: HashMap<ServiceId, Vec<Bytes>> = HashMap::new();
        for id in existing_service_ids {
            if let Some(service) = self.take_service(id) {
                while let Async::Ready(Some(update)) = service.borrow_mut().poll_update(self) {
                    updates.entry(id).or_insert(Vec::new()).push(update);
                }
            }
        }

        let mut insertions = HashMap::new();
        while self.0.borrow().inserted.len() > 0 {
            let inserted = mem::replace(&mut self.0.borrow_mut().inserted, HashSet::new());
            for id in inserted {
                if let Some(service) = self.take_service(id) {
                    let mut service = service.borrow_mut();
                    insertions.insert(id, service.init(self));
                    while let Async::Ready(Some(update)) = service.poll_update(self) {
                        updates.entry(id).or_insert(Vec::new()).push(update);
                    }
                }
            }
        }

        let mut removals = HashSet::new();
        mem::swap(&mut removals, &mut self.0.borrow_mut().removed);

        if insertions.len() > 0 || updates.len() > 0 || removals.len() > 0 || responses.len() > 0 {
            let message =
                serialize::<Result<MessageToClient, Error>>(&Ok(MessageToClient::Update {
                    insertions,
                    updates,
                    removals,
                    responses,
                })).unwrap()
                    .into();
            Ok(Async::Ready(Some(message)))
        } else {
            self.0.borrow_mut().pending_task = Some(task::current());
            Ok(Async::NotReady)
        }
    }

    fn take_service(&self, id: ServiceId) -> Option<Rc<RefCell<RawBytesService>>> {
        self.0.borrow_mut().services.get(&id).cloned()
    }
}

impl Stream for Connection {
    type Item = Bytes;
    type Error = ();

    fn poll(&mut self) -> Poll<Option<Self::Item>, Self::Error> {
        match self.poll_incoming() {
            Ok(true) => {}
            Ok(false) => return Ok(Async::Ready(None)),
            Err(error) => {
                let message = serialize::<Result<MessageToClient, Error>>(&Err(Error::IoError(
                    format!("{}", error),
                ))).unwrap();
                return Ok(Async::Ready(Some(message.into())));
            }
        }

        self.poll_outgoing()
    }
}

impl ServiceHandle {
    pub fn service_id(&self) -> ServiceId {
        self.0.service_id
    }
}

impl Drop for ServiceRegistration {
    fn drop(&mut self) {
        if let Some(connection) = self.connection.upgrade() {
            let mut connection = connection.borrow_mut();
            connection.services.remove(&self.service_id);
            connection.removed.insert(self.service_id);
            connection.pending_task.as_ref().map(|task| task.notify());
        }
    }
}

impl<T> RawBytesService for T
where
    T: Service,
{
    fn init(&mut self, connection: &mut Connection) -> Bytes {
        serialize(&T::init(self, connection)).unwrap().into()
    }

    fn poll_update(&mut self, connection: &mut Connection) -> Async<Option<Bytes>> {
        T::poll_update(self, connection)
            .map(|option| option.map(|update| serialize(&update).unwrap().into()))
    }

    fn request(
        &mut self,
        request: Bytes,
        connection: &mut Connection,
    ) -> Option<Box<Future<Item = Bytes, Error = Never>>> {
        T::request(self, deserialize(&request).unwrap(), connection).map(|future| {
            Box::new(future.map(|item| serialize(&item).unwrap().into()))
                as Box<Future<Item = Bytes, Error = Never>>
        })
    }
}
