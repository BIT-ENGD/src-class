/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

use net::subresource_integrity::{SriEntry, get_prioritized_hash_function, get_strongest_metadata};
use net::subresource_integrity::{is_response_integrity_valid, parsed_metadata};
use net_traits::response::{Response, ResponseBody};
use servo_url::ServoUrl;

#[test]
fn test_get_prioritized_hash_function() {
    let mut algorithm = get_prioritized_hash_function("sha256", "sha256");
    assert_eq!(algorithm, None);

    algorithm = get_prioritized_hash_function("sha256", "sha384");
    assert_eq!(algorithm.unwrap(), "sha384");

    algorithm = get_prioritized_hash_function("sha384", "sha512");
    assert_eq!(algorithm.unwrap(), "sha512");
}

#[test]
fn test_parsed_metadata_without_options() {
    let integrity_metadata = "sha384-Hash1";
    let ref parsed_metadata: SriEntry = parsed_metadata(integrity_metadata)[0];

    assert_eq!(parsed_metadata.alg, "sha384");
    assert_eq!(parsed_metadata.val, "Hash1");
    assert!(parsed_metadata.opt.is_none());
}

#[test]
fn test_parsed_metadata_with_options() {
    let integrity_metadata = "sha384-Hash1?opt=23";
    let ref parsed_metadata: SriEntry = parsed_metadata(integrity_metadata)[0];

    assert_eq!(parsed_metadata.alg, "sha384");
    assert_eq!(parsed_metadata.val, "Hash1");
    assert!(parsed_metadata.opt.is_some());
}

#[test]
fn test_parsed_metadata_with_malformed_integrity() {
    let integrity_metadata = "Not a valid integrity";
    let ref parsed_metadata_list: Vec<SriEntry> = parsed_metadata(integrity_metadata);

    assert!(parsed_metadata_list.is_empty());
}

#[test]
fn test_get_strongest_metadata_two_same_algorithm() {
    let integrity_metadata = "sha512-Hash1 sha512-Hash2?opt=23";
    let parsed_metadata_list: Vec<SriEntry> = parsed_metadata(integrity_metadata);

    let strong_metadata: Vec<SriEntry> = get_strongest_metadata(parsed_metadata_list);
    assert_eq!(strong_metadata.len(), 2);
    assert_eq!(strong_metadata[0].alg, strong_metadata[1].alg);
}

#[test]
fn test_get_strongest_metadata_different_algorithm() {
    let integrity_metadata = "sha256-Hash0 sha384-Hash1 sha512-Hash2?opt=23";
    let parsed_metadata_list: Vec<SriEntry> = parsed_metadata(integrity_metadata);

    let strong_metadata: Vec<SriEntry> = get_strongest_metadata(parsed_metadata_list);
    assert_eq!(strong_metadata.len(), 1);
    assert_eq!(strong_metadata[0].alg, "sha512");
}

#[test]
fn test_response_integrity_valid() {
    let url: ServoUrl = ServoUrl::parse("http://servo.org").unwrap();
    let response: Response = Response::new(url);

    let integrity_metadata = "sha384-H8BRh8j48O9oYatfu5AZzq6A9RINhZO5H16dQZngK7T62em8MUt1FLm52t+eX6xO";
    let response_body = "alert('Hello, world.');".to_owned().into_bytes();

    *response.body.lock().unwrap() = ResponseBody::Done(response_body);
    assert!(is_response_integrity_valid(integrity_metadata, &response));
}

#[test]
fn test_response_integrity_invalid() {
    let url: ServoUrl = ServoUrl::parse("http://servo.org").unwrap();
    let response: Response = Response::new(url);

    let integrity_metadata = "sha256-H8BRh8j48O9oYatfu5AZzq6A9RINhZO5H16dQZngK7T62em8MUt1FLm52t+eX6xO";
    let response_body = "alert('Hello, world.');".to_owned().into_bytes();

    *response.body.lock().unwrap() = ResponseBody::Done(response_body);
    assert!(!is_response_integrity_valid(integrity_metadata, &response));
}
/*!
This module benchmarks the glob implementation. For benchmarks on the ripgrep
tool itself, see the benchsuite directory.
*/
#![feature(test)]

extern crate glob;
extern crate globset;
#[macro_use]
extern crate lazy_static;
extern crate regex;
extern crate test;

use std::ffi::OsStr;
use std::path::Path;

use globset::{Candidate, Glob, GlobMatcher, GlobSet, GlobSetBuilder};

const EXT: &'static str = "some/a/bigger/path/to/the/crazy/needle.txt";
const EXT_PAT: &'static str = "*.txt";

const SHORT: &'static str = "some/needle.txt";
const SHORT_PAT: &'static str = "some/**/needle.txt";

const LONG: &'static str = "some/a/bigger/path/to/the/crazy/needle.txt";
const LONG_PAT: &'static str = "some/**/needle.txt";

fn new_glob(pat: &str) -> glob::Pattern {
    glob::Pattern::new(pat).unwrap()
}

fn new_reglob(pat: &str) -> GlobMatcher {
    Glob::new(pat).unwrap().compile_matcher()
}

fn new_reglob_many(pats: &[&str]) -> GlobSet {
    let mut builder = GlobSetBuilder::new();
    for pat in pats {
        builder.add(Glob::new(pat).unwrap());
    }
    builder.build().unwrap()
}

#[bench]
fn ext_glob(b: &mut test::Bencher) {
    let pat = new_glob(EXT_PAT);
    b.iter(|| assert!(pat.matches(EXT)));
}

#[bench]
fn ext_regex(b: &mut test::Bencher) {
    let set = new_reglob(EXT_PAT);
    let cand = Candidate::new(EXT);
    b.iter(|| assert!(set.is_match_candidate(&cand)));
}

#[bench]
fn short_glob(b: &mut test::Bencher) {
    let pat = new_glob(SHORT_PAT);
    b.iter(|| assert!(pat.matches(SHORT)));
}

#[bench]
fn short_regex(b: &mut test::Bencher) {
    let set = new_reglob(SHORT_PAT);
    let cand = Candidate::new(SHORT);
    b.iter(|| assert!(set.is_match_candidate(&cand)));
}

#[bench]
fn long_glob(b: &mut test::Bencher) {
    let pat = new_glob(LONG_PAT);
    b.iter(|| assert!(pat.matches(LONG)));
}

#[bench]
fn long_regex(b: &mut test::Bencher) {
    let set = new_reglob(LONG_PAT);
    let cand = Candidate::new(LONG);
    b.iter(|| assert!(set.is_match_candidate(&cand)));
}

const MANY_SHORT_GLOBS: &'static [&'static str] = &[
    // Taken from a random .gitignore on my system.
    ".*.swp",
    "tags",
    "target",
    "*.lock",
    "tmp",
    "*.csv",
    "*.fst",
    "*-got",
    "*.csv.idx",
    "words",
    "98m*",
    "dict",
    "test",
    "months",
];

const MANY_SHORT_SEARCH: &'static str = "98m-blah.csv.idx";

#[bench]
fn many_short_glob(b: &mut test::Bencher) {
    let pats: Vec<_> = MANY_SHORT_GLOBS.iter().map(|&s| new_glob(s)).collect();
    b.iter(|| {
        let mut count = 0;
        for pat in &pats {
            if pat.matches(MANY_SHORT_SEARCH) {
                count += 1;
            }
        }
        assert_eq!(2, count);
    })
}

#[bench]
fn many_short_regex_set(b: &mut test::Bencher) {
    let set = new_reglob_many(MANY_SHORT_GLOBS);
    b.iter(|| assert_eq!(2, set.matches(MANY_SHORT_SEARCH).iter().count()));
}
