use buffer::BufferSnapshot;
use cross_platform;
use futures::{Async, Future, Stream};
use notify_cell::NotifyCell;
use parking_lot::RwLock;
use rpc::{client, server};
use serde::{Deserialize, Deserializer, Serialize, Serializer};
#[cfg(test)]
use serde_json;
use std::cell::RefCell;
use std::io;
use std::iter::Iterator;
use std::rc::Rc;
use std::sync::Arc;
use ForegroundExecutor;

pub type EntryId = usize;
pub type FileId = u64;

pub trait Tree {
    fn root(&self) -> Entry;
    fn updates(&self) -> Box<Stream<Item = (), Error = ()>>;
}

pub trait LocalTree: Tree {
    fn path(&self) -> &cross_platform::Path;
    fn populated(&self) -> Box<Future<Item = (), Error = ()>>;
    fn as_tree(&self) -> &Tree;
}

pub trait FileProvider {
    fn open(&self, path: &cross_platform::Path)
        -> Box<Future<Item = Box<File>, Error = io::Error>>;
}

pub trait File {
    fn id(&self) -> FileId;
    fn read(&self) -> Box<Future<Item = String, Error = io::Error>>;
    fn write_snapshot(&self, snapshot: BufferSnapshot)
        -> Box<Future<Item = (), Error = io::Error>>;
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub enum Entry {
    #[serde(serialize_with = "serialize_dir", deserialize_with = "deserialize_dir")]
    Dir(Arc<DirInner>),
    #[serde(serialize_with = "serialize_file", deserialize_with = "deserialize_file")]
    File(Arc<FileInner>),
}

#[derive(Debug, Serialize, Deserialize)]
pub struct DirInner {
    name: cross_platform::PathComponent,
    #[serde(skip_serializing, skip_deserializing)]
    name_chars: Vec<char>,
    #[serde(serialize_with = "serialize_dir_children")]
    #[serde(deserialize_with = "deserialize_dir_children")]
    children: RwLock<Arc<Vec<Entry>>>,
    symlink: bool,
    ignored: bool,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct FileInner {
    name: cross_platform::PathComponent,
    #[serde(skip_serializing, skip_deserializing)]
    name_chars: Vec<char>,
    symlink: bool,
    ignored: bool,
}

pub struct TreeService {
    tree: Rc<LocalTree>,
    populated: Option<Box<Future<Item = (), Error = ()>>>,
}

pub struct RemoteTree(Rc<RefCell<RemoteTreeState>>);

struct RemoteTreeState {
    root: Entry,
    _service: client::Service<TreeService>,
    updates: NotifyCell<()>,
}

impl Entry {
    pub fn file(name: cross_platform::PathComponent, symlink: bool, ignored: bool) -> Self {
        Entry::File(Arc::new(FileInner {
            name_chars: name.to_string_lossy().chars().collect(),
            name,
            symlink,
            ignored,
        }))
    }

    pub fn dir(name: cross_platform::PathComponent, symlink: bool, ignored: bool) -> Self {
        let mut name_chars: Vec<char> = name.to_string_lossy().chars().collect();
        name_chars.push('/');
        Entry::Dir(Arc::new(DirInner {
            name_chars,
            name,
            children: RwLock::new(Arc::new(Vec::new())),
            symlink,
            ignored,
        }))
    }

    pub fn is_dir(&self) -> bool {
        match self {
            &Entry::Dir(_) => true,
            &Entry::File(_) => false,
        }
    }

    pub fn id(&self) -> EntryId {
        match self {
            &Entry::Dir(ref inner) => inner.as_ref() as *const DirInner as EntryId,
            &Entry::File(ref inner) => inner.as_ref() as *const FileInner as EntryId,
        }
    }

    pub fn name(&self) -> &cross_platform::PathComponent {
        match self {
            &Entry::Dir(ref inner) => &inner.name,
            &Entry::File(ref inner) => &inner.name,
        }
    }

    pub fn name_chars(&self) -> &[char] {
        match self {
            &Entry::Dir(ref inner) => &inner.name_chars,
            &Entry::File(ref inner) => &inner.name_chars,
        }
    }

    pub fn is_symlink(&self) -> bool {
        match self {
            &Entry::Dir(ref inner) => inner.symlink,
            &Entry::File(ref inner) => inner.symlink,
        }
    }

    pub fn is_ignored(&self) -> bool {
        match self {
            &Entry::Dir(ref inner) => inner.ignored,
            &Entry::File(ref inner) => inner.ignored,
        }
    }

    pub fn children(&self) -> Option<Arc<Vec<Entry>>> {
        match self {
            &Entry::Dir(ref inner) => Some(inner.children.read().clone()),
            &Entry::File(..) => None,
        }
    }

    pub fn insert(&self, new_entry: Entry) -> Result<(), ()> {
        match self {
            &Entry::Dir(ref inner) => {
                let mut children = inner.children.write();
                let children = Arc::make_mut(&mut children);
                if children
                    .last()
                    .map(|child| child.name() < new_entry.name())
                    .unwrap_or(true)
                {
                    children.push(new_entry);
                    Ok(())
                } else {
                    let index = {
                        let new_name = new_entry.name();
                        match children.binary_search_by(|child| child.name().cmp(new_name)) {
                            Ok(_) => return Err(()), // An entry already exists with this name
                            Err(index) => index,
                        }
                    };
                    children.insert(index, new_entry);
                    Ok(())
                }
            }
            &Entry::File(_) => Err(()),
        }
    }
}

fn serialize_dir<S: Serializer>(dir: &Arc<DirInner>, serializer: S) -> Result<S::Ok, S::Error> {
    dir.serialize(serializer)
}

fn deserialize_dir<'de, D: Deserializer<'de>>(deserializer: D) -> Result<Arc<DirInner>, D::Error> {
    let mut inner = DirInner::deserialize(deserializer)?;

    let mut name_chars: Vec<char> = inner.name.to_string_lossy().chars().collect();
    name_chars.push('/');
    inner.name_chars = name_chars;

    Ok(Arc::new(inner))
}

fn serialize_file<S: Serializer>(file: &Arc<FileInner>, serializer: S) -> Result<S::Ok, S::Error> {
    file.serialize(serializer)
}

fn deserialize_file<'de, D: Deserializer<'de>>(
    deserializer: D,
) -> Result<Arc<FileInner>, D::Error> {
    let mut inner = FileInner::deserialize(deserializer)?;
    inner.name_chars = inner.name.to_string_lossy().chars().collect();
    Ok(Arc::new(inner))
}

fn serialize_dir_children<S: Serializer>(
    children: &RwLock<Arc<Vec<Entry>>>,
    serializer: S,
) -> Result<S::Ok, S::Error> {
    children.read().serialize(serializer)
}

fn deserialize_dir_children<'de, D: Deserializer<'de>>(
    deserializer: D,
) -> Result<RwLock<Arc<Vec<Entry>>>, D::Error> {
    Ok(RwLock::new(Arc::new(Vec::deserialize(deserializer)?)))
}

impl TreeService {
    pub fn new(tree: Rc<LocalTree>) -> Self {
        let populated = Some(tree.populated());
        Self { tree, populated }
    }
}

impl server::Service for TreeService {
    type State = Entry;
    type Update = Entry;
    type Request = ();
    type Response = ();

    fn init(&mut self, connection: &server::Connection) -> Self::State {
        if let Async::Ready(Some(tree)) = self.poll_update(connection) {
            tree
        } else {
            let root = self.tree.root();
            Entry::dir(root.name().to_owned(), root.is_symlink(), root.is_ignored())
        }
    }

    fn poll_update(&mut self, _: &server::Connection) -> Async<Option<Self::Update>> {
        if let Some(populated) = self.populated.as_mut().map(|p| p.poll().unwrap()) {
            if let Async::Ready(_) = populated {
                self.populated.take();
                Async::Ready(Some(self.tree.root().clone()))
            } else {
                Async::NotReady
            }
        } else {
            Async::NotReady
        }
    }
}

impl RemoteTree {
    pub fn new(foreground: ForegroundExecutor, service: client::Service<TreeService>) -> Self {
        let updates = service.updates().unwrap();
        let state = Rc::new(RefCell::new(RemoteTreeState {
            root: service.state().unwrap(),
            _service: service,
            updates: NotifyCell::new(()),
        }));

        let state_clone = state.clone();
        foreground
            .execute(Box::new(updates.for_each(move |root| {
                let mut state = state_clone.borrow_mut();
                state.root = root;
                state.updates.set(());
                Ok(())
            })))
            .unwrap();

        RemoteTree(state)
    }
}

impl Tree for RemoteTree {
    fn root(&self) -> Entry {
        self.0.borrow().root.clone()
    }

    fn updates(&self) -> Box<Stream<Item = (), Error = ()>> {
        Box::new(self.0.borrow().updates.observe())
    }
}

#[cfg(test)]
pub(crate) mod tests {
    use super::*;
    use bincode::{deserialize, serialize};
    use cross_platform::PathComponent;
    use futures::{future, task, Async, IntoFuture, Poll};
    use never::Never;
    use notify_cell::NotifyCell;
    use rpc;
    use std::collections::HashMap;
    use std::ffi::OsString;
    use std::path::PathBuf;
    use stream_ext::StreamExt;
    use tokio_core::reactor;

    #[test]
    fn test_insert() {
        let root = Entry::dir(PathComponent::from("root"), false, false);
        assert_eq!(
            root.insert(Entry::file(PathComponent::from("a"), false, false)),
            Ok(())
        );
        assert_eq!(
            root.insert(Entry::file(PathComponent::from("c"), false, false)),
            Ok(())
        );
        assert_eq!(
            root.insert(Entry::file(PathComponent::from("b"), false, false)),
            Ok(())
        );
        assert_eq!(
            root.insert(Entry::file(PathComponent::from("a"), false, false)),
            Err(())
        );
        assert_eq!(root.child_names(), vec!["a", "b", "c"]);
    }

    #[test]
    fn test_serialize_deserialize() {
        let root = Entry::from_json(
            "root",
            &json!({
                "child-1": {
                    "subchild-1-1": null
                },
                "child-2": null,
                "child-3": {
                    "subchild-3-1": {
                        "subchild-3-1-1": null,
                        "subchild-3-1-2": null,
                    }
                }
            }),
        );
        assert_eq!(
            deserialize::<Entry>(&serialize(&root).unwrap()).unwrap(),
            root
        );
    }

    #[test]
    fn test_tree_replication() {
        let mut reactor = reactor::Core::new().unwrap();
        let handle = Rc::new(reactor.handle());

        let local_tree = Rc::new(TestTree::new(
            "/foo/bar",
            Entry::from_json(
                "root",
                &json!({
                    "child-1": {
                        "subchild": null
                    },
                    "child-2": null,
                }),
            ),
        ));
        let remote_tree = RemoteTree::new(
            handle,
            rpc::tests::connect(&mut reactor, TreeService::new(local_tree.clone())),
        );
        assert_eq!(remote_tree.root().name(), local_tree.root().name());
        assert_eq!(remote_tree.root().children().unwrap().len(), 0);

        let mut remote_tree_updates = remote_tree.updates();
        local_tree.populated.set(true);
        remote_tree_updates.wait_next(&mut reactor);
        assert_eq!(remote_tree.root(), local_tree.root());
    }

    pub struct TestTree {
        path: cross_platform::Path,
        root: Entry,
        pub populated: NotifyCell<bool>,
    }

    pub struct TestFileProvider(Rc<RefCell<TestFileProviderState>>);

    struct TestFileProviderState {
        next_file_id: FileId,
        files: HashMap<PathBuf, TestFile>,
    }

    #[derive(Clone)]
    struct TestFile(Rc<RefCell<TestFileState>>);

    struct TestFileState {
        id: FileId,
        content: String,
    }

    struct NextTick(bool);

    impl TestTree {
        pub fn new<T: Into<OsString>>(path: T, root: Entry) -> Self {
            Self {
                path: cross_platform::Path::from(path.into()),
                root,
                populated: NotifyCell::new(false),
            }
        }

        pub fn from_json<T: Into<PathBuf>>(path: T, json: serde_json::Value) -> Self {
            let path = path.into();
            let root = Entry::from_json(PathComponent::from(path.file_name().unwrap()), &json);
            Self::new(path, root)
        }
    }

    impl Tree for TestTree {
        fn root(&self) -> Entry {
            self.root.clone()
        }

        fn updates(&self) -> Box<Stream<Item = (), Error = ()>> {
            unimplemented!()
        }
    }

    impl LocalTree for TestTree {
        fn path(&self) -> &cross_platform::Path {
            &self.path
        }

        fn populated(&self) -> Box<Future<Item = (), Error = ()>> {
            if self.populated.get() {
                Box::new(future::ok(()))
            } else {
                Box::new(
                    self.populated
                        .observe()
                        .skip_while(|p| Ok(!p))
                        .into_future()
                        .then(|_| Ok(())),
                )
            }
        }

        fn as_tree(&self) -> &Tree {
            self
        }
    }

    impl Entry {
        fn from_json<T: Into<PathComponent>>(name: T, json: &serde_json::Value) -> Self {
            if json.is_object() {
                let object = json.as_object().unwrap();
                let dir = Entry::dir(name.into(), false, false);
                for (key, value) in object {
                    let child_entry = Self::from_json(key.as_str(), value);
                    assert_eq!(dir.insert(child_entry), Ok(()));
                }
                dir
            } else {
                Entry::file(name.into(), false, false)
            }
        }

        fn child_names(&self) -> Vec<String> {
            match self {
                &Entry::Dir(ref inner) => inner
                    .children
                    .read()
                    .iter()
                    .map(|ref entry| entry.name().to_string_lossy().into_owned())
                    .collect(),
                _ => panic!(),
            }
        }
    }

    impl PartialEq for Entry {
        fn eq(&self, other: &Self) -> bool {
            self.name() == other.name() && self.name_chars() == other.name_chars()
                && self.is_dir() == other.is_dir()
                && self.is_ignored() == other.is_ignored()
                && self.children() == other.children()
        }
    }

    impl TestFileProvider {
        pub fn new() -> Self {
            TestFileProvider(Rc::new(RefCell::new(TestFileProviderState {
                next_file_id: 0,
                files: HashMap::new(),
            })))
        }

        pub fn write_sync<S: Into<String>>(&self, path: cross_platform::Path, content: S) {
            let mut state = self.0.borrow_mut();

            let file_id = state.next_file_id;
            state.next_file_id += 1;

            state.files.insert(
                path.to_path_buf(),
                TestFile(Rc::new(RefCell::new(TestFileState {
                    id: file_id,
                    content: content.into(),
                }))),
            );
        }
    }

    impl FileProvider for TestFileProvider {
        fn open(
            &self,
            path: &cross_platform::Path,
        ) -> Box<Future<Item = Box<File>, Error = io::Error>> {
            let path = path.to_path_buf();
            let state = self.0.clone();
            Box::new(NextTick::new().then(move |_| {
                let state = state.borrow();
                state
                    .files
                    .get(&path)
                    .map(|file| Box::new(file.clone()) as Box<File>)
                    .ok_or(io::Error::new(io::ErrorKind::NotFound, "Path not found"))
                    .into_future()
            }))
        }
    }

    impl File for TestFile {
        fn id(&self) -> FileId {
            self.0.borrow().id
        }

        fn read(&self) -> Box<Future<Item = String, Error = io::Error>> {
            let file = self.0.clone();
            Box::new(NextTick::new().then(move |_| {
                let file = file.borrow();
                future::ok(file.content.clone())
            }))
        }

        fn write_snapshot(
            &self,
            snapshot: BufferSnapshot,
        ) -> Box<Future<Item = (), Error = io::Error>> {
            let file = self.0.clone();
            Box::new(NextTick::new().then(move |_| {
                let mut file = file.borrow_mut();
                file.content = snapshot.to_string();
                future::ok(())
            }))
        }
    }

    impl NextTick {
        fn new() -> Self {
            NextTick(false)
        }
    }

    impl Future for NextTick {
        type Item = ();
        type Error = Never;

        fn poll(&mut self) -> Poll<Self::Item, Self::Error> {
            if self.0 {
                Ok(Async::Ready(()))
            } else {
                self.0 = true;
                task::current().notify();
                Ok(Async::NotReady)
            }
        }
    }
}
use std::f64;
use std::fmt;
use std::ops::{Index, IndexMut};

pub type Score = f64;

pub const SCORE_MIN: Score = f64::NEG_INFINITY;
const SCORE_GAP_LEADING: Score = -0.005;
const SCORE_GAP_TRAILING: Score = -0.005;
const SCORE_GAP_INNER: Score = -0.01;
const SCORE_MATCH_CONSECUTIVE: Score = 1.0;
const SCORE_MATCH_SLASH: Score = 0.9;
const SCORE_MATCH_WORD: Score = 0.8;
const SCORE_MATCH_CAPITAL: Score = 0.7;
const SCORE_MATCH_DOT: Score = 0.6;

pub struct Matcher<'a> {
    needle: &'a [char],
    stack: Vec<usize>,
}

pub struct Scorer<'a> {
    needle: &'a [char],
    d: Matrix<Score>,
    m: Matrix<Score>,
    bonus_cache: Vec<Score>,
    stack: Vec<usize>,
}

struct Matrix<T> {
    rows: usize,
    cols: usize,
    buffer: Vec<T>,
}

impl<'a> Matcher<'a> {
    pub fn new(needle: &'a [char]) -> Self {
        Self {
            needle,
            stack: Vec::new(),
        }
    }

    pub fn push(&mut self, component: &[char]) -> bool {
        if self.needle.is_empty() {
            true
        } else {
            let mut needle_index = self.stack.last().cloned().unwrap_or(0);
            for ch in component {
                if self.needle[needle_index].eq_ignore_ascii_case(ch) {
                    needle_index += 1;
                    if needle_index == self.needle.len() {
                        self.stack.push(needle_index);
                        return true;
                    }
                }
            }
            self.stack.push(needle_index);
            false
        }
    }

    pub fn pop(&mut self) {
        self.stack.pop();
    }
}

impl<'a> Scorer<'a> {
    pub fn new(needle: &'a [char]) -> Self {
        Self {
            d: Matrix::new(needle.len(), 0),
            m: Matrix::new(needle.len(), 0),
            needle,
            bonus_cache: Vec::new(),
            stack: Vec::new(),
        }
    }

    pub fn push(&mut self, component: &[char], positions: Option<&mut [usize]>) -> Score {
        let component_len = component.len();
        let haystack_start = self.m.cols;
        let haystack_len = haystack_start + component_len;
        let needle_len = self.needle.len();

        self.stack.push(component_len);
        self.precompute_bonus(component);
        self.d.add_columns(component_len);
        self.m.add_columns(component_len);

        for i in 0..needle_len {
            let mut prev_score = if haystack_start > 0 {
                self.m[(i, haystack_start - 1)]
            } else {
                SCORE_MIN
            };
            let gap_score = if i == needle_len - 1 {
                SCORE_GAP_TRAILING
            } else {
                SCORE_GAP_INNER
            };

            for j in haystack_start..haystack_len {
                let needle_ch = self.needle[i];
                let haystack_ch = component[j - haystack_start];

                if needle_ch.eq_ignore_ascii_case(&haystack_ch) {
                    let score;
                    if i == 0 {
                        score =
                            (j as Score * SCORE_GAP_LEADING) + self.bonus_cache[j - haystack_start];
                    } else if j > 0 {
                        let score_1 = self.m[(i - 1, j - 1)] + self.bonus_cache[j - haystack_start];
                        let score_2 = self.d[(i - 1, j - 1)] + SCORE_MATCH_CONSECUTIVE;
                        score = score_1.max(score_2);
                    } else {
                        score = SCORE_MIN;
                    }

                    self.d[(i, j)] = score;
                    let best_score = score.max(prev_score + gap_score);
                    self.m[(i, j)] = best_score;
                    prev_score = best_score;
                } else {
                    self.d[(i, j)] = SCORE_MIN;
                    let best_score = prev_score + gap_score;
                    self.m[(i, j)] = best_score;
                    prev_score = best_score;
                }
            }
        }

        positions.map(|positions| {
            let mut match_required = false;
            let mut j = (haystack_len - 1) as isize;
            for i in (0..needle_len).rev() {
                while j >= 0 {
                    if self.d[(i, j)] != SCORE_MIN
                        && (match_required || self.d[(i, j)] == self.m[(i, j)])
                    {
                        match_required = i > 0 && j > 0
                            && self.m[(i, j)] == self.d[(i - 1, j - 1)] + SCORE_MATCH_CONSECUTIVE;
                        positions[i] = j as usize;
                        j -= 1;
                        break;
                    }

                    j -= 1;
                }
            }
        });

        self.m[(needle_len - 1, haystack_len - 1)]
    }

    pub fn pop(&mut self) {
        let component_len = self.stack.pop().unwrap();
        self.d.remove_columns(component_len);
        self.m.remove_columns(component_len);
    }

    fn precompute_bonus(&mut self, component: &[char]) {
        self.bonus_cache.truncate(0);
        let mut last_ch = '/';
        for ch in component {
            self.bonus_cache.push(compute_bonus(last_ch, *ch));
            last_ch = *ch;
        }
    }
}

impl<T: Clone + Default> Matrix<T> {
    pub fn new(rows: usize, cols: usize) -> Self {
        Self {
            rows,
            cols,
            buffer: Vec::with_capacity(rows * cols),
        }
    }

    fn add_columns(&mut self, additional: usize) {
        let prev_len = self.buffer.len();
        self.buffer
            .resize(prev_len + (self.rows * additional), T::default());
        self.cols += additional;
    }

    fn remove_columns(&mut self, exceeding: usize) {
        let prev_len = self.buffer.len();
        self.buffer.truncate(prev_len - (self.rows * exceeding));
        self.cols -= exceeding;
    }
}

impl<T> Index<(usize, usize)> for Matrix<T> {
    type Output = T;

    fn index(&self, (row, col): (usize, usize)) -> &Self::Output {
        &self.buffer[(col * self.rows) + row]
    }
}

impl<T> Index<(usize, isize)> for Matrix<T> {
    type Output = T;

    fn index(&self, (row, col): (usize, isize)) -> &Self::Output {
        debug_assert!(col >= 0);
        &self.buffer[(col as usize * self.rows) + row]
    }
}

impl<T: Default> IndexMut<(usize, usize)> for Matrix<T> {
    fn index_mut(&mut self, (row, col): (usize, usize)) -> &mut Self::Output {
        &mut self.buffer[(col * self.rows) + row]
    }
}

impl fmt::Debug for Matrix<f64> {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        for row in 0..self.rows {
            for col in 0..self.cols {
                write!(f, "{:.2} ", self[(row, col)])?;
            }
            writeln!(f)?;
        }

        Ok(())
    }
}

#[inline(always)]
fn compute_bonus(last_ch: char, ch: char) -> Score {
    if last_ch as usize > 255 || ch as usize > 255 {
        0_f64
    } else {
        BONUS_STATES[BONUS_INDEX[ch as usize] * 256 + last_ch as usize]
    }
}

lazy_static! {
    static ref BONUS_INDEX: [usize; 256] = {
        let mut table = [0; 256];

        for ch in b'A'..b'Z' {
            table[ch as usize] = 2;
        }

        for ch in b'a'..b'z' {
            table[ch as usize] = 1;
        }

        for ch in b'0'..b'9' {
            table[ch as usize] = 1;
        }

        table
    };
    static ref BONUS_STATES: [Score; 3 * 256] = {
        let mut table = [0_f64; 3 * 256];

        table[1 * 256 + b'/' as usize] = SCORE_MATCH_SLASH;
        table[1 * 256 + b'-' as usize] = SCORE_MATCH_WORD;
        table[1 * 256 + b'_' as usize] = SCORE_MATCH_WORD;
        table[1 * 256 + b' ' as usize] = SCORE_MATCH_WORD;
        table[1 * 256 + b'.' as usize] = SCORE_MATCH_DOT;

        table[2 * 256 + b'/' as usize] = SCORE_MATCH_SLASH;
        table[2 * 256 + b'-' as usize] = SCORE_MATCH_WORD;
        table[2 * 256 + b'_' as usize] = SCORE_MATCH_WORD;
        table[2 * 256 + b' ' as usize] = SCORE_MATCH_WORD;
        table[2 * 256 + b'.' as usize] = SCORE_MATCH_DOT;
        for ch in b'a'..b'z' {
            table[2 * 256 + ch as usize] = SCORE_MATCH_CAPITAL;
        }

        table
    };
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_matcher() {
        let needle = to_chars("abc");
        let mut matcher = Matcher::new(&needle);
        assert_eq!(matcher.push(&to_chars("abra/")), false);
        assert_eq!(matcher.push(&to_chars("cadabra")), true);
        matcher.pop();
        assert_eq!(matcher.push(&to_chars("ham/")), false);
        assert_eq!(matcher.push(&to_chars("lincoln")), true);
    }

    #[test]
    fn test_scorer() {
        let mut positions = [0; 3].to_vec();
        let needle = to_chars("bna");
        let mut scorer = Scorer::new(&needle);
        scorer.push(&to_chars("abc/"), None);
        scorer.push(&to_chars("bandana/"), None);
        scorer.push(&to_chars("banana/"), None);
        scorer.push(&to_chars("foo"), Some(&mut positions));
        assert_eq!(positions, &[12, 14, 15]);

        scorer.pop();
        scorer.pop();
        scorer.push(&to_chars("bar"), Some(&mut positions));
        assert_eq!(positions, &[4, 9, 10]);

        scorer.pop();
        scorer.pop();
        scorer.push(&to_chars("ban/"), None);
        scorer.push(&to_chars("dana"), Some(&mut positions));
        assert_eq!(positions, &[4, 10, 11]);
    }

    fn to_chars(s: &str) -> Vec<char> {
        s.chars().collect()
    }
}
