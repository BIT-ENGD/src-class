#[macro_use]
extern crate serde_derive;
extern crate serde_json as json;
extern crate alacritty;

use std::fs::File;
use std::io::{self, Read};
use std::path::Path;

use alacritty::Grid;
use alacritty::Term;
use alacritty::ansi;
use alacritty::index::Column;
use alacritty::term::Cell;
use alacritty::term::SizeInfo;
use alacritty::util::fmt::{Red, Green};
use alacritty::config::Config;

macro_rules! ref_tests {
    ($($name:ident)*) => {
        $(
            #[test]
            fn $name() {
                let test_dir = Path::new(concat!(env!("CARGO_MANIFEST_DIR"), "/tests/ref"));
                let test_path = test_dir.join(stringify!($name));
                ref_test(&test_path);
            }
        )*
    }
}

ref_tests! {
    csi_rep
    fish_cc
    indexed_256_colors
    issue_855
    ll
    newline_with_cursor_beyond_scroll_region
    tab_rendering
    tmux_git_log
    tmux_htop
    vim_24bitcolors_bce
    vim_large_window_scroll
    vim_simple_edit
    vttest_cursor_movement_1
    vttest_insert
    vttest_origin_mode_1
    vttest_origin_mode_2
    vttest_scroll
    vttest_tab_clear_set
    zsh_tab_completion
    history
    grid_reset
}

fn read_u8<P>(path: P) -> Vec<u8>
    where P: AsRef<Path>
{
    let mut res = Vec::new();
    File::open(path.as_ref()).unwrap()
        .read_to_end(&mut res).unwrap();

    res
}

fn read_string<P>(path: P) -> Result<String, ::std::io::Error>
    where P: AsRef<Path>
{
    let mut res = String::new();
    File::open(path.as_ref()).and_then(|mut f| f.read_to_string(&mut res))?;

    Ok(res)
}

#[derive(Deserialize, Default)]
struct RefConfig {
    history_size: u32,
}

fn ref_test(dir: &Path) {
    let recording = read_u8(dir.join("alacritty.recording"));
    let serialized_size = read_string(dir.join("size.json")).unwrap();
    let serialized_grid = read_string(dir.join("grid.json")).unwrap();
    let serialized_cfg = read_string(dir.join("config.json")).unwrap_or_default();

    let size: SizeInfo = json::from_str(&serialized_size).unwrap();
    let grid: Grid<Cell> = json::from_str(&serialized_grid).unwrap();
    let ref_config: RefConfig = json::from_str(&serialized_cfg).unwrap_or_default();

    let mut config: Config = Default::default();
    config.set_history(ref_config.history_size);

    let mut terminal = Term::new(&config, size);
    let mut parser = ansi::Processor::new();

    for byte in recording {
        parser.advance(&mut terminal, byte, &mut io::sink());
    }

    // Truncate invisible lines from the grid
    let mut term_grid = terminal.grid().clone();
    term_grid.truncate();

    if grid != term_grid {
        for i in 0..grid.len() {
            for j in 0..grid.num_cols().0 {
                let cell = terminal.grid()[i][Column(j)];
                let original_cell = grid[i][Column(j)];
                if original_cell != cell {
                    println!("[{i}][{j}] {original:?} => {now:?}",
                             i=i, j=j, original=Green(original_cell), now=Red(cell));
                }
            }
        }

        panic!("Ref test failed; grid doesn't match");
    }

    assert_eq!(grid, term_grid);
}
// Copyright 2016 Joe Wilm, The Alacritty Project Contributors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
use std::ops::Deref;

use foreign_types::{ForeignType, ForeignTypeRef};

use super::{ConfigRef, PatternRef, ObjectSetRef};

use super::ffi::{FcFontSetList, FcFontSetDestroy, FcFontSet};

foreign_type! {
    type CType = FcFontSet;
    fn drop = FcFontSetDestroy;
    /// Wraps an FcFontSet instance (owned)
    pub struct FontSet;
    /// Wraps an FcFontSet reference (borrowed)
    pub struct FontSetRef;
}

impl FontSet {
    pub fn list(
        config: &ConfigRef,
        source: &mut FontSetRef,
        pattern: &PatternRef,
        objects: &ObjectSetRef
    ) -> FontSet {
        let raw = unsafe {
            FcFontSetList(
                config.as_ptr(),
                &mut source.as_ptr(),
                1 /* nsets */,
                pattern.as_ptr(),
                objects.as_ptr(),
            )
        };
        FontSet(raw)
    }
}

/// Iterator over a font set
pub struct Iter<'a> {
    font_set: &'a FontSetRef,
    num_fonts: usize,
    current: usize,
}

impl<'a> IntoIterator for &'a FontSet {
    type Item = &'a PatternRef;
    type IntoIter = Iter<'a>;
    fn into_iter(self) -> Iter<'a> {
        let num_fonts = unsafe {
            (*self.as_ptr()).nfont as isize
        };

        info!("num fonts = {}", num_fonts);

        Iter {
            font_set: self.deref(),
            num_fonts: num_fonts as _,
            current: 0,
        }
    }
}

impl<'a> IntoIterator for &'a FontSetRef {
    type Item = &'a PatternRef;
    type IntoIter = Iter<'a>;
    fn into_iter(self) -> Iter<'a> {
        let num_fonts = unsafe {
            (*self.as_ptr()).nfont as isize
        };

        info!("num fonts = {}", num_fonts);

        Iter {
            font_set: self,
            num_fonts: num_fonts as _,
            current: 0,
        }
    }
}

impl<'a> Iterator for Iter<'a> {
    type Item = &'a PatternRef;

    fn next(&mut self) -> Option<Self::Item> {
        if self.current == self.num_fonts {
            None
        } else {
            let pattern = unsafe {
                let ptr = *(*self.font_set.as_ptr()).fonts.add(self.current);
                PatternRef::from_ptr(ptr)
            };

            self.current += 1;
            Some(pattern)
        }
    }
}
