/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

use fetch;
use hyper::header::ContentType;
use hyper::mime::{Attr, Mime, SubLevel, TopLevel, Value};
use hyper_serde::Serde;
use net_traits::{FetchMetadata, FilteredMetadata, NetworkError};
use net_traits::request::{Origin, Request};
use net_traits::response::ResponseBody;
use servo_url::ServoUrl;
use std::ops::Deref;

#[cfg(test)]
fn assert_parse(url:          &'static str,
                content_type: Option<ContentType>,
                charset:      Option<&str>,
                data:         Option<&[u8]>) {
    let url = ServoUrl::parse(url).unwrap();
    let origin = Origin::Origin(url.origin());
    let mut request = Request::new(url, Some(origin), None);

    let response = fetch(&mut request, None);

    match data {
        Some(data) => {
            assert!(!response.is_network_error());
            assert_eq!(response.headers.len(), 1);

            let header_content_type = response.headers.get::<ContentType>();
            assert_eq!(header_content_type, content_type.as_ref());

            let metadata = match response.metadata() {
                Ok(FetchMetadata::Filtered { filtered: FilteredMetadata::Basic(m), .. }) => m,
                result => panic!(result),
            };
            assert_eq!(metadata.content_type.map(Serde::into_inner), content_type);
            assert_eq!(metadata.charset.as_ref().map(String::deref), charset);

            let resp_body = response.body.lock().unwrap();
            match *resp_body {
                ResponseBody::Done(ref val) => {
                    assert_eq!(val, &data);
                },
                _ => panic!(),
            }
        },
        None => {
            assert!(response.is_network_error());
            assert_eq!(response.metadata().err(), Some(NetworkError::Internal("Decoding data URL failed".to_owned())));
        },
    }
}

#[test]
fn empty_invalid() {
    assert_parse("data:", None, None, None);
}

#[test]
fn plain() {
    assert_parse(
        "data:,hello%20world",
        Some(ContentType(Mime(TopLevel::Text, SubLevel::Plain,
                              vec!((Attr::Charset, Value::Ext("US-ASCII".to_owned())))))),
        Some("US-ASCII"),
        Some(b"hello world"));
}

#[test]
fn plain_ct() {
    assert_parse(
        "data:text/plain,hello",
        Some(ContentType(Mime(TopLevel::Text, SubLevel::Plain, vec!()))),
        None,
        Some(b"hello"));
}

#[test]
fn plain_html() {
    assert_parse(
        "data:text/html,<p>Servo</p>",
        Some(ContentType(Mime(TopLevel::Text, SubLevel::Html, vec!()))),
        None,
        Some(b"<p>Servo</p>"));
}

#[test]
fn plain_charset() {
    assert_parse(
        "data:text/plain;charset=latin1,hello",
        Some(ContentType(Mime(TopLevel::Text,
                              SubLevel::Plain,
                              vec!((Attr::Charset, Value::Ext("latin1".to_owned())))))),
        Some("latin1"),
        Some(b"hello"));
}

#[test]
fn plain_only_charset() {
    assert_parse(
        "data:;charset=utf-8,hello",
        Some(ContentType(Mime(TopLevel::Text,
                              SubLevel::Plain,
                              vec!((Attr::Charset, Value::Utf8))))),
        Some("utf-8"),
        Some(b"hello"));
}

#[test]
fn base64() {
    assert_parse(
        "data:;base64,C62+7w==",
        Some(ContentType(Mime(TopLevel::Text,
                              SubLevel::Plain,
                              vec!((Attr::Charset, Value::Ext("US-ASCII".to_owned())))))),
        Some("US-ASCII"),
        Some(&[0x0B, 0xAD, 0xBE, 0xEF]));
}

#[test]
fn base64_ct() {
    assert_parse(
        "data:application/octet-stream;base64,C62+7w==",
        Some(ContentType(Mime(TopLevel::Application, SubLevel::Ext("octet-stream".to_owned()), vec!()))),
        None,
        Some(&[0x0B, 0xAD, 0xBE, 0xEF]));
}

#[test]
fn base64_charset() {
    assert_parse(
        "data:text/plain;charset=koi8-r;base64,8PLl9+XkIO3l5Pfl5A==",
        Some(ContentType(Mime(TopLevel::Text, SubLevel::Plain,
                              vec!((Attr::Charset, Value::Ext("koi8-r".to_owned())))))),
        Some("koi8-r"),
        Some(&[0xF0, 0xF2, 0xE5, 0xF7, 0xE5, 0xE4, 0x20, 0xED, 0xE5, 0xE4, 0xF7, 0xE5, 0xE4]));
}
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

use net::hsts::{HstsEntry, HstsList};
use net_traits::IncludeSubdomains;
use std::collections::HashMap;
use time;

#[test]
fn test_hsts_entry_is_not_expired_when_it_has_no_timestamp() {
    let entry = HstsEntry {
        host: "mozilla.org".to_owned(),
        include_subdomains: false,
        max_age: Some(20),
        timestamp: None
    };

    assert!(!entry.is_expired());
}

#[test]
fn test_hsts_entry_is_not_expired_when_it_has_no_max_age() {
    let entry = HstsEntry {
        host: "mozilla.org".to_owned(),
        include_subdomains: false,
        max_age: None,
        timestamp: Some(time::get_time().sec as u64)
    };

    assert!(!entry.is_expired());
}

#[test]
fn test_hsts_entry_is_expired_when_it_has_reached_its_max_age() {
    let entry = HstsEntry {
        host: "mozilla.org".to_owned(),
        include_subdomains: false,
        max_age: Some(10),
        timestamp: Some(time::get_time().sec as u64 - 20u64)
    };

    assert!(entry.is_expired());
}

#[test]
fn test_hsts_entry_cant_be_created_with_ipv6_address_as_host() {
    let entry = HstsEntry::new(
        "2001:0db8:0000:0000:0000:ff00:0042:8329".to_owned(), IncludeSubdomains::NotIncluded, None
    );

    assert!(entry.is_none(), "able to create HstsEntry with IPv6 host");
}

#[test]
fn test_hsts_entry_cant_be_created_with_ipv4_address_as_host() {
    let entry = HstsEntry::new(
        "4.4.4.4".to_owned(), IncludeSubdomains::NotIncluded, None
    );

    assert!(entry.is_none(), "able to create HstsEntry with IPv4 host");
}

#[test]
fn test_base_domain_in_entries_map() {
    let entries_map = HashMap::new();

    let mut list = HstsList {
        entries_map: entries_map
    };

    list.push(HstsEntry::new("servo.mozilla.org".to_owned(),
        IncludeSubdomains::NotIncluded, None).unwrap());
    list.push(HstsEntry::new("firefox.mozilla.org".to_owned(),
        IncludeSubdomains::NotIncluded, None).unwrap());
    list.push(HstsEntry::new("bugzilla.org".to_owned(),
        IncludeSubdomains::NotIncluded, None).unwrap());

    assert_eq!(list.entries_map.len(), 2);
    assert_eq!(list.entries_map.get("mozilla.org").unwrap().len(), 2);
}

#[test]
fn test_push_entry_with_0_max_age_evicts_entry_from_list() {
    let mut entries_map = HashMap::new();
    entries_map.insert("mozilla.org".to_owned(), vec!(HstsEntry::new("mozilla.org".to_owned(),
            IncludeSubdomains::NotIncluded, Some(500000u64)).unwrap()));
    let mut list = HstsList {
        entries_map: entries_map
    };

    list.push(HstsEntry::new("mozilla.org".to_owned(),
        IncludeSubdomains::NotIncluded, Some(0)).unwrap());

    assert_eq!(list.is_host_secure("mozilla.org"), false)
}

#[test]
fn test_push_entry_to_hsts_list_should_not_add_subdomains_whose_superdomain_is_already_matched() {
    let mut entries_map = HashMap::new();
    entries_map.insert("mozilla.org".to_owned(), vec!(HstsEntry::new("mozilla.org".to_owned(),
            IncludeSubdomains::Included, None).unwrap()));
    let mut list = HstsList {
        entries_map: entries_map
    };

    list.push(HstsEntry::new("servo.mozilla.org".to_owned(),
        IncludeSubdomains::NotIncluded, None).unwrap());

    assert_eq!(list.entries_map.get("mozilla.org").unwrap().len(), 1)
}

#[test]
fn test_push_entry_to_hsts_list_should_update_existing_domain_entrys_include_subdomains() {
    let mut entries_map = HashMap::new();
    entries_map.insert("mozilla.org".to_owned(), vec!(HstsEntry::new("mozilla.org".to_owned(),
            IncludeSubdomains::Included, None).unwrap()));
    let mut list = HstsList {
        entries_map: entries_map
    };

    assert!(list.is_host_secure("servo.mozilla.org"));

    list.push(HstsEntry::new("mozilla.org".to_owned(),
        IncludeSubdomains::NotIncluded, None).unwrap());

    assert!(!list.is_host_secure("servo.mozilla.org"))
}

#[test]
fn test_push_entry_to_hsts_list_should_not_create_duplicate_entry() {
    let mut entries_map = HashMap::new();
    entries_map.insert("mozilla.org".to_owned(), vec!(HstsEntry::new("mozilla.org".to_owned(),
            IncludeSubdomains::NotIncluded, None).unwrap()));
    let mut list = HstsList {
        entries_map: entries_map
    };

    list.push(HstsEntry::new("mozilla.org".to_owned(),
        IncludeSubdomains::NotIncluded, None).unwrap());

    assert_eq!(list.entries_map.get("mozilla.org").unwrap().len(), 1)
}

#[test]
fn test_push_multiple_entrie_to_hsts_list_should_add_them_all() {
    let mut list = HstsList {
        entries_map: HashMap::new()
    };

    assert!(!list.is_host_secure("mozilla.org"));
    assert!(!list.is_host_secure("bugzilla.org"));

    list.push(HstsEntry::new("mozilla.org".to_owned(),
        IncludeSubdomains::Included, None).unwrap());
    list.push(HstsEntry::new("bugzilla.org".to_owned(),
        IncludeSubdomains::Included, None).unwrap());

    assert!(list.is_host_secure("mozilla.org"));
    assert!(list.is_host_secure("bugzilla.org"));
}

#[test]
fn test_push_entry_to_hsts_list_should_add_an_entry() {
    let mut list = HstsList {
        entries_map: HashMap::new()
    };

    assert!(!list.is_host_secure("mozilla.org"));

    list.push(HstsEntry::new("mozilla.org".to_owned(),
        IncludeSubdomains::Included, None).unwrap());

    assert!(list.is_host_secure("mozilla.org"));
}

#[test]
fn test_parse_hsts_preload_should_return_none_when_json_invalid() {
    let mock_preload_content = "derp";
    assert!(HstsList::from_preload(mock_preload_content).is_none(), "invalid preload list should not have parsed")
}

#[test]
fn test_parse_hsts_preload_should_return_none_when_json_contains_no_entries_map_key() {
    let mock_preload_content = "{\"nothing\": \"to see here\"}";
    assert!(HstsList::from_preload(mock_preload_content).is_none(), "invalid preload list should not have parsed")
}

#[test]
fn test_parse_hsts_preload_should_decode_host_and_includes_subdomains() {
    let mock_preload_content = "{\
                                    \"entries\": [\
                                       {\"host\": \"mozilla.org\",\
                                        \"include_subdomains\": false}\
                                    ]\
                                }";
    let hsts_list = HstsList::from_preload(mock_preload_content);
    let entries_map = hsts_list.unwrap().entries_map;

    assert_eq!(entries_map.get("mozilla.org").unwrap()[0].host, "mozilla.org");
    assert!(!entries_map.get("mozilla.org").unwrap()[0].include_subdomains);
}

#[test]
fn test_hsts_list_with_no_entries_map_does_not_is_host_secure() {
    let hsts_list = HstsList {
        entries_map: HashMap::new()
    };

    assert!(!hsts_list.is_host_secure("mozilla.org"));
}

#[test]
fn test_hsts_list_with_exact_domain_entry_is_is_host_secure() {
    let mut entries_map = HashMap::new();
    entries_map.insert("mozilla.org".to_owned(),  vec![HstsEntry::new("mozilla.org".to_owned(),
            IncludeSubdomains::NotIncluded, None).unwrap()]);

    let hsts_list = HstsList {
        entries_map: entries_map
    };

    assert!(hsts_list.is_host_secure("mozilla.org"));
}

#[test]
fn test_hsts_list_with_subdomain_when_include_subdomains_is_true_is_is_host_secure() {
    let mut entries_map = HashMap::new();
    entries_map.insert("mozilla.org".to_owned(), vec![HstsEntry::new("mozilla.org".to_owned(),
            IncludeSubdomains::Included, None).unwrap()]);
    let hsts_list = HstsList {
        entries_map: entries_map
    };

    assert!(hsts_list.is_host_secure("servo.mozilla.org"));
}

#[test]
fn test_hsts_list_with_subdomain_when_include_subdomains_is_false_is_not_is_host_secure() {
    let mut entries_map = HashMap::new();
    entries_map.insert("mozilla.org".to_owned(), vec![HstsEntry::new("mozilla.org".to_owned(),
            IncludeSubdomains::NotIncluded, None).unwrap()]);
    let hsts_list = HstsList {
        entries_map: entries_map
    };

    assert!(!hsts_list.is_host_secure("servo.mozilla.org"));
}

#[test]
fn test_hsts_list_with_subdomain_when_host_is_not_a_subdomain_is_not_is_host_secure() {
    let mut entries_map = HashMap::new();
    entries_map.insert("mozilla.org".to_owned(), vec![HstsEntry::new("mozilla.org".to_owned(),
            IncludeSubdomains::Included, None).unwrap()]);
    let hsts_list = HstsList {
        entries_map: entries_map
    };

    assert!(!hsts_list.is_host_secure("servo-mozilla.org"));
}

#[test]
fn test_hsts_list_with_subdomain_when_host_is_exact_match_is_is_host_secure() {
    let mut entries_map = HashMap::new();
    entries_map.insert("mozilla.org".to_owned(), vec![HstsEntry::new("mozilla.org".to_owned(),
            IncludeSubdomains::Included, None).unwrap()]);
    let hsts_list = HstsList {
        entries_map: entries_map
    };

    assert!(hsts_list.is_host_secure("mozilla.org"));
}

#[test]
fn test_hsts_list_with_expired_entry_is_not_is_host_secure() {
    let mut entries_map = HashMap::new();
    entries_map.insert("mozilla.org".to_owned(), vec![HstsEntry {
            host: "mozilla.org".to_owned(),
            include_subdomains: false,
            max_age: Some(20),
            timestamp: Some(time::get_time().sec as u64 - 100u64)
        }]);
    let hsts_list = HstsList {
        entries_map: entries_map
    };

    assert!(!hsts_list.is_host_secure("mozilla.org"));
}

#[test]
fn test_preload_hsts_domains_well_formed() {
    let hsts_list = HstsList::from_servo_preload();
    assert!(!hsts_list.entries_map.is_empty());
}
