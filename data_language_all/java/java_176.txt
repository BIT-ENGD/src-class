// You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.

// You may assume the two numbers do not contain any leading zero, except the number 0 itself.

// Input: (2 -> 4 -> 3) + (5 -> 6 -> 4)
// Output: 7 -> 0 -> 8

/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
public class AddTwoNumbers {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode current1 = l1;
        ListNode current2 = l2;
        
        ListNode head = new ListNode(0);
        ListNode currentHead = head;
        
        int sum = 0;
        
        while(current1 != null || current2 != null) {
            sum /= 10;
            
            if(current1 != null) {
                sum += current1.val;
                current1 = current1.next;
            }
            
            if(current2 != null) {
                sum += current2.val;
                current2 = current2.next;
            }

            currentHead.next = new ListNode(sum % 10);
            currentHead = currentHead.next;
        }
        
        if(sum / 10 == 1) {
            currentHead.next = new ListNode(1);
        }
        
        return head.next;
    }
}
/*
 * Copyright (C) 2018 Square, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package okhttp3.internal.sse;

import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.mockwebserver.MockResponse;
import okhttp3.mockwebserver.MockWebServer;
import okhttp3.sse.EventSource;
import okhttp3.sse.EventSources;
import org.junit.After;
import org.junit.Rule;
import org.junit.Test;

import static org.junit.Assert.assertEquals;

public final class EventSourceHttpTest {
  @Rule public final MockWebServer server = new MockWebServer();

  private final EventSourceRecorder listener = new EventSourceRecorder();
  private final EventSource.Factory factory = EventSources.createFactory(new OkHttpClient());

  @After public void after() {
    listener.assertExhausted();
  }

  @Test public void event() {
    server.enqueue(new MockResponse().setBody(""
        + "data: hey\n"
        + "\n").setHeader("content-type", "text/event-stream"));

    EventSource source = newEventSource();

    assertEquals("/", source.request().url().encodedPath());

    listener.assertOpen();
    listener.assertEvent(null, null, "hey");
    listener.assertClose();
  }

  @Test public void badContentType() {
    server.enqueue(new MockResponse().setBody(""
        + "data: hey\n"
        + "\n").setHeader("content-type", "text/plain"));

    EventSource source = newEventSource();
    listener.assertFailure("Invalid content-type: text/plain");
  }

  @Test public void badResponseCode() {
    server.enqueue(new MockResponse().setBody(""
        + "data: hey\n"
        + "\n").setHeader("content-type", "text/event-stream").setResponseCode(401));

    EventSource source = newEventSource();
    listener.assertFailure(null);
  }

  private EventSource newEventSource() {
    Request request = new Request.Builder()
        .url(server.url("/"))
        .build();
    return factory.newEventSource(request, listener);
  }
}
