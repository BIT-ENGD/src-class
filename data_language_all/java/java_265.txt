
package com.xxmassdeveloper.mpchartexample;

import android.graphics.Color;
import android.os.Bundle;
import android.util.Log;
import android.view.Menu;
import android.view.MenuItem;
import android.view.WindowManager;
import android.widget.Toast;

import com.github.mikephil.charting.charts.LineChart;
import com.github.mikephil.charting.components.Legend;
import com.github.mikephil.charting.components.Legend.LegendForm;
import com.github.mikephil.charting.components.XAxis;
import com.github.mikephil.charting.components.YAxis;
import com.github.mikephil.charting.components.YAxis.AxisDependency;
import com.github.mikephil.charting.data.Entry;
import com.github.mikephil.charting.data.LineData;
import com.github.mikephil.charting.data.LineDataSet;
import com.github.mikephil.charting.highlight.Highlight;
import com.github.mikephil.charting.interfaces.datasets.ILineDataSet;
import com.github.mikephil.charting.listener.OnChartValueSelectedListener;
import com.github.mikephil.charting.utils.ColorTemplate;
import com.xxmassdeveloper.mpchartexample.notimportant.DemoBase;

public class RealtimeLineChartActivity extends DemoBase implements
        OnChartValueSelectedListener {

    private LineChart mChart;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,
                WindowManager.LayoutParams.FLAG_FULLSCREEN);
        setContentView(R.layout.activity_realtime_linechart);

        mChart = findViewById(R.id.chart1);
        mChart.setOnChartValueSelectedListener(this);

        // enable description text
        mChart.getDescription().setEnabled(true);

        // enable touch gestures
        mChart.setTouchEnabled(true);

        // enable scaling and dragging
        mChart.setDragEnabled(true);
        mChart.setScaleEnabled(true);
        mChart.setDrawGridBackground(false);

        // if disabled, scaling can be done on x- and y-axis separately
        mChart.setPinchZoom(true);

        // set an alternative background color
        mChart.setBackgroundColor(Color.LTGRAY);

        LineData data = new LineData();
        data.setValueTextColor(Color.WHITE);

        // add empty data
        mChart.setData(data);

        // get the legend (only possible after setting data)
        Legend l = mChart.getLegend();

        // modify the legend ...
        l.setForm(LegendForm.LINE);
        l.setTypeface(mTfLight);
        l.setTextColor(Color.WHITE);

        XAxis xl = mChart.getXAxis();
        xl.setTypeface(mTfLight);
        xl.setTextColor(Color.WHITE);
        xl.setDrawGridLines(false);
        xl.setAvoidFirstLastClipping(true);
        xl.setEnabled(true);

        YAxis leftAxis = mChart.getAxisLeft();
        leftAxis.setTypeface(mTfLight);
        leftAxis.setTextColor(Color.WHITE);
        leftAxis.setAxisMaximum(100f);
        leftAxis.setAxisMinimum(0f);
        leftAxis.setDrawGridLines(true);

        YAxis rightAxis = mChart.getAxisRight();
        rightAxis.setEnabled(false);

    }

    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        getMenuInflater().inflate(R.menu.realtime, menu);
        return true;
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {

        switch (item.getItemId()) {
            case R.id.actionAdd: {
                addEntry();
                break;
            }
            case R.id.actionClear: {
                mChart.clearValues();
                Toast.makeText(this, "Chart cleared!", Toast.LENGTH_SHORT).show();
                break;
            }
            case R.id.actionFeedMultiple: {
                feedMultiple();
                break;
            }
        }
        return true;
    }

    private void addEntry() {

        LineData data = mChart.getData();

        if (data != null) {

            ILineDataSet set = data.getDataSetByIndex(0);
            // set.addEntry(...); // can be called as well

            if (set == null) {
                set = createSet();
                data.addDataSet(set);
            }

            data.addEntry(new Entry(set.getEntryCount(), (float) (Math.random() * 40) + 30f), 0);
            data.notifyDataChanged();

            // let the chart know it's data has changed
            mChart.notifyDataSetChanged();

            // limit the number of visible entries
            mChart.setVisibleXRangeMaximum(120);
            // mChart.setVisibleYRange(30, AxisDependency.LEFT);

            // move to the latest entry
            mChart.moveViewToX(data.getEntryCount());

            // this automatically refreshes the chart (calls invalidate())
            // mChart.moveViewTo(data.getXValCount()-7, 55f,
            // AxisDependency.LEFT);
        }
    }

    private LineDataSet createSet() {

        LineDataSet set = new LineDataSet(null, "Dynamic Data");
        set.setAxisDependency(AxisDependency.LEFT);
        set.setColor(ColorTemplate.getHoloBlue());
        set.setCircleColor(Color.WHITE);
        set.setLineWidth(2f);
        set.setCircleRadius(4f);
        set.setFillAlpha(65);
        set.setFillColor(ColorTemplate.getHoloBlue());
        set.setHighLightColor(Color.rgb(244, 117, 117));
        set.setValueTextColor(Color.WHITE);
        set.setValueTextSize(9f);
        set.setDrawValues(false);
        return set;
    }

    private Thread thread;

    private void feedMultiple() {

        if (thread != null)
            thread.interrupt();

        final Runnable runnable = new Runnable() {

            @Override
            public void run() {
                addEntry();
            }
        };

        thread = new Thread(new Runnable() {

            @Override
            public void run() {
                for (int i = 0; i < 1000; i++) {

                    // Don't generate garbage runnables inside the loop.
                    runOnUiThread(runnable);

                    try {
                        Thread.sleep(25);
                    } catch (InterruptedException e) {
                        // TODO Auto-generated catch block
                        e.printStackTrace();
                    }
                }
            }
        });

        thread.start();
    }

    @Override
    public void onValueSelected(Entry e, Highlight h) {
        Log.i("Entry selected", e.toString());
    }

    @Override
    public void onNothingSelected() {
        Log.i("Nothing selected", "Nothing selected.");
    }

    @Override
    protected void onPause() {
        super.onPause();

        if (thread != null) {
            thread.interrupt();
        }
    }
}
package com.bumptech.glide.annotation.compiler;

import com.bumptech.glide.annotation.GlideExtension;
import com.google.common.base.Function;
import com.google.common.base.Preconditions;
import com.google.common.collect.Lists;
import com.squareup.javapoet.AnnotationSpec;
import com.squareup.javapoet.ClassName;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.MethodSpec.Builder;
import com.squareup.javapoet.ParameterSpec;
import com.squareup.javapoet.TypeSpec;
import java.util.ArrayList;
import java.util.List;
import javax.annotation.processing.ProcessingEnvironment;
import javax.lang.model.element.AnnotationMirror;
import javax.lang.model.element.ExecutableElement;
import javax.lang.model.element.Modifier;
import javax.lang.model.element.TypeElement;
import javax.lang.model.util.Elements;

/**
 * Generates a Glide look-alike that acts as the entry point to the generated API
 * (GlideApp.with(...)).
 *
 * <p>>Generated {@code com.bumptech.glide.Glide} look-alikes look like this (note that the name
 * is configurable in {@link com.bumptech.glide.annotation.GlideModule}):
 * <pre>
 * <code>
 * public final class GlideApp {
 *   private GiphyGlide() {
 *   }
 *
 *   public static File getPhotoCacheDir(Context context) {
 *     return Glide.getPhotoCacheDir(context);
 *   }
 *
 *   public static File getPhotoCacheDir(Context context, String cacheName) {
 *     return Glide.getPhotoCacheDir(context, cacheName);
 *   }
 *
 *   public static Glide get(Context context) {
 *     return Glide.get(context);
 *   }
 *
 *   public static void tearDown() {
 *     Glide.tearDown();
 *   }
 *
 *   public static GeneratedRequestManager with(Context context) {
 *     return (GeneratedRequestManager) Glide.with(context);
 *   }
 *
 *   public static GeneratedRequestManager with(Activity activity) {
 *    return (GeneratedRequestManager) Glide.with(activity);
 *   }
 *
 *   public static GeneratedRequestManager with(FragmentActivity activity) {
 *     return (GeneratedRequestManager) Glide.with(activity);
 *   }
 *
 *   public static GeneratedRequestManager with(Fragment fragment) {
 *     return (GeneratedRequestManager) Glide.with(fragment);
 *   }
 *
 *   public static GeneratedRequestManager with(android.support.v4.app.Fragment fragment) {
 *     return (GeneratedRequestManager) Glide.with(fragment);
 *   }
 * </code>
 * </pre>
 */
final class GlideGenerator {
  private static final String GLIDE_QUALIFIED_NAME =
      "com.bumptech.glide.Glide";

  private static final String REQUEST_MANAGER_QUALIFIED_NAME =
      "com.bumptech.glide.RequestManager";

  private static final String VISIBLE_FOR_TESTING_QUALIFIED_NAME =
      "android.support.annotation.VisibleForTesting";

  private static final String VISIBLE_FOR_TESTING_QUALIFIED_NAME_ANDROIDX =
      "androidx.annotation.VisibleForTesting";

  private static final String SUPPRESS_LINT_PACKAGE_NAME =
      "android.annotation";
  private static final String SUPPRESS_LINT_CLASS_NAME =
      "SuppressLint";

  private final ProcessingEnvironment processingEnv;
  private final ProcessorUtil processorUtil;
  private final TypeElement glideType;
  private final TypeElement requestManagerType;

  GlideGenerator(ProcessingEnvironment processingEnv, ProcessorUtil processorUtil) {
    this.processingEnv = processingEnv;
    this.processorUtil = processorUtil;

    Elements elementUtils = processingEnv.getElementUtils();

    requestManagerType = elementUtils.getTypeElement(REQUEST_MANAGER_QUALIFIED_NAME);

    glideType = elementUtils.getTypeElement(GLIDE_QUALIFIED_NAME);
  }

  TypeSpec generate(
      String generatedCodePackageName, String glideName, TypeSpec generatedRequestManager) {
    return TypeSpec.classBuilder(glideName)
        .addJavadoc(
            "The entry point for interacting with Glide for Applications\n"
                + "\n"
                + "<p>Includes all generated APIs from all\n"
                + "{@link $T}s in source and dependent libraries.\n"
                + "\n"
                + "<p>This class is generated and should not be modified"
                + "\n"
                + "@see $T\n", GlideExtension.class, glideType)
        .addModifiers(Modifier.PUBLIC, Modifier.FINAL)
        .addMethod(MethodSpec.constructorBuilder()
            .addModifiers(Modifier.PRIVATE)
            .build())
        .addMethods(
            generateOverridesForGlideMethods(generatedCodePackageName, generatedRequestManager))
        .build();
  }

  private List<MethodSpec> generateOverridesForGlideMethods(
      final String generatedCodePackageName, final TypeSpec generatedRequestManager) {
    return Lists.transform(discoverGlideMethodsToOverride(),
        new Function<ExecutableElement, MethodSpec>() {
          @Override
          public MethodSpec apply(ExecutableElement input) {
            if (isGlideWithMethod(input)) {
              return overrideGlideWithMethod(
                  generatedCodePackageName, generatedRequestManager, input);
            } else {
              return overrideGlideStaticMethod(input);
            }
          }
        });
  }

  private MethodSpec overrideGlideStaticMethod(ExecutableElement methodToOverride) {
    List<ParameterSpec> parameters = ProcessorUtil.getParameters(methodToOverride);

    TypeElement element =
        (TypeElement) processingEnv.getTypeUtils().asElement(methodToOverride.getReturnType());

    MethodSpec.Builder builder =
        MethodSpec.methodBuilder(methodToOverride.getSimpleName().toString())
            .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
            .addJavadoc(processorUtil.generateSeeMethodJavadoc(methodToOverride))
            .addParameters(parameters);

    addReturnAnnotations(builder, methodToOverride);

    boolean returnsValue = element != null;
    if (returnsValue) {
      builder.returns(ClassName.get(element));
    }

    StringBuilder code = new StringBuilder(returnsValue ? "return " : "");
    code.append("$T.$N(");
    List<Object> args = new ArrayList<>();
    args.add(ClassName.get(glideType));
    args.add(methodToOverride.getSimpleName());
    if (!parameters.isEmpty()) {
      for (ParameterSpec param : parameters) {
        code.append("$L, ");
        args.add(param.name);
      }
      code = new StringBuilder(code.substring(0, code.length() - 2));
    }
    code.append(")");
    builder.addStatement(code.toString(), args.toArray(new Object[0]));
    return builder.build();
  }

  private Builder addReturnAnnotations(Builder builder, ExecutableElement methodToOverride) {
    Elements elements = processingEnv.getElementUtils();
    TypeElement visibleForTestingTypeElement = elements
        .getTypeElement(VISIBLE_FOR_TESTING_QUALIFIED_NAME_ANDROIDX);
    if (visibleForTestingTypeElement == null) {
      // Fall back to looking for the Support library version.
      visibleForTestingTypeElement = elements.getTypeElement(VISIBLE_FOR_TESTING_QUALIFIED_NAME);
    }
    String visibleForTestingTypeQualifiedName = visibleForTestingTypeElement.toString();

    for (AnnotationMirror mirror : methodToOverride.getAnnotationMirrors()) {
      builder.addAnnotation(AnnotationSpec.get(mirror));

      // Suppress a lint warning if we're overriding a VisibleForTesting method.
      // See #1977.
      String annotationQualifiedName = mirror.getAnnotationType().toString();
      if (annotationQualifiedName.equals(visibleForTestingTypeQualifiedName)) {
        builder.addAnnotation(
            AnnotationSpec.builder(
                ClassName.get(SUPPRESS_LINT_PACKAGE_NAME, SUPPRESS_LINT_CLASS_NAME))
                .addMember("value", "$S", "VisibleForTests")
                .build());
      }
    }

    return builder;
  }

  private List<ExecutableElement> discoverGlideMethodsToOverride() {
    return processorUtil.findStaticMethods(glideType);
  }

  private boolean isGlideWithMethod(ExecutableElement element) {
    return processorUtil.isReturnValueTypeMatching(element, requestManagerType);
  }

  private MethodSpec overrideGlideWithMethod(
      String packageName, TypeSpec generatedRequestManager, ExecutableElement methodToOverride) {
    ClassName generatedRequestManagerClassName =
        ClassName.get(packageName, generatedRequestManager.name);
    List<ParameterSpec> parameters = ProcessorUtil.getParameters(methodToOverride);
    Preconditions.checkArgument(
        parameters.size() == 1, "Expected size of 1, but got %s", methodToOverride);
    ParameterSpec parameter = parameters.iterator().next();

    Builder builder = MethodSpec.methodBuilder(methodToOverride.getSimpleName().toString())
        .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
        .addJavadoc(processorUtil.generateSeeMethodJavadoc(methodToOverride))
        .addParameters(parameters)
        .returns(generatedRequestManagerClassName)
        .addStatement("return ($T) $T.$N($L)",
            generatedRequestManagerClassName, glideType,
            methodToOverride.getSimpleName().toString(),
            parameter.name);

    return addReturnAnnotations(builder, methodToOverride).build();
  }
}
