module Commands where

import Parsing
import Emit
import Obj
import Types
import Infer
import Deftype
import ColorText
import Template
import Util
import Lookup
import RenderDocs

import System.Directory
import System.Info (os)
import Control.Monad.State
import Control.Monad.State.Lazy (StateT(..), runStateT, liftIO, modify, get, put)
import Data.Maybe (fromMaybe)
import Data.List (elemIndex)
import System.Exit (exitSuccess, exitFailure, exitWith, ExitCode(..))
import System.FilePath (takeDirectory)
import qualified Data.Map as Map
import System.Process (callCommand, spawnCommand, waitForProcess)
import Control.Exception

type CommandCallback = [XObj] -> StateT Context IO (Either EvalError XObj)

data CarpException =
    ShellOutException { shellOutMessage :: String, returnCode :: Int }
  | CancelEvaluationException
  | EvalException EvalError
  deriving (Eq, Show)

instance Exception CarpException

-- | A lot of commands need to return nil, which signifies a side effecting function and no printing of the result.
dynamicNil :: Either a XObj
dynamicNil = Right (XObj (Lst []) (Just dummyInfo) (Just UnitTy)) -- TODO: Remove/unwrap (Right ...) to a XObj

-- | Dynamic 'true'.
trueXObj :: XObj
trueXObj = XObj (Bol True) Nothing Nothing

-- | Dynamic 'false'.
falseXObj :: XObj
falseXObj = XObj (Bol False) Nothing Nothing

-- | Use this function to register commands in the environment.
addCommand :: String -> Int -> CommandCallback -> (String, Binder)
addCommand name arity callback =
  addCommandConfigurable name (Just arity) callback

addCommandConfigurable :: String -> Maybe Int -> CommandCallback -> (String, Binder)
addCommandConfigurable name maybeArity callback =
  let path = SymPath [] name
      cmd = XObj (Lst [XObj (Command (CommandFunction f)) (Just dummyInfo) Nothing
                      ,XObj (Sym path Symbol) Nothing Nothing
                      ])
            (Just dummyInfo) (Just DynamicTy)
  in (name, Binder emptyMeta cmd)
  where f = case maybeArity of
              Just arity -> withArity arity
              Nothing -> withoutArity
        withArity arity args =
          if length args == arity
            then callback args
            else return (Left (EvalError ("Invalid args to '" ++ name ++ "' command: " ++ joinWithComma (map pretty args))))
        withoutArity args =
          callback args

-- | DEPRECATED Command for changing various project settings.
commandProjectSet :: CommandCallback
commandProjectSet [XObj (Str key) _ _, value] =
  do ctx <- get
     let proj = contextProj ctx
         env = contextGlobalEnv ctx
     case value of
       XObj (Str valueStr) _ _ -> do
          newCtx <- case key of
                      "cflag" -> return ctx { contextProj = proj { projectCFlags = addIfNotPresent valueStr (projectCFlags proj) } }
                      "libflag" -> return ctx { contextProj = proj { projectLibFlags = addIfNotPresent valueStr (projectLibFlags proj) } }
                      "prompt" -> return ctx { contextProj = proj { projectPrompt = valueStr } }
                      "search-path" -> return ctx { contextProj = proj { projectCarpSearchPaths = addIfNotPresent valueStr (projectCarpSearchPaths proj) } }
                      "printAST" -> return ctx { contextProj = proj { projectPrintTypedAST = (valueStr == "true") } }
                      "echoC" -> return ctx { contextProj = proj { projectEchoC = (valueStr == "true") } }
                      "echoCompilationCommand" -> return ctx { contextProj = proj { projectEchoCompilationCommand = (valueStr == "true") } }
                      "compiler" -> return ctx { contextProj = proj { projectCompiler = valueStr } }
                      "title"    -> return ctx { contextProj = proj { projectTitle = valueStr } }
                      _ -> presentError ("Unrecognized key: '" ++ key ++ "'") ctx
          put newCtx
          return dynamicNil
       val -> presentError "Argument to project-set! must be a string" dynamicNil

presentError :: MonadIO m => String -> a -> m a
presentError msg ret =
  liftIO $ do putStrLnWithColor Red msg
              return ret

-- | Command for changing various project settings.
commandProjectConfig :: CommandCallback
commandProjectConfig [xobj@(XObj (Str key) _ _), value] =
  do ctx <- get
     let proj = contextProj ctx
         env = contextGlobalEnv ctx
         newProj = case key of
                     "cflag" -> do cflag <- unwrapStringXObj value
                                   return (proj { projectCFlags = addIfNotPresent cflag (projectCFlags proj) })
                     "libflag" -> do libflag <- unwrapStringXObj value
                                     return (proj { projectLibFlags = addIfNotPresent libflag (projectLibFlags proj) })
                     "prompt" -> do prompt <- unwrapStringXObj value
                                    return (proj { projectPrompt = prompt })
                     "search-path" -> do searchPath <- unwrapStringXObj value
                                         return (proj { projectCarpSearchPaths = addIfNotPresent searchPath (projectCarpSearchPaths proj) })
                     "print-ast" -> do printAST <- unwrapBoolXObj value
                                       return (proj { projectPrintTypedAST = printAST })
                     "echo-c" -> do echoC <- unwrapBoolXObj value
                                    return (proj { projectEchoC = echoC })
                     "echo-compiler-cmd" -> do echoCompilerCmd <- unwrapBoolXObj value
                                               return (proj { projectEchoCompilationCommand = echoCompilerCmd })
                     "compiler" -> do compiler <- unwrapStringXObj value
                                      return (proj { projectCompiler = compiler })
                     "title" -> do title <- unwrapStringXObj value
                                   return (proj { projectTitle = title })
                     "output-directory" -> do outDir <- unwrapStringXObj value
                                              return (proj { projectOutDir = outDir })
                     "docs-directory" -> do docsDir <- unwrapStringXObj value
                                            return (proj { projectDocsDir = docsDir })
                     "file-path-print-length" -> do length <- unwrapStringXObj value
                                                    case length of
                                                      "short" -> return (proj { projectFilePathPrintLength = ShortPath })
                                                      "full" -> return (proj { projectFilePathPrintLength = ShortPath })
                                                      _ -> Left ("Project.config can't understand the value '" ++ length ++ "' for key 'file-path-print-length.")
                     _ -> Left ("Project.config can't understand the key '" ++ key ++ "' at " ++ prettyInfoFromXObj xobj ++ ".")
     case newProj of
       Left errorMessage -> presentError ("[CONFIG ERROR] " ++ errorMessage) dynamicNil
       Right ok -> do put (ctx { contextProj = ok })
                      return dynamicNil
commandProjectConfig [faultyKey, _] =
  do presentError ("First argument to 'Project.config' must be a string: " ++ pretty faultyKey) dynamicNil

-- | Command for changing various project settings.
commandProjectGetConfig :: CommandCallback
commandProjectGetConfig [xobj@(XObj (Str key) _ _)] =
  do ctx <- get
     let proj = contextProj ctx
         env = contextGlobalEnv ctx
     case getVal proj of
      Right val -> return $ Right $ XObj val (Just dummyInfo) (Just StringTy)
      Left err -> return $ Left err
  where getVal proj = case key of
          "cflag" -> Right $ Str $ show $ projectCFlags proj
          "libflag" -> Right $ Str $ show $ projectLibFlags proj
          "prompt" -> Right $ Str $ projectPrompt proj
          "search-path" -> Right $ Str $ show $ projectCarpSearchPaths proj
          "print-ast" -> Right $ Bol $ projectPrintTypedAST proj
          "echo-c" -> Right $ Bol $ projectEchoC proj
          "echo-compiler-cmd" -> Right $ Bol $ projectEchoCompilationCommand proj
          "compiler" -> Right $ Str $ projectCompiler proj
          "title" -> Right $ Str $ projectTitle proj
          "output-directory" -> Right $ Str $ projectOutDir proj
          "docs-directory" -> Right $ Str $ projectDocsDir proj
          "file-path-print-length" -> Right $ Str $ show (projectFilePathPrintLength proj)
          _ ->
            Left $ EvalError ("[CONFIG ERROR] Project.get-config can't understand the key '" ++
                               key ++ "' at " ++ prettyInfoFromXObj xobj ++ ".")
commandProjectGetConfig [faultyKey] =
  do presentError ("First argument to 'Project.config' must be a string: " ++ pretty faultyKey) dynamicNil

-- | Command for exiting the REPL/compiler
commandQuit :: CommandCallback
commandQuit args =
  do liftIO exitSuccess
     return dynamicNil

-- | Command for printing the generated C output (in out/main.c)
commandCat :: CommandCallback
commandCat args =
  do ctx <- get
     let outDir = projectOutDir (contextProj ctx)
         outMain = outDir ++ "/" ++ "main.c"
     liftIO $ do callCommand ("cat -n " ++ outMain)
                 return dynamicNil

-- | Command for running the executable generated by the 'build' command.
commandRunExe :: CommandCallback
commandRunExe args =
  do ctx <- get
     let proj = contextProj ctx
         outDir = projectOutDir proj
         outExe = "\"" ++ outDir ++ "/" ++ projectTitle (contextProj ctx) ++ "\""
     if projectCanExecute proj
       then liftIO $ do handle <- spawnCommand outExe
                        exitCode <- waitForProcess handle
                        case exitCode of
                          ExitSuccess -> return (Right (XObj (Num IntTy 0) (Just dummyInfo) (Just IntTy)))
                          ExitFailure i -> throw (ShellOutException ("'" ++ outExe ++ "' exited with return value " ++ show i ++ ".") i)
       else liftIO $ do putStrLnWithColor Red "Can't call the 'run' command, need to build an executable first (requires a 'main' function)."
                        return dynamicNil

-- | Command for building the project, producing an executable binary or a shared library.
commandBuild :: CommandCallback
commandBuild args =
  do ctx <- get
     let env = contextGlobalEnv ctx
         typeEnv = contextTypeEnv ctx
         proj = contextProj ctx
         execMode = contextExecMode ctx
         src = do decl <- envToDeclarations typeEnv env
                  typeDecl <- envToDeclarations typeEnv (getTypeEnv typeEnv)
                  c <- envToC env Functions
                  initGlobals <- fmap (wrapInInitFunction (projectCore proj)) (globalsToC env)
                  return ("//Types:\n" ++ typeDecl ++
                          "\n\n//Declarations:\n" ++ decl ++
                          "\n\n//Init globals:\n" ++ initGlobals ++
                          "\n\n//Definitions:\n" ++ c
                         )
     case src of
       Left err ->
         return (Left (EvalError ("[CODEGEN ERROR] " ++ show err)))
       Right okSrc ->
         do let compiler = projectCompiler proj
                echoCompilationCommand = projectEchoCompilationCommand proj
                incl = projectIncludesToC proj
                includeCorePath = " -I" ++ projectCarpDir proj ++ "/core/ "
                switches = " -g "
                flags = projectFlags proj ++ includeCorePath ++ switches
                outDir = projectOutDir proj ++ "/"
                outMain = outDir ++ "main.c"
                outExe = outDir ++ projectTitle proj
                outLib = outDir ++ projectTitle proj
            liftIO $ createDirectoryIfMissing False outDir
            liftIO $ writeFile outMain (incl ++ okSrc)
            case Map.lookup "main" (envBindings env) of
              Just _ -> do let cmd = compiler ++ " " ++ outMain ++ " -o \"" ++ outExe ++ "\" " ++ flags
                           liftIO $ do when echoCompilationCommand (putStrLn cmd)
                                       callCommand cmd
                                       when (execMode == Repl) (putStrLn ("Compiled to '" ++ outExe ++ "' (executable)"))
                           setProjectCanExecute True
                           return dynamicNil
              Nothing -> do let cmd = compiler ++ " " ++ outMain ++ " -shared -o \"" ++ outLib ++ "\" " ++ flags
                            liftIO $ do when echoCompilationCommand (putStrLn cmd)
                                        callCommand cmd
                                        when (execMode == Repl) (putStrLn ("Compiled to '" ++ outLib ++ "' (shared library)"))
                            setProjectCanExecute False
                            return dynamicNil

setProjectCanExecute :: Bool -> StateT Context IO ()
setProjectCanExecute value =
  do ctx <- get
     let proj = contextProj ctx
         proj' = proj { projectCanExecute = value }
         ctx' = ctx { contextProj = proj' }
     put ctx'
     return ()

-- | Command for printing all the bindings in the current environment.
commandListBindings :: CommandCallback
commandListBindings args =
  do ctx <- get
     liftIO $ do putStrLn "Types:\n"
                 putStrLn (prettyEnvironment (getTypeEnv (contextTypeEnv ctx)))
                 putStrLn "\nGlobal environment:\n"
                 putStrLn (prettyEnvironment (contextGlobalEnv ctx))
                 putStrLn ""
                 return dynamicNil

-- | Command for printing help.
commandHelp :: CommandCallback

commandHelp [XObj (Str "about") _ _] =
  liftIO $ do putStrLn "Carp is an ongoing research project by Erik Svedäng, et al."
              putStrLn ""
              putStrLn "Licensed under the Apache License, Version 2.0 (the \"License\"); \n\
                       \you may not use this file except in compliance with the License. \n\
                       \You may obtain a copy of the License at \n\
                       \http://www.apache.org/licenses/LICENSE-2.0"
              putStrLn ""
              putStrLn "THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ``AS IS'' AND ANY \n\
                       \EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE \n\
                       \IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR \n\
                       \PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE \n\
                       \LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR \n\
                       \CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF \n\
                       \SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR \n\
                       \BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, \n\
                       \WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE \n\
                       \OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN\n\
                       \IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
              putStrLn ""
              return dynamicNil

commandHelp [XObj (Str "language") _ _] =
  liftIO $ do putStrLn "Special forms:"
              putStrLn "(if <condition> <then> <else>)"
              putStrLn "(while <condition> <body>)"
              putStrLn "(do <statement1> <statement2> ... <exprN>)"
              putStrLn "(let [<sym1> <expr1> <name2> <expr2> ...] <body>)"
              --putStrLn "(fn [<args>] <body>)"
              putStrLn "(the <type> <expression>)"
              putStrLn "(ref <expression>)"
              putStrLn "(address <expr>)"
              putStrLn "(set! <var> <value>)"
              putStrLn "(break)"
              putStrLn ""
              putStrLn "To use functions in modules without qualifying them:"
              putStrLn "(use <module>)"
              putStrLn "(with <module> <form>)"
              putStrLn ""
              putStrLn ("Valid non-alphanumerics: " ++ validCharacters)
              putStrLn ""
              putStrLn "Number literals:"
              putStrLn "1      Int"
              putStrLn "1l     Long"
              putStrLn "1.0    Double"
              putStrLn "1.0f   Float"
              putStrLn ""
              putStrLn "Reader macros:"
              putStrLn "&<expr>   (ref <expr>)"
              putStrLn "@<expr>   (copy <expr>)"
              putStrLn ""
              return dynamicNil

commandHelp [XObj (Str "macros") _ _] =
  liftIO $ do putStrLn "To inspect what macros expand to:"
              putStrLn "(expand <quoted expression>)"
              putStrLn ""
              putStrLn "Some useful macros:"
              putStrLn "(cond <condition1> <expr1> ... <else-condition>)"
              putStrLn "(case <expr> <compare-this-1> <expr1> ... <else-condition>)"
              putStrLn "(when <condition> <body>)"
              putStrLn "(for [<var> <from> <to>] <body>)"
              putStrLn "(=> <expr> <func1> <func2> ...)"
              putStrLn "(==> <expr> <func1> <func2> ...)"
              putStrLn ""
              return dynamicNil

commandHelp [XObj (Str "structs") _ _] =
  liftIO $ do putStrLn "To define a struct without any generic member variables:"
              putStrLn "(deftype <name> [<member> <type>, ...])"
              putStrLn ""
              putStrLn "If you need generic members:"
              putStrLn "(deftype (<name> <type variable 1> ...) [<member> <type>, ...])"
              putStrLn ""
              putStrLn "A type definition will generate the following methods:"
              putStrLn "Getters  (<method-name> (Ref <struct>))"
              putStrLn "Setters  (set-<method-name> <struct> <new-value>)"
              putStrLn "Updaters (update-<method-name> <struct> <new-value>)"
              putStrLn "init (stack allocation)"
              putStrLn "new (heap allocation)"
              putStrLn "copy"
              putStrLn "delete (used internally, no need to call this explicitly)"
              putStrLn ""
              return dynamicNil

commandHelp [XObj(Str "shortcuts") _ _] =
  liftIO $ do putStrLn "GHC-style shortcuts at the repl:"
              putStrLn "(reload)   :r"
              putStrLn "(build)    :b"
              putStrLn "(run)      :x"
              putStrLn "(cat)      :c"
              putStrLn "(env)      :e"
              putStrLn "(help)     :h"
              putStrLn "(project)  :p"
              putStrLn "(quit)     :q"
              putStrLn ""
              putStrLn "The shortcuts can be combined like this: \":rbx\""
              putStrLn ""
              return dynamicNil

commandHelp [XObj(Str "interop") _ _] =
  liftIO $ do putStrLn "(register <name> <type>)                      - Make an external variable or function available for usage."
              putStrLn "(register-type <name> [<member> <type>, ...]) - Make an external struct available for usage."
              putStrLn ""
              putStrLn "C-compiler configuration:"
              putStrLn "(system-include <file>)          - Include a system header file."
              putStrLn "(local-include <file>)           - Include a local header file."
              putStrLn "(add-cflag <flag>)               - Add a cflag to the compilation step."
              putStrLn "(add-lib <flag>)                 - Add a library flag to the compilation step."
              return dynamicNil

commandHelp [XObj(Str "project") _ _] =
  liftIO $ do putStrLn "(Project.config <setting> <value>) handles the following settings:"
              putStrLn ""
              putStrLn "'cflag'              - Add a flag to the compiler."
              putStrLn "'libflag'            - Add a library flag to the compiler."
              putStrLn "'compiler'           - Set what compiler should be run with the 'build' command."
              putStrLn "'title'              - Set the title of the current project, will affect the name of the binary produced."
              putStrLn "'output-directory'   - Where to put compiler artifacts, etc."
              putStrLn "'docs-directory'     - Where to put generated documentation."
              putStrLn "'prompt'             - Set the prompt in the repl."
              putStrLn "'search-path'        - Add a path where the Carp compiler will look for '*.carp' files."
              putStrLn ""
              putStrLn "'echo-c'             - When a form is defined using 'def' or 'defn' its C code will be printed."
              putStrLn "'echo-compiler-cmd'  - When building the project the command for running the C compiler will be printed."
              putStrLn "'print-ast'          - The 'info' command will print the AST for a binding."
              putStrLn ""
              return dynamicNil

commandHelp [] =
  liftIO $ do putStrLn "Compiler commands:"
              putStrLn "(load <file>)      - Load a .carp file, evaluate its content, and add it to the project."
              putStrLn "(reload)           - Reload all the project files."
              putStrLn "(build)            - Produce an executable or shared library."
              putStrLn "(run)              - Run the executable produced by 'build' (if available)."
              putStrLn "(cat)              - Look at the generated C code (make sure you build first)."
              putStrLn "(env)              - List the bindings in the global environment."
              putStrLn "(type <symbol>)    - Get the type of a binding."
              putStrLn "(info <symbol>)    - Get information about a binding."
              putStrLn "(project)          - Display information about your project."
              putStrLn "(quit)             - Terminate this Carp REPL."
              putStrLn "(help <chapter>)   - Available chapters: \"language\", \"macros\", \"structs\", \"interop\", \"shortcuts\", \"project\", \"about\"."
              putStrLn ""
              putStrLn "(Project.config! <setting> <value>) - Change a project setting."
              putStrLn ""
              putStrLn "To define things:"
              putStrLn "(def <name> <constant>)                       - Define a global variable."
              putStrLn "(defn <name> [<args>] <body>)                 - Define a function."
              putStrLn "(definterface <name> <type>)                  - Create an interface for a group of functions sharing the same name."
              putStrLn "(defmodule <name> <def1> <def2> ...)          - Define a module and/or add definitions to an existing one."
              putStrLn "(deftype <name> [<member> <type>, ...])       - Define a new struct type."
              putStrLn ""
              putStrLn "Compiler flags:"
              putStrLn "-b                               - Build."
              putStrLn "-x                               - Build and run."
              putStrLn "--no-core                        - Don't load the core library."
              putStrLn "--log-memory                     - Enables use of memory logging functions in the Debug module."
              putStrLn "--optimize                       - Removes safety checks and runs the C-compiler with the '-O3' flag."
              putStrLn "--check                          - Report all errors found in a machine readable way."
              return dynamicNil

commandHelp args =
  do liftIO $ putStrLn ("Can't find help for " ++ joinWithComma (map pretty args))
     return dynamicNil

-- | Command for printing information about the current project.
commandProject :: CommandCallback
commandProject args =
  do ctx <- get
     liftIO (print (contextProj ctx))
     return dynamicNil

-- | Command for printing a message to the screen.
commandPrint :: CommandCallback
commandPrint args =
  do liftIO $ mapM_ (putStrLn . pretty) args
     return dynamicNil

-- | Command for getting the name of the operating system you're on.
commandOS :: CommandCallback
commandOS _ =
  return (Right (XObj (Str os) (Just dummyInfo) (Just StringTy)))

-- | Command for adding a header file include to the project.
commandAddInclude :: (String -> Includer) -> CommandCallback
commandAddInclude includerConstructor [XObj (Str file) _ _] =
  do ctx <- get
     let proj = contextProj ctx
         includer = includerConstructor file
         includers = projectIncludes proj
         includers' = if includer `elem` includers
                      then includers
                      else includer : includers
         proj' = proj { projectIncludes = includers' }
     put (ctx { contextProj = proj' })
     return dynamicNil

commandAddSystemInclude = commandAddInclude SystemInclude
commandAddLocalInclude  = commandAddInclude LocalInclude

commandIsList :: CommandCallback
commandIsList [x] =
  case x of
    XObj (Lst _) _ _ -> return (Right trueXObj)
    _ -> return (Right falseXObj)

commandIsArray :: CommandCallback
commandIsArray [x] =
  case x of
    XObj (Arr _) _ _ -> return (Right trueXObj)
    _ -> return (Right falseXObj)

commandIsSymbol :: CommandCallback
commandIsSymbol [x] =
  case x of
    XObj (Sym _ _) _ _ -> return (Right trueXObj)
    _ -> return (Right falseXObj)

commandLength :: CommandCallback
commandLength [x] =
  case x of
    XObj (Lst lst) _ _ -> return (Right (XObj (Num IntTy (fromIntegral (length lst))) Nothing Nothing))
    XObj (Arr arr) _ _ -> return (Right (XObj (Num IntTy (fromIntegral (length arr))) Nothing Nothing))
    _ -> return (Left (EvalError ("Applying 'length' to non-list: " ++ pretty x ++ " at " ++ prettyInfoFromXObj x)))

commandCar :: CommandCallback
commandCar [x] =
  case x of
    XObj (Lst (car : _)) _ _ -> return (Right car)
    XObj (Arr (car : _)) _ _ -> return (Right car)
    _ -> return (Left (EvalError ("Applying 'car' to non-list: " ++ pretty x)))

commandCdr :: CommandCallback
commandCdr [x] =
  case x of
    XObj (Lst (_ : cdr)) i _ -> return (Right (XObj (Lst cdr) i Nothing))
    XObj (Arr (_ : cdr)) i _ -> return (Right (XObj (Arr cdr) i Nothing))
    _ -> return (Left (EvalError "Applying 'cdr' to non-list or empty list"))

commandLast :: CommandCallback
commandLast [x] =
  case x of
    XObj (Lst lst) _ _ -> return (Right (last lst))
    XObj (Arr arr) _ _ -> return (Right (last arr))
    _ -> return (Left (EvalError "Applying 'last' to non-list or empty list."))

commandAllButLast :: CommandCallback
commandAllButLast [x] =
  case x of
    XObj (Lst lst) i _ -> return (Right (XObj (Lst (init lst)) i Nothing))
    XObj (Arr arr) i _ -> return (Right (XObj (Arr (init arr)) i Nothing))
    _ -> return (Left (EvalError "Applying 'all-but-last' to non-list or empty list."))

commandCons :: CommandCallback
commandCons [x, xs] =
  case xs of
    XObj (Lst lst) _ _ -> return (Right (XObj (Lst (x : lst)) (info x) (ty x))) -- TODO: probably not correct to just copy 'i' and 't'?
    XObj (Arr arr) _ _ -> return (Right (XObj (Arr (x : arr)) (info x) (ty x)))
    _ -> return (Left (EvalError "Applying 'cons' to non-list or empty list."))

commandConsLast :: CommandCallback
commandConsLast [x, xs] =
  case xs of
    XObj (Lst lst) i t -> return (Right (XObj (Lst (lst ++ [x])) i t)) -- TODO: should they get their own i:s and t:s
    _ -> return (Left (EvalError "Applying 'cons-last' to non-list or empty list."))

commandAppend :: CommandCallback
commandAppend [xs, ys] =
  case (xs, ys) of
    (XObj (Lst lst1) i t, XObj (Lst lst2) _ _) ->
      return (Right (XObj (Lst (lst1 ++ lst2)) i t)) -- TODO: should they get their own i:s and t:s
    _ ->
      return (Left (EvalError "Applying 'append' to non-list or empty list."))

commandMacroError :: CommandCallback
commandMacroError [msg] =
  case msg of
    XObj (Str msg) _ _ -> return (Left (EvalError msg))
    x                  -> return (Left (EvalError (pretty x)))

commandMacroLog :: CommandCallback
commandMacroLog [msg] =
  case msg of
    XObj (Str msg) _ _ -> do liftIO (putStrLn msg)
                             return dynamicNil
    x                  -> do liftIO (putStrLn (pretty x))
                             return dynamicNil

commandEq :: CommandCallback
commandEq [a, b] =
  return $ case (a, b) of
    (XObj (Num IntTy aNum) _ _, XObj (Num IntTy bNum) _ _) ->
      if (round aNum :: Int) == (round bNum :: Int)
      then Right trueXObj else Right falseXObj
    (XObj (Num LongTy aNum) _ _, XObj (Num LongTy bNum) _ _) ->
      if (round aNum :: Int) == (round bNum :: Int)
      then Right trueXObj else Right falseXObj
    (XObj (Num FloatTy aNum) _ _, XObj (Num floatTy bNum) _ _) ->
      if aNum == bNum
      then Right trueXObj else Right falseXObj
    (XObj (Num DoubleTy aNum) _ _, XObj (Num DoubleTy bNum) _ _) ->
      if aNum == bNum
      then Right trueXObj else Right falseXObj
    (XObj (Str sa) _ _, XObj (Str sb) _ _) ->
      if sa == sb then Right trueXObj else Right falseXObj
    (XObj (Chr ca) _ _, XObj (Chr cb) _ _) ->
      if ca == cb then Right trueXObj else Right falseXObj
    (XObj (Sym sa _) _ _, XObj (Sym sb _) _ _) ->
      if sa == sb then Right trueXObj else Right falseXObj
    (XObj (Bol xa) _ _, XObj (Bol xb) _ _) ->
      if xa == xb then Right trueXObj else Right falseXObj
    (XObj (Lst []) _ _, XObj (Lst []) _ _) ->
      Right trueXObj
    _ ->
      Left (EvalError ("Can't compare " ++ pretty a ++ " with " ++ pretty b))

commandLt :: CommandCallback
commandLt [a, b] =
 return $ case (a, b) of
   (XObj (Num IntTy aNum) _ _, XObj (Num IntTy bNum) _ _) ->
     if (round aNum :: Int) < (round bNum :: Int)
     then Right trueXObj else Right falseXObj
   (XObj (Num LongTy aNum) _ _, XObj (Num LongTy bNum) _ _) ->
     if (round aNum :: Int) < (round bNum :: Int)
     then Right trueXObj else Right falseXObj
   (XObj (Num FloatTy aNum) _ _, XObj (Num floatTy bNum) _ _) ->
     if aNum < bNum
     then Right trueXObj else Right falseXObj
   (XObj (Num DoubleTy aNum) _ _, XObj (Num DoubleTy bNum) _ _) ->
     if aNum < bNum
     then Right trueXObj else Right falseXObj
   _ ->
     Left (EvalError ("Can't compare (<) " ++ pretty a ++ " with " ++ pretty b))

commandGt :: CommandCallback
commandGt [a, b] =
  return $ case (a, b) of
    (XObj (Num IntTy aNum) _ _, XObj (Num IntTy bNum) _ _) ->
      if (round aNum :: Int) > (round bNum :: Int)
      then Right trueXObj else Right falseXObj
    (XObj (Num LongTy aNum) _ _, XObj (Num LongTy bNum) _ _) ->
      if (round aNum :: Int) > (round bNum :: Int)
      then Right trueXObj else Right falseXObj
    (XObj (Num FloatTy aNum) _ _, XObj (Num floatTy bNum) _ _) ->
      if aNum > bNum
      then Right trueXObj else Right falseXObj
    (XObj (Num DoubleTy aNum) _ _, XObj (Num DoubleTy bNum) _ _) ->
      if aNum > bNum
      then Right trueXObj else Right falseXObj
    _ ->
      Left (EvalError ("Can't compare (>) " ++ pretty a ++ " with " ++ pretty b))

commandCharAt :: CommandCallback
commandCharAt [a, b] =
  return $ case (a, b) of
    (XObj (Str s) _ _, XObj (Num IntTy n) _ _) ->
      Right (XObj (Chr (s !! (round n :: Int))) (Just dummyInfo) (Just IntTy))
    _ ->
      Left (EvalError ("Can't call char-at with " ++ pretty a ++ " and " ++ pretty b))

commandIndexOf :: CommandCallback
commandIndexOf [a, b] =
  return $ case (a, b) of
    (XObj (Str s) _ _, XObj (Chr c) _ _) ->
      Right (XObj (Num IntTy (getIdx c s)) (Just dummyInfo) (Just IntTy))
    _ ->
      Left (EvalError ("Can't call index-of with " ++ pretty a ++ " and " ++ pretty b))
  where getIdx c s = fromIntegral $ fromMaybe (-1) $ elemIndex c s

commandSubstring :: CommandCallback
commandSubstring [a, b, c] =
  return $ case (a, b, c) of
    (XObj (Str s) _ _, XObj (Num IntTy f) _ _, XObj (Num IntTy t) _ _) ->
      Right (XObj (Str (take (round t :: Int) (drop (round f :: Int) s))) (Just dummyInfo) (Just StringTy))
    _ ->
      Left (EvalError ("Can't call substring with " ++ pretty a ++ ", " ++ pretty b ++ " and " ++ pretty c))

commandStringLength :: CommandCallback
commandStringLength [a] =
  return $ case a of
    XObj (Str s) _ _ ->
      Right (XObj (Num IntTy (fromIntegral (length s))) (Just dummyInfo) (Just IntTy))
    _ ->
      Left (EvalError ("Can't call length with " ++ pretty a))

commandStringJoin :: CommandCallback
commandStringJoin [a] =
  return $ case a of
    XObj (Arr strings) _ _ ->
      case (sequence (map unwrapStringXObj strings)) of
        Left err -> Left (EvalError err)
        Right result -> Right (XObj (Str (join result)) (Just dummyInfo) (Just StringTy))
    _ ->
      Left (EvalError ("Can't call join with " ++ pretty a))

commandStringDirectory :: CommandCallback
commandStringDirectory [a] =
  return $ case a of
    XObj (Str s) _ _ ->
      Right (XObj (Str (takeDirectory s)) (Just dummyInfo) (Just StringTy))
    _ ->
      Left (EvalError ("Can't call directory with " ++ pretty a))

commandPlus :: CommandCallback
commandPlus [a, b] =
  return $ case (a, b) of
    (XObj (Num aty aNum) _ _, XObj (Num bty bNum) _ _) ->
      if aty == bty
      then Right (XObj (Num aty (aNum + bNum)) (Just dummyInfo) (Just aty))
      else Left (EvalError ("Can't call + with " ++ pretty a ++ " and " ++ pretty b))
    _ ->
      Left (EvalError ("Can't call + with " ++ pretty a ++ " and " ++ pretty b))

commandMinus :: CommandCallback
commandMinus [a, b] =
  return $ case (a, b) of
    (XObj (Num aty aNum) _ _, XObj (Num bty bNum) _ _) ->
      if aty == bty
      then Right (XObj (Num aty (aNum - bNum)) (Just dummyInfo) (Just aty))
      else Left (EvalError ("Can't call - with " ++ pretty a ++ " and " ++ pretty b))
    _ ->
      Left (EvalError ("Can't call - with " ++ pretty a ++ " and " ++ pretty b))

commandDiv :: CommandCallback
commandDiv [a, b] =
  return $ case (a, b) of
    (XObj (Num IntTy aNum) _ _, XObj (Num IntTy bNum) _ _) ->
      Right (XObj (Num IntTy (fromIntegral (quot (round aNum ::Int) (round bNum :: Int)))) (Just dummyInfo) (Just IntTy))
    (XObj (Num aty aNum) _ _, XObj (Num bty bNum) _ _) ->
      if aty == bty
      then Right (XObj (Num aty (aNum / bNum)) (Just dummyInfo) (Just aty))
      else Left (EvalError ("Can't call / with " ++ pretty a ++ " and " ++ pretty b))
    _ ->
      Left (EvalError ("Can't call / with " ++ pretty a ++ " and " ++ pretty b))

commandMul :: CommandCallback
commandMul [a, b] =
  return $ case (a, b) of
    (XObj (Num aty aNum) _ _, XObj (Num bty bNum) _ _) ->
      if aty == bty
      then Right (XObj (Num aty (aNum * bNum)) (Just dummyInfo) (Just aty))
      else Left (EvalError ("Can't call * with " ++ pretty a ++ " and " ++ pretty b))
    _ ->
      Left (EvalError ("Can't call * with " ++ pretty a ++ " and " ++ pretty b))

commandStr :: CommandCallback
commandStr xs =
  return (Right (XObj (Str (join (map f xs))) (Just dummyInfo) (Just StringTy)))
  -- | TODO: Is there a better function to call here than some exceptions + 'pretty'?
  where f (XObj (Str s) _ _) = s
        f (XObj (Sym path mode) _ _) = show path
        f x = escape $ pretty x
        escape [] = []
        escape ('\\':y) = "\\\\" ++ escape y
        escape (x:y) = x : escape y

commandNot :: CommandCallback
commandNot [x] =
  case x of
    XObj (Bol ab) _ _ ->
      if ab
      then return (Right falseXObj)
      else return (Right trueXObj)
    _ ->
      return (Left (EvalError ("Can't perform logical operation (not) on " ++ pretty x)))

commandSaveDocsInternal :: CommandCallback
commandSaveDocsInternal [modulePath] =
  do ctx <- get
     let globalEnv = contextGlobalEnv ctx
     case modulePath of
       XObj (Lst xobjs) _ _ ->
         case sequence (map unwrapSymPathXObj xobjs) of
           Left err -> return (Left (EvalError err))
           Right okPaths ->
             case sequence (map (getEnvironmentForDocumentation globalEnv) okPaths) of
               Left err -> return (Left err)
               Right okEnvs -> saveDocs (zip okPaths okEnvs)
       x ->
         return (Left (EvalError ("Invalid arg to save-docs-internal (expected list of symbols): " ++ pretty x)))
  where getEnvironmentForDocumentation :: Env -> SymPath -> Either EvalError Env
        getEnvironmentForDocumentation env path =
          case lookupInEnv path env of
            Just (_, Binder _ (XObj (Mod foundEnv) _ _)) ->
              Right foundEnv
            Just (_, Binder _ x) ->
              Left (EvalError ("Non module can't be saved: " ++ pretty x))
            Nothing ->
              Left (EvalError ("Can't find module at '" ++ show path ++ "'"))

saveDocs :: [(SymPath, Env)] -> StateT Context IO (Either EvalError XObj)
saveDocs pathsAndEnvs =
  do ctx <- get
     let proj = contextProj ctx
         docsDir = projectDocsDir proj
         title = projectTitle proj
     liftIO (saveDocsForEnvs docsDir title pathsAndEnvs)
     return dynamicNil
module Concretize where

import Control.Monad.State
import qualified Data.Map as Map
import Data.Maybe (fromMaybe, fromJust)
import qualified Data.Set as Set
import Data.Set ((\\))
import Data.List (foldl')
import Debug.Trace

import Obj
import Constraints
import Types
import Util
import TypeError
import AssignTypes
import Polymorphism
import InitialTypes
import Lookup
import ToTemplate

--import Template
--import ArrayTemplates

-- | This function performs two things:
-- |  1. Finds out which polymorphic functions that needs to be added to the environment for the calls in the function to work.
-- |  2. Changes the name of symbols at call sites so they use the polymorphic name
-- |  Both of these results are returned in a tuple: (<new xobj>, <dependencies>)
concretizeXObj :: Bool -> TypeEnv -> Env -> [SymPath] -> XObj -> Either TypeError (XObj, [XObj])
concretizeXObj allowAmbiguityRoot typeEnv rootEnv visitedDefinitions root =
  case runState (visit allowAmbiguityRoot rootEnv root) [] of
    (Left err, _) -> Left err
    (Right xobj, deps) -> Right (xobj, deps)
  where
    rootDefinitionPath :: SymPath
    rootDefinitionPath = getPath root

    visit :: Bool -> Env -> XObj -> State [XObj] (Either TypeError XObj)
    visit allowAmbig env xobj@(XObj (Sym _ _) _ _) = visitSymbol allowAmbig env xobj
    visit allowAmbig env xobj@(XObj (MultiSym _ _) _ _) = visitMultiSym allowAmbig env xobj
    visit allowAmbig env xobj@(XObj (InterfaceSym _) _ _) = visitInterfaceSym allowAmbig env xobj
    visit allowAmbig env xobj@(XObj (Lst _) i t) =
      do visited <- visitList allowAmbig env xobj
         return $ do okVisited <- visited
                     Right (XObj (Lst okVisited) i t)
    visit allowAmbig env xobj@(XObj (Arr arr) i (Just t)) =
      do visited <- fmap sequence (mapM (visit allowAmbig env) arr)
         concretizeTypeOfXObj typeEnv xobj
         return $ do okVisited <- visited
                     Right (XObj (Arr okVisited) i (Just t))
    visit _ _ x = return (Right x)

    visitList :: Bool -> Env -> XObj -> State [XObj] (Either TypeError [XObj])
    visitList _ _ (XObj (Lst []) _ _) = return (Right [])

    visitList _ env (XObj (Lst [defn@(XObj Defn _ _), nameSymbol@(XObj (Sym (SymPath [] "main") _) _ _), args@(XObj (Arr argsArr) _ _), body]) _ _) =
      if not (null argsArr)
      then return $ Left (MainCannotHaveArguments nameSymbol (length argsArr))
      else do visitedBody <- visit False env body -- allowAmbig == 'False'
              return $ do okBody <- visitedBody
                          let t = fromMaybe UnitTy (ty okBody)
                          if not (isTypeGeneric t) && t /= UnitTy && t /= IntTy
                            then Left (MainCanOnlyReturnUnitOrInt nameSymbol t)
                            else return [defn, nameSymbol, args, okBody]

    visitList _ env (XObj (Lst [defn@(XObj Defn _ _), nameSymbol, args@(XObj (Arr argsArr) _ _), body]) _ t) =
      do mapM_ (concretizeTypeOfXObj typeEnv) argsArr
         let functionEnv = Env Map.empty (Just env) Nothing [] InternalEnv 0
             envWithArgs = foldl' (\e arg@(XObj (Sym (SymPath _ argSymName) _) _ _) ->
                                     extendEnv e argSymName arg)
                                  functionEnv argsArr
             Just funcTy = t
             allowAmbig = isTypeGeneric funcTy
         visitedBody <- visit allowAmbig envWithArgs body
         return $ do okBody <- visitedBody
                     return [defn, nameSymbol, args, okBody]

    -- | Fn / λ
    visitList allowAmbig env (XObj (Lst [(XObj (Fn _ _) fni fnt), args@(XObj (Arr argsArr) ai at), body]) i t) =
      -- The basic idea of this function is to first visit the body of the lambda ("in place"),
      -- then take the resulting body and put into a separate function 'defn' with a new name
      -- in the global scope. That function definition will be set as the lambdas '.callback' in
      -- the C code.
      do mapM_ (concretizeTypeOfXObj typeEnv) argsArr
         let Just ii = i
             Just funcTy = t
              -- | TODO: This code is a copy of the one above in Defn, remove duplication:
             functionEnv = Env Map.empty (Just env) Nothing [] InternalEnv (envFunctionNestingLevel env + 1)
             envWithArgs = foldl' (\e arg@(XObj (Sym (SymPath _ argSymName) _) _ _) ->
                                     extendEnv e argSymName arg)
                                  functionEnv argsArr
         visitedBody <- visit allowAmbig envWithArgs body
         case visitedBody of
           Right (okBody) ->
             let -- Analyse the body of the lambda to find what variables it captures
                 capturedVars = collectCapturedVars okBody

                 -- Create a new (top-level) function that will be used when the lambda is called.
                 -- Its name will contain the name of the (normal, non-lambda) function it's contained within,
                 -- plus the identifier of the particular s-expression that defines the lambda.
                 SymPath path name = rootDefinitionPath
                 lambdaPath = SymPath path ("_Lambda_" ++ name ++ "_" ++ show (infoIdentifier ii))
                 lambdaNameSymbol = XObj (Sym lambdaPath Symbol) (Just dummyInfo) Nothing
                 extendedArgs = if null capturedVars
                                then args
                                     -- If the lambda captures anything it need an extra arg for its env:
                                else XObj (Arr (XObj (Sym (SymPath [] "_env") Symbol)
                                                (Just dummyInfo)
                                                (Just (PointerTy (StructTy environmentTypeName []))) :
                                                argsArr)) ai at
                 lambdaCallback = XObj (Lst [XObj Defn (Just dummyInfo) Nothing, lambdaNameSymbol, extendedArgs, okBody]) i t

                 -- The lambda will also carry with it a special made struct containing the variables it captures
                 -- (if it captures at least one variable)
                 structMemberPairs = concatMap (\(XObj (Sym path _) _ (Just symTy)) ->
                                                  [XObj (Sym path Symbol) Nothing Nothing, tyToXObj symTy])
                                     capturedVars
                 environmentTypeName = pathToC lambdaPath ++ "_env"
                 environmentStructTy = StructTy environmentTypeName []
                 environmentStruct = XObj (Lst (XObj (Typ environmentStructTy) Nothing Nothing :
                                                XObj (Sym (SymPath [] environmentTypeName) Symbol) Nothing Nothing :
                                                XObj (Arr structMemberPairs) Nothing Nothing :
                                                [])) i (Just TypeTy)

                 pairs = memberXObjsToPairs structMemberPairs

                 deleteFnTy = typesDeleterFunctionType (PointerTy environmentStructTy)
                 deleteFnTemplate = concreteDeleteTakePtr typeEnv env pairs
                 (deleteFn, deleterDeps) = instantiateTemplate (SymPath [] (environmentTypeName ++ "_delete")) deleteFnTy deleteFnTemplate

                 copyFnTy = typesCopyFunctionType environmentStructTy
                 copyFnTemplate = concreteCopy typeEnv env pairs
                 (copyFn, copyDeps) = instantiateTemplate (SymPath [] (environmentTypeName ++ "_copy")) copyFnTy copyFnTemplate

                 -- The type env has to contain the lambdas environment struct for 'concretizeDefinition' to work:
                 extendedTypeEnv = TypeEnv (extendEnv (getTypeEnv typeEnv) environmentTypeName environmentStruct)

             in case concretizeDefinition allowAmbig extendedTypeEnv env visitedDefinitions lambdaCallback funcTy of
                  Left err -> return (Left err)
                  Right (concreteLiftedLambda, deps) ->
                    do when (not (or (map (isTypeGeneric . snd) pairs))) $
                         do modify (concreteLiftedLambda :)
                            modify (deps ++)
                            when (not (null capturedVars)) $
                              do modify (environmentStruct :)
                                 modify (deleteFn :)
                                 modify (deleterDeps ++)
                                 modify (copyFn :)
                                 modify (copyDeps ++)
                       return (Right [XObj (Fn (Just lambdaPath) (Set.fromList capturedVars)) fni fnt, args, okBody])
           _ ->
             error "Visited body isn't a defn."

    visitList _ env (XObj (Lst [def@(XObj Def _ _), nameSymbol, body]) _ t) =
      do let Just defTy = t
             allowAmbig = isTypeGeneric defTy
         visitedBody <- visit allowAmbig env body
         return $ do okBody <- visitedBody
                     return [def, nameSymbol, okBody]

    visitList allowAmbig env (XObj (Lst [letExpr@(XObj Let _ _), XObj (Arr bindings) bindi bindt, body]) _ _) =
      do visitedBindings <- fmap sequence (mapM (visit allowAmbig env) bindings)
         visitedBody <- visit allowAmbig env body
         mapM_ (concretizeTypeOfXObj typeEnv) (map fst (pairwise bindings))
         return $ do okVisitedBindings <- visitedBindings
                     okVisitedBody <- visitedBody
                     return [letExpr, XObj (Arr okVisitedBindings) bindi bindt, okVisitedBody]

    visitList allowAmbig env (XObj (Lst [theExpr@(XObj The _ _), typeXObj, value]) _ _) =
      do visitedValue <- visit allowAmbig env value
         return $ do okVisitedValue <- visitedValue
                     return [theExpr, typeXObj, okVisitedValue]

    visitList allowAmbig env (XObj (Lst (func : args)) _ _) =
      do concretizeTypeOfXObj typeEnv func
         mapM_ (concretizeTypeOfXObj typeEnv) args
         f <- visit allowAmbig env func
         a <- fmap sequence (mapM (visit allowAmbig env) args)
         return $ do okF <- f
                     okA <- a
                     return (okF : okA)

    visitSymbol :: Bool -> Env -> XObj -> State [XObj] (Either TypeError XObj)
    visitSymbol allowAmbig env xobj@(XObj (Sym path lookupMode) i t) =
      case lookupInEnv path env of
        Just (foundEnv, binder)
          | envIsExternal foundEnv ->
            let theXObj = binderXObj binder
                Just theType = ty theXObj
                typeOfVisited = case t of
                                  Just something -> something
                                  Nothing -> error ("Missing type on " ++ show xobj ++ " at " ++ prettyInfoFromXObj xobj)
            in if --(trace $ "CHECKING " ++ getName xobj ++ " : " ++ show theType ++ " with visited type " ++ show typeOfVisited ++ " and visited definitions: " ++ show visitedDefinitions) $
                  isTypeGeneric theType && not (isTypeGeneric typeOfVisited)
                  then case concretizeDefinition allowAmbig typeEnv env visitedDefinitions theXObj typeOfVisited of
                         Left err -> return (Left err)
                         Right (concrete, deps) ->
                           do modify (concrete :)
                              modify (deps ++)
                              return (Right (XObj (Sym (getPath concrete) lookupMode) i t))
                  else return (Right xobj)
          | otherwise -> return (Right xobj)
        Nothing -> return (Right xobj)
    visitSymbol _ _ _ = error "Not a symbol."

    visitMultiSym :: Bool -> Env -> XObj -> State [XObj] (Either TypeError XObj)
    visitMultiSym allowAmbig env xobj@(XObj (MultiSym originalSymbolName paths) i t) =
      let Just actualType = t
          tys = map (typeFromPath env) paths
          modes = map (modeFromPath env) paths
          tysToPathsDict = zip tys paths
          tysPathsModes = zip3 tys paths modes
      in  case filter (matchingSignature3 actualType) tysPathsModes of
            [] ->
              --if allowAmbiguity
              --then return (Right xobj)
              --else
              return (Left (NoMatchingSignature xobj originalSymbolName actualType tysToPathsDict))
            [(theType, singlePath, mode)] -> let Just t' = t
                                                 fake1 = XObj (Sym (SymPath [] "theType") Symbol) Nothing Nothing
                                                 fake2 = XObj (Sym (SymPath [] "xobjType") Symbol) Nothing Nothing
                                                 Just i' = i
                                       in  case solve [Constraint theType t' fake1 fake2 OrdMultiSym] of
                                             Right mappings ->
                                               let replaced = replaceTyVars mappings t'
                                                   suffixed = suffixTyVars ("_x" ++ show (infoIdentifier i')) replaced -- Make sure it gets unique type variables. TODO: Is there a better way?
                                                   normalSymbol = XObj (Sym singlePath mode) i (Just suffixed)
                                               in visitSymbol allowAmbig env $ --(trace ("Disambiguated " ++ pretty xobj ++ " at " ++ prettyInfoFromXObj xobj ++ " to " ++ show singlePath ++ " : " ++ show suffixed ++ ", used to be " ++ show t' ++ ", theType = " ++ show theType ++ ", mappings = " ++ show mappings))
                                                              normalSymbol
                                             Left failure@(UnificationFailure _ _) ->
                                               return $ Left (UnificationFailed
                                                              (unificationFailure failure)
                                                              (unificationMappings failure)
                                                              [])
                                             Left (Holes holes) ->
                                               return $ Left (HolesFound holes)
            severalPaths -> return (Right xobj)
                            -- if allowAmbig
                            -- then
                            -- else return (Left (CantDisambiguate xobj originalSymbolName actualType severalPaths))

    visitMultiSym _ _ _ = error "Not a multi symbol."

    visitInterfaceSym :: Bool -> Env -> XObj -> State [XObj] (Either TypeError XObj)
    visitInterfaceSym allowAmbig env xobj@(XObj (InterfaceSym name) i t) =
      case lookupInEnv (SymPath [] name) (getTypeEnv typeEnv) of
        Just (_, Binder _ (XObj (Lst [XObj (Interface interfaceSignature interfacePaths) _ _, _]) _ _)) ->
          let Just actualType = t
              tys = map (typeFromPath env) interfacePaths
              tysToPathsDict = zip tys interfacePaths
          in  case filter (matchingSignature actualType) tysToPathsDict of
                [] -> return $ -- (trace ("No matching signatures for interface lookup of " ++ name ++ " of type " ++ show actualType ++ " " ++ prettyInfoFromXObj xobj ++ ", options are:\n" ++ joinWith "\n" (map show tysToPathsDict))) $
                                 if allowAmbig
                                 then (Right xobj) -- No exact match of types
                                 else (Left (NoMatchingSignature xobj name actualType tysToPathsDict))
                [(theType, singlePath)] ->
                  --(trace ("One matching signature for interface lookup of '" ++ name ++ "' with single path " ++ show singlePath ++ " of type " ++ show theType ++ " at " ++ prettyInfoFromXObj xobj ++ ", original symbol: " ++ show xobj)) $
                  let Just tt = t
                  in  if isTypeGeneric tt then return (Right xobj) else replace theType singlePath
                severalPaths ->
                    --(trace ("Several matching signatures for interface lookup of '" ++ name ++ "' of type " ++ show actualType ++ " " ++ prettyInfoFromXObj xobj ++ ", options are:\n" ++ joinWith "\n" (map show tysToPathsDict) ++ "\n  Filtered paths are:\n" ++ (joinWith "\n" (map show severalPaths)))) $
                    --(Left (CantDisambiguateInterfaceLookup xobj name interfaceType severalPaths)) -- TODO unnecessary error?
                    case filter (\(tt, _) -> actualType == tt) severalPaths of
                      []      -> return (Right xobj) -- No exact match of types
                      [(theType, singlePath)] -> replace theType singlePath -- Found an exact match, will ignore any "half matched" functions that might have slipped in.
                      _       -> return (Left (SeveralExactMatches xobj name actualType severalPaths))
              where replace theType singlePath =
                      let normalSymbol = XObj (Sym singlePath (LookupGlobal CarpLand AFunction)) i t -- TODO: Is it surely AFunction here? Could be AVariable as well...!?
                      in visitSymbol allowAmbig env $ -- trace ("Replacing symbol " ++ pretty xobj ++ " with type " ++ show theType ++ " to single path " ++ show singlePath)
                                             normalSymbol

        Nothing ->
          error ("No interface named '" ++ name ++ "' found.")

-- | Find all lookups in a lambda body that should be captured by its environment
collectCapturedVars :: XObj -> [XObj]
collectCapturedVars root = removeDuplicates (map toGeneralSymbol (visit root))
  where
    removeDuplicates :: Ord a => [a] -> [a]
    removeDuplicates = Set.toList . Set.fromList

    toGeneralSymbol :: XObj -> XObj
    toGeneralSymbol (XObj (Sym path _) _ t) = XObj (Sym path Symbol) (Just dummyInfo) t
    toGeneralSymbol x = error ("Can't convert this to a general symbol: " ++ show x)

    visit xobj =
      case obj xobj of
        (Lst _) -> visitList xobj
        (Arr _) -> visitArray xobj
        (Sym path (LookupLocal Capture)) -> [xobj]
        _ -> []

    visitList :: XObj -> [XObj]
    visitList (XObj (Lst xobjs) _ _) =
      concatMap visit xobjs
    visitList _ = error "The function 'visitList' only accepts XObjs with lists in them."

    visitArray :: XObj -> [XObj]
    visitArray (XObj (Arr xobjs) _ _) =
      concatMap visit xobjs
    visitArray _ = error "The function 'visitArray' only accepts XObjs with arrays in them."

-- | Do the signatures match?
matchingSignature :: Ty -> (Ty, SymPath) -> Bool
matchingSignature tA (tB, _) = areUnifiable tA tB

-- | Do the signatures match (tuple arity 3 version)?
matchingSignature3 :: Ty -> (Ty, SymPath, SymbolMode) -> Bool
matchingSignature3 tA (tB, _, _) = areUnifiable tA tB

-- | Does the type of an XObj require additional concretization of generic types or some typedefs for function types, etc?
-- | If so, perform the concretization and append the results to the list of dependencies.
concretizeTypeOfXObj :: TypeEnv -> XObj -> State [XObj] (Either TypeError ())
concretizeTypeOfXObj typeEnv (XObj _ _ (Just t)) =
  case concretizeType typeEnv t of
    Right t -> do modify (t ++)
                  return (Right ())
    Left err -> return (Left (InvalidMemberType err))
concretizeTypeOfXObj _ xobj = return (Right ()) --error ("Missing type: " ++ show xobj)

-- | Find all the concrete deps of a type.
concretizeType :: TypeEnv -> Ty -> Either String [XObj]
concretizeType _ ft@(FuncTy _ _) =
  if isTypeGeneric ft
  then Right []
  else Right [defineFunctionTypeAlias ft]
concretizeType typeEnv arrayTy@(StructTy "Array" varTys) =
  if isTypeGeneric arrayTy
  then Right []
  else do deps <- mapM (concretizeType typeEnv) varTys
          Right ([defineArrayTypeAlias arrayTy] ++ concat deps)
concretizeType typeEnv genericStructTy@(StructTy name _) =
  case lookupInEnv (SymPath [] name) (getTypeEnv typeEnv) of
    Just (_, Binder _ (XObj (Lst (XObj (Typ originalStructTy) _ _ : _ : rest)) _ _)) ->
      if isTypeGeneric originalStructTy
      then instantiateGenericStructType typeEnv originalStructTy genericStructTy rest
      else Right []
    Just (_, Binder _ (XObj (Lst (XObj ExternalType _ _ : _)) _ _)) ->
      Right []
    Just (_, Binder _ x) ->
      error ("Non-deftype found in type env: " ++ show x)
    Nothing ->
      Right [] -- error ("Can't find type " ++ show genericStructTy ++ " with name '" ++ name ++ "' in type env.")
concretizeType env (RefTy rt) =
  concretizeType env rt
concretizeType env (PointerTy pt) =
  concretizeType env pt
concretizeType _ t =
    Right [] -- ignore all other types

-- | Given an generic struct type and a concrete version of it, generate all dependencies needed to use the concrete one.
instantiateGenericStructType :: TypeEnv -> Ty -> Ty -> [XObj] -> Either String [XObj]
instantiateGenericStructType typeEnv originalStructTy@(StructTy _ originalTyVars) genericStructTy membersXObjs =
  -- Turn (deftype (A a) [x a, y a]) into (deftype (A Int) [x Int, y Int])
  let fake1 = XObj (Sym (SymPath [] "a") Symbol) Nothing Nothing
      fake2 = XObj (Sym (SymPath [] "b") Symbol) Nothing Nothing
      XObj (Arr memberXObjs) _ _ = head membersXObjs
  in  case solve [Constraint originalStructTy genericStructTy fake1 fake2 OrdMultiSym] of
        Left e -> error (show e)
        Right mappings ->
          let concretelyTypedMembers = replaceGenericTypeSymbolsOnMembers mappings memberXObjs
          in  case validateMembers typeEnv originalTyVars concretelyTypedMembers of
                Left err -> Left err
                Right () ->
                  let deps = sequence (map (f typeEnv) (pairwise concretelyTypedMembers))
                  in case deps of
                       Left err -> Left err
                       Right okDeps ->
                         Right $ [ XObj (Lst (XObj (Typ genericStructTy) Nothing Nothing :
                                              XObj (Sym (SymPath [] (tyToC genericStructTy)) Symbol) Nothing Nothing :
                                              [(XObj (Arr concretelyTypedMembers) Nothing Nothing)])
                                        ) (Just dummyInfo) (Just TypeTy)
                                 ] ++ concat okDeps

f :: TypeEnv -> (XObj, XObj) -> Either String [XObj]
f typeEnv (_, tyXObj) =
  case (xobjToTy tyXObj) of
    Just okTy -> concretizeType typeEnv okTy
    Nothing -> error ("Failed to convert " ++ pretty tyXObj ++ "to a type.")

-- | Get the type of a symbol at a given path.
typeFromPath :: Env -> SymPath -> Ty
typeFromPath env p =
  case lookupInEnv p env of
    Just (e, Binder _ found)
      | envIsExternal e -> forceTy found
      | otherwise -> error "Local bindings shouldn't be ambiguous."
    Nothing -> error ("Couldn't find " ++ show p ++ " in env:\n" ++ prettyEnvironmentChain env)

-- | Get the mode of a symbol at a given path.
-- |
-- | TODO: this duplicates a bunch of functionality from  Qualify.hs, namely
-- | parts of doesNotBelongToAnInterface.
modeFromPath :: Env -> SymPath -> SymbolMode
modeFromPath env p =
  case lookupInEnv p env of
    Just (_, Binder _ (XObj (Lst ((XObj (External (Just overrideWithName)) _ _) : _)) _ _)) ->
      LookupGlobalOverride overrideWithName
    Just (_, Binder _ found@(XObj (Lst ((XObj (External _) _ _) : _)) _ _)) ->
      LookupGlobal ExternalCode (definitionMode found)
    Just (e, Binder _ found) ->
      case envMode e of
        ExternalEnv ->
          LookupGlobal CarpLand (definitionMode found)
        RecursionEnv -> LookupRecursive
        _ ->  LookupLocal
                (if envFunctionNestingLevel e < envFunctionNestingLevel env
                            then Capture
                            else NoCapture)
    Nothing -> error ("Couldn't find " ++ show p ++ " in env:\n" ++ prettyEnvironmentChain env)

-- | Given a definition (def, defn, template, external) and
--   a concrete type (a type without any type variables)
--   this function returns a new definition with the concrete
--   types assigned, and a list of dependencies.
concretizeDefinition :: Bool -> TypeEnv -> Env -> [SymPath] -> XObj -> Ty -> Either TypeError (XObj, [XObj])
concretizeDefinition allowAmbiguity typeEnv globalEnv visitedDefinitions definition concreteType =
  let SymPath pathStrings name = getPath definition
      Just polyType = ty definition
      suffix = polymorphicSuffix polyType concreteType
      newPath = SymPath pathStrings (name ++ suffix)
  in
    case definition of
      XObj (Lst (XObj Defn _ _ : _)) _ _ ->
        let withNewPath = setPath definition newPath
            mappings = unifySignatures polyType concreteType
        in case assignTypes mappings withNewPath of
          Right typed ->
            if newPath `elem` visitedDefinitions
            then return (trace ("Already visited " ++ show newPath) (withNewPath, []))
            else do (concrete, deps) <- concretizeXObj allowAmbiguity typeEnv globalEnv (newPath : visitedDefinitions) typed
                    (managed, memDeps) <- manageMemory typeEnv globalEnv concrete
                    return (managed, deps ++ memDeps)
          Left e -> Left e
      XObj (Lst (XObj (Deftemplate (TemplateCreator templateCreator)) _ _ : _)) _ _ ->
        let template = templateCreator typeEnv globalEnv
        in  Right (instantiateTemplate newPath concreteType template)
      XObj (Lst [XObj (External _) _ _, _]) _ _ ->
        if name == "NULL"
        then Right (definition, []) -- A hack to make all versions of NULL have the same name
        else let withNewPath = setPath definition newPath
                 withNewType = withNewPath { ty = Just concreteType }
             in  Right (withNewType, [])
      XObj (Lst [XObj (Instantiate template) _ _, _]) _ _ ->
        Right (instantiateTemplate newPath concreteType template)
      err ->
        Left $ CannotConcretize definition

-- | Find ALL functions with a certain name, matching a type signature.
allFunctionsWithNameAndSignature env functionName functionType =
  filter (predicate . ty . binderXObj . snd) (multiLookupALL functionName env)
  where
    predicate (Just t) = --trace ("areUnifiable? " ++ show functionType ++ " == " ++ show t ++ " " ++ show (areUnifiable functionType t)) $
                         areUnifiable functionType t

-- | Find all the dependencies of a polymorphic function with a name and a desired concrete type.
depsOfPolymorphicFunction :: TypeEnv -> Env -> [SymPath] -> String -> Ty -> [XObj]
depsOfPolymorphicFunction typeEnv env visitedDefinitions functionName functionType =
  case allFunctionsWithNameAndSignature env functionName functionType of
    [] ->
      (trace $ "[Warning] No '" ++ functionName ++ "' function found with type " ++ show functionType ++ ".")
      []
    -- TODO: this code was added to solve a bug (presumably) but it seems OK to comment it out?!
    -- [(_, (Binder xobj@(XObj (Lst (XObj (Instantiate template) _ _ : _)) _ _)))] ->
    --   []
    [(_, Binder _ single)] ->
      case concretizeDefinition False typeEnv env visitedDefinitions single functionType of
        Left err -> error (show err)
        Right (ok, deps) -> ok : deps
    _ ->
      (trace $ "Too many '" ++ functionName ++ "' functions found with type " ++ show functionType ++ ", can't figure out dependencies.")
      []

-- | Helper for finding the 'delete' function for a type.
depsForDeleteFunc :: TypeEnv -> Env -> Ty -> [XObj]
depsForDeleteFunc typeEnv env t =
  if isManaged typeEnv t
  then depsOfPolymorphicFunction typeEnv env [] "delete" (FuncTy [t] UnitTy)
  else []

-- | Helper for finding the 'copy' function for a type.
depsForCopyFunc :: TypeEnv -> Env -> Ty -> [XObj]
depsForCopyFunc typeEnv env t =
  if isManaged typeEnv t
  then depsOfPolymorphicFunction typeEnv env [] "copy" (FuncTy [RefTy t] t)
  else []

-- | Helper for finding the 'str' function for a type.
depsForPrnFunc :: TypeEnv -> Env -> Ty -> [XObj]
depsForPrnFunc typeEnv env t =
  if isManaged typeEnv t
  then depsOfPolymorphicFunction typeEnv env [] "prn" (FuncTy [RefTy t] StringTy)
  else depsOfPolymorphicFunction typeEnv env [] "prn" (FuncTy [t] StringTy)

-- | The type of a type's str function.
typesStrFunctionType :: TypeEnv -> Ty -> Ty
typesStrFunctionType typeEnv memberType =
  if isManaged typeEnv memberType
  then FuncTy [RefTy memberType] StringTy
  else FuncTy [memberType] StringTy

-- | The various results when trying to find a function using 'findFunctionForMember'.
data FunctionFinderResult = FunctionFound String
                          | FunctionNotFound String
                          | FunctionIgnored
                          deriving (Show)

-- | TODO: COMMENT THIS
getConcretizedPath :: XObj -> Ty -> SymPath
getConcretizedPath single functionType =
  let Just t' = ty single
      (SymPath pathStrings name) = getPath single
      suffix = polymorphicSuffix t' functionType
  in SymPath pathStrings (name ++ suffix)

-- | Used for finding functions like 'delete' or 'copy' for members of a Deftype (or Array).
findFunctionForMember :: TypeEnv -> Env -> String -> Ty -> (String, Ty) -> FunctionFinderResult
findFunctionForMember typeEnv env functionName functionType (memberName, memberType)
  | isManaged typeEnv memberType =
    case allFunctionsWithNameAndSignature env functionName functionType of
      [] -> FunctionNotFound ("Can't find any '" ++ functionName ++ "' function for member '" ++
                              memberName ++ "' of type " ++ show functionType)
      [(_, Binder _ single)] ->
        let concretizedPath = getConcretizedPath single functionType
        in  FunctionFound (pathToC concretizedPath)
      _ -> FunctionNotFound ("Can't find a single '" ++ functionName ++ "' function for member '" ++
                             memberName ++ "' of type " ++ show functionType)
  | otherwise = FunctionIgnored

-- | TODO: should this be the default and 'findFunctionForMember' be the specific one
findFunctionForMemberIncludePrimitives :: TypeEnv -> Env -> String -> Ty -> (String, Ty) -> FunctionFinderResult
findFunctionForMemberIncludePrimitives typeEnv env functionName functionType (memberName, memberType) =
  case allFunctionsWithNameAndSignature env functionName functionType of
    [] -> FunctionNotFound ("Can't find any '" ++ functionName ++ "' function for member '" ++
                            memberName ++ "' of type " ++ show functionType)
    [(_, Binder _ single)] ->
      let concretizedPath = getConcretizedPath single functionType
      in  FunctionFound (pathToC concretizedPath)
    _ -> FunctionNotFound ("Can't find a single '" ++ functionName ++ "' function for member '" ++
                           memberName ++ "' of type " ++ show functionType)



-- | Manage memory needs access to the concretizer
-- | (and the concretizer needs to manage memory)
-- | so they are put into the same module.

-- | Assign a set of Deleters to the 'infoDelete' field on Info.
setDeletersOnInfo :: Maybe Info -> Set.Set Deleter -> Maybe Info
setDeletersOnInfo i deleters = fmap (\i' -> i' { infoDelete = deleters }) i

-- | Helper function for setting the deleters for an XObj.
del :: XObj -> Set.Set Deleter -> XObj
del xobj deleters = xobj { info = setDeletersOnInfo (info xobj) deleters }

-- | To keep track of the deleters when recursively walking the form.
data MemState = MemState
                { memStateDeleters :: Set.Set Deleter
                , memStateDeps :: [XObj]
                } deriving Show

-- | Find out what deleters are needed and where in an XObj.
-- | Deleters will be added to the info field on XObj so that
-- | the code emitter can access them and insert calls to destructors.
manageMemory :: TypeEnv -> Env -> XObj -> Either TypeError (XObj, [XObj])
manageMemory typeEnv globalEnv root =
  let (finalObj, finalState) = runState (visit root) (MemState (Set.fromList []) [])
      deleteThese = memStateDeleters finalState
      deps = memStateDeps finalState
  in  -- (trace ("Delete these: " ++ joinWithComma (map show (Set.toList deleteThese)))) $
      case finalObj of
        Left err -> Left err
        Right ok -> let newInfo = fmap (\i -> i { infoDelete = deleteThese }) (info ok)
                    in  Right $ (ok { info = newInfo }, deps)

  where visit :: XObj -> State MemState (Either TypeError XObj)
        visit xobj =
          case obj xobj of
            Lst _ -> visitList xobj
            Arr _ -> visitArray xobj
            Str _ -> do manage xobj
                        return (Right xobj)
            _ -> return (Right xobj)

        visitArray :: XObj -> State MemState (Either TypeError XObj)
        visitArray xobj@(XObj (Arr arr) _ _) =
          do mapM_ visit arr
             results <- mapM unmanage arr
             case sequence results of
               Left e -> return (Left e)
               Right _ ->
                 do _ <- manage xobj -- TODO: result is discarded here, is that OK?
                    return (Right xobj)

        visitArray _ = error "Must visit array."

        visitList :: XObj -> State MemState (Either TypeError XObj)
        visitList xobj@(XObj (Lst lst) i t) =
          case lst of
            [defn@(XObj Defn _ _), nameSymbol@(XObj (Sym _ _) _ _), args@(XObj (Arr argList) _ _), body] ->
              let Just funcTy@(FuncTy _ defnReturnType) = t
              in case defnReturnType of
                   RefTy _ ->
                     return (Left (FunctionsCantReturnRefTy xobj funcTy))
                   _ ->
                     do mapM_ manage argList
                        visitedBody <- visit  body
                        result <- unmanage body
                        return $
                          case result of
                            Left e -> Left e
                            Right _ ->
                              do okBody <- visitedBody
                                 return (XObj (Lst [defn, nameSymbol, args, okBody]) i t)

            -- Fn / λ
            [fn@(XObj (Fn _ captures) _ _), args@(XObj (Arr argList) _ _), body] ->
              let Just funcTy@(FuncTy _ fnReturnType) = t
              in  do manage xobj -- manage inner lambdas but leave their bodies unvisited, they will be visited in the lifted version...
                     mapM_ unmanage captures
                     return (Right (XObj (Lst [fn, args, body]) i t))

            [def@(XObj Def _ _), nameSymbol@(XObj (Sym _ _) _ _), expr] ->
              do visitedExpr <- visit  expr
                 result <- unmanage expr
                 return $
                   case result of
                     Left e -> Left e
                     Right () ->
                       do okExpr <- visitedExpr
                          return (XObj (Lst [def, nameSymbol, okExpr]) i t)

            [letExpr@(XObj Let _ _), XObj (Arr bindings) bindi bindt, body] ->
              let Just letReturnType = t
              in case letReturnType of
                RefTy _ ->
                  return (Left (LetCantReturnRefTy xobj letReturnType))
                _ ->
                  do MemState preDeleters _ <- get
                     visitedBindings <- mapM (visitLetBinding ) (pairwise bindings)
                     visitedBody <- visit  body
                     result <- unmanage body
                     case result of
                       Left e -> return (Left e)
                       Right _ ->
                         do MemState postDeleters deps <- get
                            let diff = postDeleters Set.\\ preDeleters
                                newInfo = setDeletersOnInfo i diff
                                survivors = postDeleters Set.\\ diff -- Same as just pre deleters, right?!
                            put (MemState survivors deps)
                            --trace ("LET Pre: " ++ show preDeleters ++ "\nPost: " ++ show postDeleters ++ "\nDiff: " ++ show diff ++ "\nSurvivors: " ++ show survivors)
                            manage xobj
                            return $ do okBody <- visitedBody
                                        okBindings <- fmap (concatMap (\(n,x) -> [n, x])) (sequence visitedBindings)
                                        return (XObj (Lst [letExpr, XObj (Arr okBindings) bindi bindt, okBody]) newInfo t)

            -- Set!
            [setbangExpr@(XObj SetBang _ _), variable, value] ->
                 let varInfo = info variable
                     correctVariableAndMode =
                       case variable of
                         -- DISABLE FOR NOW: (XObj (Lst (XObj (Sym (SymPath _ "copy") _) _ _ : symObj@(XObj (Sym _ _) _ _) : _)) _ _) -> Right symObj
                         symObj@(XObj (Sym _ mode) _ _) -> Right (symObj, mode)
                         anythingElse -> Left (CannotSet anythingElse)
                 in
                 case correctVariableAndMode of
                   Left err ->
                     return (Left err)
                   Right (okCorrectVariable, okMode) ->
                     do MemState preDeleters _ <- get
                        ownsTheVarBefore <- case createDeleter okCorrectVariable of
                                              Nothing -> return (Right ())
                                              Just d -> if Set.member d preDeleters || isLookupGlobal okMode
                                                        then return (Right ())
                                                        else return (Left (UsingUnownedValue variable))

                        visitedValue <- visit  value
                        unmanage value -- The assigned value can't be used anymore
                        MemState managed deps <- get
                        -- Delete the value previously stored in the variable, if it's still alive
                        let deleters = case createDeleter okCorrectVariable of
                                         Just d  -> Set.fromList [d]
                                         Nothing -> Set.empty
                            newVariable =
                              case okMode of
                                Symbol -> error "How to handle this?"
                                LookupLocal captureMode ->
                                  if Set.size (Set.intersection managed deleters) == 1 -- The variable is still alive
                                  then variable { info = setDeletersOnInfo varInfo deleters }
                                  else variable -- don't add the new info = no deleter
                                LookupGlobal _ _ ->
                                  variable { info = setDeletersOnInfo varInfo deleters }

                            traceDeps = trace ("SET!-deleters for " ++ pretty xobj ++ " at " ++ prettyInfoFromXObj xobj ++ ":\n" ++
                                               "unmanaged " ++ pretty value ++ "\n" ++
                                               "managed: " ++ show managed ++ "\n" ++
                                               "deleters: " ++ show deleters ++ "\n")

                        case okMode of
                          Symbol -> error "Should only be be a global/local lookup symbol."
                          LookupLocal _ -> manage okCorrectVariable
                          LookupGlobal _ _ -> return ()

                        return $ do okValue <- visitedValue
                                    okOwnsTheVarBefore <- ownsTheVarBefore -- Force Either to fail
                                    return (XObj (Lst [setbangExpr, newVariable, okValue]) i t)

            [addressExpr@(XObj Address _ _), value] ->
              do visitedValue <- visit  value
                 return $ do okValue <- visitedValue
                             return (XObj (Lst [addressExpr, okValue]) i t)

            [theExpr@(XObj The _ _), typeXObj, value] ->
              do visitedValue <- visit  value
                 result <- transferOwnership  value xobj
                 return $ case result of
                            Left e -> Left e
                            Right _ -> do okValue <- visitedValue
                                          return (XObj (Lst [theExpr, typeXObj, okValue]) i t)

            [refExpr@(XObj Ref _ _), value] ->
              do visitedValue <- visit  value
                 case visitedValue of
                   Left e -> return (Left e)
                   Right visitedValue ->
                     do checkResult <- refCheck visitedValue
                        case checkResult of
                          Left e -> return (Left e)
                          Right () -> return $ Right (XObj (Lst [refExpr, visitedValue]) i t)

            doExpr@(XObj Do _ _) : expressions ->
              do visitedExpressions <- mapM (visit ) expressions
                 result <- transferOwnership  (last expressions) xobj
                 return $ case result of
                            Left e -> Left e
                            Right _ -> do okExpressions <- sequence visitedExpressions
                                          return (XObj (Lst (doExpr : okExpressions)) i t)

            [whileExpr@(XObj While _ _), expr, body] ->
              do MemState preDeleters _ <- get
                 visitedExpr <- visit  expr
                 MemState afterExprDeleters _ <- get
                 visitedBody <- visit  body
                 manage body
                 MemState postDeleters deps <- get
                 -- Visit an extra time to simulate repeated use
                 visitedExpr2 <- visit  expr
                 visitedBody2 <- visit  body
                 let diff = postDeleters \\ preDeleters
                 put (MemState (postDeleters \\ diff) deps) -- Same as just pre deleters, right?!
                 return $ do okExpr <- visitedExpr
                             okBody <- visitedBody
                             okExpr2 <- visitedExpr2 -- This evaluates the second visit so that it actually produces the error
                             okBody2 <- visitedBody2 -- And this one too. Laziness FTW.
                             let newInfo = setDeletersOnInfo i diff
                                 -- Also need to set deleters ON the expression (for first run through the loop)
                                 XObj objExpr objInfo objTy = okExpr
                                 newExprInfo = setDeletersOnInfo objInfo (afterExprDeleters \\ preDeleters)
                                 newExpr = XObj objExpr newExprInfo objTy
                             return (XObj (Lst [whileExpr, newExpr, okBody]) newInfo t)

            [ifExpr@(XObj If _ _), expr, ifTrue, ifFalse] ->
              do visitedExpr <- visit  expr
                 MemState preDeleters deps <- get

                 let (visitedTrue,  stillAliveTrue)  = runState (do { v <- visit  ifTrue;
                                                                      result <- transferOwnership  ifTrue xobj;
                                                                      return $ case result of
                                                                                 Left e -> error (show e) -- Left e
                                                                                 Right () -> v
                                                                    })
                                                       (MemState preDeleters deps)

                     (visitedFalse, stillAliveFalse) = runState (do { v <- visit  ifFalse;
                                                                      result <- transferOwnership   ifFalse xobj;
                                                                      return $ case result of
                                                                                 Left e -> error (show e) -- Left e
                                                                                 Right () -> v
                                                                    })
                                                       (MemState preDeleters deps)

                 let -- TODO! Handle deps from stillAliveTrue/stillAliveFalse
                     deletedInTrue  = preDeleters \\ (memStateDeleters stillAliveTrue)
                     deletedInFalse = preDeleters \\ (memStateDeleters stillAliveFalse)
                     deletedInBoth  = Set.intersection deletedInTrue deletedInFalse
                     createdInTrue  = (memStateDeleters stillAliveTrue)  \\ preDeleters
                     createdInFalse = (memStateDeleters stillAliveFalse) \\ preDeleters
                     selfDeleter = case createDeleter xobj of
                                     Just ok -> Set.fromList [ok]
                                     Nothing -> Set.empty
                     createdAndDeletedInTrue  = createdInTrue  \\ selfDeleter
                     createdAndDeletedInFalse = createdInFalse \\ selfDeleter
                     delsTrue  = Set.union (deletedInFalse \\ deletedInBoth) createdAndDeletedInTrue
                     delsFalse = Set.union (deletedInTrue  \\ deletedInBoth) createdAndDeletedInFalse
                     stillAliveAfter = preDeleters \\ (Set.union deletedInTrue deletedInFalse)

                     traceDeps = trace ("IF-deleters for " ++ pretty xobj ++ " at " ++ prettyInfoFromXObj xobj ++ " " ++ identifierStr xobj ++ ":\n" ++
                                        "preDeleters: " ++ show (preDeleters) ++ "\n" ++
                                        "stillAliveTrue: " ++ show (memStateDeleters stillAliveTrue) ++ "\n" ++
                                        "stillAliveFalse: " ++ show (memStateDeleters stillAliveFalse) ++ "\n" ++
                                        "createdInTrue: " ++ show (createdInTrue) ++ "\n" ++
                                        "createdInFalse: " ++ show (createdInFalse) ++ "\n" ++
                                        "createdAndDeletedInTrue: " ++ show (createdAndDeletedInTrue) ++ "\n" ++
                                        "createdAndDeletedInFalse: " ++ show (createdAndDeletedInFalse) ++ "\n" ++
                                        "deletedInTrue: " ++ show (deletedInTrue) ++ "\n" ++
                                        "deletedInFalse: " ++ show (deletedInFalse) ++ "\n" ++
                                        "deletedInBoth: " ++ show (deletedInBoth) ++ "\n" ++
                                        "delsTrue: " ++ show (delsTrue) ++ "\n" ++
                                        "delsFalse: " ++ show (delsFalse) ++ "\n" ++
                                        "stillAlive: " ++ show (stillAliveAfter) ++ "\n"
                                       )

                 put (MemState stillAliveAfter deps)
                 manage xobj

                 return $ do okExpr  <- visitedExpr
                             okTrue  <- visitedTrue
                             okFalse <- visitedFalse
                             return (XObj (Lst [ifExpr, okExpr, del okTrue delsTrue, del okFalse delsFalse]) i t)
            f : args ->
              do visitedF <- visit  f
                 visitedArgs <- sequence <$> mapM (visitArg ) args
                 manage xobj
                 return $ do okF <- visitedF
                             okArgs <- visitedArgs
                             Right (XObj (Lst (okF : okArgs)) i t)

            [] -> return (Right xobj)
        visitList _ = error "Must visit list."

        visitLetBinding :: (XObj, XObj) -> State MemState (Either TypeError (XObj, XObj))
        visitLetBinding  (name, expr) =
          do visitedExpr <- visit  expr
             result <- transferOwnership  expr name
             return $ case result of
                        Left e -> Left e
                        Right _ -> do okExpr <- visitedExpr
                                      return (name, okExpr)

        visitArg :: XObj -> State MemState (Either TypeError XObj)
        visitArg  xobj@(XObj _ _ (Just t)) =
          if isManaged typeEnv t
          then do visitedXObj <- visit  xobj
                  result <- unmanage xobj
                  case result of
                    Left e  -> return (Left e)
                    Right _ -> return visitedXObj
          else visit  xobj
        visitArg  xobj@XObj{} =
          visit  xobj

        createDeleter :: XObj -> Maybe Deleter
        createDeleter xobj =
          case ty xobj of
            Just t -> let var = varOfXObj xobj
                      in  if isManaged typeEnv t && not (isExternalType typeEnv t)
                          then case nameOfPolymorphicFunction typeEnv globalEnv (FuncTy [t] UnitTy) "delete" of
                                 Just pathOfDeleteFunc -> Just (ProperDeleter pathOfDeleteFunc var)
                                 Nothing -> --trace ("Found no delete function for " ++ var ++ " : " ++ (showMaybeTy (ty xobj)))
                                            Just (FakeDeleter var)
                          else Nothing
            Nothing -> error ("No type, can't manage " ++ show xobj)

        manage :: XObj -> State MemState ()
        manage xobj =
          if isSymbolThatCaptures xobj -- When visiting lifted lambdas, don't manage symbols that capture (they are owned by the environment).
          then return ()
          else case createDeleter xobj of
                 Just deleter -> do MemState deleters deps <- get
                                    let newDeleters = Set.insert deleter deleters
                                        Just t = ty xobj
                                        newDeps = deps ++ depsForDeleteFunc typeEnv globalEnv t
                                    put (MemState newDeleters newDeps)
                 Nothing -> return ()

        deletersMatchingXObj :: XObj -> Set.Set Deleter -> [Deleter]
        deletersMatchingXObj xobj deleters =
          let var = varOfXObj xobj
          in  Set.toList $ Set.filter (\d -> case d of
                                               ProperDeleter { deleterVariable = dv } -> dv == var
                                               FakeDeleter   { deleterVariable = dv } -> dv == var)
                                      deleters

        isSymbolThatCaptures :: XObj -> Bool
        isSymbolThatCaptures xobj =
          case xobj of
            XObj (Sym _ (LookupLocal Capture)) _ _ -> True
            _ -> False

        unmanage :: XObj -> State MemState (Either TypeError ())
        unmanage xobj =
          let Just t = ty xobj
              Just i = info xobj
          in if isManaged typeEnv t && not (isGlobalFunc xobj) && not (isExternalType typeEnv t)
             then do MemState deleters deps <- get
                     case deletersMatchingXObj xobj deleters of
                       [] -> if isSymbolThatCaptures xobj
                             then return (Left (UsingCapturedValue xobj))
                             else return (Left (UsingUnownedValue xobj))
                       [one] -> let newDeleters = Set.delete one deleters
                                in  do put (MemState newDeleters deps)
                                       return (Right ())
                       _ -> error "Too many variables with the same name in set."
             else return (Right ())

        -- | Check that the value being referenced hasn't already been given away
        refCheck :: XObj -> State MemState (Either TypeError ())
        refCheck xobj =
          let Just i = info xobj
              Just t = ty xobj
              isGlobalVariable = case xobj of
                                   XObj (Sym _ (LookupGlobal _ _)) _ _ -> True
                                   _ -> False
          in if not isGlobalVariable && not (isGlobalFunc xobj) && isManaged typeEnv t && not (isExternalType typeEnv t) && not (isSymbolThatCaptures xobj)
             then do MemState deleters deps <- get
                     case deletersMatchingXObj xobj deleters of
                       [] ->  return (Left (GettingReferenceToUnownedValue xobj))
                       [_] -> return (return ())
                       _ -> error "Too many variables with the same name in set."
             else return (return ())

        transferOwnership :: XObj -> XObj -> State MemState (Either TypeError ())
        transferOwnership  from to =
          do result <- unmanage from
             case result of
               Left e -> return (Left e)
               Right _ -> do manage to --(trace ("Transfered from " ++ getName from ++ " '" ++ varOfXObj from ++ "' to " ++ getName to ++ " '" ++ varOfXObj to ++ "'") to)
                             return (Right ())

        varOfXObj :: XObj -> String
        varOfXObj xobj =
          case xobj of
            XObj (Sym (SymPath [] name) _) _ _ -> name
            _ -> case info xobj of
                   Just i -> freshVar i
                   Nothing -> error ("Missing info on " ++ show xobj)

suffixTyVars :: String -> Ty -> Ty
suffixTyVars suffix t =
  case t of
    (VarTy key) -> (VarTy (key ++ suffix))
    (FuncTy argTys retTy) -> FuncTy (map (suffixTyVars suffix) argTys) (suffixTyVars suffix retTy)
    (StructTy name tyArgs) -> StructTy name (fmap (suffixTyVars suffix) tyArgs)
    (PointerTy x) -> PointerTy (suffixTyVars suffix x)
    (RefTy x) -> RefTy (suffixTyVars suffix x)
    _ -> t

isGlobalFunc :: XObj -> Bool
isGlobalFunc xobj =
  case xobj of
    XObj (InterfaceSym _) _ (Just (FuncTy _ _)) -> True
    XObj (MultiSym _ _) _ (Just (FuncTy _ _)) -> True
    XObj (Sym _ (LookupGlobal _ _)) _ (Just (FuncTy _ _)) -> True
    XObj (Sym _ (LookupGlobalOverride _)) _ (Just (FuncTy _ _)) -> True
    _ -> False





-- | The following functions will generate deleters and copy:ing methods for structs, they are shared with the Deftype module

data AllocationMode = StackAlloc | HeapAlloc

-- | The template for the 'delete' function of a concrete deftype.
concreteDelete :: TypeEnv -> Env -> [(String, Ty)] -> Template
concreteDelete typeEnv env members =
  Template
   (FuncTy [VarTy "p"] UnitTy)
   (const (toTemplate "void $NAME($p p)"))
   (const (toTemplate $ unlines [ "$DECL {"
                                , joinWith "\n" (map (memberDeletion typeEnv env) members)
                                , "}"]))
   (\_ -> concatMap (depsOfPolymorphicFunction typeEnv env [] "delete" . typesDeleterFunctionType)
                    (filter (isManaged typeEnv) (map snd members)))

-- | The template for the 'delete' function of a concrete deftype BUT it takes a pointer.
concreteDeleteTakePtr :: TypeEnv -> Env -> [(String, Ty)] -> Template
concreteDeleteTakePtr typeEnv env members =
  Template
   (FuncTy [(PointerTy (VarTy "p"))] UnitTy)
   (const (toTemplate "void $NAME($p* p)"))
   (const (toTemplate $ unlines [ "$DECL {"
                                , joinWith "\n" (map (memberDeletionGeneral "->" typeEnv env) members)
                                , "}"]))
   (\_ -> concatMap (depsOfPolymorphicFunction typeEnv env [] "delete" . typesDeleterFunctionType)
                    (filter (isManaged typeEnv) (map snd members)))

-- | Generate the C code for deleting a single member of the deftype.
-- | TODO: Should return an Either since this can fail!
memberDeletionGeneral :: String -> TypeEnv -> Env -> (String, Ty) -> String
memberDeletionGeneral separator typeEnv env (memberName, memberType) =
  case findFunctionForMember typeEnv env "delete" (typesDeleterFunctionType memberType) (memberName, memberType) of
    FunctionFound functionFullName -> "    " ++ functionFullName ++ "(p" ++ separator ++ memberName ++ ");"
    FunctionNotFound msg -> error msg
    FunctionIgnored -> "    /* Ignore non-managed member '" ++ memberName ++ "' */"

memberDeletion = memberDeletionGeneral "."

-- | The template for the 'copy' function of a concrete deftype.
concreteCopy :: TypeEnv -> Env -> [(String, Ty)] -> Template
concreteCopy typeEnv env memberPairs =
  Template
   (FuncTy [RefTy (VarTy "p")] (VarTy "p"))
   (const (toTemplate "$p $NAME($p* pRef)"))
   (const (tokensForCopy typeEnv env memberPairs))
   (\_ -> concatMap (depsOfPolymorphicFunction typeEnv env [] "copy" . typesCopyFunctionType)
                    (filter (isManaged typeEnv) (map snd memberPairs)))

tokensForCopy :: TypeEnv -> Env -> [(String, Ty)] -> [Token]
tokensForCopy typeEnv env memberPairs=
  (toTemplate $ unlines [ "$DECL {"
                        , "    $p copy = *pRef;"
                        , joinWith "\n" (map (memberCopy typeEnv env) memberPairs)
                        , "    return copy;"
                        , "}"])

-- | Generate the C code for copying the member of a deftype.
-- | TODO: Should return an Either since this can fail!
memberCopy :: TypeEnv -> Env -> (String, Ty) -> String
memberCopy typeEnv env (memberName, memberType) =
  case findFunctionForMember typeEnv env "copy" (typesCopyFunctionType memberType) (memberName, memberType) of
    FunctionFound functionFullName ->
      "    copy." ++ memberName ++ " = " ++ functionFullName ++ "(&(pRef->" ++ memberName ++ "));"
    FunctionNotFound msg -> error msg
    FunctionIgnored -> "    /* Ignore non-managed member '" ++ memberName ++ "' */"
