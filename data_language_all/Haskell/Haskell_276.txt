module Luna.Package.Configuration.LicenseSpec where

import Prologue

import Luna.Package.Configuration.License as License

import Data.ByteString                    ( ByteString )
import Luna.Package.Configuration.License ( License )
import Luna.ParserUtils.Test              ( shouldParseTo
                                          , shouldFailToParse )
import Luna.YamlUtils.Test                ( shouldDecodeAs
                                          , shouldGenerate )
import Test.Hspec                         ( Spec, describe, it )

knownLicense :: ByteString
knownLicense = [qqStr|
tag: mit
|]

knownLicenseResult :: License
knownLicenseResult = License.MIT

unknownLicense :: ByteString
unknownLicense = [qqStr|
tag: unknown
contents: my-custom-license
|]

unknownLicenseResult :: License
unknownLicenseResult = License.Unknown "my-custom-license"

spec :: Spec
spec = do
    describe "Parsing of license literals" $ do
        it "Parses 'none'" $ shouldParseTo "none" License.license License.None
        it "Parses 'mit'"  $ shouldParseTo "mit"  License.license License.MIT
        it "Parses unknown Licenses" $ shouldParseTo "my-license"
            License.license (License.Unknown "my-license")
        it "Empty license" $ shouldFailToParse  License.license ""

    describe "Generation of Yaml" $ do
        it "Generates valid yaml in the known license case"
            $ knownLicense `shouldDecodeAs` (Just knownLicenseResult)
        it "Generates valid yaml in the unknown license case"
            $ unknownLicense `shouldDecodeAs` (Just unknownLicenseResult)

    describe "Decoding of Yaml" $ do
        it "Generates valid representation in the known license case"
            $ knownLicenseResult `shouldGenerate` knownLicense
        it "Generates valid representation in the unknown license case"
            $ unknownLicenseResult `shouldGenerate` unknownLicense

module Luna.Package.Structure.GenerateSpec where

import Prologue

import qualified Luna.Package.Configuration.Global  as Global
import qualified Luna.Package.Configuration.License as License
import qualified Luna.Package.Structure.Name        as Name
import qualified Path                               as Path
import qualified System.Directory                   as Directory
import qualified System.IO.Temp                     as Temp

import Luna.Package.Structure.Generate ( genPackageStructure
                                       , isValidPkgName )
import System.FilePath                 ( FilePath, (</>) )
import Test.Hspec                      ( Spec, Expectation, it, describe
                                       , shouldBe )

--------------------------------------
-- === Testing Helper Functions === --
--------------------------------------


testPkgDir :: (FilePath -> Expectation) -> Expectation
testPkgDir = Temp.withSystemTempDirectory "pkgTest"

doesExist :: FilePath -> FilePath -> Expectation
doesExist path tempDir = do
    canonicalPath <- Directory.canonicalizePath tempDir
    let packageDir = canonicalPath </> "TestPackage"
    _ <- genPackageStructure packageDir (Just License.MIT) $ def @Global.Config

    dirExists <- Directory.doesPathExist (packageDir </> path)

    dirExists `shouldBe` True

findPackageDir :: Bool -> FilePath -> FilePath -> Expectation
findPackageDir shouldFind name rootPath = do
    canonicalPath <- Directory.canonicalizePath rootPath
    result <- genPackageStructure (canonicalPath </> name) (Just License.MIT)
        $ def @Global.Config

    case result of
        Right path -> do
            test <- Directory.doesDirectoryExist path
            test `shouldBe` shouldFind
        Left _ -> shouldFind `shouldBe` False

testNesting :: Bool -> FilePath -> Expectation
testNesting isNested tempPath = do
    let configDir = Path.fromRelDir Name.configDirectory
    canonicalPath <- Directory.canonicalizePath tempPath

    when isNested (Directory.createDirectory $ canonicalPath </> configDir)
    result <- genPackageStructure (canonicalPath </> "TestPackage")
        (Just License.MIT) $ def @Global.Config
    case result of
        Left _ -> isNested `shouldBe` True
        Right _ -> isNested `shouldBe` False



-----------------------
-- === The Tests === --
-----------------------

spec :: Spec
spec = do
    describe "Generates the package directory with the correct name" $ do
        it "Creates the dir if the name is correct" . testPkgDir
            $ findPackageDir True "Foo"
        it "Rejects incorrect names" . testPkgDir $ findPackageDir False "bar"

    describe "Correct generation of top-level package components" $ do
        it "Creates the configuration directory" . testPkgDir
            $ doesExist ".luna-package"
        it "Creates the distribution directory" . testPkgDir
            $ doesExist "dist"
        it "Creates the source directory" . testPkgDir $ doesExist "src"
        it "Creates the license"    . testPkgDir $ doesExist "LICENSE"
        it "Creates the readme"     . testPkgDir $ doesExist "README.md"
        it "Creates the .gitignore" . testPkgDir $ doesExist ".gitignore"

    describe "Correct generation of configuration files" $ do
        it "Creates config.yaml" . testPkgDir
            $ doesExist ".luna-package/config.yaml"
        it "Creates deps.yaml" . testPkgDir
            $ doesExist ".luna-package/deps.yaml"
        it "Creates deps-history.yaml" . testPkgDir
            $ doesExist ".luna-package/deps-history.yaml"
        it "Creates project.lunaproject" . testPkgDir
            $ doesExist ".luna-package/TestPackage.lunaproject"

    describe "Correct generation of stub files" .
        it "Generates the project main" . testPkgDir
            $ doesExist "src/Main.luna"

    describe "Generation of the LIR cache" .
        it "Generates the LIR cache directory" . testPkgDir
            $ doesExist "dist/.lir"

    describe "Package name checking" $ do
        it "Is a valid package name" $ isValidPkgName "Foo"
        it "Is an invalid packageName" . not $ isValidPkgName "baAr"

    describe "Detection of nested packages" $ do
        it "Is inside a package" . testPkgDir $ testNesting True
        it "Is not inside a package" . testPkgDir $ testNesting False

