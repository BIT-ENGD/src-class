module Main where

import GHC.Conc
import Control.Concurrent

snapshot t1 t2 = atomically ( do v1 <- readTVar t1
                                 v2 <- readTVar t2
                                 return (v1, v2) )

twiddle mv _ _ 0 = putMVar mv ()
twiddle mv t1 t2 n = do atomically ( do v1 <- readTVar t1
                                        v2 <- readTVar t2
                                        writeTVar t2 (v1+1)
                                        writeTVar t1 (v2+1) )
                        twiddle mv t1 t2 (n-1)
                  

-- Contended updates to a pair of TVars 
main = do
  putStr "Before\n"
  (t1,t2) <- atomically ( do t1 <- newTVar 0
                             t2 <- newTVar 1
                             return (t1, t2))

  -- MVars used to signal completion 
  t1c <- newEmptyMVar
  t2c <- newEmptyMVar

  forkIO (twiddle t1c t1 t2 1000)
  forkIO (twiddle t2c t1 t2 1000)

  -- Wait for threads to exit
  takeMVar t1c
  takeMVar t2c

  -- Display final state
  (r1,r2) <- snapshot t1 t2 
  putStr ("After " ++ (show r1) ++ " , " ++ (show r2) ++ "\n")
         
module Main (main) where

import System.Environment
import Control.Concurrent
import Control.Monad

-----------------------------------------------------------------------------
-- test MVar throughput between the main thread and a child thread

-- This test runs quite slowly on the threaded/SMP RTS vs. the normal RTS,
-- because the main thread and child thread are run by different OS threads,
-- so each MVar communication requires real OS thread switching.
--
-- Figures I get are about a factor of 10 difference in speed, at GHC 6.5.

main = chanTest 300000

chanTest :: Int -> IO ()
chanTest n = do
  chan <- newEmptyMVar
  forkIO (writer chan n)
  reader chan n

reader chan 0 = return ()
reader chan n = do
  takeMVar chan
  reader chan (n-1)

writer chan 0 = return ()
writer chan n = do
  putMVar chan ()
  writer chan (n-1)
