module Polymorphism where

import Debug.Trace

import Obj
import Types
import Util
import TypeError
import Lookup

-- | Calculate the full, mangled name of a concretized polymorphic function.
-- | For example, The 'id' in "(id 3)" will become 'id__int'.
-- | This function uses the 'multiLookupALL' function which gives it acces to
-- | modules that are not imported. This allows it to access 'delete' functions
-- | and similar for internal use.

-- | TODO: Environments are passed in different order here!!!

nameOfPolymorphicFunction :: TypeEnv -> Env -> Ty -> String -> Maybe SymPath
nameOfPolymorphicFunction typeEnv env functionType functionName =
  let foundBinders = multiLookupALL functionName env
  in case filter ((\(Just t') -> areUnifiable functionType t') . ty . binderXObj . snd) foundBinders of
       [] -> Nothing
       [(_, Binder _ single)] ->
         let Just t' = ty single
             (SymPath pathStrings name) = getPath single
             suffix = polymorphicSuffix t' functionType
             concretizedPath = SymPath pathStrings (name ++ suffix)
         in  Just concretizedPath
       _ -> Nothing
module Workbench where

import ColorText
import Obj
import Types
import Commands
import Template
import Parsing
import Infer
import Constraints
import Emit
import Eval
import qualified Data.Map as Map

-- | Not part of the cabal file, just for interactive repl sessions:


startingGlobalEnv :: Env
startingGlobalEnv = Env { envBindings = bs,
                          envParent = Nothing,
                          envModuleName = Nothing,
                          envUseModules = [SymPath [] "String"],
                          envMode = ExternalEnv
                        }
  where bs = Map.fromList [ register "and" (FuncTy [BoolTy, BoolTy] BoolTy)
                          , register "or" (FuncTy [BoolTy, BoolTy] BoolTy)
                          , register "not" (FuncTy [BoolTy] BoolTy)
                          , templateNoop
                          --, ("Array", Binder (XObj (Mod arrayModule) Nothing Nothing))
                          , register "NULL" (VarTy "a")
                          ]

startingTypeEnv :: Env
startingTypeEnv = Env { envBindings = Map.empty, envParent = Nothing, envModuleName = Nothing, envUseModules = [], envMode = ExternalEnv }


pt :: XObj -> IO ()
pt = putStrLn . prettyTyped

Right [parsed] = parse "(defn f [x] (Int.+ x 10))" ""

p1 = pt parsed
p2 = case expandAll startingGlobalEnv parsed of
       Left e -> error (show e)
       Right ok -> pt ok
