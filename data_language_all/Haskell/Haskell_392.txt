{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE ConstraintKinds #-}
{-# LANGUAGE FlexibleContexts #-}

module Eta.HsSyn.PlaceHolder where

import Eta.Types.Type       ( Type )
import Eta.Utils.Outputable
import Eta.BasicTypes.Name
import Eta.BasicTypes.NameSet
import Eta.BasicTypes.RdrName
import Eta.BasicTypes.Var
import Eta.Types.Coercion

import Data.Data hiding ( Fixity )
import Eta.BasicTypes.BasicTypes       (Fixity)


{-
%************************************************************************
%*                                                                      *
\subsection{Annotating the syntax}
%*                                                                      *
%************************************************************************
-}

-- | used as place holder in PostTc and PostRn values
data PlaceHolder = PlaceHolder
  deriving (Data,Typeable)

-- | Types that are not defined until after type checking
type family PostTc it ty :: * -- Note [Pass sensitive types]
type instance PostTc Id      ty = ty
type instance PostTc Name    ty = PlaceHolder
type instance PostTc RdrName ty = PlaceHolder

-- | Types that are not defined until after renaming
type family PostRn id ty :: * -- Note [Pass sensitive types]
type instance PostRn Id      ty = ty
type instance PostRn Name    ty = ty
type instance PostRn RdrName ty = PlaceHolder

placeHolderKind :: PlaceHolder
placeHolderKind = PlaceHolder

placeHolderFixity :: PlaceHolder
placeHolderFixity = PlaceHolder

placeHolderType :: PlaceHolder
placeHolderType = PlaceHolder

placeHolderTypeTc :: Type
placeHolderTypeTc = panic "Evaluated the place holder for a PostTcType"

placeHolderNames :: PlaceHolder
placeHolderNames = PlaceHolder

placeHolderNamesTc :: NameSet
placeHolderNamesTc = emptyNameSet

{-

Note [Pass sensitive types]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Since the same AST types are re-used through parsing,renaming and type
checking there are naturally some places in the AST that do not have
any meaningful value prior to the pass they are assigned a value.

Historically these have been filled in with place holder values of the form

  panic "error message"

This has meant the AST is difficult to traverse using standed generic
programming techniques. The problem is addressed by introducing
pass-specific data types, implemented as a pair of open type families,
one for PostTc and one for PostRn. These are then explicitly populated
with a PlaceHolder value when they do not yet have meaning.

Since the required bootstrap compiler at this stage does not have
closed type families, an open type family had to be used, which
unfortunately forces the requirement for UndecidableInstances.

In terms of actual usage, we have the following

  PostTc id Kind
  PostTc id Type

  PostRn id Fixity
  PostRn id NameSet

TcId and Var are synonyms for Id
-}

type DataId id =
  ( Data id
  , Data (PostRn id NameSet)
  , Data (PostRn id Fixity)
  , Data (PostRn id Bool)
  , Data (PostRn id [Name])

  , Data (PostTc id Type)
  , Data (PostTc id Coercion)
  )
{-
(c) The GRASP/AQUA Project, Glasgow University, 1992-1998

\section[Constants]{Info about this compilation}
-}
{-# LANGUAGE TemplateHaskell #-}
module Eta.Main.Constants where

import Paths_eta (version)
import Data.Version (versionBranch)
import Development.GitRev

hiVersion :: Integer
hiVersion = read cProjectVersionInt :: Integer

cProjectName, cProjectVersion, cProjectVersionNumbers, cProjectVersionInt, cProjectPatchLevel, cProjectPatchLevel1, cProjectPatchLevel2, cProjectHomeURL, cProjectIssueReportURL, ghcProjectVersion, ghcProjectVersionInt, ghcprojectPatchLevel, ghcProjectPatchLevel1, ghcProjectPatchLevel2, cProjectGitCommitId
  :: String
cProjectName = "The Eta Programming Language Compiler"
cProjectVersion = show maj ++ "." ++ show minor ++ "." ++ show patch ++ "b"
               ++ cProjectPatchLevel
  where [maj,minor,patch,_] = versionBranch version
cProjectVersionNumbers = show maj ++ "." ++ show minor ++ "." ++ show patch ++ "."
                     ++ cProjectPatchLevel
  where [maj,minor,patch,_] = versionBranch version
cProjectVersionInt = show (maj * 100 + minor * 10 + patch)
  where [maj,minor,patch,_] = versionBranch version

cProjectPatchLevel = show (last (versionBranch version))
cProjectPatchLevel1 = cProjectPatchLevel
cProjectPatchLevel2 = ""
cProjectHomeURL = "http://github.com/typelead/eta"
cProjectIssueReportURL = cProjectHomeURL ++ "/issues"
cProjectGitCommitId = $(gitHash)

ghcProjectVersion = "7.10.3"
ghcProjectVersionInt = "710"
ghcprojectPatchLevel = "3"
ghcProjectPatchLevel1 = "3"
ghcProjectPatchLevel2 = ""

-- All pretty arbitrary:

mAX_TUPLE_SIZE :: Int
mAX_TUPLE_SIZE = 62 -- Should really match the number
                    -- of decls in Data.Tuple

mAX_CONTEXT_REDUCTION_DEPTH :: Int
mAX_CONTEXT_REDUCTION_DEPTH = 100
  -- Trac #5395 reports at least one library that needs depth 37 here

mAX_TYPE_FUNCTION_REDUCTION_DEPTH :: Int
mAX_TYPE_FUNCTION_REDUCTION_DEPTH = 200
  -- Needs to be much higher than mAX_CONTEXT_REDUCTION_DEPTH; see Trac #5395

wORD64_SIZE :: Int
wORD64_SIZE = 8

tARGET_MAX_CHAR :: Int
tARGET_MAX_CHAR = 0x10ffff

mAX_INTLIKE, mIN_INTLIKE, mAX_CHARLIKE, mIN_CHARLIKE, mAX_SPEC_AP_SIZE :: Int
mIN_INTLIKE = -16
mAX_INTLIKE = 16
mIN_CHARLIKE = 0
mAX_CHARLIKE = 255
mAX_SPEC_AP_SIZE = 7
