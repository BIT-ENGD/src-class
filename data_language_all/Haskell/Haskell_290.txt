module Data.Graph.Component.Node.Destruction where

import           Prologue hiding (Type)
import qualified Prologue as P

import qualified Data.Graph.Component.Edge.Class       as Edge
import qualified Data.Graph.Component.Edge.Destruction as Edge
import qualified Data.Graph.Component.Node.Class       as Node
import qualified Data.Graph.Component.Node.Layer       as Node
import qualified Data.Graph.Data.Component.Class       as Component
import qualified Data.Graph.Data.Component.List        as ComponentList
import qualified Data.Graph.Data.Layer.Class           as Layer
import qualified Data.Graph.Data.Layer.Layout          as Layout
import qualified Data.Mutable.Class                    as Mutable
import qualified Data.Set                              as Set

import Control.Monad                   (filterM)
import Data.Graph.Component.Edge.Class (Edge, Edges, Source, Target)
import Data.Graph.Component.Node.Class (Node, Nodes)
import Data.Graph.Component.Node.Layer (Model, Type, Users)
import Data.Graph.Fold.SubComponents   (SubComponents, SubComponents1,
                                        subComponents, subComponents1)


-------------------------
-- === Destruction === --
-------------------------

-- === API === --

type Delete m =
    ( MonadIO m
    , Edge.Delete m
    , Component.Destructor1 m Node
    , SubComponents1 Edges m Nodes
    )

delete :: Delete m => Node layout -> m ()
delete = \node -> do
    edges <- subComponents1 @Edges node
    let es = Set.toList $ Set.fromList $ (convert edges :: [Edge.SomeEdge])
    traverse Edge.delete es
    Component.destruct1 node
    return ()
{-# INLINE delete #-}

type DeleteSubtree m =
    ( MonadIO m
    , Delete m
    , Layer.Reader Node Users  m
    , Layer.Reader Node Model  m
    , Layer.Reader Node Type   m
    , Layer.Reader Edge Target m
    , Layer.Reader Edge Source m
    , SubComponents Edges m (Node.Uni ())
    , Layer.IsUnwrapped Node.Uni
    )

safeToDelete :: ∀ m. DeleteSubtree m
             => Set.Set Node.Some -> Node.Some -> m Bool
safeToDelete whitelist root = do
    succs <- Mutable.toList =<< Layer.read @Users root
    loops <- traverse Edge.cyclic succs
    let allLoops    = and loops
        whitelisted = Set.member root whitelist
    return $ allLoops && not whitelisted
{-# INLINE safeToDelete #-}

deleteSubtreeWithWhitelist :: ∀ layout m. DeleteSubtree m
                           => Set.Set Node.Some -> Node layout -> m ()
deleteSubtreeWithWhitelist whitelist (Layout.relayout -> root) = whenM (safeToDelete whitelist root) $ go root where
    go :: Node.Some -> m ()
    go root = do
        inputEdges :: [Edge.SomeEdge] <- convert <$> Node.inputs root
        tpEdge <- Layer.read @Type root
        let allInputEdges = Layout.relayout tpEdge : inputEdges
        nonCyclicEdges <- filterM (fmap not . Edge.cyclic) allInputEdges
        inputs         <- traverse (Layer.read @Source) nonCyclicEdges
        delete root
        safeChildren <- filterM (safeToDelete whitelist) $ Set.toList $ Set.fromList inputs
        traverse_ go safeChildren
{-# INLINE deleteSubtreeWithWhitelist #-}

deleteSubtree :: DeleteSubtree m => Node layout -> m ()
deleteSubtree = deleteSubtreeWithWhitelist mempty
{-# INLINE deleteSubtree #-}
module AssignTypes where

import Types
import Obj
import Util
import TypeError
import Data.List (nub)
import qualified Data.Map as Map

import Debug.Trace

{-# ANN assignTypes "HLint: ignore Eta reduce" #-}
-- | Walk the whole expression tree and replace all occurences of VarTy with their corresponding actual type.
assignTypes :: TypeMappings -> XObj -> Either TypeError XObj
assignTypes mappings root = visit root
  where
    visit xobj =
      case obj xobj of
        (Lst _) -> visitList xobj
        (Arr _) -> visitArray xobj
        _ -> assignType xobj

    visitList :: XObj -> Either TypeError XObj
    visitList (XObj (Lst xobjs) i t) =
      do visited <- mapM (assignTypes mappings) xobjs
         let xobj' = XObj (Lst visited) i t
         assignType xobj'
    visitList _ = error "The function 'visitList' only accepts XObjs with lists in them."

    visitArray :: XObj -> Either TypeError XObj
    visitArray (XObj (Arr xobjs) i t) =
      do visited <- mapM (assignTypes mappings) xobjs
         let xobj' = XObj (Arr visited) i t
         assignType xobj'
    visitArray _ = error "The function 'visitArray' only accepts XObjs with arrays in them."

    assignType :: XObj -> Either TypeError XObj
    assignType xobj = case ty xobj of
      Just startingType ->
        let finalType = replaceTyVars mappings startingType
        in  if isArrayTypeOK finalType
            then Right (xobj { ty = Just finalType })
            else Left  (ArraysCannotContainRefs xobj)
      Nothing -> return xobj


isArrayTypeOK :: Ty -> Bool
isArrayTypeOK (StructTy "Array" [RefTy _]) = False -- An array containing refs!
isArrayTypeOK _ = True


-- | Change auto generated type names (i.e. 't0') to letters (i.e. 'a', 'b', 'c', etc...)
-- | TODO: Only change variables that are machine generated.
beautifyTypeVariables :: XObj -> Either TypeError XObj
beautifyTypeVariables root =
  let Just t = ty root
      tys = nub (typeVariablesInOrderOfAppearance t)
      mappings = Map.fromList (zip (map (\(VarTy name) -> name) tys)
                                   (map (VarTy . (:[])) ['a'..]))
  in  assignTypes mappings root

typeVariablesInOrderOfAppearance :: Ty -> [Ty]
typeVariablesInOrderOfAppearance (FuncTy argTys retTy) =
  concatMap typeVariablesInOrderOfAppearance argTys ++ typeVariablesInOrderOfAppearance retTy
typeVariablesInOrderOfAppearance (StructTy _ typeArgs) =
  concatMap typeVariablesInOrderOfAppearance typeArgs
typeVariablesInOrderOfAppearance (RefTy innerTy) =
  typeVariablesInOrderOfAppearance innerTy
typeVariablesInOrderOfAppearance (PointerTy innerTy) =
  typeVariablesInOrderOfAppearance innerTy
typeVariablesInOrderOfAppearance t@(VarTy _) =
  [t]
typeVariablesInOrderOfAppearance _ =
  []
