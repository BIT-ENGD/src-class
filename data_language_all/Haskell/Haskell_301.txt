{-# LANGUAGE LambdaCase #-}

module ArrayTemplates where

import Debug.Trace

import Util
import Types
import Obj
import Parsing
import Template
import ToTemplate
import Polymorphism
import Concretize
import Lookup

-- | "Endofunctor Map"
templateEMap :: (String, Binder)
templateEMap =
  let fTy = FuncTy [VarTy "a"] (VarTy "a")
      aTy = StructTy "Array" [VarTy "a"]
      bTy = StructTy "Array" [VarTy "a"]
      elem = "((($a*)a.data)[i])"
  in  defineTemplate
      (SymPath ["Array"] "endo-map")
      (FuncTy [fTy, aTy] bTy)
      (toTemplate "Array $NAME(Lambda f, Array a)") -- Lambda used to be $(Fn [a] a)
      (toTemplate $ unlines
        ["$DECL { "
        ,"    for(int i = 0; i < a.len; ++i) {"
        ,"        (($a*)a.data)[i] = " ++ (templateCodeForCallingLambda "f" fTy [elem]) ++ ";"
        ,"    }"
        ,"    return a;"
        ,"}"
        ])
      (\(FuncTy [t@(FuncTy fArgTys fRetTy), arrayType] _) ->
         [defineFunctionTypeAlias t, defineFunctionTypeAlias (FuncTy (lambdaEnvTy : fArgTys) fRetTy)])

templateFilter :: (String, Binder)
templateFilter = defineTypeParameterizedTemplate templateCreator path t
  where
    fTy = FuncTy [RefTy (VarTy "a")] BoolTy
    aTy = StructTy "Array" [VarTy "a"]
    path = SymPath ["Array"] "filter"
    t = FuncTy [fTy, aTy] aTy
    elem = "&((($a*)a.data)[i])"
    templateCreator = TemplateCreator $
      \typeEnv env ->
        Template
        t
        (const (toTemplate "Array $NAME(Lambda predicate, Array a)")) -- Lambda used to be $(Fn [(Ref a)] Bool)
        (\(FuncTy [FuncTy [RefTy insideTy] BoolTy, _] _) ->
           (toTemplate $ unlines $
            let deleter = insideArrayDeletion typeEnv env insideTy
            in ["$DECL { "
               , "    int insertIndex = 0;"
               , "    for(int i = 0; i < a.len; ++i) {"
               , "        if(" ++ (templateCodeForCallingLambda "predicate" fTy [elem]) ++ ") {"
               , "            ((($a*)a.data)[insertIndex++]) = (($a*)a.data)[i];"
               , "        } else {"
               , "        " ++ deleter "i"
               , "        }"
               , "    }"
               , "    a.len = insertIndex;"
               , "    // NOTE: the array isn't resized for now, it probably should be?"
               , "    return a;"
               , "}"
               ]))
        (\(FuncTy [ft@(FuncTy fArgTys@[RefTy insideType] BoolTy), arrayType] _) ->
           [defineFunctionTypeAlias ft, defineFunctionTypeAlias (FuncTy (lambdaEnvTy : fArgTys) BoolTy)] ++
            depsForDeleteFunc typeEnv env insideType)

templatePushBack :: (String, Binder)
templatePushBack =
  let aTy = StructTy "Array" [VarTy "a"]
      valTy = VarTy "a"
  in  defineTemplate
      (SymPath ["Array"] "push-back")
      (FuncTy [aTy, valTy] aTy)
      (toTemplate "Array $NAME(Array a, $a value)")
      (toTemplate $ unlines
        ["$DECL { "
        ,"    a.len++;"
        ,"    if(a.len > a.capacity) {"
        ,"        a.capacity = a.len * 2;"
        ,"        a.data = realloc(a.data, sizeof($a) * a.capacity);"
        -- ,"        void *pre = a.data;"
        -- ,"        a.data = CARP_MALLOC(sizeof($a) * a.capacity);"
        -- ,"        unsigned long s = sizeof($a) * (a.len - 1);"
        -- ,"        memmove(a.data, pre, s);"
        -- ,"        CARP_FREE(pre);"
        ,"    }"
        ,"    (($a*)a.data)[a.len - 1] = value;"
        ,"    return a;"
        ,"}"
        ])
      (\(FuncTy [arrayType, _] _) -> [])

templatePushBackBang :: (String, Binder)
templatePushBackBang =
  let aTy = RefTy (StructTy "Array" [VarTy "a"])
      valTy = VarTy "a"
  in  defineTemplate
      (SymPath ["Array"] "push-back!")
      (FuncTy [aTy, valTy] UnitTy)
      (toTemplate "void $NAME(Array *aRef, $a value)")
      (toTemplate $ unlines
        ["$DECL { "
        ,"    aRef->len++;"
        ,"    if(aRef->len > aRef->capacity) {"
        ,"        aRef->capacity = aRef->len * 2;"
        ,"        aRef->data = realloc(aRef->data, sizeof($a) * aRef->capacity);"
        ,"    }"
        ,"    (($a*)aRef->data)[aRef->len - 1] = value;"
        ,"}"
        ])
      (\(FuncTy [arrayType, _] _) -> [])

templatePopBack :: (String, Binder)
templatePopBack = defineTypeParameterizedTemplate templateCreator path t
  where path = SymPath ["Array"] "pop-back"
        aTy = StructTy "Array" [VarTy "a"]
        t = FuncTy [aTy] aTy
        templateCreator = TemplateCreator $
          \typeEnv env ->
            Template
            t
            (const (toTemplate "Array $NAME(Array a)"))
            (\(FuncTy [arrayType@(StructTy _ [insideTy])] _) ->
               let deleteElement = insideArrayDeletion typeEnv env insideTy
               in toTemplate (unlines
                               ["$DECL { "
                               ,"  #ifndef OPTIMIZE"
                               ,"  assert(a.len > 0);"
                               ,"  #endif"
                               ,"  a.len--;"
                               ,"  " ++ deleteElement "a.len"
                               ,"    if(a.len < (a.capacity / 4)) {"
                               ,"        void *pre = a.data;"
                               ,"        unsigned long s = sizeof($a) * a.len;"
                               ,"        a.data = CARP_MALLOC(s);"
                               ,"        memcpy(a.data, pre, s);"
                               ,"        CARP_FREE(pre);"
                               ,"        a.capacity = a.len;"
                               ,"    }"
                               ,"  return a;"
                               ,"}"
                               ]))
            (\(FuncTy [arrayType@(StructTy _ [insideTy])] _) ->
               depsForDeleteFunc typeEnv env arrayType ++
               depsForCopyFunc typeEnv env insideTy
            )

templatePopBackBang :: (String, Binder)
templatePopBackBang =
  let aTy = RefTy (StructTy "Array" [VarTy "a"])
      valTy = VarTy "a"
  in  defineTemplate
      (SymPath ["Array"] "pop-back!")
      (FuncTy [aTy] (VarTy "a"))
      (toTemplate "$a $NAME(Array *aRef)")
      (toTemplate $ unlines
        ["$DECL { "
         ,"  $a ret;"
         ,"  #ifndef OPTIMIZE"
         ,"  assert(aRef->len > 0);"
         ,"  #endif"
         ,"  ret = (($a*)aRef->data)[aRef->len - 1];"
         ,"  aRef->len--;"
         ,"  return ret;"
         ,"}"
        ])
      (\(FuncTy [arrayType] _) -> [])


templateNth :: (String, Binder)
templateNth =
  let t = VarTy "t"
  in defineTemplate
  (SymPath ["Array"] "nth")
  (FuncTy [RefTy (StructTy "Array" [t]), IntTy] (RefTy t))
  (toTemplate "$t* $NAME (Array *aRef, int n)")
  (toTemplate $ unlines ["$DECL {"
                        ,"    Array a = *aRef;"
                        ,"    #ifndef OPTIMIZE"
                        ,"    assert(n >= 0);"
                        ,"    assert(n < a.len);"
                        ,"    #endif"
                        ,"    return &((($t*)a.data)[n]);"
                        ,"}"])
  (\(FuncTy [(RefTy arrayType), _] _) ->
     [])

templateRaw :: (String, Binder)
templateRaw = defineTemplate
  (SymPath ["Array"] "raw")
  (FuncTy [StructTy "Array" [VarTy "t"]] (PointerTy (VarTy "t")))
  (toTemplate "$t* $NAME (Array a)")
  (toTemplate "$DECL { return a.data; }")
  (\(FuncTy [arrayType] _) -> [])

templateAset :: (String, Binder)
templateAset = defineTypeParameterizedTemplate templateCreator path t
  where path = SymPath ["Array"] "aset"
        t = (FuncTy [StructTy "Array" [VarTy "t"], IntTy, VarTy "t"] (StructTy "Array" [VarTy "t"]))
        templateCreator = TemplateCreator $
          \typeEnv env ->
            Template
            t
            (\_ -> toTemplate $ "Array $NAME (Array a, int n, $t newValue)")
            (\(FuncTy [_, _, insideTy] _) ->
               let deleter = insideArrayDeletion typeEnv env insideTy
               in  toTemplate $ unlines ["$DECL {"
                                        ,"    #ifndef OPTIMIZE"
                                        ,"    assert(n >= 0);"
                                        ,"    assert(n < a.len);"
                                        ,"    #endif"
                                        ,     deleter "n"
                                        ,"    (($t*)a.data)[n] = newValue;"
                                        ,"    return a;"
                                        ,"}"])
            (\(FuncTy [_, _, insideTy] _) ->
                depsForDeleteFunc typeEnv env insideTy)

templateAsetBang :: (String, Binder)
templateAsetBang = defineTypeParameterizedTemplate templateCreator path t
  where path = (SymPath ["Array"] "aset!")
        t = (FuncTy [RefTy (StructTy "Array" [VarTy "t"]), IntTy, VarTy "t"] UnitTy)
        templateCreator = TemplateCreator $
          \typeEnv env ->
            Template
            t
            (const (toTemplate "void $NAME (Array *aRef, int n, $t newValue)"))
            (\(FuncTy [_, _, insideTy] _) ->
               let deleter = insideArrayDeletion typeEnv env insideTy
               in  (toTemplate $ unlines ["$DECL {"
                                         ,"    Array a = *aRef;"
                                         ,"    #ifndef OPTIMIZE"
                                         ,"    assert(n >= 0);"
                                         ,"    assert(n < a.len);"
                                         ,"    #endif"
                                         ,     deleter "n"
                                         ,"    (($t*)a.data)[n] = newValue;"
                                         ,"}"]))
            (\(FuncTy [(RefTy arrayType), _, _] _) ->
               depsForDeleteFunc typeEnv env arrayType)

-- | This function can set uninitialized memory in an array (used together with 'allocate').
-- | It will NOT try to free the value that is already at location 'n'.
templateAsetUninitializedBang :: (String, Binder)
templateAsetUninitializedBang = defineTypeParameterizedTemplate templateCreator path t
  where path = (SymPath ["Array"] "aset-uninitialized!")
        t = (FuncTy [RefTy (StructTy "Array" [VarTy "t"]), IntTy, VarTy "t"] UnitTy)
        templateCreator = TemplateCreator $
          \typeEnv env ->
            Template
            t
            (const (toTemplate "void $NAME (Array *aRef, int n, $t newValue)"))
            (const (toTemplate $ unlines ["$DECL {"
                                         ,"    Array a = *aRef;"
                                         ,"    #ifndef OPTIMIZE"
                                         ,"    assert(n >= 0);"
                                         ,"    assert(n < a.len);"
                                         ,"    #endif"
                                         ,"    (($t*)a.data)[n] = newValue;"
                                         ,"}"]))
            (const [])

templateLength :: (String, Binder)
templateLength = defineTypeParameterizedTemplate templateCreator path t
  where path = (SymPath ["Array"] "length")
        t = (FuncTy [RefTy (StructTy "Array" [VarTy "t"])] IntTy)
        templateCreator = TemplateCreator $
          \typeEnv env ->
            Template
            t
            (const (toTemplate "int $NAME (Array *a)"))
            (const (toTemplate "$DECL { return (*a).len; }"))
            (\(FuncTy [(RefTy arrayType)] _) ->
              depsForDeleteFunc typeEnv env arrayType)

templateAllocate :: (String, Binder)
templateAllocate = defineTypeParameterizedTemplate templateCreator path t
  where path = (SymPath ["Array"] "allocate")
        t = (FuncTy [IntTy] (StructTy "Array" [VarTy "t"]))
        templateCreator = TemplateCreator $
          \typeEnv env ->
            Template
            t
            (const (toTemplate "Array $NAME (int n)"))
            (const (toTemplate $ unlines ["$DECL {"
                                         ,"    Array a;"
                                         ,"    a.len = n;"
                                         ,"    a.capacity = n;"
                                         ,"    a.data = CARP_MALLOC(n*sizeof($t));"
                                         ,"    return a;"
                                         ,"}"]))
            (\(FuncTy [_] arrayType) ->
               depsForDeleteFunc typeEnv env arrayType)

templateDeleteArray :: (String, Binder)
templateDeleteArray = defineTypeParameterizedTemplate templateCreator path t
  where path = SymPath ["Array"] "delete"
        t = FuncTy [StructTy "Array" [VarTy "a"]] UnitTy
        templateCreator = TemplateCreator $
          \typeEnv env ->
             Template
             t
             (const (toTemplate "void $NAME (Array a)"))
             (\(FuncTy [arrayType] UnitTy) ->
                [TokDecl, TokC "{\n"] ++
                deleteTy typeEnv env arrayType ++
                [TokC "}\n"])
             (\(FuncTy [arrayType@(StructTy "Array" [insideType])] UnitTy) ->
                depsForDeleteFunc typeEnv env insideType)

deleteTy :: TypeEnv -> Env -> Ty -> [Token]
deleteTy typeEnv env (StructTy "Array" [innerType]) =
  [ TokC   "    for(int i = 0; i < a.len; i++) {\n"
  , TokC $ "    " ++ insideArrayDeletion typeEnv env innerType "i"
  , TokC   "    }\n"
  , TokC   "    CARP_FREE(a.data);\n"
  ]
deleteTy _ _ _ = []

insideArrayDeletion :: TypeEnv -> Env -> Ty -> String -> String
insideArrayDeletion typeEnv env t indexer =
  case findFunctionForMember typeEnv env "delete" (typesDeleterFunctionType t) ("Inside array.", t) of
    FunctionFound functionFullName ->
      "    " ++ functionFullName ++ "(((" ++ tyToC t ++ "*)a.data)[" ++ indexer ++ "]);\n"
    FunctionNotFound msg -> error msg
    FunctionIgnored -> "    /* Ignore non-managed type inside Array: '" ++ show t ++ "' */\n"

templateCopyArray :: (String, Binder)
templateCopyArray = defineTypeParameterizedTemplate templateCreator path t
  where path = SymPath ["Array"] "copy"
        t = FuncTy [RefTy (StructTy "Array" [VarTy "a"])] (StructTy "Array" [VarTy "a"])
        templateCreator = TemplateCreator $
          \typeEnv env ->
             Template
             t
             (const (toTemplate "Array $NAME (Array* a)"))
             (\(FuncTy [RefTy arrayType] _) ->
                [TokDecl, TokC "{\n"] ++
                [TokC "    Array copy;\n"] ++
                [TokC "    copy.len = a->len;\n"] ++
                [TokC "    copy.capacity = a->capacity;\n"] ++
                [TokC "    copy.data = CARP_MALLOC(sizeof(", TokTy (VarTy "a") Normal, TokC ") * a->capacity);\n"] ++
                copyTy typeEnv env arrayType ++
                [TokC "    return copy;\n"] ++
                [TokC "}\n"])
             (\case
                 (FuncTy [RefTy arrayType@(StructTy "Array" [insideType])] _) ->
                   depsForCopyFunc typeEnv env insideType ++
                   depsForDeleteFunc typeEnv env arrayType
                 err ->
                   error ("CAN'T MATCH: " ++ show err))

copyTy :: TypeEnv -> Env -> Ty -> [Token]
copyTy typeEnv env (StructTy "Array" [innerType]) =
  [ TokC   "    for(int i = 0; i < a->len; i++) {\n"
  , TokC $ "    " ++ insideArrayCopying typeEnv env innerType
  , TokC   "    }\n"
  ]
copyTy _ _ _ = []

-- | The "memberCopy" and "memberDeletion" functions in Deftype are very similar!
insideArrayCopying :: TypeEnv -> Env -> Ty -> String
insideArrayCopying typeEnv env t =
  case findFunctionForMemberIncludePrimitives typeEnv env "copy" (typesCopyFunctionType t) ("Inside array.", t) of
    FunctionFound functionFullName ->
      "    ((" ++ tyToC t ++ "*)(copy.data))[i] = " ++ functionFullName ++ "(&(((" ++ tyToC t ++ "*)a->data)[i]));\n"
    FunctionNotFound msg -> error msg
    FunctionIgnored ->
      "    /* Ignore type inside Array when copying: '" ++ show t ++ "' (no copy function known)*/\n"

templateStrArray :: (String, Binder)
templateStrArray = defineTypeParameterizedTemplate templateCreator path t
  where templateCreator = TemplateCreator $
          \typeEnv env ->
             Template
             t
             (const (toTemplate "String $NAME (Array* a)"))
             (\(FuncTy [RefTy arrayType] StringTy) ->
                [TokDecl, TokC " {\n"] ++
                strTy typeEnv env arrayType ++
                [TokC "}\n"])
             (\(FuncTy [RefTy arrayType@(StructTy "Array" [insideType])] StringTy) ->
                depsForPrnFunc typeEnv env insideType)
        path = SymPath ["Array"] "str"
        t = FuncTy [RefTy (StructTy "Array" [VarTy "a"])] StringTy

-- | TODO: move this into the templateStrArray function?
strTy :: TypeEnv -> Env -> Ty -> [Token]
strTy typeEnv env (StructTy "Array" [innerType]) =
  [ TokC   ""
  , TokC   "  String temp = NULL;\n"
  , TokC $ calculateStrSize typeEnv env innerType
  , TokC   "  String buffer = CARP_MALLOC(size);\n"
  , TokC   "  String bufferPtr = buffer;\n"
  , TokC   "\n"
  , TokC   "  snprintf(buffer, size, \"[\");\n"
  , TokC   "  bufferPtr += 1;\n"
  , TokC   "\n"
  , TokC   "  for(int i = 0; i < a->len; i++) {\n"
  , TokC $ "  " ++ insideArrayStr typeEnv env innerType
  , TokC   "  }\n"
  , TokC   "\n"
  , TokC   "  if(a->len > 0) { bufferPtr -= 1; }\n"
  , TokC   "  snprintf(bufferPtr, size, \"]\");\n"
  , TokC   "  return buffer;\n"
  ]
strTy _ _ _ = []

calculateStrSize :: TypeEnv -> Env -> Ty -> String
calculateStrSize typeEnv env t =
  unlines [ "  int size = 3; // opening and closing brackets and terminator"
          , "  for(int i = 0; i < a->len; i++) {"
          , arrayMemberSizeCalc ++ "  }"
          , ""
          ]
  where arrayMemberSizeCalc =
          case findFunctionForMemberIncludePrimitives typeEnv env "prn" (typesStrFunctionType typeEnv t) ("Inside array.", t) of
              FunctionFound functionFullName ->
                let takeAddressOrNot = if isManaged typeEnv t then "&" else ""
                in  unlines [ "    temp = " ++ functionFullName ++ "(" ++ takeAddressOrNot ++ "((" ++ tyToC t ++ "*)a->data)[i]);"
                            , "    size += snprintf(NULL, 0, \"%s \", temp);"
                            , "    if(temp) {"
                            , "      CARP_FREE(temp);"
                            , "      temp = NULL;"
                            , "    }"
                            ]
              FunctionNotFound msg -> error msg
              FunctionIgnored -> "    /* Ignore type inside Array: '" ++ show t ++ "' ??? */\n"


insideArrayStr :: TypeEnv -> Env -> Ty -> String
insideArrayStr typeEnv env t =
  case findFunctionForMemberIncludePrimitives typeEnv env "prn" (typesStrFunctionType typeEnv t) ("Inside array.", t) of
    FunctionFound functionFullName ->
      let takeAddressOrNot = if isManaged typeEnv t then "&" else ""
      in  unlines [ "  temp = " ++ functionFullName ++ "(" ++ takeAddressOrNot ++ "((" ++ tyToC t ++ "*)a->data)[i]);"
                  , "    snprintf(bufferPtr, size, \"%s \", temp);"
                  , "    bufferPtr += strlen(temp) + 1;"
                  , "    if(temp) {"
                  , "      CARP_FREE(temp);"
                  , "      temp = NULL;"
                  , "    }"
                  ]
    FunctionNotFound msg -> error msg
    FunctionIgnored -> "    /* Ignore type inside Array: '" ++ show t ++ "' ??? */\n"
module Lookup where

import Data.List (intercalate, foldl')
import qualified Data.Map as Map
import Data.Maybe (mapMaybe, fromMaybe, fromJust)

import Types
import Obj
import Util
import Debug.Trace

-- | Find the Binder at a specified path.
lookupInEnv :: SymPath -> Env -> Maybe (Env, Binder)
lookupInEnv (SymPath [] name) env =
  case Map.lookup name (envBindings env) of
    Just found -> Just (env, found)
    Nothing -> case envParent env of
                 Just parent -> lookupInEnv (SymPath [] name) parent
                 Nothing -> Nothing
lookupInEnv path@(SymPath (p : ps) name) env =
  case Map.lookup p (envBindings env) of
    Just (Binder _ xobj) ->
      case xobj of
        (XObj (Mod modEnv) _ _) -> lookupInEnv (SymPath ps name) modEnv
        _ -> Nothing
    Nothing ->
      case envParent env of
        Just parent -> lookupInEnv path parent
        Nothing -> Nothing

-- |
findAllGlobalVariables :: Env -> [Binder]
findAllGlobalVariables env =
  concatMap finder (envBindings env)
  where finder :: Binder -> [Binder]
        finder def@(Binder _ (XObj (Lst (XObj Def _ _ : _)) _ _)) =
          [def]
        finder (Binder _ (XObj (Mod innerEnv) _ _)) =
          findAllGlobalVariables innerEnv
        finder _ =
          []

-- | Find all the possible (imported) symbols that could be referred to
multiLookup :: String -> Env -> [(Env, Binder)]
multiLookup = multiLookupInternal False

multiLookupALL :: String -> Env -> [(Env, Binder)]
multiLookupALL = multiLookupInternal True

{-# ANN multiLookupInternal "HLint: ignore Eta reduce" #-}
-- | The advanced version of multiLookup that allows for looking into modules that are NOT imported.
-- | Perhaps this function will become unnecessary when all functions can be found through Interfaces? (even 'delete', etc.)
multiLookupInternal :: Bool -> String -> Env -> [(Env, Binder)]
multiLookupInternal allowLookupInAllModules name rootEnv = recursiveLookup rootEnv

  where lookupInLocalEnv :: String -> Env -> Maybe (Env, Binder)
        lookupInLocalEnv n localEnv = case Map.lookup n (envBindings localEnv) of -- No recurse!
                                        Just b -> Just (localEnv, b)
                                        Nothing -> Nothing

        importsAll :: Env -> [Env]
        importsAll env =
          let envs = mapMaybe (binderToEnv . snd) (Map.toList (envBindings env))
          in  envs ++ concatMap importsAll envs

        -- Only lookup in imported modules (nonrecursively!)
        importsNormal :: Env -> [Env]
        importsNormal env =
          mapMaybe (\path -> fmap getEnvFromBinder (lookupInEnv path env)) (envUseModules env)

        binderToEnv :: Binder -> Maybe Env
        binderToEnv (Binder _ (XObj (Mod e) _ _)) = Just e
        binderToEnv _ = Nothing

        importsLookup :: Env -> [(Env, Binder)]
        importsLookup env =
          let envs = (if allowLookupInAllModules then importsAll else importsNormal) env
          in  mapMaybe (lookupInLocalEnv name) envs

        recursiveLookup :: Env -> [(Env, Binder)]
        recursiveLookup env =
          let spine = case Map.lookup name (envBindings env) of
                        Just found -> [(env, found)]
                        Nothing -> []
              leaves = importsLookup env
              above = case envParent env of
                        Just parent -> recursiveLookup parent
                        Nothing -> []
          in --(trace $ "multiLookupInternal '" ++ name ++ "' " ++ show (envModuleName env) ++ ", spine: " ++ show (fmap snd spine) ++ ", leaves: " ++ show (fmap snd leaves) ++ ", above: " ++ show (fmap snd above))
            spine ++ leaves ++ above

getEnvFromBinder :: (a, Binder) -> Env
getEnvFromBinder (_, Binder _ (XObj (Mod foundEnv) _ _)) = foundEnv
getEnvFromBinder (_, Binder _ err) = error ("Can't handle imports of non modules yet: " ++ show err)

-- | Enables look up "semi qualified" (and fully qualified) symbols.
-- | i.e. if there are nested environments with a function A.B.f
-- | you can find it by doing "(use A)" and then "(B.f)".
multiLookupQualified :: SymPath -> Env -> [(Env, Binder)]
multiLookupQualified (SymPath [] name) rootEnv =
  -- This case is just like normal multiLookup, we have a name but no qualifyers:
  multiLookup name rootEnv
multiLookupQualified path@(SymPath (p:ps) name) rootEnv =
  case lookupInEnv (SymPath [] p) rootEnv of
    Just (_, Binder _ (XObj (Mod _) _ _)) ->
      -- Found a module with the correct name, that means we should not look at anything else:
      case lookupInEnv path rootEnv of
        Just found -> [found]
        Nothing -> []
    Just _ -> inexactMatch
    Nothing -> inexactMatch
  where inexactMatch =
          -- No exact match on the first qualifier, will look in various places for a match:
          let fromParent = case envParent rootEnv of
                                Just parent -> multiLookupQualified path parent
                                Nothing -> []
              fromUsedModules = let usedModules = envUseModules rootEnv
                                    envs = mapMaybe (\path -> fmap getEnvFromBinder (lookupInEnv path rootEnv)) usedModules
                                in  concatMap (multiLookupQualified path) envs
          in fromParent ++ fromUsedModules


-- | Add an XObj to a specific environment. TODO: rename to envInsert
extendEnv :: Env -> String -> XObj -> Env
extendEnv env name xobj = envAddBinding env name (Binder emptyMeta xobj)

-- | Add a Binder to an environment at a specific path location.
envInsertAt :: Env -> SymPath -> Binder -> Env
envInsertAt env (SymPath [] name) binder =
  envAddBinding env name binder
envInsertAt env (SymPath (p:ps) name) xobj =
  case Map.lookup p (envBindings env) of
    Just (Binder _ (XObj (Mod innerEnv) i t)) ->
      let newInnerEnv = Binder emptyMeta (XObj (Mod (envInsertAt innerEnv (SymPath ps name) xobj)) i t)
      in  env { envBindings = Map.insert p newInnerEnv (envBindings env) }
    Just _ -> error ("Can't insert into non-module: " ++ p)
    Nothing -> error ("Can't insert into non-existing module: " ++ p)

envReplaceEnvAt :: Env -> [String] -> Env -> Env
envReplaceEnvAt _ [] replacement = replacement
envReplaceEnvAt env (p:ps) replacement =
  case Map.lookup p (envBindings env) of
    Just (Binder _ (XObj (Mod innerEnv) i t)) ->
      let newInnerEnv = Binder emptyMeta (XObj (Mod (envReplaceEnvAt innerEnv ps replacement)) i t)
      in  env { envBindings = Map.insert p newInnerEnv (envBindings env) }
    Just _ -> error ("Can't replace non-module: " ++ p)
    Nothing -> error ("Can't replace non-existing module: " ++ p)

-- | Add a Binder to a specific environment.
envAddBinding :: Env -> String -> Binder -> Env
envAddBinding env name binder = env { envBindings = Map.insert name binder (envBindings env) }

{-# ANN addListOfBindings "HLint: ignore Eta reduce" #-}
-- | Add a list of bindings to an environment
addListOfBindings :: Env -> [(String, Binder)] -> Env
addListOfBindings env bindingsToAdd = foldl' (\e (n, b) -> envAddBinding e n b) env bindingsToAdd

-- | Get an inner environment.
getEnv :: Env -> [String] -> Env
getEnv env [] = env
getEnv env (p:ps) = case Map.lookup p (envBindings env) of
                      Just (Binder _ (XObj (Mod innerEnv) _ _)) -> getEnv innerEnv ps
                      Just _ -> error "Can't get non-env."
                      Nothing -> error "Can't get env."

-- | Checks if an environment is "external", meaning it's either the global scope or a module scope.
envIsExternal :: Env -> Bool
envIsExternal env =
  case envMode env of
    ExternalEnv -> True
    InternalEnv -> False
    RecursionEnv -> True

-- | Find out if a type is "external", meaning it is not defined by the user
--   in this program but instead imported from another C library or similar.
isExternalType :: TypeEnv -> Ty -> Bool
isExternalType typeEnv (PointerTy p) =
  isExternalType typeEnv p
isExternalType typeEnv (StructTy name _) =
  case lookupInEnv (SymPath [] name) (getTypeEnv typeEnv) of
    Just (_, Binder _ (XObj (Lst (XObj ExternalType _ _ : _)) _ _)) -> True
    Just _ -> False
    Nothing -> False
isExternalType _ _ =
  False

-- | Is this type managed - does it need to be freed?
isManaged :: TypeEnv -> Ty -> Bool
isManaged typeEnv (StructTy name _) =
  (name == "Array") || (name == "Dictionary") || (
    case lookupInEnv (SymPath [] name) (getTypeEnv typeEnv) of
         Just (_, Binder _ (XObj (Lst (XObj ExternalType _ _ : _)) _ _)) -> False
         Just (_, Binder _ (XObj (Lst (XObj (Typ _) _ _ : _)) _ _)) -> True
         Just (_, Binder _ (XObj wrong _ _)) -> error ("Invalid XObj in type env: " ++ show wrong)
         Nothing -> error ("Can't find " ++ name ++ " in type env.")
    )
isManaged _ StringTy  = True
isManaged _ PatternTy = True
isManaged _ (FuncTy _ _) = True
isManaged _ _ = False

-- | Is this type a function type?
isFunctionType :: Ty -> Bool
isFunctionType (FuncTy _ _) = True
isFunctionType _ = False

{-# ANN validateMembers "HLint: ignore Eta reduce" #-}
-- | Make sure that the member declarations in a type definition
-- | Follow the pattern [<name> <type>, <name> <type>, ...]
validateMemberCases :: TypeEnv -> [Ty] -> [XObj] -> Either String ()
validateMemberCases typeEnv typeVariables rest = mapM_ visit rest
  where visit (XObj (Arr membersXObjs) _ _) =
          validateMembers typeEnv typeVariables membersXObjs
        visit xobj =
          Left ("Invalid case in deftype: " ++ pretty xobj ++ " at " ++ prettyInfoFromXObj xobj)

validateMembers :: TypeEnv -> [Ty] -> [XObj] -> Either String ()
validateMembers typeEnv typeVariables membersXObjs =
  if length membersXObjs `mod` 2 == 0
  then mapM_ (okXObjForType typeEnv typeVariables . snd) (pairwise membersXObjs)
  else Left ("Uneven nr of members / types: " ++ joinWithComma (map pretty membersXObjs))
validateOneCase _ XObj {} =
  Left "Type members must be defined using array syntax: [member1 type1 member2 type2 ...]"

okXObjForType :: TypeEnv -> [Ty] -> XObj -> Either String ()
okXObjForType typeEnv typeVariables xobj =
  case xobjToTy xobj of
    Just t -> canBeUsedAsMemberType typeEnv typeVariables t
    Nothing -> Left ("Can't interpret this as a type: " ++ pretty xobj)

-- | Can this type be used as a member for a deftype?
canBeUsedAsMemberType :: TypeEnv -> [Ty] -> Ty -> Either String ()
canBeUsedAsMemberType typeEnv typeVariables t =
  case t of
    IntTy     -> return ()
    FloatTy   -> return ()
    DoubleTy  -> return ()
    LongTy    -> return ()
    BoolTy    -> return ()
    StringTy  -> return ()
    PatternTy -> return ()
    CharTy    -> return ()
    FuncTy _ _ -> return ()
    PointerTy inner -> do _ <- canBeUsedAsMemberType typeEnv typeVariables inner
                          return ()
    StructTy "Array" [inner] -> do _ <- canBeUsedAsMemberType typeEnv typeVariables inner
                                   return ()
    StructTy name tyVars ->
      case lookupInEnv (SymPath [] name) (getTypeEnv typeEnv) of
        Just _ -> return ()
        Nothing -> Left ("Can't find '" ++ name ++ "' among registered types.")
    VarTy _ -> if t `elem` typeVariables
               then return ()
               else Left ("Invalid type variable as member type: " ++ show t)
    _ -> Left ("Invalid member type: " ++ show t)
