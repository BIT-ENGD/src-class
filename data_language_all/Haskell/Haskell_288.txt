{-# LANGUAGE TypeInType           #-}
{-# LANGUAGE UndecidableInstances #-}

module Data.Graph.Component.Node.Class where

import Prologue

import qualified Data.Graph.Data              as Component
import qualified Data.Graph.Data.Layer.Layout as Layout
import qualified Data.Tag                     as Tag
import qualified Type.Show                    as Type

import Data.Generics.Traversable (GTraversable)


------------------
-- === Node === --
------------------

-- === Definition === --

Component.define "Node"
Tag.family "NodeTag"
type Some = Component.Some Nodes


-- === Node Constructor === --

data family Constructor (tag :: Type) (layout :: Type)

-- FIXME: Remove
type family TagToCons t where
    TagToCons t = Constructor t

-- FIXME: Rename to ConstructorTag
type family ConsToTag a where
    ConsToTag (Constructor t) = t


-- === Instances === --

type instance Layout.Default Nodes = ()

type instance Layout.Merge (NodeTag a) (NodeTag b) = Merge__ a b
type family Merge__ a b where
    Merge__ a a = NodeTag a
    -- Merge__ a b = -- TODO: when needed


-- instance GTraversable (Component.Provider tag m) (Constructor t a)
--     => Component.Provider tag m (Constructor t a) where
--     gather = Component.ggather @tag  ; {-# INLINE gather #-}

-- instance GTraversable Component.DynamicProvider (Constructor t a)
--     => Component.DynamicProvider (Constructor t a) where
--     dynamicComponentsIO = Component.gdynamicComponents  ; {-# INLINE dynamicComponentsIO #-}



---------------------
-- === TagShow === --
---------------------

data TagOnly = TagOnly
type ShowTag = StyledShow TagOnly
type instance StyledShowOutput TagOnly = Text

instance (Tag.Tag fam name ~ tag, Type.Show name)
    => StyledShow TagOnly (Constructor tag layout) where
    styledShow _ _ = convert $ Type.show @name

showTag :: ShowTag a => a -> Text
showTag = styledShow TagOnly ; {-# INLINE showTag #-}



---------------------------

---------------------
-- === UniTerm === --
---------------------

-- | The implementation of Uni is delayed until we know
--   all possible Term constructors.
type family Uni :: Type -> Type

class IsUni t where
    toUni :: ∀ a. t a -> Uni a



-- === Discovery === --

-- | IsTermTag is used to gather all IR terms when generating UniNode in TH.
class IsTermTag (t :: Type)
module Data.Graph.Component.Node.Destruction where

import           Prologue hiding (Type)
import qualified Prologue as P

import qualified Data.Graph.Component.Edge.Class       as Edge
import qualified Data.Graph.Component.Edge.Destruction as Edge
import qualified Data.Graph.Component.Node.Class       as Node
import qualified Data.Graph.Component.Node.Layer       as Node
import qualified Data.Graph.Data.Component.Class       as Component
import qualified Data.Graph.Data.Component.List        as ComponentList
import qualified Data.Graph.Data.Layer.Class           as Layer
import qualified Data.Graph.Data.Layer.Layout          as Layout
import qualified Data.Mutable.Class                    as Mutable
import qualified Data.Set                              as Set

import Control.Monad                   (filterM)
import Data.Graph.Component.Edge.Class (Edge, Edges, Source, Target)
import Data.Graph.Component.Node.Class (Node, Nodes)
import Data.Graph.Component.Node.Layer (Model, Type, Users)
import Data.Graph.Fold.SubComponents   (SubComponents, SubComponents1,
                                        subComponents, subComponents1)


-------------------------
-- === Destruction === --
-------------------------

-- === API === --

type Delete m =
    ( MonadIO m
    , Edge.Delete m
    , Component.Destructor1 m Node
    , SubComponents1 Edges m Nodes
    )

delete :: Delete m => Node layout -> m ()
delete = \node -> do
    edges <- subComponents1 @Edges node
    let es = Set.toList $ Set.fromList $ (convert edges :: [Edge.SomeEdge])
    traverse Edge.delete es
    Component.destruct1 node
    return ()
{-# INLINE delete #-}

type DeleteSubtree m =
    ( MonadIO m
    , Delete m
    , Layer.Reader Node Users  m
    , Layer.Reader Node Model  m
    , Layer.Reader Node Type   m
    , Layer.Reader Edge Target m
    , Layer.Reader Edge Source m
    , SubComponents Edges m (Node.Uni ())
    , Layer.IsUnwrapped Node.Uni
    )

safeToDelete :: ∀ m. DeleteSubtree m
             => Set.Set Node.Some -> Node.Some -> m Bool
safeToDelete whitelist root = do
    succs <- Mutable.toList =<< Layer.read @Users root
    loops <- traverse Edge.cyclic succs
    let allLoops    = and loops
        whitelisted = Set.member root whitelist
    return $ allLoops && not whitelisted
{-# INLINE safeToDelete #-}

deleteSubtreeWithWhitelist :: ∀ layout m. DeleteSubtree m
                           => Set.Set Node.Some -> Node layout -> m ()
deleteSubtreeWithWhitelist whitelist (Layout.relayout -> root) = whenM (safeToDelete whitelist root) $ go root where
    go :: Node.Some -> m ()
    go root = do
        inputEdges :: [Edge.SomeEdge] <- convert <$> Node.inputs root
        tpEdge <- Layer.read @Type root
        let allInputEdges = Layout.relayout tpEdge : inputEdges
        nonCyclicEdges <- filterM (fmap not . Edge.cyclic) allInputEdges
        inputs         <- traverse (Layer.read @Source) nonCyclicEdges
        delete root
        safeChildren <- filterM (safeToDelete whitelist) $ Set.toList $ Set.fromList inputs
        traverse_ go safeChildren
{-# INLINE deleteSubtreeWithWhitelist #-}

deleteSubtree :: DeleteSubtree m => Node layout -> m ()
deleteSubtree = deleteSubtreeWithWhitelist mempty
{-# INLINE deleteSubtree #-}
