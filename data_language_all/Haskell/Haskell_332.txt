{-
   http://www.xe.com/symbols.php 
  
   http://www.fatvat.co.uk/2010/07/foreign-exchange-arbitrage.html 


    > showExchange (againstBRL GBP)
    "GBP/BRL =  0.22624423496905544"
    > 
    > showExchange (againstUSD GBP)
    "GBP/USD =  0.648511"
    > 
    > 


    
-}
import Text.Printf


-- Pipe Operators
(|>) x f = f x
(|>>) x f = map f x
(?>>) x f = filter f x

 
enumerate list = zip [0..(length list)]  list

-- findElement list element  = 


data Currency = USD | EUR | GBP | AUD | CAD | JPY | CNY |  KWR | SGD | BRL | INR
                deriving(Eq, Enum, Show, Read, Ord)
--                  
--                CurrencyX , Currency-Base  --> Exchange Rate
--                CurrencyX/CurrencyBase
type CurencyPair = (Currency, Currency)

data ExchangeRate = ExchangeRate {
    currencyPair  :: CurencyPair,
    exchangeRate  :: Double

} deriving(Eq, Show)


-- Exchange Tables Against USD
-- Prices of currencies, or exchange rates in USD $ 
-- in the day 19/21/2014
--
ratetable = [
    (USD,  1.000000),
    (EUR,  0.880281),
    (GBP,  0.648511),
    (CAD,  1.24904 ),
    (AUD,  1.28299 ),
    (JPY,  119.057 ),
    (BRL,  2.86642 ),
    (KWR,  1112.37 ),
    (INR,  62.187  )
    ]          




-- Find the position of the first element in the list
-- findElement :: Eq a => [a] -> a -> Maybe (Int, a) 

--  Find Element in a list and return the position of first element found
--
--
findElement :: Eq b => [b] -> b -> Maybe Int
findElement list elem = case result of
                        []  -> Nothing
                        [x] -> Just(fst x)
                        xs  -> Just(fst $ xs !! 0)
                        where
                        result = list |> enumerate |> filter (\el -> snd el == elem ) 

fromJust :: Maybe t -> t
fromJust (Just x) = x
--fromJust Nothing  = Nothing


--
--  table   - table of rows ( tuples)
--  column  - A column that will be looked up 
--  elemn   - Element to be searched in the column
--
--  :return: The row that has the searched element
--
lookupTable :: Eq b => [a] -> [b] -> b -> Maybe a
lookupTable table column elem =  case idx of 
                            Nothing -> Nothing
                            Just n  -> Just(table !! n)
                            where 
                            idx = findElement column elem

--getExchangeRate :: (Currency a, Currency b, ExchangeRate c)=>  (a, b) -> c

lookupt = lookupTable ratetable (map fst ratetable)


getExchangeRate currency1 currency2 = 
                    ExchangeRate { currencyPair = (currency1, currency2), exchangeRate = rate   }
                    where                      
                    row1 = lookupt currency1 |> fromJust
                    row2 = lookupt currency2 |> fromJust
                    
                    rate = (snd row2)/(snd row1)

-- List of all available currencies
currencies = map fst ratetable

-- Calculates the exchange Rate against this currency
againstBRL = getExchangeRate BRL 
againstUSD = getExchangeRate USD
againstGBP = getExchangeRate GBP

-- List of all exchange rates aginst USD and BRL
exchangesAgainstUSD = map againstUSD currencies
exchangesAgainstBRL = map againstBRL currencies

--showExchange :: ExchangeRate -> IO ()
showExchange exchange = show(currency2) ++ "/" ++ show(currency1) ++ " =  " ++ show(rate)
                      where
                      currency1 = fst $ currencyPair exchange
                      currency2 = snd $ currencyPair exchange
                      rate      =       exchangeRate exchange

                       
-- getExchangeRate Curr1  Curr2 = 
{-
 
http://learnyouahaskell.com/making-our-own-types-and-typeclasses

> people !! 0
Person {firstName = "Ayn", lastName = "Rand", age = 50}
> people !! 1
Person {firstName = "John", lastName = "Galt", age = 28}
> people !! 2
Person {firstName = "Adam", lastName = "Smith", age = 70}


> "person 0 is " ++ show (people !! 0)
"person 0 is Person {firstName = \"Ayn\", lastName = \"Rand\", age = 50}"
> 
> "person 1 is " ++ show (people !! 1)
"person 1 is Person {firstName = \"John\", lastName = \"Galt\", age = 28}"
> 
> "person 3 is " ++ show (people !! 2)
"person 3 is Person {firstName = \"Adam\", lastName = \"Smith\", age = 70}"
> 
> "person 2 is " ++ show (people !! 2)
"person 2 is Person {firstName = \"Adam\", lastName = \"Smith\", age = 70}


> let person = read "Person {firstName =\"Elmo\", lastName =\"NA\", age = 0}" :: Person
> person
Person {firstName = "Elmo", lastName = "NA", age = 0}
>

> let p  = people !! 1
> 
> p
Person {firstName = "John", lastName = "Galt", age = 28}
> 
> firstName p
"John"
> lastName p
"Galt"
> age p
28
> 
> 

> 
> ::t firstName 
> String
> 
> ::t lastName 
> String
> 
> ::t age 
> Int
>


*Main> map  showPerson people 
["Name: \"Ayn\" - Last Name: \"Rand\" - Age 50","Name: \"John\" - Last Name: \"Galt\" - Age 28","Name: \"Adam\" - Last Name: \"Smith\" - Age 70"]

 
-}

-- type String = [Char]

type PhoneNumber = String
type Name = String
type PhoneBook = [(Name,PhoneNumber)]


data Person = Person { firstName :: String, 
                       lastName :: String, 
                       age :: Int 
                     }
                     deriving (Eq, Show, Read)


people = [ Person { firstName = "Ayn",  lastName = "Rand",  age =50},
           Person { firstName = "John", lastName = "Galt",  age =28},
           Person { firstName = "Adam", lastName = "Smith", age =70}]

-- Get someone from the people database
getPerson n = people !! n

-- Show Person
showPerson :: Person -> String
showPerson person  = "Name: " ++ show(firstName person) ++ " - Last Name: " ++ show(lastName person) ++ " - Age " ++ show(age person)  

-- getName :: Person -> String
-- getName person = 


data Configuration = Configuration  String     -- User Name
                                     String    --  Local Host
                                     String     -- Remote Host
                                     Bool       -- Is guest
                                     deriving (Show)

username Configuration  x _ _ _ _  = x



phoneBook :: [(String, String)] 
phoneBook =    
    [("betty","555-2938")   
    ,("bonnie","452-2928")   
    ,("patsy","493-2928")   
    ,("lucille","205-2928")   
    ,("wendy","939-8282")   
    ,("penny","853-2492")   
    ]

