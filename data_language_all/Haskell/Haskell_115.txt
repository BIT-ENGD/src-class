module Deps.Solver
  ( Solver
  , run
  , solve
  )
  where


import Control.Monad (foldM, guard, mzero, msum)
import Control.Monad.Logic (LogicT, runLogicT, lift)
import qualified Data.List as List
import qualified Data.Map as Map
import Data.Map (Map)

import Elm.Package (Name, Version)

import Deps.Explorer (Explorer)
import qualified Deps.Explorer as Explorer
import Elm.Project.Constraint (Constraint)
import qualified Elm.Project.Constraint as Con



-- SOLVE


solve :: Map Name Constraint -> Solver (Map Name Version)
solve cons =
  mkSolver (State Map.empty cons)


type Solver a =
  LogicT Explorer a


run :: Solver a -> Explorer (Maybe a)
run solver =
  runLogicT solver (const . return . Just) (return Nothing)



-- SOLVER


data State =
  State
    { _solution :: Map Name Version
    , _unsolved :: Map Name Constraint
    }


mkSolver :: State -> Solver (Map Name Version)
mkSolver (State solution unsolved) =
  case Map.minViewWithKey unsolved of
    Nothing ->
      return solution

    Just ((name, constraint), otherUnsolved) ->
      do  allVersions <- lift $ Explorer.getVersions name
          let versions =
                reverse $ List.sort $
                  filter (Con.satisfies constraint) allVersions

          let state1 = State solution otherUnsolved
          state2 <- msum (map (addVersion state1 name) versions)
          mkSolver state2


addVersion :: State -> Name -> Version -> Solver State
addVersion (State solution unsolved) name version =
  do  (Explorer.Info elm cons) <-
        lift $ Explorer.getConstraints name version

      guard (Con.goodElm elm)
      newUnsolved <- foldM (addConstraint solution) unsolved (Map.toList cons)
      return (State (Map.insert name version solution) newUnsolved)


addConstraint :: Map Name Version -> Map Name Constraint -> (Name, Constraint) -> Solver (Map Name Constraint)
addConstraint solution unsolved (name, newConstraint) =
  case Map.lookup name solution of
    Just version ->
      if Con.satisfies newConstraint version then
        return unsolved
      else
        mzero

    Nothing ->
      case Map.lookup name unsolved of
        Nothing ->
          return $ Map.insert name newConstraint unsolved

        Just oldConstraint ->
          case Con.intersect oldConstraint newConstraint of
            Nothing ->
              mzero

            Just mergedConstraint ->
              if oldConstraint == mergedConstraint then
                return unsolved
              else
                return (Map.insert name mergedConstraint unsolved)

{-# LANGUAGE OverloadedStrings #-}
module Elm.Bump
  ( bump
  , toPossibleBumps
  )
  where


import Control.Monad.Trans (liftIO)
import qualified Data.List as List

import qualified Deps.Cache as Cache
import qualified Deps.Diff as Diff
import qualified Elm.Package as Pkg
import qualified Elm.Project as Project
import qualified Elm.Project.Json as Project
import qualified Elm.Project.Summary as Summary
import Reporting.Doc ((<>), (<+>))
import qualified Reporting.Doc as D
import qualified Reporting.Exit as Exit
import qualified Reporting.Exit.Bump as E
import qualified Reporting.Exit.Help as Help
import qualified Reporting.Progress.Terminal as Terminal
import qualified Reporting.Task as Task



-- BUMP


bump :: Summary.Summary -> Task.Task ()
bump summary@(Summary.Summary root project _ _ _) =
  case project of
    Project.App _ ->
      Task.throw (Exit.Bump E.Application)

    Project.Pkg info@(Project.PkgInfo name _ _ version _ _ _ _) ->
      do  registry <- Cache.mandatoryUpdate
          case Cache.getVersions name registry of
            Left _suggestions ->
              checkNewPackage root info

            Right publishedVersions ->
              let
                bumpableVersions =
                  map (\(old, _, _) -> old) (toPossibleBumps publishedVersions)
              in
                if elem version bumpableVersions then
                  suggestVersion summary info
                else
                  Task.throw $ Exit.Bump $ E.Unbumpable version $
                    map head (List.group (List.sort bumpableVersions))



-- VALID BUMPS


toPossibleBumps :: [Pkg.Version] -> [(Pkg.Version, Pkg.Version, Diff.Magnitude)]
toPossibleBumps publishedVersions =
  case publishedVersions of
    [] ->
      []

    _ ->
      let
        patchPoints =
          Pkg.filterLatest Pkg.majorAndMinor publishedVersions

        minorPoints =
          Pkg.filterLatest Pkg._major publishedVersions

        majorPoint =
          maximum publishedVersions
      in
        (majorPoint, Pkg.bumpMajor majorPoint, Diff.MAJOR)
        :  map (\v -> (v, Pkg.bumpMinor v, Diff.MINOR)) minorPoints
        ++ map (\v -> (v, Pkg.bumpPatch v, Diff.PATCH)) patchPoints



-- CHECK NEW PACKAGE


checkNewPackage :: FilePath -> Project.PkgInfo -> Task.Task ()
checkNewPackage root info@(Project.PkgInfo _ _ _ version _ _ _ _) =
  do  liftIO $ putStrLn Terminal.newPackageOverview
      if version == Pkg.initialVersion
        then
          liftIO $ putStrLn "The version number in elm.json is correct so you are all set!"
        else
          changeVersion root info Pkg.initialVersion $
            "It looks like the version in elm.json has been changed though!\n\
            \Would you like me to change it back to "
            <> D.fromText (Pkg.versionToText Pkg.initialVersion) <> "? [Y/n] "



-- SUGGEST VERSION


suggestVersion :: Summary.Summary -> Project.PkgInfo -> Task.Task ()
suggestVersion summary@(Summary.Summary root _ _ _ _) info@(Project.PkgInfo name _ _ version _ _ _ _) =
  do  oldDocs <- Cache.getDocs name version
      newDocs <- Task.silently (Project.generateDocs summary)
      let changes = Diff.diff oldDocs newDocs
      let newVersion = Diff.bump changes version
      changeVersion root info newVersion $
        let
          old = D.fromText $ Pkg.versionToText version
          new = D.fromText $ Pkg.versionToText newVersion
          mag = D.fromString $ Diff.magnitudeToString (Diff.toMagnitude changes)
        in
          "Based on your new API, this should be a" <+> D.green mag <+> "change (" <> old <> " => " <> new <> ")\n"
          <> "Bail out of this command and run 'elm diff' for a full explanation.\n"
          <> "\n"
          <> "Should I perform the update (" <> old <> " => " <> new <> ") in elm.json? [Y/n] "



-- CHANGE VERSION


changeVersion :: FilePath -> Project.PkgInfo -> Pkg.Version -> D.Doc -> Task.Task ()
changeVersion root info targetVersion explanation =
  do  approved <- Task.getApproval explanation
      if not approved
        then
          liftIO $ putStrLn "Okay, I did not change anything!"

        else
          do  liftIO $ Project.write root $ Project.Pkg $
                info { Project._pkg_version = targetVersion }

              liftIO $ Help.toStdout $
                "Version changed to "
                <> D.green (D.fromText (Pkg.versionToText targetVersion))
                <> "!\n"
