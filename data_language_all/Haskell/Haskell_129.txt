{-# OPTIONS_GHC -Wall #-}
{-# LANGUAGE OverloadedStrings #-}
module File.Find
  ( Asset(..)
  , find
  )
  where

import Control.Monad.Except (liftIO)
import qualified Data.Map as Map
import qualified Data.Maybe as Maybe
import qualified System.FilePath as FP
import qualified System.Directory as Dir
import System.FilePath ((</>), (<.>))

import qualified Elm.Compiler.Module as Module
import qualified Elm.Name as N
import qualified Elm.Package as Pkg

import qualified Elm.Project.Json as Project
import qualified Elm.Project.Summary as Summary
import qualified Reporting.Exit.Crawl as E
import qualified Reporting.Task as Task



-- ASSET


data Asset
  = Local FilePath
  | Kernel FilePath (Maybe FilePath)
  | Foreign Pkg.Package
  | ForeignKernel



-- FIND


find :: Summary.Summary -> E.Origin -> Module.Raw -> Task.Task_ E.Problem Asset
find (Summary.Summary root project exposed _ _) origin name =
  do  here <- liftIO Dir.getCurrentDirectory
      let toRoot dir = FP.makeRelative here (root </> dir)
      case project of
        Project.App info ->
          do  let srcDirs = map toRoot (Project._app_source_dirs info)
              findElm project srcDirs exposed origin name

        Project.Pkg _ ->
          if N.startsWith "Elm.Kernel." name then
            if Project.isPlatformPackage project then
              findKernel (toRoot "src") exposed origin name
            else
              Task.throw $ E.ModuleNameReservedForKernel origin name

          else
            findElm project [ toRoot "src" ] exposed origin name



-- FIND ELM


findElm :: Project.Project -> [FilePath] -> Summary.ExposedModules -> E.Origin -> Module.Raw -> Task.Task_ E.Problem Asset
findElm project srcDirs exposed origin name =
  do
      paths <- liftIO $ Maybe.catMaybes <$> mapM (elmExists name) srcDirs

      case (paths, Map.lookup name exposed) of
        ([path], Nothing) ->
            return (Local path)

        ([], Just [pkg]) ->
            return (Foreign pkg)

        ([], Nothing) ->
            case project of
              Project.App _ ->
                Task.throw $ E.ModuleNotFound origin name (E.App srcDirs)

              Project.Pkg _ ->
                Task.throw $ E.ModuleNotFound origin name E.Pkg

        (_, maybePkgs) ->
            Task.throw $ E.ModuleAmbiguous origin name paths (maybe [] id maybePkgs)


elmExists :: Module.Raw -> FilePath -> IO (Maybe FilePath)
elmExists name srcDir =
  do  let path = srcDir </> Module.nameToSlashPath name <.> "elm"
      exists <- Dir.doesFileExist path
      return $ if exists then Just path else Nothing



-- FIND KERNEL


findKernel :: FilePath -> Summary.ExposedModules -> E.Origin -> Module.Raw -> Task.Task_ E.Problem Asset
findKernel srcDir exposed origin name =
  do  let clientPath = srcDir </> Module.nameToSlashPath name <.> "js"
      let serverPath = srcDir </> Module.nameToSlashPath name <.> "server.js"
      client <- liftIO $ Dir.doesFileExist clientPath
      server <- liftIO $ Dir.doesFileExist serverPath
      if client
        then return $ Kernel clientPath (if server then Just serverPath else Nothing)
        else
          case Map.lookup (N.drop 11 name) exposed of
            Just [Pkg.Package pkg _vsn] | pkg == Pkg.core || pkg == Pkg.virtualDom ->
              return ForeignKernel

            _ ->
              Task.throw $ E.ModuleNotFound origin name E.Pkg
{-# OPTIONS_GHC -Wall #-}
module File.Hash
  ( Hasher
  , put
  , Digest
  , toString
  , putByteString
  , putBuilder
  , putFile
  )
  where


import Prelude hiding (appendFile)
import Control.Monad (foldM)
import qualified Control.Monad.State as State
import qualified Data.Binary.Get as Binary
import qualified Data.ByteString as BS
import qualified Data.ByteString.Builder as BS
import qualified Data.ByteString.Builder.Extra as BS (defaultChunkSize)
import qualified Data.ByteString.Lazy as LBS
import qualified Data.Digest.Pure.SHA as SHA
import qualified System.IO as IO



-- HASHER


type Hasher = State.StateT State IO ()


type Digest = SHA.Digest SHA.SHA1State


put :: FilePath -> Hasher -> IO Digest
put path hasher =
  IO.withBinaryFile path IO.WriteMode $ \handle ->
    do  let state = State handle 0 SHA.sha1Incremental
        (State _ len decoder) <- State.execStateT hasher state
        return (SHA.completeSha1Incremental decoder len)


toString :: Digest -> String
toString =
  SHA.showDigest



-- HASH STATE


data State =
  State
    { _handle :: !IO.Handle
    , _length :: !Int
    , _decoder :: !(Binary.Decoder SHA.SHA1State)
    }



-- PUBLIC API


putByteString :: BS.ByteString -> Hasher
putByteString chunk =
  do  state <- State.get
      State.put =<< State.liftIO (appendByteString state chunk)


putBuilder :: BS.Builder -> Hasher
putBuilder builder =
  do  state <- State.get
      State.put =<< State.liftIO (appendBuilder builder state)


putFile :: FilePath -> Hasher
putFile path =
  do  state <- State.get
      State.put =<< State.liftIO (appendFile path state)



-- PRIMITIVES


appendByteString :: State -> BS.ByteString -> IO State
appendByteString (State handle len decoder) chunk =
  do  BS.hPut handle chunk
      return $ State handle (len + BS.length chunk) (Binary.pushChunk decoder chunk)


appendBuilder :: BS.Builder -> State -> IO State
appendBuilder builder state =
  foldM appendByteString state $
    LBS.toChunks (BS.toLazyByteString builder)


appendFile :: FilePath -> State -> IO State
appendFile path state =
  IO.withBinaryFile path IO.ReadMode $ \handle ->
    appendHelp handle state


appendHelp :: IO.Handle -> State -> IO State
appendHelp handle state =
  do  chunk <- BS.hGet handle BS.defaultChunkSize
      if BS.null chunk
        then return state
        else appendHelp handle =<< appendByteString state chunk
