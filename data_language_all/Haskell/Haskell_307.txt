module Qualify where

import qualified Data.Set as Set
import qualified Data.Map as Map
import Data.List (intercalate, foldl')
import Debug.Trace

import Types
import Obj
import Lookup
import Util

-- | Changes the symbol part of a defn (the name) to a new symbol path
-- | Example: (defn foo () 123) => (defn GreatModule.foo () 123)
setFullyQualifiedDefn :: XObj -> SymPath -> XObj
setFullyQualifiedDefn (XObj (Lst [defn, XObj _ symi symt, args, body]) i t) newPath =
  XObj (Lst [defn, XObj (Sym newPath Symbol) symi symt, args, body]) i t
setFullyQualifiedDefn (XObj (Lst [def, XObj _ symi symt, expr]) i t) newPath =
  XObj (Lst [def, XObj (Sym newPath Symbol) symi symt, expr]) i t
setFullyQualifiedDefn xobj _ = error ("Can't set new path on " ++ show xobj)

-- | Changes all symbols EXCEPT bound vars (defn names, variable names, etc) to their fully qualified paths.
-- | This must run after the 'setFullyQualifiedDefn' function has fixed the paths of all bindings in the environment.
-- | This function does NOT go into function-body scope environments and the like.
setFullyQualifiedSymbols :: TypeEnv -> Env -> Env -> XObj -> XObj
setFullyQualifiedSymbols typeEnv globalEnv env (XObj (Lst [defn@(XObj Defn _ _),
                                                 sym@(XObj (Sym (SymPath _ functionName) _) _ _),
                                                 args@(XObj (Arr argsArr) _ _),
                                                 body])
                                      i t) =
  -- For self-recursion, there must be a binding to the function in the inner env.
  -- It is marked as RecursionEnv basically is the same thing as external to not mess up lookup.
  -- Inside the recursion env is the function env that contains bindings for the arguments of the function.
  -- Note: These inner envs is ephemeral since they are not stored in a module or global scope.
  let recursionEnv = Env Map.empty (Just env) (Just (functionName ++ "-recurse-env")) [] RecursionEnv 0
      envWithSelf = extendEnv recursionEnv functionName sym
      functionEnv = Env Map.empty (Just envWithSelf) Nothing [] InternalEnv 0
      envWithArgs = foldl' (\e arg@(XObj (Sym (SymPath _ argSymName) _) _ _) -> extendEnv e argSymName arg) functionEnv argsArr
  in  XObj (Lst [defn, sym, args, setFullyQualifiedSymbols typeEnv globalEnv envWithArgs body]) i t
setFullyQualifiedSymbols typeEnv globalEnv env (XObj (Lst [fn@(XObj (Fn _ _) _ _),
                                                 args@(XObj (Arr argsArr) _ _),
                                                 body])
                                      i t) =
  let lvl = envFunctionNestingLevel env
      functionEnv = Env Map.empty (Just env) Nothing [] InternalEnv (lvl + 1)
      envWithArgs = foldl' (\e arg@(XObj (Sym (SymPath _ argSymName) _) _ _) -> extendEnv e argSymName arg) functionEnv argsArr
  in  XObj (Lst [fn, args, setFullyQualifiedSymbols typeEnv globalEnv envWithArgs body]) i t
setFullyQualifiedSymbols typeEnv globalEnv env (XObj (Lst [the@(XObj The _ _), typeXObj, value]) i t) =
  let value' = setFullyQualifiedSymbols typeEnv globalEnv env value
  in  XObj (Lst [the, typeXObj, value']) i t
setFullyQualifiedSymbols typeEnv globalEnv env (XObj (Lst [def@(XObj Def _ _), sym, expr]) i t) =
  let expr' = setFullyQualifiedSymbols typeEnv globalEnv env expr
  in  XObj (Lst [def, sym, expr']) i t
setFullyQualifiedSymbols typeEnv globalEnv env (XObj (Lst [letExpr@(XObj Let _ _), bind@(XObj (Arr bindings) bindi bindt), body]) i t) =
  if even (length bindings)
  then let Just ii = i
           lvl = envFunctionNestingLevel env
           innerEnv = Env Map.empty (Just env) (Just ("let-env-" ++ show (infoIdentifier ii))) [] InternalEnv lvl
           (innerEnv', bindings') =
             foldl' (\(e, bs) (s@(XObj (Sym (SymPath _ binderName) _) _ _), o) ->
                       let qualified = setFullyQualifiedSymbols typeEnv globalEnv e o
                       in (extendEnv e binderName s, bs ++ [s, qualified]))
                    (innerEnv, []) (pairwise bindings)
           newBody = setFullyQualifiedSymbols typeEnv globalEnv innerEnv' body
       in  XObj (Lst [letExpr, XObj (Arr bindings') bindi bindt, newBody]) i t
  else XObj (Lst [letExpr, bind, body]) i t -- Leave it untouched for the compiler to find the error.
setFullyQualifiedSymbols typeEnv globalEnv env (XObj (Lst [XObj With _ _, XObj (Sym path _) _ _, expression]) _ _) =
  let useThese = envUseModules env
      env' = if path `elem` useThese then env else env { envUseModules = path : useThese }
  in  setFullyQualifiedSymbols typeEnv globalEnv env' expression
setFullyQualifiedSymbols typeEnv globalEnv env (XObj (Lst xobjs) i t) =
  -- TODO: Perhaps this general case can be sufficient? No need with all the cases above..?
  let xobjs' = map (setFullyQualifiedSymbols typeEnv globalEnv env) xobjs
  in  XObj (Lst xobjs') i t
setFullyQualifiedSymbols typeEnv globalEnv localEnv xobj@(XObj (Sym path _) i t) =
  case path of
    -- Unqualified:
    SymPath [] name ->
      case lookupInEnv path (getTypeEnv typeEnv) of
        Just found ->
          -- Found an interface with the same path!
          -- Have to ensure it's not a local variable with the same name as the interface
          case lookupInEnv path localEnv of
            Just (foundEnv, _) ->
              if envIsExternal foundEnv
              then createInterfaceSym name
              else doesNotBelongToAnInterface False localEnv
            Nothing ->
              --trace ("Will turn '" ++ show path ++ "' " ++ prettyInfoFromXObj xobj ++ " into an interface symbol.")
                createInterfaceSym name
        Nothing ->
          doesNotBelongToAnInterface False localEnv
    -- Qualified:
    _ ->
      doesNotBelongToAnInterface False localEnv
  where
    createInterfaceSym name =
      XObj (InterfaceSym name) i t

    captureOrNot foundEnv = if envFunctionNestingLevel foundEnv < envFunctionNestingLevel localEnv
                            then Capture
                            else NoCapture

    doesNotBelongToAnInterface :: Bool -> Env -> XObj
    doesNotBelongToAnInterface finalRecurse theEnv =
      let results = multiLookupQualified path theEnv
          results' = removeThoseShadowedByRecursiveSymbol results
      in
      case results' of
          [] -> case envParent theEnv of
                  Just p ->
                    doesNotBelongToAnInterface False p
                  Nothing ->
                    -- | OBS! The environment with no parent is the global env but it's an old one without the latest bindings!
                    if finalRecurse
                    then xobj -- This was the TRUE global env, stop here and leave 'xobj' as is.
                    else doesNotBelongToAnInterface True globalEnv
          [(_, Binder _ foundOne@(XObj (Lst ((XObj (External (Just overrideWithName)) _ _) : _)) _ _))] ->
            XObj (Sym (getPath foundOne) (LookupGlobalOverride overrideWithName)) i t
          [(e, Binder _ foundOne)] ->
            case envMode e of
              ExternalEnv -> XObj (Sym (getPath foundOne)
                                   (LookupGlobal (if isExternalFunction foundOne then ExternalCode else CarpLand) (definitionMode foundOne))) i t
              RecursionEnv -> XObj (Sym (getPath foundOne) LookupRecursive) i t
              _ -> --trace ("\nLOCAL variable " ++ show (getPath foundOne) ++ ":\n" ++ prettyEnvironmentChain e) $
                   XObj (Sym (getPath foundOne) (LookupLocal (captureOrNot e))) i t
          multiple ->
            case filter (not . envIsExternal . fst) multiple of
            -- There is at least one local binding, use the path of that one:
              (e, Binder _ local) : _ -> XObj (Sym (getPath local) (LookupLocal (captureOrNot e))) i t
            -- There are no local bindings, this is allowed to become a multi lookup symbol:
              [] ->
                --(trace $ "Turned " ++ show path ++ " into multisym: " ++ joinWithComma (map (show . (\(e, b) -> (getPath (binderXObj b), safeEnvModuleName e, envMode e))) multiple)) $
                case path of
                  (SymPath [] name) ->
                     -- Create a MultiSym!
                    XObj (MultiSym name (map (getPath . binderXObj . snd) multiple)) i t
                  pathWithQualifiers ->
                    -- The symbol IS qualified but can't be found, should produce an error later during compilation.
                    trace ("PROBLEMATIC: " ++ show path) (XObj (Sym pathWithQualifiers (LookupGlobal CarpLand AFunction)) i t)

    removeThoseShadowedByRecursiveSymbol :: [(Env, Binder)] -> [(Env, Binder)]
    removeThoseShadowedByRecursiveSymbol allBinders = visit allBinders allBinders
      where visit [] result = result
            visit (b:bs) result =
              visit bs $ case b of
                           (Env { envMode = RecursionEnv }, Binder _ xobj) ->
                             remove (\(_, Binder _ x) -> xobj /= x && getName xobj == getName x) result
                           _ -> result


setFullyQualifiedSymbols typeEnv globalEnv env xobj@(XObj (Arr array) i t) =
  let array' = map (setFullyQualifiedSymbols typeEnv globalEnv env) array
  in  XObj (Arr array') i t
setFullyQualifiedSymbols _ _ _ xobj = xobj

isExternalFunction :: XObj -> Bool
isExternalFunction (XObj (Lst (XObj (External _) _ _ : _)) _ _) = True
isExternalFunction _ = False
module StartingEnv where

import qualified Data.Set as Set
import qualified Data.Map as Map

import ColorText
import Obj
import Types
import Template
import ToTemplate
import ArrayTemplates
import Commands
import Parsing
import Eval
import Concretize

-- | These modules will be loaded in order before any other code is evaluated.
coreModules :: String -> [String]
coreModules carpDir = [carpDir ++ "/core/Core.carp"]

-- | The array module contains functions for working with the Array type.
arrayModule :: Env
arrayModule = Env { envBindings = bindings
                  , envParent = Nothing
                  , envModuleName = Just "Array"
                  , envUseModules = []
                  , envMode = ExternalEnv
                  , envFunctionNestingLevel = 0 }
  where bindings = Map.fromList [ templateNth
                                , templateAllocate
                                , templateEMap
                                , templateFilter
                                , templateRaw
                                , templateAset
                                , templateAsetBang
                                , templateAsetUninitializedBang
                                , templateLength
                                , templatePushBack
                                , templatePushBackBang
                                , templatePopBack
                                , templatePopBackBang
                                , templateDeleteArray
                                , templateCopyArray
                                , templateStrArray
                                ]

-- | The Pointer module contains functions for dealing with pointers.
pointerModule :: Env
pointerModule = Env { envBindings = bindings
                    , envParent = Nothing
                    , envModuleName = Just "Pointer"
                    , envUseModules = []
                    , envMode = ExternalEnv
                    , envFunctionNestingLevel = 0 }
  where bindings = Map.fromList [ templatePointerCopy, templatePointerEqual, templatePointerToRef ]

-- | A template function for copying (= deref:ing) any pointer.
templatePointerCopy :: (String, Binder)
templatePointerCopy = defineTemplate
  (SymPath ["Pointer"] "copy")
  (FuncTy [RefTy (PointerTy (VarTy "p"))] (PointerTy (VarTy "p")))
  (toTemplate "$p* $NAME ($p** ptrRef)")
  (toTemplate $ unlines ["$DECL {"
                        ,"    return *ptrRef;"
                        ,"}"])
  (const [])

templatePointerEqual = defineTemplate
  (SymPath ["Pointer"] "eq")
  (FuncTy [(PointerTy (VarTy "p")), (PointerTy (VarTy "p"))] BoolTy)
  (toTemplate "bool $NAME ($p *p1, $p *p2)")
  (toTemplate $ unlines ["$DECL {"
                        ,"    return p1 == p2;"
                        ,"}"])
  (const [])

-- | A template function for converting pointers to ref (it's up to the user of this function to make sure that is a safe operation).
templatePointerToRef = defineTemplate
  (SymPath ["Pointer"] "to-ref")
  (FuncTy [(PointerTy (VarTy "p"))] (RefTy (VarTy "p")))
  (toTemplate "$p* $NAME ($p *p)")
  (toTemplate $ unlines ["$DECL {"
                        ,"    return p;"
                        ,"}"])
  (const [])

-- | The System module contains functions for various OS related things like timing and process control.
systemModule :: Env
systemModule = Env { envBindings = bindings
                   , envParent = Nothing
                   , envModuleName = Just "System"
                   , envUseModules = []
                   , envMode = ExternalEnv
                   , envFunctionNestingLevel = 0 }
  where bindings = Map.fromList [ templateExit ]

-- | A template function for exiting.
templateExit :: (String, Binder)
templateExit = defineTemplate
  (SymPath ["System"] "exit")
  (FuncTy [IntTy] (VarTy "a"))
  (toTemplate "$a $NAME (int code)")
  (toTemplate $ unlines ["$DECL {"
                        ,"    exit(code);"
                        ,"}"])
  (const [])

maxArity :: Int
maxArity = 9

-- | The Function module contains functions for dealing with functions.
functionModule :: Env
functionModule = Env { envBindings = bindings
                     , envParent = Nothing
                     , envModuleName = Just "Function"
                     , envUseModules = []
                     , envMode = ExternalEnv
                     , envFunctionNestingLevel = 0 }
  where
    bindEnv env = let Just name = envModuleName env
                  in  (name, Binder emptyMeta (XObj (Mod env) Nothing Nothing))
    bindings = Map.fromList (map (bindEnv . generateInnerFunctionModule) [0..maxArity])

-- | Each arity of functions need their own module to enable copying and string representation
generateInnerFunctionModule :: Int -> Env
generateInnerFunctionModule arity =
  Env { envBindings = bindings
      , envParent = Nothing
      , envModuleName = Just ("Arity" ++ show arity)
      , envUseModules = []
      , envMode = ExternalEnv
      , envFunctionNestingLevel = 0
      }
  where
    alphabet = ['d'..'y']
    charToTyName c = [c]
    funcTy = FuncTy (take arity (map (VarTy . charToTyName) alphabet)) (VarTy "z")
    bindings = Map.fromList [ generateTemplateFuncCopy funcTy
                            , generateTemplateFuncDelete funcTy
                            , generateTemplateFuncStrOrPrn "str" funcTy
                            , generateTemplateFuncStrOrPrn "prn" funcTy
                            ]


-- | A template function for generating 'copy' functions for function pointers.
generateTemplateFuncCopy :: Ty -> (String, Binder)
generateTemplateFuncCopy funcTy = defineTemplate
  (SymPath ["Function"] "copy")
  (FuncTy [RefTy funcTy] (VarTy "a"))
  (toTemplate "$a $NAME ($a* ref)")
  (toTemplate $ unlines ["$DECL {"
                        ,"    if(ref->env) {"
                        ,"        $a f_copy;"
                        ,"        f_copy.callback = ref->callback;"
                        ,"        f_copy.delete = ref->delete;"
                        ,"        f_copy.copy = ref->copy;"
                        ,"        f_copy.env = ((void*(*)(void*))ref->copy)(ref->env);"
                        ,"        return f_copy;"
                        ,"    } else {"
                        ,"        return *ref;"
                        ,"    }"
                        ,"}"])
  (const [])

-- | A template function for generating 'deleter' functions for function pointers.
generateTemplateFuncDelete :: Ty -> (String, Binder)
generateTemplateFuncDelete funcTy = defineTemplate
  (SymPath ["Function"] "delete")
  (FuncTy [funcTy] UnitTy)
  (toTemplate "void $NAME (Lambda f)")
  (toTemplate $ unlines ["$DECL {"
                        ,"  if(f.delete) {"
                        ,"      ((void(*)(void*))f.delete)(f.env);"
                        ,"      CARP_FREE(f.env);"
                        ,"  }"
                        ,"}"])
  (const [])

-- | A template function for generating 'str' or 'prn' functions for function pointers.
generateTemplateFuncStrOrPrn :: String -> Ty -> (String, Binder)
generateTemplateFuncStrOrPrn name funcTy = defineTemplate
  (SymPath ["Function"] name)
  (FuncTy [(RefTy funcTy)] StringTy)
  (toTemplate "String $NAME (Lambda *f)")
  (toTemplate $ unlines ["$DECL {"
                        ,"    static String lambda = \"λ\";"
                        ,"    return String_copy(&lambda);"
                        ,"}"])
  (const [])

-- | The dynamic module contains dynamic functions only available in the repl and during compilation.
dynamicModule :: Env
dynamicModule = Env { envBindings = bindings
                    , envParent = Nothing
                    , envModuleName = Just "Dynamic"
                    , envUseModules = []
                    , envMode = ExternalEnv
                    , envFunctionNestingLevel = 0 }
  where bindings = Map.fromList $
                    [ addCommand "list?" 1 commandIsList
                    , addCommand "array?" 1 commandIsArray
                    , addCommand "symbol?" 1 commandIsSymbol
                    , addCommand "length" 1 commandLength
                    , addCommand "car" 1 commandCar
                    , addCommand "cdr" 1 commandCdr
                    , addCommand "last" 1 commandLast
                    , addCommand "all-but-last" 1 commandAllButLast
                    , addCommand "cons" 2 commandCons
                    , addCommand "cons-last" 2 commandConsLast
                    , addCommand "append" 2 commandAppend
                    , addCommand "macro-error" 1 commandMacroError
                    , addCommand "macro-log" 1 commandMacroLog
                    , addCommandConfigurable "str" Nothing commandStr
                    , addCommand "not" 1 commandNot
                    , addCommand "=" 2 commandEq
                    , addCommand "<" 2 commandLt
                    , addCommand ">" 2 commandGt
                    , addCommand "+" 2 commandPlus
                    , addCommand "-" 2 commandMinus
                    , addCommand "/" 2 commandDiv
                    , addCommand "*" 2 commandMul
                    , addCommand "c" 1 commandC
                    , addCommand "quit" 0 commandQuit
                    , addCommand "cat" 0 commandCat
                    , addCommand "run" 0 commandRunExe
                    , addCommand "build" 0 commandBuild
                    , addCommand "reload" 0 commandReload
                    , addCommand "env" 0 commandListBindings
                    , addCommandConfigurable "help" Nothing commandHelp
                    , addCommand "project" 0 commandProject
                    , addCommand "load" 1 commandLoad
                    , addCommand "macro-log" 1 commandPrint
                    , addCommand "expand" 1 commandExpand
                    , addCommand "project-set!" 2 commandProjectSet
                    , addCommand "os" 0 commandOS
                    , addCommand "system-include" 1 commandAddSystemInclude
                    , addCommand "local-include" 1 commandAddLocalInclude
                    , addCommand "save-docs-internal" 1 commandSaveDocsInternal
                    ]
                    ++ [("String", Binder emptyMeta (XObj (Mod dynamicStringModule) Nothing Nothing))
                       ,("Project", Binder emptyMeta (XObj (Mod dynamicProjectModule) Nothing Nothing))
                       ]

-- | A submodule of the Dynamic module. Contains functions for working with strings in the repl or during compilation.
dynamicStringModule :: Env
dynamicStringModule = Env { envBindings = bindings
                          , envParent = Nothing
                          , envModuleName = Just "String"
                          , envUseModules = []
                          , envMode = ExternalEnv
                          , envFunctionNestingLevel = 0 }
  where bindings = Map.fromList [ addCommand "char-at" 2 commandCharAt
                                , addCommand "index-of" 2 commandIndexOf
                                , addCommand "substring" 3 commandSubstring
                                , addCommand "length" 1 commandStringLength
                                , addCommand "join" 1 commandStringJoin
                                , addCommand "directory" 1 commandStringDirectory
                                ]

-- | A submodule of the Dynamic module. Contains functions for working with the active Carp project.
dynamicProjectModule :: Env
dynamicProjectModule = Env { envBindings = bindings
                           , envParent = Nothing
                           , envModuleName = Just "Project"
                           , envUseModules = []
                           , envMode = ExternalEnv
                           , envFunctionNestingLevel = 0 }
  where bindings = Map.fromList [ addCommand "config" 2 commandProjectConfig
                                , addCommand "get-config" 1 commandProjectGetConfig
                                ]

-- | A hack-ish function for converting any enum to an int.
templateEnumToInt :: (String, Binder)
templateEnumToInt = defineTemplate
  (SymPath [] "enum-to-int")
  (FuncTy [(VarTy "a")] IntTy)
  (toTemplate "int $NAME ($a e)")
  (toTemplate $ unlines ["$DECL {"
                        ,"    return (int)e;"
                        ,"}"])
  (const [])

-- | The global environment before any code is run.
startingGlobalEnv :: Bool -> Env
startingGlobalEnv noArray =
  Env { envBindings = bindings
      , envParent = Nothing
      , envModuleName = Nothing
      , envUseModules = [SymPath [] "String"]
      , envMode = ExternalEnv
      , envFunctionNestingLevel = 0
      }
  where bindings = Map.fromList $ [ register "not" (FuncTy [BoolTy] BoolTy)
                                  , register "NULL" (VarTy "a")
                                  , templateEnumToInt
                                  ]
                   ++ (if noArray then [] else [("Array", Binder emptyMeta (XObj (Mod arrayModule) Nothing Nothing))])
                   ++ [("Pointer",  Binder emptyMeta (XObj (Mod pointerModule) Nothing Nothing))]
                   ++ [("System",   Binder emptyMeta (XObj (Mod systemModule) Nothing Nothing))]
                   ++ [("Dynamic",  Binder emptyMeta (XObj (Mod dynamicModule) Nothing Nothing))]
                   ++ [("Function", Binder emptyMeta (XObj (Mod functionModule) Nothing Nothing))]

-- | The type environment (containing deftypes and interfaces) before any code is run.
startingTypeEnv :: Env
startingTypeEnv = Env { envBindings = bindings
                      , envParent = Nothing
                      , envModuleName = Nothing
                      , envUseModules = []
                      , envMode = ExternalEnv
                      , envFunctionNestingLevel = 0
                      }
  where bindings = Map.fromList
          $ [ interfaceBinder "copy" (FuncTy [(RefTy (VarTy "a"))] (VarTy "a"))
              ([SymPath ["Array"] "copy", SymPath ["Pointer"] "copy"] ++ registerFunctionFunctionsWithInterface "copy")
              builtInSymbolInfo

            , interfaceBinder "str" (FuncTy [(VarTy "a")] StringTy)
              ([SymPath ["Array"] "str"] ++ registerFunctionFunctionsWithInterface "str")
              builtInSymbolInfo

            , interfaceBinder "prn" (FuncTy [(VarTy "a")] StringTy)
              (registerFunctionFunctionsWithInterface "prn")
              builtInSymbolInfo
            ]
        builtInSymbolInfo = Info (-1) (-1) "Built-in." Set.empty (-1)

-- | Make the functions in the Function.Arity<N> modules register with the interfaces in the type Env.
registerFunctionFunctionsWithInterface :: String -> [SymPath]
registerFunctionFunctionsWithInterface interfaceName =
  map (\arity -> (SymPath ["Function", "Arity" ++ show arity] interfaceName)) [0..maxArity]

-- | Create a binder for an interface definition.
interfaceBinder :: String -> Ty -> [SymPath] -> Info -> (String, Binder)
interfaceBinder name t paths i = (name, Binder emptyMeta (defineInterface name t paths (Just i)))
