module Test.Auxx.Lang.ParserSpec
       ( spec
       ) where

import           Universum

import           Test.Hspec (Expectation, Spec, describe, it, shouldSatisfy)

import           Lang.Parser (parse)

spec :: Spec
spec = describe "Auxx.Lang.Parser" $ do
    it "handles sample-1" unitParserSample1

unitParserSample1 :: Expectation
unitParserSample1 = parse input `shouldSatisfy` isRight
  where
    input = "wait (epoch 6);; propose-patak kek:15 \"lel\" mem:(epoch 7) zaz:(get (rekt mem: to-next ses: \"zaz\" ))"

module Pos.Binary.SafeCopy
       ( getCopyBi
       , putCopyBi
       ) where

import           Universum

import           Data.SafeCopy (Contained, contain, safeGet, safePut)
import qualified Data.Serialize as Cereal

import           Pos.Binary.Class (Bi)
import qualified Pos.Binary.Class as Bi

import           Pos.Util.Util (toCerealError)


getCopyBi :: forall a. Bi a => Contained (Cereal.Get a)
getCopyBi = contain $ do
    bs <- safeGet
    toCerealError $ case Bi.deserializeOrFail bs of
        Left (err, _) -> Left $ "getCopy@" <> Bi.label (Proxy @a) <> ": " <> show err
        Right (x, _)  -> Right x

putCopyBi :: Bi a => a -> Contained Cereal.Put
putCopyBi = contain . safePut . Bi.serialize
