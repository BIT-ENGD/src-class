module InitialTypes where

import Control.Monad.State
import qualified Data.Map as Map
import Debug.Trace

import Types
import Obj
import Util
import TypeError
import Lookup

-- | Create a fresh type variable (eg. 'VarTy t0', 'VarTy t1', etc...)
genVarTyWithPrefix :: String -> State Integer Ty
genVarTyWithPrefix prefix =
  do x <- get
     put (x + 1)
     return (VarTy (prefix ++ show x))

genVarTy :: State Integer Ty
genVarTy = genVarTyWithPrefix "t"

-- | Create a list of type variables with increasing names
genVarTys :: Int -> State Integer [Ty]
genVarTys n = replicateM n genVarTy

-- | Gives all type variables new names ("t<n>", counting from current state) while
--   still preserving the same name for type variables with a shared name.
--   Example: (t0, t1, t1) -> t0
--   becomes: (r2, r3, r3) -> r2
renameVarTys :: Ty -> State Integer Ty
renameVarTys rootType = do n <- get
                           let (result, (n', _)) = runState (rename rootType) (n, Map.empty)
                           put n'
                           return result
  where
    rename :: Ty -> State (Integer, Map.Map String Ty) Ty
    rename (FuncTy argTys retTy) = do argTys' <- mapM rename argTys
                                      retTy' <- rename retTy
                                      return (FuncTy argTys' retTy')
    rename (VarTy v) = do (n, mappings) <- get
                          case Map.lookup v mappings of
                            Just found -> return found
                            Nothing -> do let varTy = VarTy ("r" ++ show n)
                                              newMappings = Map.insert v varTy mappings
                                          put (n + 1, newMappings)
                                          return varTy
    rename (StructTy name tyArgs) = do tyArgs' <- mapM rename tyArgs
                                       return (StructTy name tyArgs')

    rename (PointerTy x) = do x' <- rename x
                              return (PointerTy x')

    rename (RefTy x) = do x' <- rename x
                          return (RefTy x')

    rename x = return x

-- | Adds initial types to a s-expression and all its sub-nodes.
-- | Example: (f 10) => <(<f : (Fn [Int] Bool>) <10 : Int>) : t0>
initialTypes :: TypeEnv -> Env -> XObj -> Either TypeError XObj
initialTypes typeEnv rootEnv root = evalState (visit rootEnv root) 0
  where
    visit :: Env -> XObj -> State Integer (Either TypeError XObj)
    visit env xobj = case obj xobj of
                       (Num t _)          -> return (Right (xobj { ty = Just t }))
                       (Bol _)            -> return (Right (xobj { ty = Just BoolTy }))
                       (Str _)            -> return (Right (xobj { ty = Just (RefTy StringTy) }))
                       (Pattern _)          -> return (Right (xobj { ty = Just (RefTy PatternTy) }))
                       (Chr _)            -> return (Right (xobj { ty = Just CharTy }))
                       Break              -> return (Right (xobj { ty = Just (FuncTy [] UnitTy)}))
                       (Lst _)            -> visitList env xobj
                       (Arr _)            -> visitArray env xobj
                       (Dict _)           -> visitDictionary env xobj
                       (Sym symPath _)    -> visitSymbol env xobj symPath
                       (MultiSym _ paths) -> visitMultiSym env xobj paths
                       (InterfaceSym _)   -> visitInterfaceSym env xobj
                       Defn               -> return (Left (InvalidObj Defn xobj))
                       Def                -> return (Left (InvalidObj Def xobj))
                       e@(Fn _ _)         -> return (Left (InvalidObj e xobj))
                       Let                -> return (Left (InvalidObj Let xobj))
                       If                 -> return (Left (InvalidObj If xobj))
                       While              -> return (Left (InvalidObj While xobj))
                       Do                 -> return (Left (InvalidObj Do xobj))
                       (Mod _)            -> return (Left (InvalidObj If xobj))
                       e@(Typ _)          -> return (Left (InvalidObj e xobj))
                       e@(External _)     -> return (Left (InvalidObj e xobj))
                       ExternalType       -> return (Left (InvalidObj ExternalType xobj))
                       e@(Deftemplate _)  -> return (Left (InvalidObj e xobj))
                       e@(Instantiate _)  -> return (Left (InvalidObj e xobj))
                       e@(Defalias _)     -> return (Left (InvalidObj e xobj))
                       Address            -> return (Left (InvalidObj Address xobj))
                       SetBang            -> return (Left (InvalidObj SetBang xobj))
                       Macro              -> return (Left (InvalidObj Macro xobj))
                       The                -> return (Left (InvalidObj The xobj))
                       Dynamic            -> return (Left (InvalidObj Dynamic xobj))
                       Ref                -> return (Left (InvalidObj Ref xobj))
                       With               -> return (Left (InvalidObj With xobj))

    visitSymbol :: Env -> XObj -> SymPath -> State Integer (Either TypeError XObj)
    visitSymbol _ xobj@(XObj (Sym _ LookupRecursive) _ _) _ =
      -- Recursive lookups are left untouched (this avoids problems with looking up the thing they're referring to)
      do freshTy <- genVarTy
         return (Right xobj { ty = Just freshTy })
    visitSymbol env xobj symPath =
      case symPath of
        -- Symbols with leading ? are 'holes'.
        SymPath _ name@('?' : _) -> return (Right (xobj { ty = Just (VarTy name) }))
        SymPath _ (':' : _) -> return (Left (LeadingColon xobj))
        _ ->
          case lookupInEnv symPath env of
            Just (foundEnv, binder) ->
              case ty (binderXObj binder) of
                -- Don't rename internal symbols like parameters etc!
                Just theType | envIsExternal foundEnv -> do renamed <- renameVarTys theType
                                                            return (Right (xobj { ty = Just renamed }))
                             | otherwise -> return (Right (xobj { ty = Just theType }))
                Nothing -> return (Left (SymbolMissingType xobj foundEnv))
            Nothing -> return (Left (SymbolNotDefined symPath xobj)) -- Gives the error message "Trying to refer to an undefined symbol ..."

    visitMultiSym :: Env -> XObj -> [SymPath] -> State Integer (Either TypeError XObj)
    visitMultiSym _ xobj@(XObj (MultiSym name _) _ _) _ =
      do freshTy <- genVarTy
         return (Right xobj { ty = Just freshTy })

    visitInterfaceSym :: Env -> XObj -> State Integer (Either TypeError XObj)
    visitInterfaceSym env xobj@(XObj (InterfaceSym name) _ _) =
      do freshTy <- case lookupInEnv (SymPath [] name) (getTypeEnv typeEnv) of
                      Just (_, Binder _ (XObj (Lst [XObj (Interface interfaceSignature _) _ _, _]) _ _)) -> renameVarTys interfaceSignature
                      Just (_, Binder _ x) -> error ("A non-interface named '" ++ name ++ "' was found in the type environment: " ++ show x)
                      Nothing -> genVarTy
         return (Right xobj { ty = Just freshTy })

    visitArray :: Env -> XObj -> State Integer (Either TypeError XObj)
    visitArray env (XObj (Arr xobjs) i _) =
      do visited <- mapM (visit env) xobjs
         arrayVarTy <- genVarTy
         return $ do okVisited <- sequence visited
                     Right (XObj (Arr okVisited) i (Just (StructTy "Array" [arrayVarTy])))

    visitArray _ _ = error "The function 'visitArray' only accepts XObj:s with arrays in them."

    visitDictionary :: Env -> XObj -> State Integer (Either TypeError XObj)
    visitDictionary env (XObj (Dict xobjs) i _) =
      do visited <- mapM (visit env) xobjs
         arrayVarTy <- genVarTy
         return $ do okVisited <- sequence visited
                     Right (XObj (Dict okVisited) i (Just (StructTy "Dictionary" [arrayVarTy])))

    visitDictionary _ _ = error "The function 'visitArray' only accepts XObj:s with dictionaries in them."

    visitList :: Env -> XObj -> State Integer (Either TypeError XObj)
    visitList env xobj@(XObj (Lst xobjs) i _) =
      case xobjs of
        -- Defn
        [defn@(XObj Defn _ _), nameSymbol@(XObj (Sym (SymPath _ name) _) _ _), XObj (Arr argList) argsi argst, body] ->
          do argTypes <- genVarTys (length argList)
             returnType <- genVarTy
             funcScopeEnv <- extendEnvWithParamList env argList
             let funcTy = Just (FuncTy argTypes returnType)
                 typedNameSymbol = nameSymbol { ty = funcTy }
                 -- TODO! After the introduction of 'LookupRecursive' this env shouldn't be needed anymore? (but it is for some reason...)
                 envWithSelf = extendEnv funcScopeEnv name typedNameSymbol
             visitedBody <- visit envWithSelf body
             visitedArgs <- mapM (visit envWithSelf) argList
             return $ do okBody <- visitedBody
                         okArgs <- sequence visitedArgs
                         return (XObj (Lst [defn, nameSymbol, XObj (Arr okArgs) argsi argst, okBody]) i funcTy)

        [XObj Defn _ _, XObj (Sym _ _) _ _, XObj (Arr _) _ _] -> return (Left (NoFormsInBody xobj))
        XObj Defn _ _ : _  -> return (Left (InvalidObj Defn xobj))

        -- Fn
        [fn@(XObj (Fn _ _) _ _), XObj (Arr argList) argsi argst, body] ->
          do argTypes <- genVarTys (length argList)
             returnType <- genVarTy
             funcScopeEnv <- extendEnvWithParamList env argList
             let funcTy = Just (FuncTy argTypes returnType)
             visitedBody <- visit funcScopeEnv body
             visitedArgs <- mapM (visit funcScopeEnv) argList
             return $ do okBody <- visitedBody
                         okArgs <- sequence visitedArgs
                         let final = (XObj (Lst [fn, XObj (Arr okArgs) argsi argst, okBody]) i funcTy)
                         return final --(trace ("FINAL: " ++ show final) final)

        [XObj (Fn _ _) _ _, XObj (Arr _) _ _] -> return (Left (NoFormsInBody xobj)) -- TODO: Special error message for lambdas needed?
        XObj fn@(Fn _ _) _ _ : _  -> return (Left (InvalidObj fn xobj))

        -- Def
        [def@(XObj Def _ _), nameSymbol, expression]->
          do definitionType <- genVarTy
             visitedExpr <- visit env expression
             return $ do okExpr <- visitedExpr
                         return (XObj (Lst [def, nameSymbol, okExpr]) i (Just definitionType))

        XObj Def _ _ : _ -> return (Left (InvalidObj Def xobj))

        -- Let binding
        [letExpr@(XObj Let _ _), XObj (Arr bindings) bindi bindt, body] ->
          do wholeExprType <- genVarTy
             letScopeEnv <- extendEnvWithLetBindings env bindings
             case letScopeEnv of
               Right okLetScopeEnv ->
                 do visitedBindings <- mapM (visit okLetScopeEnv) bindings
                    visitedBody <- visit okLetScopeEnv body
                    return $ do okBindings <- sequence visitedBindings
                                okBody <- visitedBody
                                return (XObj (Lst [letExpr, XObj (Arr okBindings) bindi bindt, okBody]) i (Just wholeExprType))
               Left err -> return (Left err)

        [XObj Let _ _, XObj (Arr _) _ _] ->
          return (Left (NoFormsInBody xobj))
        XObj Let _ _ : XObj (Arr _) _ _ : _ ->
          return (Left (TooManyFormsInBody xobj))
        XObj Let _ _ : _ ->
          return (Left (InvalidObj Let xobj))

        -- If
        [ifExpr@(XObj If _ _), expr, ifTrue, ifFalse] ->
          do visitedExpr <- visit env expr
             visitedTrue <- visit env ifTrue
             visitedFalse <- visit env ifFalse
             returnType <- genVarTy
             return $ do okExpr <- visitedExpr
                         okTrue <- visitedTrue
                         okFalse <- visitedFalse
                         return (XObj (Lst [ifExpr
                                           ,okExpr
                                           ,okTrue
                                           ,okFalse
                                           ]) i (Just returnType))

        XObj If _ _ : _ -> return (Left (InvalidObj If xobj))

        -- While (always return Unit)
        [whileExpr@(XObj While _ _), expr, body] ->
          do visitedExpr <- visit env expr
             visitedBody <- visit env body
             return $ do okExpr <- visitedExpr
                         okBody <- visitedBody
                         return (XObj (Lst [whileExpr, okExpr, okBody]) i (Just UnitTy))

        [XObj While _ _, _] ->
          return (Left (NoFormsInBody xobj))
        XObj While _ _ : _ ->
          return (Left (TooManyFormsInBody xobj))

        -- Do
        doExpr@(XObj Do _ _) : expressions ->
          do t <- genVarTy
             visitedExpressions <- fmap sequence (mapM (visit env) expressions)
             return $ do okExpressions <- visitedExpressions
                         return (XObj (Lst (doExpr : okExpressions)) i (Just t))

        -- Address
        [addressExpr@(XObj Address _ _), value] ->
          do visitedValue <- visit env value
             return $ do okValue <- visitedValue
                         let Just t' = ty okValue
                         return (XObj (Lst [addressExpr, okValue]) i (Just (PointerTy t')))

        -- Set!
        [setExpr@(XObj SetBang _ _), variable, value] ->
          do visitedVariable <- visit env variable
             visitedValue <- visit env value
             return $ do okVariable <- visitedVariable
                         okValue <- visitedValue
                         return (XObj (Lst [setExpr, okVariable, okValue]) i (Just UnitTy))
        XObj SetBang _ _ : _ -> return (Left (InvalidObj SetBang xobj))

        -- The
        [theExpr@(XObj The _ _), typeXObj, value] ->
          do visitedValue <- visit env value
             return $ do okValue <- visitedValue
                         case xobjToTy typeXObj of
                           Just okType -> return (XObj (Lst [theExpr, typeXObj, okValue]) i (Just okType))
                           Nothing -> Left (NotAType typeXObj)
        XObj The _ _ : _ -> return (Left (InvalidObj The xobj))

        -- Ref
        [refExpr@(XObj Ref _ _), value] ->
          do visitedValue <- visit env value
             return $ do okValue <- visitedValue
                         let Just valueTy = ty okValue
                         return (XObj (Lst [refExpr, okValue]) i (Just (RefTy valueTy)))

        -- Function application
        func : args ->
          do t <- genVarTy
             visitedFunc <- visit env func
             visitedArgs <- fmap sequence (mapM (visit env) args)
             return $ do okFunc <- visitedFunc
                         okArgs <- visitedArgs
                         return (XObj (Lst (okFunc : okArgs)) i (Just t))

        -- Empty list
        [] -> return (Right xobj { ty = Just UnitTy })

    visitList _ _ = error "Must match on list!"

    extendEnvWithLetBindings :: Env -> [XObj] -> State Integer (Either TypeError Env)
    extendEnvWithLetBindings env xobjs =
      let pairs = pairwise xobjs
          emptyInnerEnv = Env { envBindings = Map.fromList []
                              , envParent = Just env
                              , envModuleName = Nothing
                              , envUseModules = []
                              , envMode = InternalEnv
                              , envFunctionNestingLevel = envFunctionNestingLevel env
                              }
      -- Need to fold (rather than map) to make the previous bindings accessible to the later ones, i.e. (let [a 100 b a] ...)
      in  foldM createBinderForLetPair (Right emptyInnerEnv) pairs
      where
        createBinderForLetPair :: Either TypeError Env -> (XObj, XObj) -> State Integer (Either TypeError Env)
        createBinderForLetPair envOrErr (sym, expr) =
          case envOrErr of
            Left err -> return (Left err)
            Right env' ->
              case obj sym of
                (Sym (SymPath _ name) _) -> do visited <- visit env' expr
                                               return $ do okVisited <- visited
                                                           return (envAddBinding env' name (Binder emptyMeta okVisited))
                _ -> error ("Can't create let-binder for non-symbol: " ++ show sym) -- TODO: Use proper error mechanism

    extendEnvWithParamList :: Env -> [XObj] -> State Integer Env
    extendEnvWithParamList env xobjs =
      do binders <- mapM createBinderForParam xobjs
         return Env { envBindings = Map.fromList binders
                    , envParent = Just env
                    , envModuleName = Nothing
                    , envUseModules = []
                    , envMode = InternalEnv
                    , envFunctionNestingLevel = envFunctionNestingLevel env
                    }
      where
        createBinderForParam :: XObj -> State Integer (String, Binder)
        createBinderForParam xobj =
          case obj xobj of
            (Sym (SymPath _ name) _) ->
              do t <- genVarTy
                 let xobjWithTy = xobj { ty = Just t }
                 return (name, Binder emptyMeta xobjWithTy)
            _ -> error "Can't create binder for non-symbol parameter."
{-# LANGUAGE FlexibleContexts #-}

module Parsing (parse, validCharacters, balance) where

import Text.Parsec ((<|>))
import qualified Text.Parsec as Parsec
-- import Text.Parsec.Error (newErrorMessage, Message(..))
-- import Text.Parsec.Pos (newPos)
import qualified Data.Set as Set
import qualified Data.Map as Map
import Obj
import Types
import Util
import Control.Monad.Error.Class (throwError)

import Debug.Trace

newtype ParseState = ParseState { parseInfo :: Info }

createInfo :: Parsec.Parsec String ParseState (Maybe Info)
createInfo = do i <- fmap parseInfo Parsec.getState
                return (Just i)

firstDigit :: Parsec.Parsec String ParseState Char
firstDigit = Parsec.choice [Parsec.digit, Parsec.char '-']

maybeSigned :: Parsec.Parsec String ParseState (Maybe Info, String)
maybeSigned = do i <- createInfo
                 num0 <- firstDigit
                 num1 <- Parsec.many Parsec.digit
                 let num = num0 : num1
                 incColumn (length num)
                 return (i, num)

double :: Parsec.Parsec String ParseState XObj
double = do (i, num) <- maybeSigned
            _ <- Parsec.char '.'
            incColumn 1
            decimals <- Parsec.many1 Parsec.digit
            incColumn (length decimals)
            if num == "-"
              then return (XObj (Sym (SymPath [] "-") Symbol) i Nothing)
              else return (XObj (Num DoubleTy (read (num ++ "." ++ decimals))) i Nothing)

float :: Parsec.Parsec String ParseState XObj
float = do (i, num) <- maybeSigned
           _ <- Parsec.char '.'
           incColumn 1
           decimals <- Parsec.many1 Parsec.digit
           incColumn (length decimals)
           _ <- Parsec.char 'f'
           incColumn 1
           if num == "-"
             then return (XObj (Sym (SymPath [] "-") Symbol) i Nothing)
             else return (XObj (Num FloatTy (read (num ++ "." ++ decimals))) i Nothing)

floatNoPeriod :: Parsec.Parsec String ParseState XObj
floatNoPeriod =
  do (i, num) <- maybeSigned
     _ <- Parsec.char 'f'
     incColumn 1
     if num == "-"
       then return (XObj (Sym (SymPath [] "-") Symbol) i Nothing)
       else return (XObj (Num FloatTy (read num)) i Nothing)

integer :: Parsec.Parsec String ParseState XObj
integer = do (i, num) <- maybeSigned
             if num == "-"
               then return (XObj (Sym (SymPath [] "-") Symbol) i Nothing)
               else return (XObj (Num IntTy (read num)) i Nothing)

long :: Parsec.Parsec String ParseState XObj
long = do (i, num) <- maybeSigned
          _ <- Parsec.char 'l'
          incColumn 1
          if num == "-"
            then return (XObj (Sym (SymPath [] "-") Symbol) i Nothing)
            else return (XObj (Num LongTy (read num)) i Nothing)

number :: Parsec.Parsec String ParseState XObj
number = Parsec.try float <|>
         Parsec.try floatNoPeriod <|>
         Parsec.try double <|>
         Parsec.try long <|>
         Parsec.try integer

string :: Parsec.Parsec String ParseState XObj
string = do i <- createInfo
            _ <- Parsec.char '"'
            str <- Parsec.many (Parsec.try escaped <|> Parsec.noneOf ['"'])
            _ <- Parsec.char '"'
            incColumn (length str + 2)
            return (XObj (Str str) i Nothing)

parseInternalPattern :: Parsec.Parsec String ParseState String
parseInternalPattern = do maybeAnchor <- Parsec.optionMaybe (Parsec.char '^')
                          str <- Parsec.many (Parsec.try patternEscaped <|>
                                              Parsec.try bracketClass <|>
                                              Parsec.try capture <|>
                                              simple)
                          maybeEnd <- Parsec.optionMaybe (Parsec.char '$')
                          return $ unwrapMaybe maybeAnchor ++ concat str ++
                                   unwrapMaybe maybeEnd
    where unwrapMaybe (Just c) = [c]
          unwrapMaybe (Nothing) = []
          simple :: Parsec.Parsec String ParseState String
          simple = do char <- Parsec.noneOf "^$()[]\\\""
                      return [char]
          patternEscaped :: Parsec.Parsec String ParseState String
          patternEscaped = do
            _ <- Parsec.char '\\'
            c <- Parsec.oneOf ['1', '2', '3', '4', '5', '6', '7', '8', '9',
                               'a', 'c', 'd', 'g', 'l', 'p', 's', 'u', 'w',
                               'x', 'n', 't', 'b', 'f', '[', ']', '\\', '$',
                               '(', ')', '^', '"']
            case c of
              'b' -> do c1 <- Parsec.noneOf ['"']
                        c2 <- Parsec.noneOf ['"']
                        return ['\\', c, c1, c2]
              'f' -> do str <- bracketClass
                        return $ '\\' : c : str
              _   -> return ['\\', c]
          capture :: Parsec.Parsec String ParseState String
          capture = do
            opening <- Parsec.char '('
            str <- Parsec.many (Parsec.try patternEscaped <|>
                                Parsec.try bracketClass <|>
                                simple)
            closing <- Parsec.char ')'
            return $ "(" ++ concat str ++ ")"
          range :: Parsec.Parsec String ParseState String
          range = do
            begin <- Parsec.alphaNum
            _ <- Parsec.char '-'
            end <- Parsec.alphaNum
            return [begin, '-', end]
          bracketClass :: Parsec.Parsec String ParseState String
          bracketClass = do
            opening <- Parsec.char '['
            maybeAnchor <- Parsec.optionMaybe (Parsec.char '^')
            str <- Parsec.many (Parsec.try range <|>
                                Parsec.try patternEscaped <|>
                                Parsec.many1 (Parsec.noneOf "-^$()[]\\\""))
            closing <- Parsec.char ']'
            return $ "[" ++ unwrapMaybe maybeAnchor ++ concat str ++ "]"


pattern :: Parsec.Parsec String ParseState XObj
pattern = do i <- createInfo
             _ <- Parsec.char '#'
             _ <- Parsec.char '"'
             str <- parseInternalPattern
             _ <- Parsec.char '"'
             incColumn (length str + 2)
             return (XObj (Pattern $ treat str) i Nothing)
  -- auto-escaping backslashes
  where treat :: String -> String
        treat [] = []
        treat ('\\':r) = "\\\\" ++ treat r
        treat (x:r) = x : treat r

escaped :: Parsec.Parsec String ParseState Char
escaped =  do
    _ <- Parsec.char '\\'
    _ <- Parsec.char '\"'
    return '\"'

escapedQuoteChar :: Parsec.Parsec String ParseState Char
escapedQuoteChar = do c <- Parsec.string "\""
                      incColumn 2
                      return '\"'

escapedSpaceChar :: Parsec.Parsec String ParseState Char
escapedSpaceChar = do c <- Parsec.string "space"
                      incColumn 5
                      return ' '

escapedNewlineChar :: Parsec.Parsec String ParseState Char
escapedNewlineChar = do c <- Parsec.string "newline"
                        incColumn 7
                        return '\n'

escapedTabChar :: Parsec.Parsec String ParseState Char
escapedTabChar = do c <- Parsec.string "tab"
                    incColumn 3
                    return '\t'

aChar :: Parsec.Parsec String ParseState XObj
aChar = do i <- createInfo
           _ <- Parsec.char '\\'
           c <- Parsec.try escapedQuoteChar <|>
                Parsec.try escapedNewlineChar <|>
                Parsec.try escapedTabChar <|>
                Parsec.try escapedSpaceChar <|>
                Parsec.anyChar
           incColumn 2
           return (XObj (Chr c) i Nothing)

{-# ANN validCharacters "HLint: ignore Use String" #-}
validCharacters :: [Char]
validCharacters = "+-*/?!><=_:\9580\9559"

symbolSegment :: Parsec.Parsec String ParseState String
symbolSegment = do sym <- Parsec.many1 validInSymbol
                   incColumn (length sym)
                   return sym
  where validInSymbol = Parsec.choice [Parsec.letter, Parsec.digit, Parsec.oneOf validCharacters]

period :: Parsec.Parsec String ParseState ()
period = do Parsec.char '.'
            incColumn 1
            return ()

symbol :: Parsec.Parsec String ParseState XObj
symbol = do i <- createInfo
            segments <- Parsec.sepBy1 symbolSegment period
            case last segments of
              "defn" -> return (XObj Defn i Nothing)
              "def" -> return (XObj Def i Nothing)
              -- TODO: What about the other def- forms?
              "do" -> return (XObj Do i Nothing)
              "while" -> return (XObj While i Nothing)
              "fn" -> return (XObj (Fn Nothing Set.empty) i Nothing)
              "let" -> return (XObj Let i Nothing)
              "break" -> return (XObj Break i Nothing)
              "if" -> return (XObj If i Nothing)
              "true" -> return (XObj (Bol True) i Nothing)
              "false" -> return (XObj (Bol False) i Nothing)
              "address" -> return (XObj Address i Nothing)
              "set!" -> return (XObj SetBang i Nothing)
              "the" -> return (XObj The i Nothing)
              "ref" -> return (XObj Ref i Nothing)
              "with" -> return (XObj With i Nothing)
              name   -> return (XObj (Sym (SymPath (init segments) name) Symbol) i Nothing)

atom :: Parsec.Parsec String ParseState XObj
atom = Parsec.choice [number, pattern, string, aChar, symbol]

incColumn :: Int -> Parsec.Parsec String ParseState ()
incColumn x = do s <- Parsec.getState
                 let i = parseInfo s
                     line = infoLine i
                     column = infoColumn i
                     identifier = infoIdentifier i
                     file = infoFile i
                     newInfo = Info line (column + x) file (Set.fromList []) identifier
                 Parsec.putState (s { parseInfo = newInfo })
                 return ()

comment :: Parsec.Parsec String ParseState ()
comment = do _ <- Parsec.char ';'
             _ <- Parsec.many (Parsec.noneOf ['\n'])
             return ()

linebreak :: Parsec.Parsec String ParseState ()
linebreak = do s <- Parsec.getState
               let i = parseInfo s
                   line = infoLine i
                   identifier = infoIdentifier i
                   file = infoFile i
                   newInfo = Info (line + 1) 1 file (Set.fromList [])  identifier
               Parsec.putState (s { parseInfo = newInfo })
               _ <- Parsec.char '\n'
               return ()

space :: Parsec.Parsec String ParseState ()
space = do incColumn 1
           _ <- Parsec.char ' '
           return ()

comma :: Parsec.Parsec String ParseState ()
comma = do incColumn 1
           _ <- Parsec.char ','
           return ()

tab :: Parsec.Parsec String ParseState ()
tab = do incColumn 1
         _ <- Parsec.char '\t'
         return ()

eof :: Parsec.Parsec String ParseState ()
eof = do _ <- Parsec.char '\0'
         return ()

emptyCharacters :: [Parsec.Parsec String ParseState ()]
emptyCharacters = [space, tab, comma, linebreak, eof, comment]

whitespace :: Parsec.Parsec String ParseState ()
whitespace = do _ <- Parsec.many1 (Parsec.choice emptyCharacters)
                return ()

whitespaceOrNothing :: Parsec.Parsec String ParseState ()
whitespaceOrNothing = do _ <- Parsec.many (Parsec.choice emptyCharacters)
                         return ()

readObjs :: Parsec.Parsec String ParseState [XObj]
readObjs = do padding <- Parsec.many whitespace
              incColumn (length padding)
              Parsec.many sexpr

array :: Parsec.Parsec String ParseState XObj
array = do i <- createInfo
           _ <- Parsec.char '['
           incColumn 1
           objs <- readObjs
           _ <- Parsec.char ']'
           incColumn 1
           return (XObj (Arr objs) i Nothing)

list :: Parsec.Parsec String ParseState XObj
list = do i <- createInfo
          _ <- Parsec.char '('
          incColumn 1
          objs <- readObjs
          _ <- Parsec.char ')'
          incColumn 1
          return (XObj (Lst objs) i Nothing)

dictionary :: Parsec.Parsec String ParseState XObj
dictionary = do i <- createInfo
                _ <- Parsec.char '{'
                incColumn 1
                objs <- readObjs
                _ <- Parsec.char '}'
                incColumn 1
                let objs' = if even (length objs) then objs else init objs -- Drop last if uneven nr of forms.
                -- TODO! Signal error here!
                --return (XObj (Dict (Map.fromList (pairwise objs'))) i Nothing)
                    pairInit = XObj (Sym (SymPath ["Pair"] "init") (LookupGlobal CarpLand AFunction)) i Nothing
                    pairs = map (\(k,v) -> XObj (Lst [pairInit, k, v]) i Nothing) (pairwise objs')
                    arrayLiteral = XObj (Arr pairs) i Nothing
                    reffedArrayLiteral = XObj (Lst [(XObj Ref i Nothing), arrayLiteral]) i Nothing
                    fromArraySymbol = XObj (Sym (SymPath ["Map"] "from-array") (LookupGlobal CarpLand AFunction)) i Nothing
                    fromArraySexp = XObj (Lst [fromArraySymbol, reffedArrayLiteral]) i Nothing
                return fromArraySexp


ref :: Parsec.Parsec String ParseState XObj
ref = do i <- createInfo
         _ <- Parsec.char '&'
         incColumn 1
         expr <- sexpr
         return (XObj (Lst [XObj Ref Nothing Nothing, expr]) i Nothing)

copy :: Parsec.Parsec String ParseState XObj
copy = do i1 <- createInfo
          i2 <- createInfo
          _ <- Parsec.char '@'
          incColumn 1
          expr <- sexpr
          return (XObj (Lst [XObj (Sym (SymPath [] "copy") Symbol) i1 Nothing, expr]) i2 Nothing)

quote :: Parsec.Parsec String ParseState XObj
quote = do i1 <- createInfo
           i2 <- createInfo
           _ <- Parsec.char '\''
           incColumn 1
           expr <- sexpr
           return (XObj (Lst [XObj (Sym (SymPath [] "quote") Symbol) i1 Nothing, expr]) i2 Nothing)

sexpr :: Parsec.Parsec String ParseState XObj
sexpr = do x <- Parsec.choice [ref, copy, quote, list, array, dictionary, atom]
           _ <- whitespaceOrNothing
           return x

lispSyntax :: Parsec.Parsec String ParseState [XObj]
lispSyntax = do padding <- Parsec.many whitespace
                incColumn (length padding)
                result <- Parsec.sepBy sexpr whitespaceOrNothing
                Parsec.eof
                return result

parse :: String -> String -> Either Parsec.ParseError [XObj]
parse text fileName = let initState = ParseState (Info 1 1 fileName (Set.fromList []) 0)
                      in  Parsec.runParser lispSyntax initState fileName text



{-# ANN balance "HLint: ignore Use String" #-}
-- | For detecting the parenthesis balance in a string, i.e. "((( ))" = 1
balance :: String -> Int
balance text =
  case Parsec.runParser parenSyntax [] "(parens)" text of
    Left err -> error (show err)
    Right ok -> ok

  where
        parenSyntax :: Parsec.Parsec String [Char] Int
        parenSyntax = do _ <- Parsec.many character
                         parens <- Parsec.getState
                         return (length parens)

        character :: Parsec.Parsec String [Char] ()
        character = do c <- Parsec.anyChar
                       parens <- Parsec.getState
                       case parens of
                         [] -> push c
                         '"':xs -> case c of
                                     '\\' -> do c <- Parsec.anyChar -- consume next
                                                return ()
                                     '"' -> Parsec.putState xs -- close string
                                     _ -> return () -- inside string
                         (x:xs) -> case (x, c) of
                                     ('(', ')') -> Parsec.putState xs
                                     ('[', ']') -> Parsec.putState xs
                                     ('"', '"') -> Parsec.putState xs
                                     --('\\', _) -> Parsec.putState xs -- ignore char after '\'
                                     _ -> push c

        push :: Char -> Parsec.Parsec String String ()
        push c =
          do parens <- Parsec.getState
             case c of
               '(' -> Parsec.putState (c : parens)
               '[' -> Parsec.putState (c : parens)
               '"' -> Parsec.putState (c : parens)
               _ -> return ()
