{-# OPTIONS_GHC -Wall #-}
{-# LANGUAGE OverloadedStrings #-}
module Generate.Output
  ( Mode(..)
  , Mode.Target(..)
  , generate
  , generateReplFile
  , noDebugUsesInPackage
  , Output(..)
  , output
  )
  where


import Control.Concurrent.MVar (MVar, putMVar)
import Control.Monad.Trans (liftIO)
import qualified Data.ByteString.Builder as B
import qualified Data.Map as Map
import Data.Monoid ((<>))
import qualified System.Directory as Dir
import qualified System.FilePath as FP
import System.FilePath ((</>))

import qualified Elm.Compiler as Compiler
import qualified Elm.Compiler.Module as Module
import qualified Elm.Compiler.Objects as Obj
import qualified Elm.Interface as I
import qualified Elm.Name as N
import qualified Elm.Package as Pkg

import qualified AST.Module.Name as ModuleName
import qualified Elm.Project.Json as Project
import qualified Elm.Project.Summary as Summary
import qualified File.Args as Args
import qualified File.Crawl as Crawl
import qualified File.IO as IO
import qualified Generate.Functions as Functions
import qualified Generate.Html as Html
import qualified Generate.Nitpick as Nitpick
import qualified Generate.JavaScript.Mode as Mode
import qualified Reporting.Exit as Exit
import qualified Reporting.Exit.Make as E
import qualified Reporting.Render.Type.Localizer as L
import qualified Reporting.Task as Task
import qualified Stuff.Paths as Paths
import Terminal.Args (Parser(..))



-- GENERATE


data Mode = Debug | Dev | Prod


generate
  :: Mode
  -> Mode.Target
  -> Maybe Output
  -> Summary.Summary
  -> Crawl.Result
  -> Map.Map Module.Raw Compiler.Artifacts
  -> Task.Task ()
generate mode target maybeOutput summary graph@(Crawl.Graph args locals _ _ _) artifacts =
  case args of
    Args.Pkg _ ->
      return ()

    Args.Roots name names ->
      do  objectGraph <- organize summary graph

          realMode <-
            case mode of
              Debug ->
                do  interfaces <- getInterfaces summary locals artifacts
                    return $ Mode.debug target interfaces

              Dev ->
                return $ Mode.dev target

              Prod ->
                do  noDebugUses summary objectGraph
                    return $ Mode.prod target objectGraph

          generateMonolith realMode maybeOutput summary objectGraph (name:names)


getInterfaces
  :: Summary.Summary
  -> Map.Map Module.Raw a
  -> Map.Map Module.Raw Compiler.Artifacts
  -> Task.Task I.Interfaces
getInterfaces (Summary.Summary root project _ interfaces _) locals artifacts =
  let
    pkg =
      Project.getName project

    addArtifact home (Compiler.Artifacts elmi _ _) ifaces =
      (ModuleName.Canonical pkg home, elmi) : ifaces

    addInterface home iface ifaces =
      (ModuleName.Canonical pkg home, iface) : ifaces

    readInterface home _ =
      IO.readBinary (Paths.elmi root home)
  in
  do  cached <- Map.traverseWithKey readInterface (Map.difference locals artifacts)
      return $
        Map.union interfaces $ Map.fromList $
          Map.foldrWithKey addInterface (Map.foldrWithKey addArtifact [] artifacts) cached



-- GENERATE MONOLITH


generateMonolith
  :: Mode.Mode
  -> Maybe Output
  -> Summary.Summary
  -> Obj.Graph
  -> [Module.Raw]
  -> Task.Task ()
generateMonolith mode maybeOutput (Summary.Summary _ project _ _ _) graph rootNames =
  do  let pkg = Project.getName project
      let roots = map (Module.Canonical pkg) rootNames
      case Obj.generate mode graph roots of
        Obj.None ->
          return ()

        Obj.Some name _names builder ->
          let
            monolith =
              "(function(scope){\n'use strict';"
              <> Functions.functions <> builder <> "}(this));"
          in
          liftIO $
          case maybeOutput of
            Nothing ->
              IO.writeBuilder "index.html" (Html.sandwich name monolith)

            Just output_ ->
              case output_ of
                None ->
                  return ()

                JavaScript maybeDir fileName ->
                  do  path <- toWritablePath maybeDir fileName
                      IO.writeBuilder path monolith

                HtmlBuilder mvar ->
                  putMVar mvar (Html.sandwich name monolith)

                Html maybeDir fileName ->
                  do  path <- toWritablePath maybeDir fileName
                      IO.writeBuilder path (Html.sandwich name monolith)



-- GENERATE REPL MONOLITH


generateReplFile
  :: Bool
  -> L.Localizer
  -> Summary.Summary
  -> Crawl.Result
  -> I.Interface
  -> N.Name
  -> Task.Task FilePath
generateReplFile noColors localizer summary@(Summary.Summary _ project _ _ _) graph iface name =
  do
      objectGraph <- organize summary graph

      let home = Module.Canonical (Project.getName project) N.replModule
      let builder = Obj.generateForRepl (not noColors) localizer objectGraph iface home name

      liftIO $ IO.writeBuilder (Paths.temp "js") $
        replRecovery <> "(function(){\n'use strict';" <> Functions.functions <> builder <> "}());"

      return (Paths.temp "js")


replRecovery :: B.Builder
replRecovery =
  "process.on('uncaughtException', function(err) { process.stderr.write(err.toString()); process.exit(1); });"



-- ORGANIZE


organize :: Summary.Summary -> Crawl.Result -> Task.Task Obj.Graph
organize (Summary.Summary root _ _ _ deps) (Crawl.Graph _ locals _ _ _) =
  do  localObjs <- Obj.unions <$> traverse (loadModuleObj root) (Map.keys locals)
      foreignObjs <- Obj.unions <$> traverse loadPackageObj (Map.toList deps)
      return (Obj.union localObjs foreignObjs)


loadModuleObj :: FilePath -> Module.Raw -> Task.Task Obj.Graph
loadModuleObj root name =
  IO.readBinary (Paths.elmo root name)


loadPackageObj :: ( Pkg.Name, (Pkg.Version, deps) ) -> Task.Task Obj.Graph
loadPackageObj ( name, (version,_) ) =
  do  dir <- Task.getPackageCacheDirFor name version
      IO.readBinary (dir </> "objs.dat")



-- NO DEBUG USES


noDebugUses :: Summary.Summary -> Obj.Graph -> Task.Task ()
noDebugUses (Summary.Summary _ project _ _ _) graph =
  case Nitpick.findDebugUses (Project.getName project) graph of
    [] ->
      return ()

    m:ms ->
      Task.throw (Exit.Make (E.CannotOptimizeDebugValues m ms))


noDebugUsesInPackage :: Summary.Summary -> Crawl.Result -> Task.Task ()
noDebugUsesInPackage summary graph =
  noDebugUses summary =<< organize summary graph



-- OUTPUT


data Output
  = None
  | Html (Maybe FilePath) FilePath
  | JavaScript (Maybe FilePath) FilePath
  | HtmlBuilder (MVar B.Builder)


toWritablePath :: Maybe FilePath -> FilePath -> IO FilePath
toWritablePath maybeDir fileName =
  case maybeDir of
    Nothing ->
      do  return fileName

    Just dir ->
      do  Dir.createDirectoryIfMissing True dir
          return (dir </> fileName)



-- OUTPUT PARSER


output :: Parser Output
output =
  Parser
    { _singular = "output file"
    , _plural = "output files"
    , _parser = parseOutput
    , _suggest = \_ -> return []
    , _examples = exampleOutput
    }


parseOutput :: String -> Maybe Output
parseOutput string =
    if string == "/dev/null" || string == "NUL" || string == "$null" then
      Just None

    else if FP.takeExtension string == ".html" && length string > 5 then
      splitOutput Html string

    else if FP.takeExtension string == ".js" && length string > 3 then
      splitOutput JavaScript string

    else
      Nothing


splitOutput :: (Maybe FilePath -> FilePath -> Output) -> String -> Maybe Output
splitOutput toOutput string =
  case FP.splitPath string of
    [] ->
      Nothing

    [name] ->
      Just $ toOutput Nothing name

    segments ->
      Just $ toOutput (Just (FP.joinPath (init segments))) (last segments)


exampleOutput :: String -> IO [String]
exampleOutput _ =
  return [ "elm.js", "index.html", "/dev/null" ]
{-# LANGUAGE OverloadedStrings #-}
module Reporting.Exit
  ( Exit(..)
  , toString
  , toStderr
  , toJson
  )
  where


import qualified Elm.Compiler.Module as Module
import qualified Json.Encode as Encode
import qualified Reporting.Doc as D
import qualified Reporting.Exit.Assets as Asset
import qualified Reporting.Exit.Bump as Bump
import qualified Reporting.Exit.Compile as Compile
import qualified Reporting.Exit.Crawl as Crawl
import qualified Reporting.Exit.Deps as Deps
import qualified Reporting.Exit.Diff as Diff
import qualified Reporting.Exit.Help as Help
import qualified Reporting.Exit.Http as Http
import qualified Reporting.Exit.Make as Make
import qualified Reporting.Exit.Init as Init
import qualified Reporting.Exit.Install as Install
import qualified Reporting.Exit.Publish as Publish



-- ALL POSSIBLE ERRORS


data Exit
  = NoElmJson
  | Assets Asset.Exit
  | Bump Bump.Exit
  | Compile Compile.Exit [Compile.Exit]
  | Crawl Crawl.Exit
  | Cycle [Module.Raw] -- TODO write docs to help with this scenario
  | Deps Deps.Exit
  | Diff Diff.Exit
  | Make Make.Exit
  | Init Init.Exit
  | Install Install.Exit
  | Publish Publish.Exit
  | BadHttp String Http.Exit



-- RENDERERS


toString :: Exit -> String
toString exit =
  Help.toString (Help.reportToDoc (toReport exit))


toStderr :: Exit -> IO ()
toStderr exit =
  Help.toStderr (Help.reportToDoc (toReport exit))


toJson :: Exit -> Encode.Value
toJson exit =
  Help.reportToJson (toReport exit)


toReport :: Exit -> Help.Report
toReport exit =
  case exit of
    NoElmJson ->
      Help.report "NO elm.json FILE" Nothing
        "It looks like you are starting a new Elm project. Very exciting! Try running:"
        [ D.indent 4 $ D.green $ "elm init"
        , D.reflow $
            "It will help you get set up. It is really simple!"
        ]

    Assets assetExit ->
      Asset.toReport assetExit

    Bump bumpExit ->
      Bump.toReport bumpExit

    Compile e es ->
      Help.compilerReport e es

    Crawl crawlExit ->
      Crawl.toReport crawlExit

    Cycle names ->
      Help.report "IMPORT CYCLE" Nothing
        "Your module imports form a cycle:"
        [ D.cycle 4 names
        , D.reflow $
            "Learn more about why this is disallowed and how to break cycles here:"
            ++ D.makeLink "import-cycles"
        ]

    Deps depsExit ->
      Deps.toReport depsExit

    Diff commandsExit ->
      Diff.toReport commandsExit

    Make makeExit ->
      Make.toReport makeExit

    Init initExit ->
      Init.toReport initExit

    Install installExit ->
      Install.toReport installExit

    Publish publishExit ->
      Publish.toReport publishExit

    BadHttp url httpExit ->
      Http.toReport url httpExit
